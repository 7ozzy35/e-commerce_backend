{"ast":null,"code":"import { QueryResult } from \"../../query-runner/QueryResult\";\nimport { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\";\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\";\nimport { Table } from \"../../schema-builder/table/Table\";\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\";\nimport { TableIndex } from \"../../schema-builder/table/TableIndex\";\nimport { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\";\nimport { View } from \"../../schema-builder/view/View\";\nimport { Query } from \"../Query\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { TableUnique } from \"../../schema-builder/table/TableUnique\";\nimport { BaseQueryRunner } from \"../../query-runner/BaseQueryRunner\";\nimport { Broadcaster } from \"../../subscriber/Broadcaster\";\nimport { TypeORMError } from \"../../error\";\nimport { MetadataTableType } from \"../types/MetadataTableType\";\nimport { InstanceChecker } from \"../../util/InstanceChecker\";\n/**\n * Runs queries on a single mysql database connection.\n */\nexport class AuroraMysqlQueryRunner extends BaseQueryRunner {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(driver, client) {\n    super();\n    this.driver = driver;\n    this.connection = driver.connection;\n    this.client = client;\n    this.broadcaster = new Broadcaster(this);\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates/uses database connection from the connection pool to perform further operations.\n   * Returns obtained database connection.\n   */\n  async connect() {\n    return {};\n  }\n  /**\n   * Releases used database connection.\n   * You cannot use query runner methods once its released.\n   */\n  release() {\n    this.isReleased = true;\n    if (this.databaseConnection) this.databaseConnection.release();\n    return Promise.resolve();\n  }\n  /**\n   * Starts transaction on the current connection.\n   */\n  async startTransaction(isolationLevel) {\n    this.isTransactionActive = true;\n    try {\n      await this.broadcaster.broadcast(\"BeforeTransactionStart\");\n    } catch (err) {\n      this.isTransactionActive = false;\n      throw err;\n    }\n    if (this.transactionDepth === 0) {\n      this.transactionDepth += 1;\n      await this.client.startTransaction();\n    } else {\n      this.transactionDepth += 1;\n      await this.query(`SAVEPOINT typeorm_${this.transactionDepth - 1}`);\n    }\n    await this.broadcaster.broadcast(\"AfterTransactionStart\");\n  }\n  /**\n   * Commits transaction.\n   * Error will be thrown if transaction was not started.\n   */\n  async commitTransaction() {\n    if (!this.isTransactionActive) throw new TransactionNotStartedError();\n    await this.broadcaster.broadcast(\"BeforeTransactionCommit\");\n    if (this.transactionDepth > 1) {\n      this.transactionDepth -= 1;\n      await this.query(`RELEASE SAVEPOINT typeorm_${this.transactionDepth}`);\n    } else {\n      this.transactionDepth -= 1;\n      await this.client.commitTransaction();\n      this.isTransactionActive = false;\n    }\n    await this.broadcaster.broadcast(\"AfterTransactionCommit\");\n  }\n  /**\n   * Rollbacks transaction.\n   * Error will be thrown if transaction was not started.\n   */\n  async rollbackTransaction() {\n    if (!this.isTransactionActive) throw new TransactionNotStartedError();\n    await this.broadcaster.broadcast(\"BeforeTransactionRollback\");\n    if (this.transactionDepth > 1) {\n      this.transactionDepth -= 1;\n      await this.query(`ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth}`);\n    } else {\n      this.transactionDepth -= 1;\n      await this.client.rollbackTransaction();\n      this.isTransactionActive = false;\n    }\n    await this.broadcaster.broadcast(\"AfterTransactionRollback\");\n  }\n  /**\n   * Executes a raw SQL query.\n   */\n  async query(query, parameters, useStructuredResult = false) {\n    if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();\n    const raw = await this.client.query(query, parameters);\n    const result = new QueryResult();\n    result.raw = raw;\n    if (raw?.hasOwnProperty(\"records\") && Array.isArray(raw.records)) {\n      result.records = raw.records;\n    }\n    if (raw?.hasOwnProperty(\"numberOfRecordsUpdated\")) {\n      result.affected = raw.numberOfRecordsUpdated;\n    }\n    if (!useStructuredResult) {\n      return result.raw;\n    }\n    return result;\n  }\n  /**\n   * Returns raw data stream.\n   */\n  stream(query, parameters, onEnd, onError) {\n    if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();\n    return new Promise(async (ok, fail) => {\n      try {\n        const databaseConnection = await this.connect();\n        const stream = databaseConnection.query(query, parameters);\n        if (onEnd) stream.on(\"end\", onEnd);\n        if (onError) stream.on(\"error\", onError);\n        ok(stream);\n      } catch (err) {\n        fail(err);\n      }\n    });\n  }\n  /**\n   * Returns all available database names including system databases.\n   */\n  async getDatabases() {\n    return Promise.resolve([]);\n  }\n  /**\n   * Returns all available schema names including system schemas.\n   * If database parameter specified, returns schemas of that database.\n   */\n  async getSchemas(database) {\n    throw new TypeORMError(`MySql driver does not support table schemas`);\n  }\n  /**\n   * Checks if database with the given name exist.\n   */\n  async hasDatabase(database) {\n    const result = await this.query(`SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`SCHEMATA\\` WHERE \\`SCHEMA_NAME\\` = '${database}'`);\n    return result.length ? true : false;\n  }\n  /**\n   * Loads currently using database\n   */\n  async getCurrentDatabase() {\n    const query = await this.query(`SELECT DATABASE() AS \\`db_name\\``);\n    return query[0][\"db_name\"];\n  }\n  /**\n   * Checks if schema with the given name exist.\n   */\n  async hasSchema(schema) {\n    throw new TypeORMError(`MySql driver does not support table schemas`);\n  }\n  /**\n   * Loads currently using database schema\n   */\n  async getCurrentSchema() {\n    const query = await this.query(`SELECT SCHEMA() AS \\`schema_name\\``);\n    return query[0][\"schema_name\"];\n  }\n  /**\n   * Checks if table with the given name exist in the database.\n   */\n  async hasTable(tableOrName) {\n    const parsedTableName = this.driver.parseTableName(tableOrName);\n    const sql = `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`COLUMNS\\` WHERE \\`TABLE_SCHEMA\\` = '${parsedTableName.database}' AND \\`TABLE_NAME\\` = '${parsedTableName.tableName}'`;\n    const result = await this.query(sql);\n    return result.length ? true : false;\n  }\n  /**\n   * Checks if column with the given name exist in the given table.\n   */\n  async hasColumn(tableOrName, column) {\n    const parsedTableName = this.driver.parseTableName(tableOrName);\n    const columnName = InstanceChecker.isTableColumn(column) ? column.name : column;\n    const sql = `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`COLUMNS\\` WHERE \\`TABLE_SCHEMA\\` = '${parsedTableName.database}' AND \\`TABLE_NAME\\` = '${parsedTableName.tableName}' AND \\`COLUMN_NAME\\` = '${columnName}'`;\n    const result = await this.query(sql);\n    return result.length ? true : false;\n  }\n  /**\n   * Creates a new database.\n   */\n  async createDatabase(database, ifNotExist) {\n    const up = ifNotExist ? `CREATE DATABASE IF NOT EXISTS \\`${database}\\`` : `CREATE DATABASE \\`${database}\\``;\n    const down = `DROP DATABASE \\`${database}\\``;\n    await this.executeQueries(new Query(up), new Query(down));\n  }\n  /**\n   * Drops database.\n   */\n  async dropDatabase(database, ifExist) {\n    const up = ifExist ? `DROP DATABASE IF EXISTS \\`${database}\\`` : `DROP DATABASE \\`${database}\\``;\n    const down = `CREATE DATABASE \\`${database}\\``;\n    await this.executeQueries(new Query(up), new Query(down));\n  }\n  /**\n   * Creates a new table schema.\n   */\n  async createSchema(schemaPath, ifNotExist) {\n    throw new TypeORMError(`Schema create queries are not supported by MySql driver.`);\n  }\n  /**\n   * Drops table schema.\n   */\n  async dropSchema(schemaPath, ifExist) {\n    throw new TypeORMError(`Schema drop queries are not supported by MySql driver.`);\n  }\n  /**\n   * Creates a new table.\n   */\n  async createTable(table, ifNotExist = false, createForeignKeys = true) {\n    if (ifNotExist) {\n      const isTableExist = await this.hasTable(table);\n      if (isTableExist) return Promise.resolve();\n    }\n    const upQueries = [];\n    const downQueries = [];\n    upQueries.push(this.createTableSql(table, createForeignKeys));\n    downQueries.push(this.dropTableSql(table));\n    // we must first drop indices, than drop foreign keys, because drop queries runs in reversed order\n    // and foreign keys will be dropped first as indices. This order is very important, because we can't drop index\n    // if it related to the foreign key.\n    // createTable does not need separate method to create indices, because it create indices in the same query with table creation.\n    table.indices.forEach(index => downQueries.push(this.dropIndexSql(table, index)));\n    // if createForeignKeys is true, we must drop created foreign keys in down query.\n    // createTable does not need separate method to create foreign keys, because it create fk's in the same query with table creation.\n    if (createForeignKeys) table.foreignKeys.forEach(foreignKey => downQueries.push(this.dropForeignKeySql(table, foreignKey)));\n    return this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Drop the table.\n   */\n  async dropTable(target, ifExist, dropForeignKeys = true) {\n    // It needs because if table does not exist and dropForeignKeys or dropIndices is true, we don't need\n    // to perform drop queries for foreign keys and indices.\n    if (ifExist) {\n      const isTableExist = await this.hasTable(target);\n      if (!isTableExist) return Promise.resolve();\n    }\n    // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.\n    const createForeignKeys = dropForeignKeys;\n    const tablePath = this.getTablePath(target);\n    const table = await this.getCachedTable(tablePath);\n    const upQueries = [];\n    const downQueries = [];\n    if (dropForeignKeys) table.foreignKeys.forEach(foreignKey => upQueries.push(this.dropForeignKeySql(table, foreignKey)));\n    table.indices.forEach(index => upQueries.push(this.dropIndexSql(table, index)));\n    upQueries.push(this.dropTableSql(table));\n    downQueries.push(this.createTableSql(table, createForeignKeys));\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Creates a new view.\n   */\n  async createView(view, syncWithMetadata = false) {\n    const upQueries = [];\n    const downQueries = [];\n    upQueries.push(this.createViewSql(view));\n    if (syncWithMetadata) upQueries.push(await this.insertViewDefinitionSql(view));\n    downQueries.push(this.dropViewSql(view));\n    if (syncWithMetadata) downQueries.push(await this.deleteViewDefinitionSql(view));\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Drops the view.\n   */\n  async dropView(target) {\n    const viewName = InstanceChecker.isView(target) ? target.name : target;\n    const view = await this.getCachedView(viewName);\n    const upQueries = [];\n    const downQueries = [];\n    upQueries.push(await this.deleteViewDefinitionSql(view));\n    upQueries.push(this.dropViewSql(view));\n    downQueries.push(await this.insertViewDefinitionSql(view));\n    downQueries.push(this.createViewSql(view));\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Renames a table.\n   */\n  async renameTable(oldTableOrName, newTableName) {\n    const upQueries = [];\n    const downQueries = [];\n    const oldTable = InstanceChecker.isTable(oldTableOrName) ? oldTableOrName : await this.getCachedTable(oldTableOrName);\n    const newTable = oldTable.clone();\n    const {\n      database\n    } = this.driver.parseTableName(oldTable);\n    newTable.name = database ? `${database}.${newTableName}` : newTableName;\n    // rename table\n    upQueries.push(new Query(`RENAME TABLE ${this.escapePath(oldTable)} TO ${this.escapePath(newTable)}`));\n    downQueries.push(new Query(`RENAME TABLE ${this.escapePath(newTable)} TO ${this.escapePath(oldTable)}`));\n    // rename index constraints\n    newTable.indices.forEach(index => {\n      // build new constraint name\n      const columnNames = index.columnNames.map(column => `\\`${column}\\``).join(\", \");\n      const newIndexName = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);\n      // build queries\n      let indexType = \"\";\n      if (index.isUnique) indexType += \"UNIQUE \";\n      if (index.isSpatial) indexType += \"SPATIAL \";\n      if (index.isFulltext) indexType += \"FULLTEXT \";\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} DROP INDEX \\`${index.name}\\`, ADD ${indexType}INDEX \\`${newIndexName}\\` (${columnNames})`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} DROP INDEX \\`${newIndexName}\\`, ADD ${indexType}INDEX \\`${index.name}\\` (${columnNames})`));\n      // replace constraint name\n      index.name = newIndexName;\n    });\n    // rename foreign key constraint\n    newTable.foreignKeys.forEach(foreignKey => {\n      // build new constraint name\n      const columnNames = foreignKey.columnNames.map(column => `\\`${column}\\``).join(\", \");\n      const referencedColumnNames = foreignKey.referencedColumnNames.map(column => `\\`${column}\\``).join(\",\");\n      const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames);\n      // build queries\n      let up = `ALTER TABLE ${this.escapePath(newTable)} DROP FOREIGN KEY \\`${foreignKey.name}\\`, ADD CONSTRAINT \\`${newForeignKeyName}\\` FOREIGN KEY (${columnNames}) ` + `REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;\n      if (foreignKey.onDelete) up += ` ON DELETE ${foreignKey.onDelete}`;\n      if (foreignKey.onUpdate) up += ` ON UPDATE ${foreignKey.onUpdate}`;\n      let down = `ALTER TABLE ${this.escapePath(newTable)} DROP FOREIGN KEY \\`${newForeignKeyName}\\`, ADD CONSTRAINT \\`${foreignKey.name}\\` FOREIGN KEY (${columnNames}) ` + `REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;\n      if (foreignKey.onDelete) down += ` ON DELETE ${foreignKey.onDelete}`;\n      if (foreignKey.onUpdate) down += ` ON UPDATE ${foreignKey.onUpdate}`;\n      upQueries.push(new Query(up));\n      downQueries.push(new Query(down));\n      // replace constraint name\n      foreignKey.name = newForeignKeyName;\n    });\n    await this.executeQueries(upQueries, downQueries);\n    // rename old table and replace it in cached tabled;\n    oldTable.name = newTable.name;\n    this.replaceCachedTable(oldTable, newTable);\n  }\n  /**\n   * Creates a new column from the column in the table.\n   */\n  async addColumn(tableOrName, column) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const clonedTable = table.clone();\n    const upQueries = [];\n    const downQueries = [];\n    const skipColumnLevelPrimary = clonedTable.primaryColumns.length > 0;\n    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(column, skipColumnLevelPrimary, false)}`));\n    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN \\`${column.name}\\``));\n    // create or update primary key constraint\n    if (column.isPrimary && skipColumnLevelPrimary) {\n      // if we already have generated column, we must temporary drop AUTO_INCREMENT property.\n      const generatedColumn = clonedTable.columns.find(column => column.isGenerated && column.generationStrategy === \"increment\");\n      if (generatedColumn) {\n        const nonGeneratedColumn = generatedColumn.clone();\n        nonGeneratedColumn.isGenerated = false;\n        nonGeneratedColumn.generationStrategy = undefined;\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${column.name}\\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${nonGeneratedColumn.name}\\` ${this.buildCreateColumnSql(column, true)}`));\n      }\n      const primaryColumns = clonedTable.primaryColumns;\n      let columnNames = primaryColumns.map(column => `\\`${column.name}\\``).join(\", \");\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));\n      primaryColumns.push(column);\n      columnNames = primaryColumns.map(column => `\\`${column.name}\\``).join(\", \");\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));\n      // if we previously dropped AUTO_INCREMENT property, we must bring it back\n      if (generatedColumn) {\n        const nonGeneratedColumn = generatedColumn.clone();\n        nonGeneratedColumn.isGenerated = false;\n        nonGeneratedColumn.generationStrategy = undefined;\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${nonGeneratedColumn.name}\\` ${this.buildCreateColumnSql(column, true)}`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${column.name}\\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));\n      }\n    }\n    // create column index\n    const columnIndex = clonedTable.indices.find(index => index.columnNames.length === 1 && index.columnNames[0] === column.name);\n    if (columnIndex) {\n      upQueries.push(this.createIndexSql(table, columnIndex));\n      downQueries.push(this.dropIndexSql(table, columnIndex));\n    } else if (column.isUnique) {\n      const uniqueIndex = new TableIndex({\n        name: this.connection.namingStrategy.indexName(table, [column.name]),\n        columnNames: [column.name],\n        isUnique: true\n      });\n      clonedTable.indices.push(uniqueIndex);\n      clonedTable.uniques.push(new TableUnique({\n        name: uniqueIndex.name,\n        columnNames: uniqueIndex.columnNames\n      }));\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD UNIQUE INDEX \\`${uniqueIndex.name}\\` (\\`${column.name}\\`)`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \\`${uniqueIndex.name}\\``));\n    }\n    await this.executeQueries(upQueries, downQueries);\n    clonedTable.addColumn(column);\n    this.replaceCachedTable(table, clonedTable);\n  }\n  /**\n   * Creates a new columns from the column in the table.\n   */\n  async addColumns(tableOrName, columns) {\n    for (const column of columns) {\n      await this.addColumn(tableOrName, column);\n    }\n  }\n  /**\n   * Renames column in the given table.\n   */\n  async renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find(c => c.name === oldTableColumnOrName);\n    if (!oldColumn) throw new TypeORMError(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n    let newColumn = undefined;\n    if (InstanceChecker.isTableColumn(newTableColumnOrName)) {\n      newColumn = newTableColumnOrName;\n    } else {\n      newColumn = oldColumn.clone();\n      newColumn.name = newTableColumnOrName;\n    }\n    await this.changeColumn(table, oldColumn, newColumn);\n  }\n  /**\n   * Changes a column in the table.\n   */\n  async changeColumn(tableOrName, oldColumnOrName, newColumn) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    let clonedTable = table.clone();\n    const upQueries = [];\n    const downQueries = [];\n    const oldColumn = InstanceChecker.isTableColumn(oldColumnOrName) ? oldColumnOrName : table.columns.find(column => column.name === oldColumnOrName);\n    if (!oldColumn) throw new TypeORMError(`Column \"${oldColumnOrName}\" was not found in the \"${table.name}\" table.`);\n    if (newColumn.isGenerated !== oldColumn.isGenerated && newColumn.generationStrategy !== \"uuid\" || oldColumn.type !== newColumn.type || oldColumn.length !== newColumn.length || oldColumn.generatedType !== newColumn.generatedType) {\n      await this.dropColumn(table, oldColumn);\n      await this.addColumn(table, newColumn);\n      // update cloned table\n      clonedTable = table.clone();\n    } else {\n      if (newColumn.name !== oldColumn.name) {\n        // We don't change any column properties, just rename it.\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${oldColumn.name}\\` \\`${newColumn.name}\\` ${this.buildCreateColumnSql(oldColumn, true, true)}`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${newColumn.name}\\` \\`${oldColumn.name}\\` ${this.buildCreateColumnSql(oldColumn, true, true)}`));\n        // rename index constraints\n        clonedTable.findColumnIndices(oldColumn).forEach(index => {\n          // build new constraint name\n          index.columnNames.splice(index.columnNames.indexOf(oldColumn.name), 1);\n          index.columnNames.push(newColumn.name);\n          const columnNames = index.columnNames.map(column => `\\`${column}\\``).join(\", \");\n          const newIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);\n          // build queries\n          let indexType = \"\";\n          if (index.isUnique) indexType += \"UNIQUE \";\n          if (index.isSpatial) indexType += \"SPATIAL \";\n          if (index.isFulltext) indexType += \"FULLTEXT \";\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \\`${index.name}\\`, ADD ${indexType}INDEX \\`${newIndexName}\\` (${columnNames})`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \\`${newIndexName}\\`, ADD ${indexType}INDEX \\`${index.name}\\` (${columnNames})`));\n          // replace constraint name\n          index.name = newIndexName;\n        });\n        // rename foreign key constraints\n        clonedTable.findColumnForeignKeys(oldColumn).forEach(foreignKey => {\n          // build new constraint name\n          foreignKey.columnNames.splice(foreignKey.columnNames.indexOf(oldColumn.name), 1);\n          foreignKey.columnNames.push(newColumn.name);\n          const columnNames = foreignKey.columnNames.map(column => `\\`${column}\\``).join(\", \");\n          const referencedColumnNames = foreignKey.referencedColumnNames.map(column => `\\`${column}\\``).join(\",\");\n          const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames);\n          // build queries\n          let up = `ALTER TABLE ${this.escapePath(table)} DROP FOREIGN KEY \\`${foreignKey.name}\\`, ADD CONSTRAINT \\`${newForeignKeyName}\\` FOREIGN KEY (${columnNames}) ` + `REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;\n          if (foreignKey.onDelete) up += ` ON DELETE ${foreignKey.onDelete}`;\n          if (foreignKey.onUpdate) up += ` ON UPDATE ${foreignKey.onUpdate}`;\n          let down = `ALTER TABLE ${this.escapePath(table)} DROP FOREIGN KEY \\`${newForeignKeyName}\\`, ADD CONSTRAINT \\`${foreignKey.name}\\` FOREIGN KEY (${columnNames}) ` + `REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;\n          if (foreignKey.onDelete) down += ` ON DELETE ${foreignKey.onDelete}`;\n          if (foreignKey.onUpdate) down += ` ON UPDATE ${foreignKey.onUpdate}`;\n          upQueries.push(new Query(up));\n          downQueries.push(new Query(down));\n          // replace constraint name\n          foreignKey.name = newForeignKeyName;\n        });\n        // rename old column in the Table object\n        const oldTableColumn = clonedTable.columns.find(column => column.name === oldColumn.name);\n        clonedTable.columns[clonedTable.columns.indexOf(oldTableColumn)].name = newColumn.name;\n        oldColumn.name = newColumn.name;\n      }\n      if (this.isColumnChanged(oldColumn, newColumn, true)) {\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${oldColumn.name}\\` ${this.buildCreateColumnSql(newColumn, true)}`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${newColumn.name}\\` ${this.buildCreateColumnSql(oldColumn, true)}`));\n      }\n      if (newColumn.isPrimary !== oldColumn.isPrimary) {\n        // if table have generated column, we must drop AUTO_INCREMENT before changing primary constraints.\n        const generatedColumn = clonedTable.columns.find(column => column.isGenerated && column.generationStrategy === \"increment\");\n        if (generatedColumn) {\n          const nonGeneratedColumn = generatedColumn.clone();\n          nonGeneratedColumn.isGenerated = false;\n          nonGeneratedColumn.generationStrategy = undefined;\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${generatedColumn.name}\\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${nonGeneratedColumn.name}\\` ${this.buildCreateColumnSql(generatedColumn, true)}`));\n        }\n        const primaryColumns = clonedTable.primaryColumns;\n        // if primary column state changed, we must always drop existed constraint.\n        if (primaryColumns.length > 0) {\n          const columnNames = primaryColumns.map(column => `\\`${column.name}\\``).join(\", \");\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));\n        }\n        if (newColumn.isPrimary === true) {\n          primaryColumns.push(newColumn);\n          // update column in table\n          const column = clonedTable.columns.find(column => column.name === newColumn.name);\n          column.isPrimary = true;\n          const columnNames = primaryColumns.map(column => `\\`${column.name}\\``).join(\", \");\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));\n        } else {\n          const primaryColumn = primaryColumns.find(c => c.name === newColumn.name);\n          primaryColumns.splice(primaryColumns.indexOf(primaryColumn), 1);\n          // update column in table\n          const column = clonedTable.columns.find(column => column.name === newColumn.name);\n          column.isPrimary = false;\n          // if we have another primary keys, we must recreate constraint.\n          if (primaryColumns.length > 0) {\n            const columnNames = primaryColumns.map(column => `\\`${column.name}\\``).join(\", \");\n            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));\n            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));\n          }\n        }\n        // if we have generated column, and we dropped AUTO_INCREMENT property before, we must bring it back\n        if (generatedColumn) {\n          const nonGeneratedColumn = generatedColumn.clone();\n          nonGeneratedColumn.isGenerated = false;\n          nonGeneratedColumn.generationStrategy = undefined;\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${nonGeneratedColumn.name}\\` ${this.buildCreateColumnSql(generatedColumn, true)}`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${generatedColumn.name}\\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));\n        }\n      }\n      if (newColumn.isUnique !== oldColumn.isUnique) {\n        if (newColumn.isUnique === true) {\n          const uniqueIndex = new TableIndex({\n            name: this.connection.namingStrategy.indexName(table, [newColumn.name]),\n            columnNames: [newColumn.name],\n            isUnique: true\n          });\n          clonedTable.indices.push(uniqueIndex);\n          clonedTable.uniques.push(new TableUnique({\n            name: uniqueIndex.name,\n            columnNames: uniqueIndex.columnNames\n          }));\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD UNIQUE INDEX \\`${uniqueIndex.name}\\` (\\`${newColumn.name}\\`)`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \\`${uniqueIndex.name}\\``));\n        } else {\n          const uniqueIndex = clonedTable.indices.find(index => {\n            return index.columnNames.length === 1 && index.isUnique === true && !!index.columnNames.find(columnName => columnName === newColumn.name);\n          });\n          clonedTable.indices.splice(clonedTable.indices.indexOf(uniqueIndex), 1);\n          const tableUnique = clonedTable.uniques.find(unique => unique.name === uniqueIndex.name);\n          clonedTable.uniques.splice(clonedTable.uniques.indexOf(tableUnique), 1);\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \\`${uniqueIndex.name}\\``));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD UNIQUE INDEX \\`${uniqueIndex.name}\\` (\\`${newColumn.name}\\`)`));\n        }\n      }\n    }\n    await this.executeQueries(upQueries, downQueries);\n    this.replaceCachedTable(table, clonedTable);\n  }\n  /**\n   * Changes a column in the table.\n   */\n  async changeColumns(tableOrName, changedColumns) {\n    for (const {\n      oldColumn,\n      newColumn\n    } of changedColumns) {\n      await this.changeColumn(tableOrName, oldColumn, newColumn);\n    }\n  }\n  /**\n   * Drops column in the table.\n   */\n  async dropColumn(tableOrName, columnOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const column = InstanceChecker.isTableColumn(columnOrName) ? columnOrName : table.findColumnByName(columnOrName);\n    if (!column) throw new TypeORMError(`Column \"${columnOrName}\" was not found in table \"${table.name}\"`);\n    const clonedTable = table.clone();\n    const upQueries = [];\n    const downQueries = [];\n    // drop primary key constraint\n    if (column.isPrimary) {\n      // if table have generated column, we must drop AUTO_INCREMENT before changing primary constraints.\n      const generatedColumn = clonedTable.columns.find(column => column.isGenerated && column.generationStrategy === \"increment\");\n      if (generatedColumn) {\n        const nonGeneratedColumn = generatedColumn.clone();\n        nonGeneratedColumn.isGenerated = false;\n        nonGeneratedColumn.generationStrategy = undefined;\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${generatedColumn.name}\\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${nonGeneratedColumn.name}\\` ${this.buildCreateColumnSql(generatedColumn, true)}`));\n      }\n      // dropping primary key constraint\n      const columnNames = clonedTable.primaryColumns.map(primaryColumn => `\\`${primaryColumn.name}\\``).join(\", \");\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP PRIMARY KEY`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD PRIMARY KEY (${columnNames})`));\n      // update column in table\n      const tableColumn = clonedTable.findColumnByName(column.name);\n      tableColumn.isPrimary = false;\n      // if primary key have multiple columns, we must recreate it without dropped column\n      if (clonedTable.primaryColumns.length > 0) {\n        const columnNames = clonedTable.primaryColumns.map(primaryColumn => `\\`${primaryColumn.name}\\``).join(\", \");\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD PRIMARY KEY (${columnNames})`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP PRIMARY KEY`));\n      }\n      // if we have generated column, and we dropped AUTO_INCREMENT property before, and this column is not current dropping column, we must bring it back\n      if (generatedColumn && generatedColumn.name !== column.name) {\n        const nonGeneratedColumn = generatedColumn.clone();\n        nonGeneratedColumn.isGenerated = false;\n        nonGeneratedColumn.generationStrategy = undefined;\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${nonGeneratedColumn.name}\\` ${this.buildCreateColumnSql(generatedColumn, true)}`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${generatedColumn.name}\\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));\n      }\n    }\n    // drop column index\n    const columnIndex = clonedTable.indices.find(index => index.columnNames.length === 1 && index.columnNames[0] === column.name);\n    if (columnIndex) {\n      clonedTable.indices.splice(clonedTable.indices.indexOf(columnIndex), 1);\n      upQueries.push(this.dropIndexSql(table, columnIndex));\n      downQueries.push(this.createIndexSql(table, columnIndex));\n    } else if (column.isUnique) {\n      // we splice constraints both from table uniques and indices.\n      const uniqueName = this.connection.namingStrategy.uniqueConstraintName(table, [column.name]);\n      const foundUnique = clonedTable.uniques.find(unique => unique.name === uniqueName);\n      if (foundUnique) clonedTable.uniques.splice(clonedTable.uniques.indexOf(foundUnique), 1);\n      const indexName = this.connection.namingStrategy.indexName(table, [column.name]);\n      const foundIndex = clonedTable.indices.find(index => index.name === indexName);\n      if (foundIndex) clonedTable.indices.splice(clonedTable.indices.indexOf(foundIndex), 1);\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \\`${indexName}\\``));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD UNIQUE INDEX \\`${indexName}\\` (\\`${column.name}\\`)`));\n    }\n    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN \\`${column.name}\\``));\n    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(column, true)}`));\n    await this.executeQueries(upQueries, downQueries);\n    clonedTable.removeColumn(column);\n    this.replaceCachedTable(table, clonedTable);\n  }\n  /**\n   * Drops the columns in the table.\n   */\n  async dropColumns(tableOrName, columns) {\n    for (const column of columns) {\n      await this.dropColumn(tableOrName, column);\n    }\n  }\n  /**\n   * Creates a new primary key.\n   */\n  async createPrimaryKey(tableOrName, columnNames) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const clonedTable = table.clone();\n    const up = this.createPrimaryKeySql(table, columnNames);\n    const down = this.dropPrimaryKeySql(table);\n    await this.executeQueries(up, down);\n    clonedTable.columns.forEach(column => {\n      if (columnNames.find(columnName => columnName === column.name)) column.isPrimary = true;\n    });\n    this.replaceCachedTable(table, clonedTable);\n  }\n  /**\n   * Updates composite primary keys.\n   */\n  async updatePrimaryKeys(tableOrName, columns) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const clonedTable = table.clone();\n    const columnNames = columns.map(column => column.name);\n    const upQueries = [];\n    const downQueries = [];\n    // if table have generated column, we must drop AUTO_INCREMENT before changing primary constraints.\n    const generatedColumn = clonedTable.columns.find(column => column.isGenerated && column.generationStrategy === \"increment\");\n    if (generatedColumn) {\n      const nonGeneratedColumn = generatedColumn.clone();\n      nonGeneratedColumn.isGenerated = false;\n      nonGeneratedColumn.generationStrategy = undefined;\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${generatedColumn.name}\\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${nonGeneratedColumn.name}\\` ${this.buildCreateColumnSql(generatedColumn, true)}`));\n    }\n    // if table already have primary columns, we must drop them.\n    const primaryColumns = clonedTable.primaryColumns;\n    if (primaryColumns.length > 0) {\n      const columnNames = primaryColumns.map(column => `\\`${column.name}\\``).join(\", \");\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));\n    }\n    // update columns in table.\n    clonedTable.columns.filter(column => columnNames.indexOf(column.name) !== -1).forEach(column => column.isPrimary = true);\n    const columnNamesString = columnNames.map(columnName => `\\`${columnName}\\``).join(\", \");\n    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNamesString})`));\n    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));\n    // if we already have generated column or column is changed to generated, and we dropped AUTO_INCREMENT property before, we must bring it back\n    const newOrExistGeneratedColumn = generatedColumn ? generatedColumn : columns.find(column => column.isGenerated && column.generationStrategy === \"increment\");\n    if (newOrExistGeneratedColumn) {\n      const nonGeneratedColumn = newOrExistGeneratedColumn.clone();\n      nonGeneratedColumn.isGenerated = false;\n      nonGeneratedColumn.generationStrategy = undefined;\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${nonGeneratedColumn.name}\\` ${this.buildCreateColumnSql(newOrExistGeneratedColumn, true)}`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \\`${newOrExistGeneratedColumn.name}\\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));\n      // if column changed to generated, we must update it in table\n      const changedGeneratedColumn = clonedTable.columns.find(column => column.name === newOrExistGeneratedColumn.name);\n      changedGeneratedColumn.isGenerated = true;\n      changedGeneratedColumn.generationStrategy = \"increment\";\n    }\n    await this.executeQueries(upQueries, downQueries);\n    this.replaceCachedTable(table, clonedTable);\n  }\n  /**\n   * Drops a primary key.\n   */\n  async dropPrimaryKey(tableOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const up = this.dropPrimaryKeySql(table);\n    const down = this.createPrimaryKeySql(table, table.primaryColumns.map(column => column.name));\n    await this.executeQueries(up, down);\n    table.primaryColumns.forEach(column => {\n      column.isPrimary = false;\n    });\n  }\n  /**\n   * Creates a new unique constraint.\n   */\n  async createUniqueConstraint(tableOrName, uniqueConstraint) {\n    throw new TypeORMError(`MySql does not support unique constraints. Use unique index instead.`);\n  }\n  /**\n   * Creates a new unique constraints.\n   */\n  async createUniqueConstraints(tableOrName, uniqueConstraints) {\n    throw new TypeORMError(`MySql does not support unique constraints. Use unique index instead.`);\n  }\n  /**\n   * Drops an unique constraint.\n   */\n  async dropUniqueConstraint(tableOrName, uniqueOrName) {\n    throw new TypeORMError(`MySql does not support unique constraints. Use unique index instead.`);\n  }\n  /**\n   * Drops an unique constraints.\n   */\n  async dropUniqueConstraints(tableOrName, uniqueConstraints) {\n    throw new TypeORMError(`MySql does not support unique constraints. Use unique index instead.`);\n  }\n  /**\n   * Creates a new check constraint.\n   */\n  async createCheckConstraint(tableOrName, checkConstraint) {\n    throw new TypeORMError(`MySql does not support check constraints.`);\n  }\n  /**\n   * Creates a new check constraints.\n   */\n  async createCheckConstraints(tableOrName, checkConstraints) {\n    throw new TypeORMError(`MySql does not support check constraints.`);\n  }\n  /**\n   * Drops check constraint.\n   */\n  async dropCheckConstraint(tableOrName, checkOrName) {\n    throw new TypeORMError(`MySql does not support check constraints.`);\n  }\n  /**\n   * Drops check constraints.\n   */\n  async dropCheckConstraints(tableOrName, checkConstraints) {\n    throw new TypeORMError(`MySql does not support check constraints.`);\n  }\n  /**\n   * Creates a new exclusion constraint.\n   */\n  async createExclusionConstraint(tableOrName, exclusionConstraint) {\n    throw new TypeORMError(`MySql does not support exclusion constraints.`);\n  }\n  /**\n   * Creates a new exclusion constraints.\n   */\n  async createExclusionConstraints(tableOrName, exclusionConstraints) {\n    throw new TypeORMError(`MySql does not support exclusion constraints.`);\n  }\n  /**\n   * Drops exclusion constraint.\n   */\n  async dropExclusionConstraint(tableOrName, exclusionOrName) {\n    throw new TypeORMError(`MySql does not support exclusion constraints.`);\n  }\n  /**\n   * Drops exclusion constraints.\n   */\n  async dropExclusionConstraints(tableOrName, exclusionConstraints) {\n    throw new TypeORMError(`MySql does not support exclusion constraints.`);\n  }\n  /**\n   * Creates a new foreign key.\n   */\n  async createForeignKey(tableOrName, foreignKey) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    // new FK may be passed without name. In this case we generate FK name manually.\n    if (!foreignKey.name) foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames);\n    const up = this.createForeignKeySql(table, foreignKey);\n    const down = this.dropForeignKeySql(table, foreignKey);\n    await this.executeQueries(up, down);\n    table.addForeignKey(foreignKey);\n  }\n  /**\n   * Creates a new foreign keys.\n   */\n  async createForeignKeys(tableOrName, foreignKeys) {\n    const promises = foreignKeys.map(foreignKey => this.createForeignKey(tableOrName, foreignKey));\n    await Promise.all(promises);\n  }\n  /**\n   * Drops a foreign key.\n   */\n  async dropForeignKey(tableOrName, foreignKeyOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const foreignKey = InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName : table.foreignKeys.find(fk => fk.name === foreignKeyOrName);\n    if (!foreignKey) throw new TypeORMError(`Supplied foreign key was not found in table ${table.name}`);\n    const up = this.dropForeignKeySql(table, foreignKey);\n    const down = this.createForeignKeySql(table, foreignKey);\n    await this.executeQueries(up, down);\n    table.removeForeignKey(foreignKey);\n  }\n  /**\n   * Drops a foreign keys from the table.\n   */\n  async dropForeignKeys(tableOrName, foreignKeys) {\n    const promises = foreignKeys.map(foreignKey => this.dropForeignKey(tableOrName, foreignKey));\n    await Promise.all(promises);\n  }\n  /**\n   * Creates a new index.\n   */\n  async createIndex(tableOrName, index) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    // new index may be passed without name. In this case we generate index name manually.\n    if (!index.name) index.name = this.generateIndexName(table, index);\n    const up = this.createIndexSql(table, index);\n    const down = this.dropIndexSql(table, index);\n    await this.executeQueries(up, down);\n    table.addIndex(index, true);\n  }\n  /**\n   * Creates a new indices\n   */\n  async createIndices(tableOrName, indices) {\n    const promises = indices.map(index => this.createIndex(tableOrName, index));\n    await Promise.all(promises);\n  }\n  /**\n   * Drops an index.\n   */\n  async dropIndex(tableOrName, indexOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const index = InstanceChecker.isTableIndex(indexOrName) ? indexOrName : table.indices.find(i => i.name === indexOrName);\n    if (!index) throw new TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`);\n    // old index may be passed without name. In this case we generate index name manually.\n    if (!index.name) index.name = this.generateIndexName(table, index);\n    const up = this.dropIndexSql(table, index);\n    const down = this.createIndexSql(table, index);\n    await this.executeQueries(up, down);\n    table.removeIndex(index, true);\n  }\n  /**\n   * Drops an indices from the table.\n   */\n  async dropIndices(tableOrName, indices) {\n    const promises = indices.map(index => this.dropIndex(tableOrName, index));\n    await Promise.all(promises);\n  }\n  /**\n   * Clears all table contents.\n   * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.\n   */\n  async clearTable(tableOrName) {\n    await this.query(`TRUNCATE TABLE ${this.escapePath(tableOrName)}`);\n  }\n  /**\n   * Removes all tables from the currently connected database.\n   * Be careful using this method and avoid using it in production or migrations\n   * (because it can clear all your database).\n   */\n  async clearDatabase(database) {\n    const dbName = database ? database : this.driver.database;\n    if (dbName) {\n      const isDatabaseExist = await this.hasDatabase(dbName);\n      if (!isDatabaseExist) return Promise.resolve();\n    } else {\n      throw new TypeORMError(`Can not clear database. No database is specified`);\n    }\n    const isAnotherTransactionActive = this.isTransactionActive;\n    if (!isAnotherTransactionActive) await this.startTransaction();\n    try {\n      const selectViewDropsQuery = `SELECT concat('DROP VIEW IF EXISTS \\`', table_schema, '\\`.\\`', table_name, '\\`') AS \\`query\\` FROM \\`INFORMATION_SCHEMA\\`.\\`VIEWS\\` WHERE \\`TABLE_SCHEMA\\` = '${dbName}'`;\n      const dropViewQueries = await this.query(selectViewDropsQuery);\n      await Promise.all(dropViewQueries.map(q => this.query(q[\"query\"])));\n      const disableForeignKeysCheckQuery = `SET FOREIGN_KEY_CHECKS = 0;`;\n      const dropTablesQuery = `SELECT concat('DROP TABLE IF EXISTS \\`', table_schema, '\\`.\\`', table_name, '\\`') AS \\`query\\` FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` WHERE \\`TABLE_SCHEMA\\` = '${dbName}'`;\n      const enableForeignKeysCheckQuery = `SET FOREIGN_KEY_CHECKS = 1;`;\n      await this.query(disableForeignKeysCheckQuery);\n      const dropQueries = await this.query(dropTablesQuery);\n      await Promise.all(dropQueries.map(query => this.query(query[\"query\"])));\n      await this.query(enableForeignKeysCheckQuery);\n      if (!isAnotherTransactionActive) {\n        await this.commitTransaction();\n      }\n    } catch (error) {\n      try {\n        // we throw original error even if rollback thrown an error\n        if (!isAnotherTransactionActive) {\n          await this.rollbackTransaction();\n        }\n      } catch (rollbackError) {}\n      throw error;\n    }\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  async loadViews(viewNames) {\n    const hasTable = await this.hasTable(this.getTypeormMetadataTableName());\n    if (!hasTable) {\n      return [];\n    }\n    if (!viewNames) {\n      viewNames = [];\n    }\n    const currentDatabase = await this.getCurrentDatabase();\n    const viewsCondition = viewNames.map(tableName => {\n      let {\n        database,\n        tableName: name\n      } = this.driver.parseTableName(tableName);\n      if (!database) {\n        database = currentDatabase;\n      }\n      return `(\\`t\\`.\\`schema\\` = '${database}' AND \\`t\\`.\\`name\\` = '${name}')`;\n    }).join(\" OR \");\n    const query = `SELECT \\`t\\`.*, \\`v\\`.\\`check_option\\` FROM ${this.escapePath(this.getTypeormMetadataTableName())} \\`t\\` ` + `INNER JOIN \\`information_schema\\`.\\`views\\` \\`v\\` ON \\`v\\`.\\`table_schema\\` = \\`t\\`.\\`schema\\` AND \\`v\\`.\\`table_name\\` = \\`t\\`.\\`name\\` WHERE \\`t\\`.\\`type\\` = '${MetadataTableType.VIEW}' ${viewsCondition ? `AND (${viewsCondition})` : \"\"}`;\n    const dbViews = await this.query(query);\n    return dbViews.map(dbView => {\n      const view = new View();\n      const db = dbView[\"schema\"] === currentDatabase ? undefined : dbView[\"schema\"];\n      view.database = dbView[\"schema\"];\n      view.name = this.driver.buildTableName(dbView[\"name\"], undefined, db);\n      view.expression = dbView[\"value\"];\n      return view;\n    });\n  }\n  /**\n   * Loads all tables (with given names) from the database and creates a Table from them.\n   */\n  async loadTables(tableNames) {\n    // if no tables given then no need to proceed\n    if (tableNames && tableNames.length === 0) {\n      return [];\n    }\n    const dbTables = [];\n    const currentDatabase = await this.getCurrentDatabase();\n    if (!tableNames) {\n      const tablesSql = `SELECT TABLE_NAME, TABLE_SCHEMA FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\``;\n      dbTables.push(...(await this.query(tablesSql)));\n    } else {\n      const tablesCondition = tableNames.map(tableName => {\n        let [database, name] = tableName.split(\".\");\n        if (!name) {\n          name = database;\n          database = this.driver.database || currentDatabase;\n        }\n        return `(\\`TABLE_SCHEMA\\` = '${database}' AND \\`TABLE_NAME\\` = '${name}')`;\n      }).join(\" OR \");\n      const tablesSql = `SELECT TABLE_NAME, TABLE_SCHEMA FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` WHERE ` + tablesCondition;\n      dbTables.push(...(await this.query(tablesSql)));\n    }\n    if (dbTables.length === 0) {\n      return [];\n    }\n    const columnsCondition = dbTables.map(({\n      TABLE_NAME,\n      TABLE_SCHEMA\n    }) => {\n      return `(\\`TABLE_SCHEMA\\` = '${TABLE_SCHEMA}' AND \\`TABLE_NAME\\` = '${TABLE_NAME}')`;\n    }).join(\" OR \");\n    const columnsSql = `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`COLUMNS\\` WHERE ` + columnsCondition;\n    const primaryKeySql = `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`KEY_COLUMN_USAGE\\` WHERE \\`CONSTRAINT_NAME\\` = 'PRIMARY' AND (${columnsCondition})`;\n    const collationsSql = `SELECT \\`SCHEMA_NAME\\`, \\`DEFAULT_CHARACTER_SET_NAME\\` as \\`CHARSET\\`, \\`DEFAULT_COLLATION_NAME\\` AS \\`COLLATION\\` FROM \\`INFORMATION_SCHEMA\\`.\\`SCHEMATA\\``;\n    const indicesCondition = dbTables.map(({\n      TABLE_NAME,\n      TABLE_SCHEMA\n    }) => {\n      return `(\\`s\\`.\\`TABLE_SCHEMA\\` = '${TABLE_SCHEMA}' AND \\`s\\`.\\`TABLE_NAME\\` = '${TABLE_NAME}')`;\n    }).join(\" OR \");\n    const indicesSql = `SELECT \\`s\\`.* FROM \\`INFORMATION_SCHEMA\\`.\\`STATISTICS\\` \\`s\\` ` + `LEFT JOIN \\`INFORMATION_SCHEMA\\`.\\`REFERENTIAL_CONSTRAINTS\\` \\`rc\\` ON \\`s\\`.\\`INDEX_NAME\\` = \\`rc\\`.\\`CONSTRAINT_NAME\\` ` + `WHERE (${indicesCondition}) AND \\`s\\`.\\`INDEX_NAME\\` != 'PRIMARY' AND \\`rc\\`.\\`CONSTRAINT_NAME\\` IS NULL`;\n    const foreignKeysCondition = dbTables.map(({\n      TABLE_NAME,\n      TABLE_SCHEMA\n    }) => {\n      return `(\\`kcu\\`.\\`TABLE_SCHEMA\\` = '${TABLE_SCHEMA}' AND \\`kcu\\`.\\`TABLE_NAME\\` = '${TABLE_NAME}')`;\n    }).join(\" OR \");\n    const foreignKeysSql = `SELECT \\`kcu\\`.\\`TABLE_SCHEMA\\`, \\`kcu\\`.\\`TABLE_NAME\\`, \\`kcu\\`.\\`CONSTRAINT_NAME\\`, \\`kcu\\`.\\`COLUMN_NAME\\`, \\`kcu\\`.\\`REFERENCED_TABLE_SCHEMA\\`, ` + `\\`kcu\\`.\\`REFERENCED_TABLE_NAME\\`, \\`kcu\\`.\\`REFERENCED_COLUMN_NAME\\`, \\`rc\\`.\\`DELETE_RULE\\` \\`ON_DELETE\\`, \\`rc\\`.\\`UPDATE_RULE\\` \\`ON_UPDATE\\` ` + `FROM \\`INFORMATION_SCHEMA\\`.\\`KEY_COLUMN_USAGE\\` \\`kcu\\` ` + `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`REFERENTIAL_CONSTRAINTS\\` \\`rc\\` ON \\`rc\\`.\\`constraint_name\\` = \\`kcu\\`.\\`constraint_name\\` ` + `WHERE ` + foreignKeysCondition;\n    const [dbColumns, dbPrimaryKeys, dbCollations, dbIndices, dbForeignKeys] = await Promise.all([this.query(columnsSql), this.query(primaryKeySql), this.query(collationsSql), this.query(indicesSql), this.query(foreignKeysSql)]);\n    // create tables for loaded tables\n    return Promise.all(dbTables.map(async dbTable => {\n      const table = new Table();\n      const dbCollation = dbCollations.find(coll => coll[\"SCHEMA_NAME\"] === dbTable[\"TABLE_SCHEMA\"]);\n      const defaultCollation = dbCollation[\"COLLATION\"];\n      const defaultCharset = dbCollation[\"CHARSET\"];\n      // We do not need to join database name, when database is by default.\n      const db = dbTable[\"TABLE_SCHEMA\"] === currentDatabase ? undefined : dbTable[\"TABLE_SCHEMA\"];\n      table.database = dbTable[\"TABLE_SCHEMA\"];\n      table.name = this.driver.buildTableName(dbTable[\"TABLE_NAME\"], undefined, db);\n      // create columns from the loaded columns\n      table.columns = dbColumns.filter(dbColumn => dbColumn[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"] && dbColumn[\"TABLE_SCHEMA\"] === dbTable[\"TABLE_SCHEMA\"]).map(dbColumn => {\n        const columnUniqueIndices = dbIndices.filter(dbIndex => {\n          return dbIndex[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"] && dbIndex[\"TABLE_SCHEMA\"] === dbTable[\"TABLE_SCHEMA\"] && dbIndex[\"COLUMN_NAME\"] === dbColumn[\"COLUMN_NAME\"] && parseInt(dbIndex[\"NON_UNIQUE\"], 10) === 0;\n        });\n        const tableMetadata = this.connection.entityMetadatas.find(metadata => this.getTablePath(table) === this.getTablePath(metadata));\n        const hasIgnoredIndex = columnUniqueIndices.length > 0 && tableMetadata && tableMetadata.indices.some(index => {\n          return columnUniqueIndices.some(uniqueIndex => {\n            return index.name === uniqueIndex[\"INDEX_NAME\"] && index.synchronize === false;\n          });\n        });\n        const isConstraintComposite = columnUniqueIndices.every(uniqueIndex => {\n          return dbIndices.some(dbIndex => dbIndex[\"INDEX_NAME\"] === uniqueIndex[\"INDEX_NAME\"] && dbIndex[\"COLUMN_NAME\"] !== dbColumn[\"COLUMN_NAME\"]);\n        });\n        const tableColumn = new TableColumn();\n        tableColumn.name = dbColumn[\"COLUMN_NAME\"];\n        tableColumn.type = dbColumn[\"DATA_TYPE\"].toLowerCase();\n        // Unsigned columns are handled differently when it comes to width.\n        // Hence, we need to set the unsigned attribute before we check the width.\n        tableColumn.unsigned = tableColumn.zerofill ? true : dbColumn[\"COLUMN_TYPE\"].indexOf(\"unsigned\") !== -1;\n        if (this.driver.withWidthColumnTypes.indexOf(tableColumn.type) !== -1) {\n          const width = dbColumn[\"COLUMN_TYPE\"].substring(dbColumn[\"COLUMN_TYPE\"].indexOf(\"(\") + 1, dbColumn[\"COLUMN_TYPE\"].indexOf(\")\"));\n          tableColumn.width = width && !this.isDefaultColumnWidth(table, tableColumn, parseInt(width)) ? parseInt(width) : undefined;\n        }\n        if (dbColumn[\"COLUMN_DEFAULT\"] === null || dbColumn[\"COLUMN_DEFAULT\"] === undefined) {\n          tableColumn.default = undefined;\n        } else {\n          tableColumn.default = dbColumn[\"COLUMN_DEFAULT\"] === \"CURRENT_TIMESTAMP\" ? dbColumn[\"COLUMN_DEFAULT\"] : `'${dbColumn[\"COLUMN_DEFAULT\"]}'`;\n        }\n        if (dbColumn[\"EXTRA\"].indexOf(\"on update\") !== -1) {\n          tableColumn.onUpdate = dbColumn[\"EXTRA\"].substring(dbColumn[\"EXTRA\"].indexOf(\"on update\") + 10);\n        }\n        if (dbColumn[\"GENERATION_EXPRESSION\"]) {\n          tableColumn.asExpression = dbColumn[\"GENERATION_EXPRESSION\"];\n          tableColumn.generatedType = dbColumn[\"EXTRA\"].indexOf(\"VIRTUAL\") !== -1 ? \"VIRTUAL\" : \"STORED\";\n        }\n        tableColumn.isUnique = columnUniqueIndices.length > 0 && !hasIgnoredIndex && !isConstraintComposite;\n        tableColumn.isNullable = dbColumn[\"IS_NULLABLE\"] === \"YES\";\n        tableColumn.isPrimary = dbPrimaryKeys.some(dbPrimaryKey => {\n          return dbPrimaryKey[\"TABLE_NAME\"] === dbColumn[\"TABLE_NAME\"] && dbPrimaryKey[\"TABLE_SCHEMA\"] === dbColumn[\"TABLE_SCHEMA\"] && dbPrimaryKey[\"COLUMN_NAME\"] === dbColumn[\"COLUMN_NAME\"];\n        });\n        tableColumn.zerofill = dbColumn[\"COLUMN_TYPE\"].indexOf(\"zerofill\") !== -1;\n        tableColumn.isGenerated = dbColumn[\"EXTRA\"].indexOf(\"auto_increment\") !== -1;\n        if (tableColumn.isGenerated) tableColumn.generationStrategy = \"increment\";\n        tableColumn.comment = typeof dbColumn[\"COLUMN_COMMENT\"] === \"string\" && dbColumn[\"COLUMN_COMMENT\"].length === 0 ? undefined : dbColumn[\"COLUMN_COMMENT\"];\n        if (dbColumn[\"CHARACTER_SET_NAME\"]) tableColumn.charset = dbColumn[\"CHARACTER_SET_NAME\"] === defaultCharset ? undefined : dbColumn[\"CHARACTER_SET_NAME\"];\n        if (dbColumn[\"COLLATION_NAME\"]) tableColumn.collation = dbColumn[\"COLLATION_NAME\"] === defaultCollation ? undefined : dbColumn[\"COLLATION_NAME\"];\n        // check only columns that have length property\n        if (this.driver.withLengthColumnTypes.indexOf(tableColumn.type) !== -1 && dbColumn[\"CHARACTER_MAXIMUM_LENGTH\"]) {\n          const length = dbColumn[\"CHARACTER_MAXIMUM_LENGTH\"].toString();\n          tableColumn.length = !this.isDefaultColumnLength(table, tableColumn, length) ? length : \"\";\n        }\n        if (tableColumn.type === \"decimal\" || tableColumn.type === \"double\" || tableColumn.type === \"float\") {\n          if (dbColumn[\"NUMERIC_PRECISION\"] !== null && !this.isDefaultColumnPrecision(table, tableColumn, dbColumn[\"NUMERIC_PRECISION\"])) tableColumn.precision = parseInt(dbColumn[\"NUMERIC_PRECISION\"]);\n          if (dbColumn[\"NUMERIC_SCALE\"] !== null && !this.isDefaultColumnScale(table, tableColumn, dbColumn[\"NUMERIC_SCALE\"])) tableColumn.scale = parseInt(dbColumn[\"NUMERIC_SCALE\"]);\n        }\n        if (tableColumn.type === \"enum\" || tableColumn.type === \"simple-enum\" || tableColumn.type === \"set\") {\n          const colType = dbColumn[\"COLUMN_TYPE\"];\n          const items = colType.substring(colType.indexOf(\"(\") + 1, colType.lastIndexOf(\")\")).split(\",\");\n          tableColumn.enum = items.map(item => {\n            return item.substring(1, item.length - 1);\n          });\n          tableColumn.length = \"\";\n        }\n        if ((tableColumn.type === \"datetime\" || tableColumn.type === \"time\" || tableColumn.type === \"timestamp\") && dbColumn[\"DATETIME_PRECISION\"] !== null && dbColumn[\"DATETIME_PRECISION\"] !== undefined && !this.isDefaultColumnPrecision(table, tableColumn, parseInt(dbColumn[\"DATETIME_PRECISION\"]))) {\n          tableColumn.precision = parseInt(dbColumn[\"DATETIME_PRECISION\"]);\n        }\n        return tableColumn;\n      });\n      // find foreign key constraints of table, group them by constraint name and build TableForeignKey.\n      const tableForeignKeyConstraints = OrmUtils.uniq(dbForeignKeys.filter(dbForeignKey => {\n        return dbForeignKey[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"] && dbForeignKey[\"TABLE_SCHEMA\"] === dbTable[\"TABLE_SCHEMA\"];\n      }), dbForeignKey => dbForeignKey[\"CONSTRAINT_NAME\"]);\n      table.foreignKeys = tableForeignKeyConstraints.map(dbForeignKey => {\n        const foreignKeys = dbForeignKeys.filter(dbFk => dbFk[\"CONSTRAINT_NAME\"] === dbForeignKey[\"CONSTRAINT_NAME\"]);\n        // if referenced table located in currently used db, we don't need to concat db name to table name.\n        const database = dbForeignKey[\"REFERENCED_TABLE_SCHEMA\"] === currentDatabase ? undefined : dbForeignKey[\"REFERENCED_TABLE_SCHEMA\"];\n        const referencedTableName = this.driver.buildTableName(dbForeignKey[\"REFERENCED_TABLE_NAME\"], undefined, database);\n        return new TableForeignKey({\n          name: dbForeignKey[\"CONSTRAINT_NAME\"],\n          columnNames: foreignKeys.map(dbFk => dbFk[\"COLUMN_NAME\"]),\n          referencedDatabase: dbForeignKey[\"REFERENCED_TABLE_SCHEMA\"],\n          referencedTableName: referencedTableName,\n          referencedColumnNames: foreignKeys.map(dbFk => dbFk[\"REFERENCED_COLUMN_NAME\"]),\n          onDelete: dbForeignKey[\"ON_DELETE\"],\n          onUpdate: dbForeignKey[\"ON_UPDATE\"]\n        });\n      });\n      // find index constraints of table, group them by constraint name and build TableIndex.\n      const tableIndexConstraints = OrmUtils.uniq(dbIndices.filter(dbIndex => {\n        return dbIndex[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"] && dbIndex[\"TABLE_SCHEMA\"] === dbTable[\"TABLE_SCHEMA\"];\n      }), dbIndex => dbIndex[\"INDEX_NAME\"]);\n      table.indices = tableIndexConstraints.map(constraint => {\n        const indices = dbIndices.filter(index => {\n          return index[\"TABLE_SCHEMA\"] === constraint[\"TABLE_SCHEMA\"] && index[\"TABLE_NAME\"] === constraint[\"TABLE_NAME\"] && index[\"INDEX_NAME\"] === constraint[\"INDEX_NAME\"];\n        });\n        const nonUnique = parseInt(constraint[\"NON_UNIQUE\"], 10);\n        return new TableIndex({\n          table: table,\n          name: constraint[\"INDEX_NAME\"],\n          columnNames: indices.map(i => i[\"COLUMN_NAME\"]),\n          isUnique: nonUnique === 0,\n          isSpatial: constraint[\"INDEX_TYPE\"] === \"SPATIAL\",\n          isFulltext: constraint[\"INDEX_TYPE\"] === \"FULLTEXT\"\n        });\n      });\n      return table;\n    }));\n  }\n  /**\n   * Builds create table sql\n   */\n  createTableSql(table, createForeignKeys) {\n    const columnDefinitions = table.columns.map(column => this.buildCreateColumnSql(column, true)).join(\", \");\n    let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`;\n    // we create unique indexes instead of unique constraints, because MySql does not have unique constraints.\n    // if we mark column as Unique, it means that we create UNIQUE INDEX.\n    table.columns.filter(column => column.isUnique).forEach(column => {\n      const isUniqueIndexExist = table.indices.some(index => {\n        return index.columnNames.length === 1 && !!index.isUnique && index.columnNames.indexOf(column.name) !== -1;\n      });\n      const isUniqueConstraintExist = table.uniques.some(unique => {\n        return unique.columnNames.length === 1 && unique.columnNames.indexOf(column.name) !== -1;\n      });\n      if (!isUniqueIndexExist && !isUniqueConstraintExist) table.indices.push(new TableIndex({\n        name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),\n        columnNames: [column.name],\n        isUnique: true\n      }));\n    });\n    // as MySql does not have unique constraints, we must create table indices from table uniques and mark them as unique.\n    if (table.uniques.length > 0) {\n      table.uniques.forEach(unique => {\n        const uniqueExist = table.indices.some(index => index.name === unique.name);\n        if (!uniqueExist) {\n          table.indices.push(new TableIndex({\n            name: unique.name,\n            columnNames: unique.columnNames,\n            isUnique: true\n          }));\n        }\n      });\n    }\n    if (table.indices.length > 0) {\n      const indicesSql = table.indices.map(index => {\n        const columnNames = index.columnNames.map(columnName => `\\`${columnName}\\``).join(\", \");\n        if (!index.name) index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);\n        let indexType = \"\";\n        if (index.isUnique) indexType += \"UNIQUE \";\n        if (index.isSpatial) indexType += \"SPATIAL \";\n        if (index.isFulltext) indexType += \"FULLTEXT \";\n        return `${indexType}INDEX \\`${index.name}\\` (${columnNames})`;\n      }).join(\", \");\n      sql += `, ${indicesSql}`;\n    }\n    if (table.foreignKeys.length > 0 && createForeignKeys) {\n      const foreignKeysSql = table.foreignKeys.map(fk => {\n        const columnNames = fk.columnNames.map(columnName => `\\`${columnName}\\``).join(\", \");\n        if (!fk.name) fk.name = this.connection.namingStrategy.foreignKeyName(table, fk.columnNames);\n        const referencedColumnNames = fk.referencedColumnNames.map(columnName => `\\`${columnName}\\``).join(\", \");\n        let constraint = `CONSTRAINT \\`${fk.name}\\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(fk))} (${referencedColumnNames})`;\n        if (fk.onDelete) constraint += ` ON DELETE ${fk.onDelete}`;\n        if (fk.onUpdate) constraint += ` ON UPDATE ${fk.onUpdate}`;\n        return constraint;\n      }).join(\", \");\n      sql += `, ${foreignKeysSql}`;\n    }\n    if (table.primaryColumns.length > 0) {\n      const columnNames = table.primaryColumns.map(column => `\\`${column.name}\\``).join(\", \");\n      sql += `, PRIMARY KEY (${columnNames})`;\n    }\n    sql += `) ENGINE=${table.engine || \"InnoDB\"}`;\n    return new Query(sql);\n  }\n  /**\n   * Builds drop table sql\n   */\n  dropTableSql(tableOrName) {\n    return new Query(`DROP TABLE ${this.escapePath(tableOrName)}`);\n  }\n  createViewSql(view) {\n    if (typeof view.expression === \"string\") {\n      return new Query(`CREATE VIEW ${this.escapePath(view)} AS ${view.expression}`);\n    } else {\n      return new Query(`CREATE VIEW ${this.escapePath(view)} AS ${view.expression(this.connection).getQuery()}`);\n    }\n  }\n  async insertViewDefinitionSql(view) {\n    const currentDatabase = await this.getCurrentDatabase();\n    const expression = typeof view.expression === \"string\" ? view.expression.trim() : view.expression(this.connection).getQuery();\n    return this.insertTypeormMetadataSql({\n      type: MetadataTableType.VIEW,\n      schema: currentDatabase,\n      name: view.name,\n      value: expression\n    });\n  }\n  /**\n   * Builds drop view sql.\n   */\n  dropViewSql(viewOrPath) {\n    return new Query(`DROP VIEW ${this.escapePath(viewOrPath)}`);\n  }\n  /**\n   * Builds remove view sql.\n   */\n  async deleteViewDefinitionSql(viewOrPath) {\n    const currentDatabase = await this.getCurrentDatabase();\n    const viewName = InstanceChecker.isView(viewOrPath) ? viewOrPath.name : viewOrPath;\n    return this.deleteTypeormMetadataSql({\n      type: MetadataTableType.VIEW,\n      schema: currentDatabase,\n      name: viewName\n    });\n  }\n  /**\n   * Builds create index sql.\n   */\n  createIndexSql(table, index) {\n    const columns = index.columnNames.map(columnName => `\\`${columnName}\\``).join(\", \");\n    let indexType = \"\";\n    if (index.isUnique) indexType += \"UNIQUE \";\n    if (index.isSpatial) indexType += \"SPATIAL \";\n    if (index.isFulltext) indexType += \"FULLTEXT \";\n    return new Query(`CREATE ${indexType}INDEX \\`${index.name}\\` ON ${this.escapePath(table)} (${columns})`);\n  }\n  /**\n   * Builds drop index sql.\n   */\n  dropIndexSql(table, indexOrName) {\n    let indexName = InstanceChecker.isTableIndex(indexOrName) ? indexOrName.name : indexOrName;\n    return new Query(`DROP INDEX \\`${indexName}\\` ON ${this.escapePath(table)}`);\n  }\n  /**\n   * Builds create primary key sql.\n   */\n  createPrimaryKeySql(table, columnNames) {\n    const columnNamesString = columnNames.map(columnName => `\\`${columnName}\\``).join(\", \");\n    return new Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNamesString})`);\n  }\n  /**\n   * Builds drop primary key sql.\n   */\n  dropPrimaryKeySql(table) {\n    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`);\n  }\n  /**\n   * Builds create foreign key sql.\n   */\n  createForeignKeySql(table, foreignKey) {\n    const columnNames = foreignKey.columnNames.map(column => `\\`${column}\\``).join(\", \");\n    const referencedColumnNames = foreignKey.referencedColumnNames.map(column => `\\`${column}\\``).join(\",\");\n    let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \\`${foreignKey.name}\\` FOREIGN KEY (${columnNames}) ` + `REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;\n    if (foreignKey.onDelete) sql += ` ON DELETE ${foreignKey.onDelete}`;\n    if (foreignKey.onUpdate) sql += ` ON UPDATE ${foreignKey.onUpdate}`;\n    return new Query(sql);\n  }\n  /**\n   * Builds drop foreign key sql.\n   */\n  dropForeignKeySql(table, foreignKeyOrName) {\n    const foreignKeyName = InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName.name : foreignKeyOrName;\n    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP FOREIGN KEY \\`${foreignKeyName}\\``);\n  }\n  /**\n   * Escapes a given comment so it's safe to include in a query.\n   */\n  escapeComment(comment) {\n    if (!comment || comment.length === 0) {\n      return `''`;\n    }\n    comment = comment.replace(/\\\\/g, \"\\\\\\\\\") // MySQL allows escaping characters via backslashes\n    .replace(/'/g, \"''\").replace(/\\u0000/g, \"\"); // Null bytes aren't allowed in comments\n    return `'${comment}'`;\n  }\n  /**\n   * Escapes given table or view path.\n   */\n  escapePath(target) {\n    const {\n      database,\n      tableName\n    } = this.driver.parseTableName(target);\n    if (database && database !== this.driver.database) {\n      return `\\`${database}\\`.\\`${tableName}\\``;\n    }\n    return `\\`${tableName}\\``;\n  }\n  /**\n   * Builds a part of query to create/change a column.\n   */\n  buildCreateColumnSql(column, skipPrimary, skipName = false) {\n    let c = \"\";\n    if (skipName) {\n      c = this.connection.driver.createFullType(column);\n    } else {\n      c = `\\`${column.name}\\` ${this.connection.driver.createFullType(column)}`;\n    }\n    if (column.asExpression) c += ` AS (${column.asExpression}) ${column.generatedType ? column.generatedType : \"VIRTUAL\"}`;\n    // if you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to that column.\n    if (column.zerofill) {\n      c += \" ZEROFILL\";\n    } else if (column.unsigned) {\n      c += \" UNSIGNED\";\n    }\n    if (column.enum) c += ` (${column.enum.map(value => \"'\" + value + \"'\").join(\", \")})`;\n    if (column.charset) c += ` CHARACTER SET \"${column.charset}\"`;\n    if (column.collation) c += ` COLLATE \"${column.collation}\"`;\n    if (!column.isNullable) c += \" NOT NULL\";\n    if (column.isNullable) c += \" NULL\";\n    if (column.isPrimary && !skipPrimary) c += \" PRIMARY KEY\";\n    if (column.isGenerated && column.generationStrategy === \"increment\")\n      // don't use skipPrimary here since updates can update already exist primary without auto inc.\n      c += \" AUTO_INCREMENT\";\n    if (column.comment) c += ` COMMENT ${this.escapeComment(column.comment)}`;\n    if (column.default !== undefined && column.default !== null) c += ` DEFAULT ${column.default}`;\n    if (column.onUpdate) c += ` ON UPDATE ${column.onUpdate}`;\n    return c;\n  }\n  /**\n   * Checks if column display width is by default.\n   */\n  isDefaultColumnWidth(table, column, width) {\n    // if table have metadata, we check if length is specified in column metadata\n    if (this.connection.hasMetadata(table.name)) {\n      const metadata = this.connection.getMetadata(table.name);\n      const columnMetadata = metadata.findColumnWithDatabaseName(column.name);\n      if (columnMetadata && columnMetadata.width) return false;\n    }\n    const defaultWidthForType = this.connection.driver.dataTypeDefaults && this.connection.driver.dataTypeDefaults[column.type] && this.connection.driver.dataTypeDefaults[column.type].width;\n    if (defaultWidthForType) {\n      // In MariaDB & MySQL 5.7, the default widths of certain numeric types are 1 less than\n      // the usual defaults when the column is unsigned.\n      // This also applies to Aurora MySQL.\n      const typesWithReducedUnsignedDefault = [\"int\", \"tinyint\", \"smallint\", \"mediumint\"];\n      const needsAdjustment = typesWithReducedUnsignedDefault.indexOf(column.type) !== -1;\n      if (column.unsigned && needsAdjustment) {\n        return defaultWidthForType - 1 === width;\n      } else {\n        return defaultWidthForType === width;\n      }\n    }\n    return false;\n  }\n  /**\n   * Change table comment.\n   */\n  changeTableComment(tableOrName, comment) {\n    throw new TypeORMError(`aurora-mysql driver does not support change table comment.`);\n  }\n}","map":{"version":3,"names":["QueryResult","TransactionNotStartedError","TableColumn","Table","TableForeignKey","TableIndex","QueryRunnerAlreadyReleasedError","View","Query","OrmUtils","TableUnique","BaseQueryRunner","Broadcaster","TypeORMError","MetadataTableType","InstanceChecker","AuroraMysqlQueryRunner","constructor","driver","client","connection","broadcaster","connect","release","isReleased","databaseConnection","Promise","resolve","startTransaction","isolationLevel","isTransactionActive","broadcast","err","transactionDepth","query","commitTransaction","rollbackTransaction","parameters","useStructuredResult","raw","result","hasOwnProperty","Array","isArray","records","affected","numberOfRecordsUpdated","stream","onEnd","onError","ok","fail","on","getDatabases","getSchemas","database","hasDatabase","length","getCurrentDatabase","hasSchema","schema","getCurrentSchema","hasTable","tableOrName","parsedTableName","parseTableName","sql","tableName","hasColumn","column","columnName","isTableColumn","name","createDatabase","ifNotExist","up","down","executeQueries","dropDatabase","ifExist","createSchema","schemaPath","dropSchema","createTable","table","createForeignKeys","isTableExist","upQueries","downQueries","push","createTableSql","dropTableSql","indices","forEach","index","dropIndexSql","foreignKeys","foreignKey","dropForeignKeySql","dropTable","target","dropForeignKeys","tablePath","getTablePath","getCachedTable","createView","view","syncWithMetadata","createViewSql","insertViewDefinitionSql","dropViewSql","deleteViewDefinitionSql","dropView","viewName","isView","getCachedView","renameTable","oldTableOrName","newTableName","oldTable","isTable","newTable","clone","escapePath","columnNames","map","join","newIndexName","namingStrategy","indexName","where","indexType","isUnique","isSpatial","isFulltext","referencedColumnNames","newForeignKeyName","foreignKeyName","onDelete","onUpdate","replaceCachedTable","addColumn","clonedTable","skipColumnLevelPrimary","primaryColumns","buildCreateColumnSql","isPrimary","generatedColumn","columns","find","isGenerated","generationStrategy","nonGeneratedColumn","undefined","columnIndex","createIndexSql","uniqueIndex","uniques","addColumns","renameColumn","oldTableColumnOrName","newTableColumnOrName","oldColumn","c","newColumn","changeColumn","oldColumnOrName","type","generatedType","dropColumn","findColumnIndices","splice","indexOf","findColumnForeignKeys","oldTableColumn","isColumnChanged","primaryColumn","tableUnique","unique","changeColumns","changedColumns","columnOrName","findColumnByName","tableColumn","uniqueName","uniqueConstraintName","foundUnique","foundIndex","removeColumn","dropColumns","createPrimaryKey","createPrimaryKeySql","dropPrimaryKeySql","updatePrimaryKeys","filter","columnNamesString","newOrExistGeneratedColumn","changedGeneratedColumn","dropPrimaryKey","createUniqueConstraint","uniqueConstraint","createUniqueConstraints","uniqueConstraints","dropUniqueConstraint","uniqueOrName","dropUniqueConstraints","createCheckConstraint","checkConstraint","createCheckConstraints","checkConstraints","dropCheckConstraint","checkOrName","dropCheckConstraints","createExclusionConstraint","exclusionConstraint","createExclusionConstraints","exclusionConstraints","dropExclusionConstraint","exclusionOrName","dropExclusionConstraints","createForeignKey","createForeignKeySql","addForeignKey","promises","all","dropForeignKey","foreignKeyOrName","isTableForeignKey","fk","removeForeignKey","createIndex","generateIndexName","addIndex","createIndices","dropIndex","indexOrName","isTableIndex","i","removeIndex","dropIndices","clearTable","clearDatabase","dbName","isDatabaseExist","isAnotherTransactionActive","selectViewDropsQuery","dropViewQueries","q","disableForeignKeysCheckQuery","dropTablesQuery","enableForeignKeysCheckQuery","dropQueries","error","rollbackError","loadViews","viewNames","getTypeormMetadataTableName","currentDatabase","viewsCondition","VIEW","dbViews","dbView","db","buildTableName","expression","loadTables","tableNames","dbTables","tablesSql","tablesCondition","split","columnsCondition","TABLE_NAME","TABLE_SCHEMA","columnsSql","primaryKeySql","collationsSql","indicesCondition","indicesSql","foreignKeysCondition","foreignKeysSql","dbColumns","dbPrimaryKeys","dbCollations","dbIndices","dbForeignKeys","dbTable","dbCollation","coll","defaultCollation","defaultCharset","dbColumn","columnUniqueIndices","dbIndex","parseInt","tableMetadata","entityMetadatas","metadata","hasIgnoredIndex","some","synchronize","isConstraintComposite","every","toLowerCase","unsigned","zerofill","withWidthColumnTypes","width","substring","isDefaultColumnWidth","default","asExpression","isNullable","dbPrimaryKey","comment","charset","collation","withLengthColumnTypes","toString","isDefaultColumnLength","isDefaultColumnPrecision","precision","isDefaultColumnScale","scale","colType","items","lastIndexOf","enum","item","tableForeignKeyConstraints","uniq","dbForeignKey","dbFk","referencedTableName","referencedDatabase","tableIndexConstraints","constraint","nonUnique","columnDefinitions","isUniqueIndexExist","isUniqueConstraintExist","uniqueExist","engine","getQuery","trim","insertTypeormMetadataSql","value","viewOrPath","deleteTypeormMetadataSql","escapeComment","replace","skipPrimary","skipName","createFullType","hasMetadata","getMetadata","columnMetadata","findColumnWithDatabaseName","defaultWidthForType","dataTypeDefaults","typesWithReducedUnsignedDefault","needsAdjustment","changeTableComment"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\driver\\aurora-mysql\\AuroraMysqlQueryRunner.ts"],"sourcesContent":["import { QueryResult } from \"../../query-runner/QueryResult\"\nimport { QueryRunner } from \"../../query-runner/QueryRunner\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\"\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\"\nimport { Table } from \"../../schema-builder/table/Table\"\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\"\nimport { TableIndex } from \"../../schema-builder/table/TableIndex\"\nimport { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\"\nimport { View } from \"../../schema-builder/view/View\"\nimport { Query } from \"../Query\"\nimport { AuroraMysqlDriver } from \"./AuroraMysqlDriver\"\nimport { ReadStream } from \"../../platform/PlatformTools\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { TableIndexOptions } from \"../../schema-builder/options/TableIndexOptions\"\nimport { TableUnique } from \"../../schema-builder/table/TableUnique\"\nimport { BaseQueryRunner } from \"../../query-runner/BaseQueryRunner\"\nimport { Broadcaster } from \"../../subscriber/Broadcaster\"\nimport { ColumnType } from \"../types/ColumnTypes\"\nimport { TableCheck } from \"../../schema-builder/table/TableCheck\"\nimport { IsolationLevel } from \"../types/IsolationLevel\"\nimport { TableExclusion } from \"../../schema-builder/table/TableExclusion\"\nimport { TypeORMError } from \"../../error\"\nimport { MetadataTableType } from \"../types/MetadataTableType\"\nimport { InstanceChecker } from \"../../util/InstanceChecker\"\n\n/**\n * Runs queries on a single mysql database connection.\n */\nexport class AuroraMysqlQueryRunner\n    extends BaseQueryRunner\n    implements QueryRunner\n{\n    // -------------------------------------------------------------------------\n    // Public Implemented Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Database driver used by connection.\n     */\n\n    driver: AuroraMysqlDriver\n\n    protected client: any\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Promise used to obtain a database connection from a pool for a first time.\n     */\n    protected databaseConnectionPromise: Promise<any>\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(driver: AuroraMysqlDriver, client: any) {\n        super()\n        this.driver = driver\n        this.connection = driver.connection\n        this.client = client\n        this.broadcaster = new Broadcaster(this)\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates/uses database connection from the connection pool to perform further operations.\n     * Returns obtained database connection.\n     */\n    async connect(): Promise<any> {\n        return {}\n    }\n\n    /**\n     * Releases used database connection.\n     * You cannot use query runner methods once its released.\n     */\n    release(): Promise<void> {\n        this.isReleased = true\n        if (this.databaseConnection) this.databaseConnection.release()\n        return Promise.resolve()\n    }\n\n    /**\n     * Starts transaction on the current connection.\n     */\n    async startTransaction(isolationLevel?: IsolationLevel): Promise<void> {\n        this.isTransactionActive = true\n        try {\n            await this.broadcaster.broadcast(\"BeforeTransactionStart\")\n        } catch (err) {\n            this.isTransactionActive = false\n            throw err\n        }\n\n        if (this.transactionDepth === 0) {\n            this.transactionDepth += 1\n            await this.client.startTransaction()\n        } else {\n            this.transactionDepth += 1\n            await this.query(`SAVEPOINT typeorm_${this.transactionDepth - 1}`)\n        }\n\n        await this.broadcaster.broadcast(\"AfterTransactionStart\")\n    }\n\n    /**\n     * Commits transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async commitTransaction(): Promise<void> {\n        if (!this.isTransactionActive) throw new TransactionNotStartedError()\n\n        await this.broadcaster.broadcast(\"BeforeTransactionCommit\")\n\n        if (this.transactionDepth > 1) {\n            this.transactionDepth -= 1\n            await this.query(\n                `RELEASE SAVEPOINT typeorm_${this.transactionDepth}`,\n            )\n        } else {\n            this.transactionDepth -= 1\n            await this.client.commitTransaction()\n            this.isTransactionActive = false\n        }\n\n        await this.broadcaster.broadcast(\"AfterTransactionCommit\")\n    }\n\n    /**\n     * Rollbacks transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async rollbackTransaction(): Promise<void> {\n        if (!this.isTransactionActive) throw new TransactionNotStartedError()\n\n        await this.broadcaster.broadcast(\"BeforeTransactionRollback\")\n\n        if (this.transactionDepth > 1) {\n            this.transactionDepth -= 1\n            await this.query(\n                `ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth}`,\n            )\n        } else {\n            this.transactionDepth -= 1\n            await this.client.rollbackTransaction()\n            this.isTransactionActive = false\n        }\n\n        await this.broadcaster.broadcast(\"AfterTransactionRollback\")\n    }\n\n    /**\n     * Executes a raw SQL query.\n     */\n    async query(\n        query: string,\n        parameters?: any[],\n        useStructuredResult = false,\n    ): Promise<any> {\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        const raw = await this.client.query(query, parameters)\n\n        const result = new QueryResult()\n\n        result.raw = raw\n\n        if (raw?.hasOwnProperty(\"records\") && Array.isArray(raw.records)) {\n            result.records = raw.records\n        }\n\n        if (raw?.hasOwnProperty(\"numberOfRecordsUpdated\")) {\n            result.affected = raw.numberOfRecordsUpdated\n        }\n\n        if (!useStructuredResult) {\n            return result.raw\n        }\n\n        return result\n    }\n\n    /**\n     * Returns raw data stream.\n     */\n    stream(\n        query: string,\n        parameters?: any[],\n        onEnd?: Function,\n        onError?: Function,\n    ): Promise<ReadStream> {\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        return new Promise(async (ok, fail) => {\n            try {\n                const databaseConnection = await this.connect()\n                const stream = databaseConnection.query(query, parameters)\n                if (onEnd) stream.on(\"end\", onEnd)\n                if (onError) stream.on(\"error\", onError)\n                ok(stream)\n            } catch (err) {\n                fail(err)\n            }\n        })\n    }\n\n    /**\n     * Returns all available database names including system databases.\n     */\n    async getDatabases(): Promise<string[]> {\n        return Promise.resolve([])\n    }\n\n    /**\n     * Returns all available schema names including system schemas.\n     * If database parameter specified, returns schemas of that database.\n     */\n    async getSchemas(database?: string): Promise<string[]> {\n        throw new TypeORMError(`MySql driver does not support table schemas`)\n    }\n\n    /**\n     * Checks if database with the given name exist.\n     */\n    async hasDatabase(database: string): Promise<boolean> {\n        const result = await this.query(\n            `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`SCHEMATA\\` WHERE \\`SCHEMA_NAME\\` = '${database}'`,\n        )\n        return result.length ? true : false\n    }\n\n    /**\n     * Loads currently using database\n     */\n    async getCurrentDatabase(): Promise<string> {\n        const query = await this.query(`SELECT DATABASE() AS \\`db_name\\``)\n        return query[0][\"db_name\"]\n    }\n\n    /**\n     * Checks if schema with the given name exist.\n     */\n    async hasSchema(schema: string): Promise<boolean> {\n        throw new TypeORMError(`MySql driver does not support table schemas`)\n    }\n\n    /**\n     * Loads currently using database schema\n     */\n    async getCurrentSchema(): Promise<string> {\n        const query = await this.query(`SELECT SCHEMA() AS \\`schema_name\\``)\n        return query[0][\"schema_name\"]\n    }\n\n    /**\n     * Checks if table with the given name exist in the database.\n     */\n    async hasTable(tableOrName: Table | string): Promise<boolean> {\n        const parsedTableName = this.driver.parseTableName(tableOrName)\n        const sql = `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`COLUMNS\\` WHERE \\`TABLE_SCHEMA\\` = '${parsedTableName.database}' AND \\`TABLE_NAME\\` = '${parsedTableName.tableName}'`\n        const result = await this.query(sql)\n        return result.length ? true : false\n    }\n\n    /**\n     * Checks if column with the given name exist in the given table.\n     */\n    async hasColumn(\n        tableOrName: Table | string,\n        column: TableColumn | string,\n    ): Promise<boolean> {\n        const parsedTableName = this.driver.parseTableName(tableOrName)\n        const columnName = InstanceChecker.isTableColumn(column)\n            ? column.name\n            : column\n        const sql = `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`COLUMNS\\` WHERE \\`TABLE_SCHEMA\\` = '${parsedTableName.database}' AND \\`TABLE_NAME\\` = '${parsedTableName.tableName}' AND \\`COLUMN_NAME\\` = '${columnName}'`\n        const result = await this.query(sql)\n        return result.length ? true : false\n    }\n\n    /**\n     * Creates a new database.\n     */\n    async createDatabase(\n        database: string,\n        ifNotExist?: boolean,\n    ): Promise<void> {\n        const up = ifNotExist\n            ? `CREATE DATABASE IF NOT EXISTS \\`${database}\\``\n            : `CREATE DATABASE \\`${database}\\``\n        const down = `DROP DATABASE \\`${database}\\``\n        await this.executeQueries(new Query(up), new Query(down))\n    }\n\n    /**\n     * Drops database.\n     */\n    async dropDatabase(database: string, ifExist?: boolean): Promise<void> {\n        const up = ifExist\n            ? `DROP DATABASE IF EXISTS \\`${database}\\``\n            : `DROP DATABASE \\`${database}\\``\n        const down = `CREATE DATABASE \\`${database}\\``\n        await this.executeQueries(new Query(up), new Query(down))\n    }\n\n    /**\n     * Creates a new table schema.\n     */\n    async createSchema(\n        schemaPath: string,\n        ifNotExist?: boolean,\n    ): Promise<void> {\n        throw new TypeORMError(\n            `Schema create queries are not supported by MySql driver.`,\n        )\n    }\n\n    /**\n     * Drops table schema.\n     */\n    async dropSchema(schemaPath: string, ifExist?: boolean): Promise<void> {\n        throw new TypeORMError(\n            `Schema drop queries are not supported by MySql driver.`,\n        )\n    }\n\n    /**\n     * Creates a new table.\n     */\n    async createTable(\n        table: Table,\n        ifNotExist: boolean = false,\n        createForeignKeys: boolean = true,\n    ): Promise<void> {\n        if (ifNotExist) {\n            const isTableExist = await this.hasTable(table)\n            if (isTableExist) return Promise.resolve()\n        }\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        upQueries.push(this.createTableSql(table, createForeignKeys))\n        downQueries.push(this.dropTableSql(table))\n\n        // we must first drop indices, than drop foreign keys, because drop queries runs in reversed order\n        // and foreign keys will be dropped first as indices. This order is very important, because we can't drop index\n        // if it related to the foreign key.\n\n        // createTable does not need separate method to create indices, because it create indices in the same query with table creation.\n        table.indices.forEach((index) =>\n            downQueries.push(this.dropIndexSql(table, index)),\n        )\n\n        // if createForeignKeys is true, we must drop created foreign keys in down query.\n        // createTable does not need separate method to create foreign keys, because it create fk's in the same query with table creation.\n        if (createForeignKeys)\n            table.foreignKeys.forEach((foreignKey) =>\n                downQueries.push(this.dropForeignKeySql(table, foreignKey)),\n            )\n\n        return this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Drop the table.\n     */\n    async dropTable(\n        target: Table | string,\n        ifExist?: boolean,\n        dropForeignKeys: boolean = true,\n    ): Promise<void> {\n        // It needs because if table does not exist and dropForeignKeys or dropIndices is true, we don't need\n        // to perform drop queries for foreign keys and indices.\n        if (ifExist) {\n            const isTableExist = await this.hasTable(target)\n            if (!isTableExist) return Promise.resolve()\n        }\n\n        // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.\n        const createForeignKeys: boolean = dropForeignKeys\n        const tablePath = this.getTablePath(target)\n        const table = await this.getCachedTable(tablePath)\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        if (dropForeignKeys)\n            table.foreignKeys.forEach((foreignKey) =>\n                upQueries.push(this.dropForeignKeySql(table, foreignKey)),\n            )\n\n        table.indices.forEach((index) =>\n            upQueries.push(this.dropIndexSql(table, index)),\n        )\n\n        upQueries.push(this.dropTableSql(table))\n        downQueries.push(this.createTableSql(table, createForeignKeys))\n\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Creates a new view.\n     */\n    async createView(\n        view: View,\n        syncWithMetadata: boolean = false,\n    ): Promise<void> {\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n        upQueries.push(this.createViewSql(view))\n        if (syncWithMetadata)\n            upQueries.push(await this.insertViewDefinitionSql(view))\n        downQueries.push(this.dropViewSql(view))\n        if (syncWithMetadata)\n            downQueries.push(await this.deleteViewDefinitionSql(view))\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Drops the view.\n     */\n    async dropView(target: View | string): Promise<void> {\n        const viewName = InstanceChecker.isView(target) ? target.name : target\n        const view = await this.getCachedView(viewName)\n\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n        upQueries.push(await this.deleteViewDefinitionSql(view))\n        upQueries.push(this.dropViewSql(view))\n        downQueries.push(await this.insertViewDefinitionSql(view))\n        downQueries.push(this.createViewSql(view))\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Renames a table.\n     */\n    async renameTable(\n        oldTableOrName: Table | string,\n        newTableName: string,\n    ): Promise<void> {\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n        const oldTable = InstanceChecker.isTable(oldTableOrName)\n            ? oldTableOrName\n            : await this.getCachedTable(oldTableOrName)\n        const newTable = oldTable.clone()\n\n        const { database } = this.driver.parseTableName(oldTable)\n        newTable.name = database ? `${database}.${newTableName}` : newTableName\n\n        // rename table\n        upQueries.push(\n            new Query(\n                `RENAME TABLE ${this.escapePath(oldTable)} TO ${this.escapePath(\n                    newTable,\n                )}`,\n            ),\n        )\n        downQueries.push(\n            new Query(\n                `RENAME TABLE ${this.escapePath(newTable)} TO ${this.escapePath(\n                    oldTable,\n                )}`,\n            ),\n        )\n\n        // rename index constraints\n        newTable.indices.forEach((index) => {\n            // build new constraint name\n            const columnNames = index.columnNames\n                .map((column) => `\\`${column}\\``)\n                .join(\", \")\n            const newIndexName = this.connection.namingStrategy.indexName(\n                newTable,\n                index.columnNames,\n                index.where,\n            )\n\n            // build queries\n            let indexType = \"\"\n            if (index.isUnique) indexType += \"UNIQUE \"\n            if (index.isSpatial) indexType += \"SPATIAL \"\n            if (index.isFulltext) indexType += \"FULLTEXT \"\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(newTable)} DROP INDEX \\`${\n                        index.name\n                    }\\`, ADD ${indexType}INDEX \\`${newIndexName}\\` (${columnNames})`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        newTable,\n                    )} DROP INDEX \\`${newIndexName}\\`, ADD ${indexType}INDEX \\`${\n                        index.name\n                    }\\` (${columnNames})`,\n                ),\n            )\n\n            // replace constraint name\n            index.name = newIndexName\n        })\n\n        // rename foreign key constraint\n        newTable.foreignKeys.forEach((foreignKey) => {\n            // build new constraint name\n            const columnNames = foreignKey.columnNames\n                .map((column) => `\\`${column}\\``)\n                .join(\", \")\n            const referencedColumnNames = foreignKey.referencedColumnNames\n                .map((column) => `\\`${column}\\``)\n                .join(\",\")\n            const newForeignKeyName =\n                this.connection.namingStrategy.foreignKeyName(\n                    newTable,\n                    foreignKey.columnNames,\n                )\n\n            // build queries\n            let up =\n                `ALTER TABLE ${this.escapePath(newTable)} DROP FOREIGN KEY \\`${\n                    foreignKey.name\n                }\\`, ADD CONSTRAINT \\`${newForeignKeyName}\\` FOREIGN KEY (${columnNames}) ` +\n                `REFERENCES ${this.escapePath(\n                    this.getTablePath(foreignKey),\n                )}(${referencedColumnNames})`\n            if (foreignKey.onDelete) up += ` ON DELETE ${foreignKey.onDelete}`\n            if (foreignKey.onUpdate) up += ` ON UPDATE ${foreignKey.onUpdate}`\n\n            let down =\n                `ALTER TABLE ${this.escapePath(\n                    newTable,\n                )} DROP FOREIGN KEY \\`${newForeignKeyName}\\`, ADD CONSTRAINT \\`${\n                    foreignKey.name\n                }\\` FOREIGN KEY (${columnNames}) ` +\n                `REFERENCES ${this.escapePath(\n                    this.getTablePath(foreignKey),\n                )}(${referencedColumnNames})`\n            if (foreignKey.onDelete) down += ` ON DELETE ${foreignKey.onDelete}`\n            if (foreignKey.onUpdate) down += ` ON UPDATE ${foreignKey.onUpdate}`\n\n            upQueries.push(new Query(up))\n            downQueries.push(new Query(down))\n\n            // replace constraint name\n            foreignKey.name = newForeignKeyName\n        })\n\n        await this.executeQueries(upQueries, downQueries)\n\n        // rename old table and replace it in cached tabled;\n        oldTable.name = newTable.name\n        this.replaceCachedTable(oldTable, newTable)\n    }\n\n    /**\n     * Creates a new column from the column in the table.\n     */\n    async addColumn(\n        tableOrName: Table | string,\n        column: TableColumn,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const clonedTable = table.clone()\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n        const skipColumnLevelPrimary = clonedTable.primaryColumns.length > 0\n\n        upQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    table,\n                )} ADD ${this.buildCreateColumnSql(\n                    column,\n                    skipColumnLevelPrimary,\n                    false,\n                )}`,\n            ),\n        )\n        downQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(table)} DROP COLUMN \\`${\n                    column.name\n                }\\``,\n            ),\n        )\n\n        // create or update primary key constraint\n        if (column.isPrimary && skipColumnLevelPrimary) {\n            // if we already have generated column, we must temporary drop AUTO_INCREMENT property.\n            const generatedColumn = clonedTable.columns.find(\n                (column) =>\n                    column.isGenerated &&\n                    column.generationStrategy === \"increment\",\n            )\n            if (generatedColumn) {\n                const nonGeneratedColumn = generatedColumn.clone()\n                nonGeneratedColumn.isGenerated = false\n                nonGeneratedColumn.generationStrategy = undefined\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                            column.name\n                        }\\` ${this.buildCreateColumnSql(\n                            nonGeneratedColumn,\n                            true,\n                        )}`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                            nonGeneratedColumn.name\n                        }\\` ${this.buildCreateColumnSql(column, true)}`,\n                    ),\n                )\n            }\n\n            const primaryColumns = clonedTable.primaryColumns\n            let columnNames = primaryColumns\n                .map((column) => `\\`${column.name}\\``)\n                .join(\", \")\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        table,\n                    )} ADD PRIMARY KEY (${columnNames})`,\n                ),\n            )\n\n            primaryColumns.push(column)\n            columnNames = primaryColumns\n                .map((column) => `\\`${column.name}\\``)\n                .join(\", \")\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        table,\n                    )} ADD PRIMARY KEY (${columnNames})`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`,\n                ),\n            )\n\n            // if we previously dropped AUTO_INCREMENT property, we must bring it back\n            if (generatedColumn) {\n                const nonGeneratedColumn = generatedColumn.clone()\n                nonGeneratedColumn.isGenerated = false\n                nonGeneratedColumn.generationStrategy = undefined\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                            nonGeneratedColumn.name\n                        }\\` ${this.buildCreateColumnSql(column, true)}`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                            column.name\n                        }\\` ${this.buildCreateColumnSql(\n                            nonGeneratedColumn,\n                            true,\n                        )}`,\n                    ),\n                )\n            }\n        }\n\n        // create column index\n        const columnIndex = clonedTable.indices.find(\n            (index) =>\n                index.columnNames.length === 1 &&\n                index.columnNames[0] === column.name,\n        )\n        if (columnIndex) {\n            upQueries.push(this.createIndexSql(table, columnIndex))\n            downQueries.push(this.dropIndexSql(table, columnIndex))\n        } else if (column.isUnique) {\n            const uniqueIndex = new TableIndex({\n                name: this.connection.namingStrategy.indexName(table, [\n                    column.name,\n                ]),\n                columnNames: [column.name],\n                isUnique: true,\n            })\n            clonedTable.indices.push(uniqueIndex)\n            clonedTable.uniques.push(\n                new TableUnique({\n                    name: uniqueIndex.name,\n                    columnNames: uniqueIndex.columnNames,\n                }),\n            )\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(table)} ADD UNIQUE INDEX \\`${\n                        uniqueIndex.name\n                    }\\` (\\`${column.name}\\`)`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(table)} DROP INDEX \\`${\n                        uniqueIndex.name\n                    }\\``,\n                ),\n            )\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n\n        clonedTable.addColumn(column)\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Creates a new columns from the column in the table.\n     */\n    async addColumns(\n        tableOrName: Table | string,\n        columns: TableColumn[],\n    ): Promise<void> {\n        for (const column of columns) {\n            await this.addColumn(tableOrName, column)\n        }\n    }\n\n    /**\n     * Renames column in the given table.\n     */\n    async renameColumn(\n        tableOrName: Table | string,\n        oldTableColumnOrName: TableColumn | string,\n        newTableColumnOrName: TableColumn | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName)\n            ? oldTableColumnOrName\n            : table.columns.find((c) => c.name === oldTableColumnOrName)\n        if (!oldColumn)\n            throw new TypeORMError(\n                `Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`,\n            )\n\n        let newColumn: TableColumn | undefined = undefined\n        if (InstanceChecker.isTableColumn(newTableColumnOrName)) {\n            newColumn = newTableColumnOrName\n        } else {\n            newColumn = oldColumn.clone()\n            newColumn.name = newTableColumnOrName\n        }\n\n        await this.changeColumn(table, oldColumn, newColumn)\n    }\n\n    /**\n     * Changes a column in the table.\n     */\n    async changeColumn(\n        tableOrName: Table | string,\n        oldColumnOrName: TableColumn | string,\n        newColumn: TableColumn,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        let clonedTable = table.clone()\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        const oldColumn = InstanceChecker.isTableColumn(oldColumnOrName)\n            ? oldColumnOrName\n            : table.columns.find((column) => column.name === oldColumnOrName)\n        if (!oldColumn)\n            throw new TypeORMError(\n                `Column \"${oldColumnOrName}\" was not found in the \"${table.name}\" table.`,\n            )\n\n        if (\n            (newColumn.isGenerated !== oldColumn.isGenerated &&\n                newColumn.generationStrategy !== \"uuid\") ||\n            oldColumn.type !== newColumn.type ||\n            oldColumn.length !== newColumn.length ||\n            oldColumn.generatedType !== newColumn.generatedType\n        ) {\n            await this.dropColumn(table, oldColumn)\n            await this.addColumn(table, newColumn)\n\n            // update cloned table\n            clonedTable = table.clone()\n        } else {\n            if (newColumn.name !== oldColumn.name) {\n                // We don't change any column properties, just rename it.\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                            oldColumn.name\n                        }\\` \\`${newColumn.name}\\` ${this.buildCreateColumnSql(\n                            oldColumn,\n                            true,\n                            true,\n                        )}`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                            newColumn.name\n                        }\\` \\`${oldColumn.name}\\` ${this.buildCreateColumnSql(\n                            oldColumn,\n                            true,\n                            true,\n                        )}`,\n                    ),\n                )\n\n                // rename index constraints\n                clonedTable.findColumnIndices(oldColumn).forEach((index) => {\n                    // build new constraint name\n                    index.columnNames.splice(\n                        index.columnNames.indexOf(oldColumn.name),\n                        1,\n                    )\n                    index.columnNames.push(newColumn.name)\n                    const columnNames = index.columnNames\n                        .map((column) => `\\`${column}\\``)\n                        .join(\", \")\n                    const newIndexName =\n                        this.connection.namingStrategy.indexName(\n                            clonedTable,\n                            index.columnNames,\n                            index.where,\n                        )\n\n                    // build queries\n                    let indexType = \"\"\n                    if (index.isUnique) indexType += \"UNIQUE \"\n                    if (index.isSpatial) indexType += \"SPATIAL \"\n                    if (index.isFulltext) indexType += \"FULLTEXT \"\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP INDEX \\`${\n                                index.name\n                            }\\`, ADD ${indexType}INDEX \\`${newIndexName}\\` (${columnNames})`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP INDEX \\`${newIndexName}\\`, ADD ${indexType}INDEX \\`${\n                                index.name\n                            }\\` (${columnNames})`,\n                        ),\n                    )\n\n                    // replace constraint name\n                    index.name = newIndexName\n                })\n\n                // rename foreign key constraints\n                clonedTable\n                    .findColumnForeignKeys(oldColumn)\n                    .forEach((foreignKey) => {\n                        // build new constraint name\n                        foreignKey.columnNames.splice(\n                            foreignKey.columnNames.indexOf(oldColumn.name),\n                            1,\n                        )\n                        foreignKey.columnNames.push(newColumn.name)\n                        const columnNames = foreignKey.columnNames\n                            .map((column) => `\\`${column}\\``)\n                            .join(\", \")\n                        const referencedColumnNames =\n                            foreignKey.referencedColumnNames\n                                .map((column) => `\\`${column}\\``)\n                                .join(\",\")\n                        const newForeignKeyName =\n                            this.connection.namingStrategy.foreignKeyName(\n                                clonedTable,\n                                foreignKey.columnNames,\n                            )\n\n                        // build queries\n                        let up =\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP FOREIGN KEY \\`${\n                                foreignKey.name\n                            }\\`, ADD CONSTRAINT \\`${newForeignKeyName}\\` FOREIGN KEY (${columnNames}) ` +\n                            `REFERENCES ${this.escapePath(\n                                this.getTablePath(foreignKey),\n                            )}(${referencedColumnNames})`\n                        if (foreignKey.onDelete)\n                            up += ` ON DELETE ${foreignKey.onDelete}`\n                        if (foreignKey.onUpdate)\n                            up += ` ON UPDATE ${foreignKey.onUpdate}`\n\n                        let down =\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP FOREIGN KEY \\`${newForeignKeyName}\\`, ADD CONSTRAINT \\`${\n                                foreignKey.name\n                            }\\` FOREIGN KEY (${columnNames}) ` +\n                            `REFERENCES ${this.escapePath(\n                                this.getTablePath(foreignKey),\n                            )}(${referencedColumnNames})`\n                        if (foreignKey.onDelete)\n                            down += ` ON DELETE ${foreignKey.onDelete}`\n                        if (foreignKey.onUpdate)\n                            down += ` ON UPDATE ${foreignKey.onUpdate}`\n\n                        upQueries.push(new Query(up))\n                        downQueries.push(new Query(down))\n\n                        // replace constraint name\n                        foreignKey.name = newForeignKeyName\n                    })\n\n                // rename old column in the Table object\n                const oldTableColumn = clonedTable.columns.find(\n                    (column) => column.name === oldColumn.name,\n                )\n                clonedTable.columns[\n                    clonedTable.columns.indexOf(oldTableColumn!)\n                ].name = newColumn.name\n                oldColumn.name = newColumn.name\n            }\n\n            if (this.isColumnChanged(oldColumn, newColumn, true)) {\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                            oldColumn.name\n                        }\\` ${this.buildCreateColumnSql(newColumn, true)}`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                            newColumn.name\n                        }\\` ${this.buildCreateColumnSql(oldColumn, true)}`,\n                    ),\n                )\n            }\n\n            if (newColumn.isPrimary !== oldColumn.isPrimary) {\n                // if table have generated column, we must drop AUTO_INCREMENT before changing primary constraints.\n                const generatedColumn = clonedTable.columns.find(\n                    (column) =>\n                        column.isGenerated &&\n                        column.generationStrategy === \"increment\",\n                )\n                if (generatedColumn) {\n                    const nonGeneratedColumn = generatedColumn.clone()\n                    nonGeneratedColumn.isGenerated = false\n                    nonGeneratedColumn.generationStrategy = undefined\n\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                                generatedColumn.name\n                            }\\` ${this.buildCreateColumnSql(\n                                nonGeneratedColumn,\n                                true,\n                            )}`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                                nonGeneratedColumn.name\n                            }\\` ${this.buildCreateColumnSql(\n                                generatedColumn,\n                                true,\n                            )}`,\n                        ),\n                    )\n                }\n\n                const primaryColumns = clonedTable.primaryColumns\n\n                // if primary column state changed, we must always drop existed constraint.\n                if (primaryColumns.length > 0) {\n                    const columnNames = primaryColumns\n                        .map((column) => `\\`${column.name}\\``)\n                        .join(\", \")\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP PRIMARY KEY`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ADD PRIMARY KEY (${columnNames})`,\n                        ),\n                    )\n                }\n\n                if (newColumn.isPrimary === true) {\n                    primaryColumns.push(newColumn)\n                    // update column in table\n                    const column = clonedTable.columns.find(\n                        (column) => column.name === newColumn.name,\n                    )\n                    column!.isPrimary = true\n                    const columnNames = primaryColumns\n                        .map((column) => `\\`${column.name}\\``)\n                        .join(\", \")\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ADD PRIMARY KEY (${columnNames})`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP PRIMARY KEY`,\n                        ),\n                    )\n                } else {\n                    const primaryColumn = primaryColumns.find(\n                        (c) => c.name === newColumn.name,\n                    )\n                    primaryColumns.splice(\n                        primaryColumns.indexOf(primaryColumn!),\n                        1,\n                    )\n                    // update column in table\n                    const column = clonedTable.columns.find(\n                        (column) => column.name === newColumn.name,\n                    )\n                    column!.isPrimary = false\n\n                    // if we have another primary keys, we must recreate constraint.\n                    if (primaryColumns.length > 0) {\n                        const columnNames = primaryColumns\n                            .map((column) => `\\`${column.name}\\``)\n                            .join(\", \")\n                        upQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ADD PRIMARY KEY (${columnNames})`,\n                            ),\n                        )\n                        downQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} DROP PRIMARY KEY`,\n                            ),\n                        )\n                    }\n                }\n\n                // if we have generated column, and we dropped AUTO_INCREMENT property before, we must bring it back\n                if (generatedColumn) {\n                    const nonGeneratedColumn = generatedColumn.clone()\n                    nonGeneratedColumn.isGenerated = false\n                    nonGeneratedColumn.generationStrategy = undefined\n\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                                nonGeneratedColumn.name\n                            }\\` ${this.buildCreateColumnSql(\n                                generatedColumn,\n                                true,\n                            )}`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                                generatedColumn.name\n                            }\\` ${this.buildCreateColumnSql(\n                                nonGeneratedColumn,\n                                true,\n                            )}`,\n                        ),\n                    )\n                }\n            }\n\n            if (newColumn.isUnique !== oldColumn.isUnique) {\n                if (newColumn.isUnique === true) {\n                    const uniqueIndex = new TableIndex({\n                        name: this.connection.namingStrategy.indexName(table, [\n                            newColumn.name,\n                        ]),\n                        columnNames: [newColumn.name],\n                        isUnique: true,\n                    })\n                    clonedTable.indices.push(uniqueIndex)\n                    clonedTable.uniques.push(\n                        new TableUnique({\n                            name: uniqueIndex.name,\n                            columnNames: uniqueIndex.columnNames,\n                        }),\n                    )\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ADD UNIQUE INDEX \\`${uniqueIndex.name}\\` (\\`${\n                                newColumn.name\n                            }\\`)`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP INDEX \\`${uniqueIndex.name}\\``,\n                        ),\n                    )\n                } else {\n                    const uniqueIndex = clonedTable.indices.find((index) => {\n                        return (\n                            index.columnNames.length === 1 &&\n                            index.isUnique === true &&\n                            !!index.columnNames.find(\n                                (columnName) => columnName === newColumn.name,\n                            )\n                        )\n                    })\n                    clonedTable.indices.splice(\n                        clonedTable.indices.indexOf(uniqueIndex!),\n                        1,\n                    )\n\n                    const tableUnique = clonedTable.uniques.find(\n                        (unique) => unique.name === uniqueIndex!.name,\n                    )\n                    clonedTable.uniques.splice(\n                        clonedTable.uniques.indexOf(tableUnique!),\n                        1,\n                    )\n\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP INDEX \\`${uniqueIndex!.name}\\``,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ADD UNIQUE INDEX \\`${uniqueIndex!.name}\\` (\\`${\n                                newColumn.name\n                            }\\`)`,\n                        ),\n                    )\n                }\n            }\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Changes a column in the table.\n     */\n    async changeColumns(\n        tableOrName: Table | string,\n        changedColumns: { newColumn: TableColumn; oldColumn: TableColumn }[],\n    ): Promise<void> {\n        for (const { oldColumn, newColumn } of changedColumns) {\n            await this.changeColumn(tableOrName, oldColumn, newColumn)\n        }\n    }\n\n    /**\n     * Drops column in the table.\n     */\n    async dropColumn(\n        tableOrName: Table | string,\n        columnOrName: TableColumn | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const column = InstanceChecker.isTableColumn(columnOrName)\n            ? columnOrName\n            : table.findColumnByName(columnOrName)\n        if (!column)\n            throw new TypeORMError(\n                `Column \"${columnOrName}\" was not found in table \"${table.name}\"`,\n            )\n\n        const clonedTable = table.clone()\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        // drop primary key constraint\n        if (column.isPrimary) {\n            // if table have generated column, we must drop AUTO_INCREMENT before changing primary constraints.\n            const generatedColumn = clonedTable.columns.find(\n                (column) =>\n                    column.isGenerated &&\n                    column.generationStrategy === \"increment\",\n            )\n            if (generatedColumn) {\n                const nonGeneratedColumn = generatedColumn.clone()\n                nonGeneratedColumn.isGenerated = false\n                nonGeneratedColumn.generationStrategy = undefined\n\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                            generatedColumn.name\n                        }\\` ${this.buildCreateColumnSql(\n                            nonGeneratedColumn,\n                            true,\n                        )}`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                            nonGeneratedColumn.name\n                        }\\` ${this.buildCreateColumnSql(\n                            generatedColumn,\n                            true,\n                        )}`,\n                    ),\n                )\n            }\n\n            // dropping primary key constraint\n            const columnNames = clonedTable.primaryColumns\n                .map((primaryColumn) => `\\`${primaryColumn.name}\\``)\n                .join(\", \")\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        clonedTable,\n                    )} DROP PRIMARY KEY`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        clonedTable,\n                    )} ADD PRIMARY KEY (${columnNames})`,\n                ),\n            )\n\n            // update column in table\n            const tableColumn = clonedTable.findColumnByName(column.name)\n            tableColumn!.isPrimary = false\n\n            // if primary key have multiple columns, we must recreate it without dropped column\n            if (clonedTable.primaryColumns.length > 0) {\n                const columnNames = clonedTable.primaryColumns\n                    .map((primaryColumn) => `\\`${primaryColumn.name}\\``)\n                    .join(\", \")\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(\n                            clonedTable,\n                        )} ADD PRIMARY KEY (${columnNames})`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(\n                            clonedTable,\n                        )} DROP PRIMARY KEY`,\n                    ),\n                )\n            }\n\n            // if we have generated column, and we dropped AUTO_INCREMENT property before, and this column is not current dropping column, we must bring it back\n            if (generatedColumn && generatedColumn.name !== column.name) {\n                const nonGeneratedColumn = generatedColumn.clone()\n                nonGeneratedColumn.isGenerated = false\n                nonGeneratedColumn.generationStrategy = undefined\n\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                            nonGeneratedColumn.name\n                        }\\` ${this.buildCreateColumnSql(\n                            generatedColumn,\n                            true,\n                        )}`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                            generatedColumn.name\n                        }\\` ${this.buildCreateColumnSql(\n                            nonGeneratedColumn,\n                            true,\n                        )}`,\n                    ),\n                )\n            }\n        }\n\n        // drop column index\n        const columnIndex = clonedTable.indices.find(\n            (index) =>\n                index.columnNames.length === 1 &&\n                index.columnNames[0] === column.name,\n        )\n        if (columnIndex) {\n            clonedTable.indices.splice(\n                clonedTable.indices.indexOf(columnIndex),\n                1,\n            )\n            upQueries.push(this.dropIndexSql(table, columnIndex))\n            downQueries.push(this.createIndexSql(table, columnIndex))\n        } else if (column.isUnique) {\n            // we splice constraints both from table uniques and indices.\n            const uniqueName =\n                this.connection.namingStrategy.uniqueConstraintName(table, [\n                    column.name,\n                ])\n            const foundUnique = clonedTable.uniques.find(\n                (unique) => unique.name === uniqueName,\n            )\n            if (foundUnique)\n                clonedTable.uniques.splice(\n                    clonedTable.uniques.indexOf(foundUnique),\n                    1,\n                )\n\n            const indexName = this.connection.namingStrategy.indexName(table, [\n                column.name,\n            ])\n            const foundIndex = clonedTable.indices.find(\n                (index) => index.name === indexName,\n            )\n            if (foundIndex)\n                clonedTable.indices.splice(\n                    clonedTable.indices.indexOf(foundIndex),\n                    1,\n                )\n\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        table,\n                    )} DROP INDEX \\`${indexName}\\``,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        table,\n                    )} ADD UNIQUE INDEX \\`${indexName}\\` (\\`${column.name}\\`)`,\n                ),\n            )\n        }\n\n        upQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(table)} DROP COLUMN \\`${\n                    column.name\n                }\\``,\n            ),\n        )\n        downQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    table,\n                )} ADD ${this.buildCreateColumnSql(column, true)}`,\n            ),\n        )\n\n        await this.executeQueries(upQueries, downQueries)\n\n        clonedTable.removeColumn(column)\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Drops the columns in the table.\n     */\n    async dropColumns(\n        tableOrName: Table | string,\n        columns: TableColumn[] | string[],\n    ): Promise<void> {\n        for (const column of columns) {\n            await this.dropColumn(tableOrName, column)\n        }\n    }\n\n    /**\n     * Creates a new primary key.\n     */\n    async createPrimaryKey(\n        tableOrName: Table | string,\n        columnNames: string[],\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const clonedTable = table.clone()\n\n        const up = this.createPrimaryKeySql(table, columnNames)\n        const down = this.dropPrimaryKeySql(table)\n\n        await this.executeQueries(up, down)\n        clonedTable.columns.forEach((column) => {\n            if (columnNames.find((columnName) => columnName === column.name))\n                column.isPrimary = true\n        })\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Updates composite primary keys.\n     */\n    async updatePrimaryKeys(\n        tableOrName: Table | string,\n        columns: TableColumn[],\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const clonedTable = table.clone()\n        const columnNames = columns.map((column) => column.name)\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        // if table have generated column, we must drop AUTO_INCREMENT before changing primary constraints.\n        const generatedColumn = clonedTable.columns.find(\n            (column) =>\n                column.isGenerated && column.generationStrategy === \"increment\",\n        )\n        if (generatedColumn) {\n            const nonGeneratedColumn = generatedColumn.clone()\n            nonGeneratedColumn.isGenerated = false\n            nonGeneratedColumn.generationStrategy = undefined\n\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                        generatedColumn.name\n                    }\\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                        nonGeneratedColumn.name\n                    }\\` ${this.buildCreateColumnSql(generatedColumn, true)}`,\n                ),\n            )\n        }\n\n        // if table already have primary columns, we must drop them.\n        const primaryColumns = clonedTable.primaryColumns\n        if (primaryColumns.length > 0) {\n            const columnNames = primaryColumns\n                .map((column) => `\\`${column.name}\\``)\n                .join(\", \")\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        table,\n                    )} ADD PRIMARY KEY (${columnNames})`,\n                ),\n            )\n        }\n\n        // update columns in table.\n        clonedTable.columns\n            .filter((column) => columnNames.indexOf(column.name) !== -1)\n            .forEach((column) => (column.isPrimary = true))\n\n        const columnNamesString = columnNames\n            .map((columnName) => `\\`${columnName}\\``)\n            .join(\", \")\n        upQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    table,\n                )} ADD PRIMARY KEY (${columnNamesString})`,\n            ),\n        )\n        downQueries.push(\n            new Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`),\n        )\n\n        // if we already have generated column or column is changed to generated, and we dropped AUTO_INCREMENT property before, we must bring it back\n        const newOrExistGeneratedColumn = generatedColumn\n            ? generatedColumn\n            : columns.find(\n                  (column) =>\n                      column.isGenerated &&\n                      column.generationStrategy === \"increment\",\n              )\n        if (newOrExistGeneratedColumn) {\n            const nonGeneratedColumn = newOrExistGeneratedColumn.clone()\n            nonGeneratedColumn.isGenerated = false\n            nonGeneratedColumn.generationStrategy = undefined\n\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                        nonGeneratedColumn.name\n                    }\\` ${this.buildCreateColumnSql(\n                        newOrExistGeneratedColumn,\n                        true,\n                    )}`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(table)} CHANGE \\`${\n                        newOrExistGeneratedColumn.name\n                    }\\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`,\n                ),\n            )\n\n            // if column changed to generated, we must update it in table\n            const changedGeneratedColumn = clonedTable.columns.find(\n                (column) => column.name === newOrExistGeneratedColumn.name,\n            )\n            changedGeneratedColumn!.isGenerated = true\n            changedGeneratedColumn!.generationStrategy = \"increment\"\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Drops a primary key.\n     */\n    async dropPrimaryKey(tableOrName: Table | string): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const up = this.dropPrimaryKeySql(table)\n        const down = this.createPrimaryKeySql(\n            table,\n            table.primaryColumns.map((column) => column.name),\n        )\n        await this.executeQueries(up, down)\n        table.primaryColumns.forEach((column) => {\n            column.isPrimary = false\n        })\n    }\n\n    /**\n     * Creates a new unique constraint.\n     */\n    async createUniqueConstraint(\n        tableOrName: Table | string,\n        uniqueConstraint: TableUnique,\n    ): Promise<void> {\n        throw new TypeORMError(\n            `MySql does not support unique constraints. Use unique index instead.`,\n        )\n    }\n\n    /**\n     * Creates a new unique constraints.\n     */\n    async createUniqueConstraints(\n        tableOrName: Table | string,\n        uniqueConstraints: TableUnique[],\n    ): Promise<void> {\n        throw new TypeORMError(\n            `MySql does not support unique constraints. Use unique index instead.`,\n        )\n    }\n\n    /**\n     * Drops an unique constraint.\n     */\n    async dropUniqueConstraint(\n        tableOrName: Table | string,\n        uniqueOrName: TableUnique | string,\n    ): Promise<void> {\n        throw new TypeORMError(\n            `MySql does not support unique constraints. Use unique index instead.`,\n        )\n    }\n\n    /**\n     * Drops an unique constraints.\n     */\n    async dropUniqueConstraints(\n        tableOrName: Table | string,\n        uniqueConstraints: TableUnique[],\n    ): Promise<void> {\n        throw new TypeORMError(\n            `MySql does not support unique constraints. Use unique index instead.`,\n        )\n    }\n\n    /**\n     * Creates a new check constraint.\n     */\n    async createCheckConstraint(\n        tableOrName: Table | string,\n        checkConstraint: TableCheck,\n    ): Promise<void> {\n        throw new TypeORMError(`MySql does not support check constraints.`)\n    }\n\n    /**\n     * Creates a new check constraints.\n     */\n    async createCheckConstraints(\n        tableOrName: Table | string,\n        checkConstraints: TableCheck[],\n    ): Promise<void> {\n        throw new TypeORMError(`MySql does not support check constraints.`)\n    }\n\n    /**\n     * Drops check constraint.\n     */\n    async dropCheckConstraint(\n        tableOrName: Table | string,\n        checkOrName: TableCheck | string,\n    ): Promise<void> {\n        throw new TypeORMError(`MySql does not support check constraints.`)\n    }\n\n    /**\n     * Drops check constraints.\n     */\n    async dropCheckConstraints(\n        tableOrName: Table | string,\n        checkConstraints: TableCheck[],\n    ): Promise<void> {\n        throw new TypeORMError(`MySql does not support check constraints.`)\n    }\n\n    /**\n     * Creates a new exclusion constraint.\n     */\n    async createExclusionConstraint(\n        tableOrName: Table | string,\n        exclusionConstraint: TableExclusion,\n    ): Promise<void> {\n        throw new TypeORMError(`MySql does not support exclusion constraints.`)\n    }\n\n    /**\n     * Creates a new exclusion constraints.\n     */\n    async createExclusionConstraints(\n        tableOrName: Table | string,\n        exclusionConstraints: TableExclusion[],\n    ): Promise<void> {\n        throw new TypeORMError(`MySql does not support exclusion constraints.`)\n    }\n\n    /**\n     * Drops exclusion constraint.\n     */\n    async dropExclusionConstraint(\n        tableOrName: Table | string,\n        exclusionOrName: TableExclusion | string,\n    ): Promise<void> {\n        throw new TypeORMError(`MySql does not support exclusion constraints.`)\n    }\n\n    /**\n     * Drops exclusion constraints.\n     */\n    async dropExclusionConstraints(\n        tableOrName: Table | string,\n        exclusionConstraints: TableExclusion[],\n    ): Promise<void> {\n        throw new TypeORMError(`MySql does not support exclusion constraints.`)\n    }\n\n    /**\n     * Creates a new foreign key.\n     */\n    async createForeignKey(\n        tableOrName: Table | string,\n        foreignKey: TableForeignKey,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // new FK may be passed without name. In this case we generate FK name manually.\n        if (!foreignKey.name)\n            foreignKey.name = this.connection.namingStrategy.foreignKeyName(\n                table,\n                foreignKey.columnNames,\n            )\n\n        const up = this.createForeignKeySql(table, foreignKey)\n        const down = this.dropForeignKeySql(table, foreignKey)\n        await this.executeQueries(up, down)\n        table.addForeignKey(foreignKey)\n    }\n\n    /**\n     * Creates a new foreign keys.\n     */\n    async createForeignKeys(\n        tableOrName: Table | string,\n        foreignKeys: TableForeignKey[],\n    ): Promise<void> {\n        const promises = foreignKeys.map((foreignKey) =>\n            this.createForeignKey(tableOrName, foreignKey),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Drops a foreign key.\n     */\n    async dropForeignKey(\n        tableOrName: Table | string,\n        foreignKeyOrName: TableForeignKey | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const foreignKey = InstanceChecker.isTableForeignKey(foreignKeyOrName)\n            ? foreignKeyOrName\n            : table.foreignKeys.find((fk) => fk.name === foreignKeyOrName)\n        if (!foreignKey)\n            throw new TypeORMError(\n                `Supplied foreign key was not found in table ${table.name}`,\n            )\n\n        const up = this.dropForeignKeySql(table, foreignKey)\n        const down = this.createForeignKeySql(table, foreignKey)\n        await this.executeQueries(up, down)\n        table.removeForeignKey(foreignKey)\n    }\n\n    /**\n     * Drops a foreign keys from the table.\n     */\n    async dropForeignKeys(\n        tableOrName: Table | string,\n        foreignKeys: TableForeignKey[],\n    ): Promise<void> {\n        const promises = foreignKeys.map((foreignKey) =>\n            this.dropForeignKey(tableOrName, foreignKey),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Creates a new index.\n     */\n    async createIndex(\n        tableOrName: Table | string,\n        index: TableIndex,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // new index may be passed without name. In this case we generate index name manually.\n        if (!index.name) index.name = this.generateIndexName(table, index)\n\n        const up = this.createIndexSql(table, index)\n        const down = this.dropIndexSql(table, index)\n        await this.executeQueries(up, down)\n        table.addIndex(index, true)\n    }\n\n    /**\n     * Creates a new indices\n     */\n    async createIndices(\n        tableOrName: Table | string,\n        indices: TableIndex[],\n    ): Promise<void> {\n        const promises = indices.map((index) =>\n            this.createIndex(tableOrName, index),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Drops an index.\n     */\n    async dropIndex(\n        tableOrName: Table | string,\n        indexOrName: TableIndex | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const index = InstanceChecker.isTableIndex(indexOrName)\n            ? indexOrName\n            : table.indices.find((i) => i.name === indexOrName)\n        if (!index)\n            throw new TypeORMError(\n                `Supplied index ${indexOrName} was not found in table ${table.name}`,\n            )\n\n        // old index may be passed without name. In this case we generate index name manually.\n        if (!index.name) index.name = this.generateIndexName(table, index)\n\n        const up = this.dropIndexSql(table, index)\n        const down = this.createIndexSql(table, index)\n        await this.executeQueries(up, down)\n        table.removeIndex(index, true)\n    }\n\n    /**\n     * Drops an indices from the table.\n     */\n    async dropIndices(\n        tableOrName: Table | string,\n        indices: TableIndex[],\n    ): Promise<void> {\n        const promises = indices.map((index) =>\n            this.dropIndex(tableOrName, index),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Clears all table contents.\n     * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.\n     */\n    async clearTable(tableOrName: Table | string): Promise<void> {\n        await this.query(`TRUNCATE TABLE ${this.escapePath(tableOrName)}`)\n    }\n\n    /**\n     * Removes all tables from the currently connected database.\n     * Be careful using this method and avoid using it in production or migrations\n     * (because it can clear all your database).\n     */\n    async clearDatabase(database?: string): Promise<void> {\n        const dbName = database ? database : this.driver.database\n        if (dbName) {\n            const isDatabaseExist = await this.hasDatabase(dbName)\n            if (!isDatabaseExist) return Promise.resolve()\n        } else {\n            throw new TypeORMError(\n                `Can not clear database. No database is specified`,\n            )\n        }\n\n        const isAnotherTransactionActive = this.isTransactionActive\n        if (!isAnotherTransactionActive) await this.startTransaction()\n        try {\n            const selectViewDropsQuery = `SELECT concat('DROP VIEW IF EXISTS \\`', table_schema, '\\`.\\`', table_name, '\\`') AS \\`query\\` FROM \\`INFORMATION_SCHEMA\\`.\\`VIEWS\\` WHERE \\`TABLE_SCHEMA\\` = '${dbName}'`\n            const dropViewQueries: ObjectLiteral[] = await this.query(\n                selectViewDropsQuery,\n            )\n            await Promise.all(\n                dropViewQueries.map((q) => this.query(q[\"query\"])),\n            )\n\n            const disableForeignKeysCheckQuery = `SET FOREIGN_KEY_CHECKS = 0;`\n            const dropTablesQuery = `SELECT concat('DROP TABLE IF EXISTS \\`', table_schema, '\\`.\\`', table_name, '\\`') AS \\`query\\` FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` WHERE \\`TABLE_SCHEMA\\` = '${dbName}'`\n            const enableForeignKeysCheckQuery = `SET FOREIGN_KEY_CHECKS = 1;`\n\n            await this.query(disableForeignKeysCheckQuery)\n            const dropQueries: ObjectLiteral[] = await this.query(\n                dropTablesQuery,\n            )\n            await Promise.all(\n                dropQueries.map((query) => this.query(query[\"query\"])),\n            )\n            await this.query(enableForeignKeysCheckQuery)\n\n            if (!isAnotherTransactionActive) {\n                await this.commitTransaction()\n            }\n        } catch (error) {\n            try {\n                // we throw original error even if rollback thrown an error\n                if (!isAnotherTransactionActive) {\n                    await this.rollbackTransaction()\n                }\n            } catch (rollbackError) {}\n            throw error\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    protected async loadViews(viewNames?: string[]): Promise<View[]> {\n        const hasTable = await this.hasTable(this.getTypeormMetadataTableName())\n        if (!hasTable) {\n            return []\n        }\n\n        if (!viewNames) {\n            viewNames = []\n        }\n\n        const currentDatabase = await this.getCurrentDatabase()\n        const viewsCondition = viewNames\n            .map((tableName) => {\n                let { database, tableName: name } =\n                    this.driver.parseTableName(tableName)\n\n                if (!database) {\n                    database = currentDatabase\n                }\n\n                return `(\\`t\\`.\\`schema\\` = '${database}' AND \\`t\\`.\\`name\\` = '${name}')`\n            })\n            .join(\" OR \")\n\n        const query =\n            `SELECT \\`t\\`.*, \\`v\\`.\\`check_option\\` FROM ${this.escapePath(\n                this.getTypeormMetadataTableName(),\n            )} \\`t\\` ` +\n            `INNER JOIN \\`information_schema\\`.\\`views\\` \\`v\\` ON \\`v\\`.\\`table_schema\\` = \\`t\\`.\\`schema\\` AND \\`v\\`.\\`table_name\\` = \\`t\\`.\\`name\\` WHERE \\`t\\`.\\`type\\` = '${\n                MetadataTableType.VIEW\n            }' ${viewsCondition ? `AND (${viewsCondition})` : \"\"}`\n        const dbViews = await this.query(query)\n        return dbViews.map((dbView: any) => {\n            const view = new View()\n            const db =\n                dbView[\"schema\"] === currentDatabase\n                    ? undefined\n                    : dbView[\"schema\"]\n            view.database = dbView[\"schema\"]\n            view.name = this.driver.buildTableName(\n                dbView[\"name\"],\n                undefined,\n                db,\n            )\n            view.expression = dbView[\"value\"]\n            return view\n        })\n    }\n\n    /**\n     * Loads all tables (with given names) from the database and creates a Table from them.\n     */\n    protected async loadTables(tableNames?: string[]): Promise<Table[]> {\n        // if no tables given then no need to proceed\n        if (tableNames && tableNames.length === 0) {\n            return []\n        }\n\n        const dbTables: { TABLE_NAME: string; TABLE_SCHEMA: string }[] = []\n\n        const currentDatabase = await this.getCurrentDatabase()\n\n        if (!tableNames) {\n            const tablesSql = `SELECT TABLE_NAME, TABLE_SCHEMA FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\``\n\n            dbTables.push(...(await this.query(tablesSql)))\n        } else {\n            const tablesCondition = tableNames\n                .map((tableName) => {\n                    let [database, name] = tableName.split(\".\")\n                    if (!name) {\n                        name = database\n                        database = this.driver.database || currentDatabase\n                    }\n                    return `(\\`TABLE_SCHEMA\\` = '${database}' AND \\`TABLE_NAME\\` = '${name}')`\n                })\n                .join(\" OR \")\n            const tablesSql =\n                `SELECT TABLE_NAME, TABLE_SCHEMA FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` WHERE ` +\n                tablesCondition\n\n            dbTables.push(...(await this.query(tablesSql)))\n        }\n\n        if (dbTables.length === 0) {\n            return []\n        }\n\n        const columnsCondition = dbTables\n            .map(({ TABLE_NAME, TABLE_SCHEMA }) => {\n                return `(\\`TABLE_SCHEMA\\` = '${TABLE_SCHEMA}' AND \\`TABLE_NAME\\` = '${TABLE_NAME}')`\n            })\n            .join(\" OR \")\n        const columnsSql =\n            `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`COLUMNS\\` WHERE ` +\n            columnsCondition\n\n        const primaryKeySql = `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`KEY_COLUMN_USAGE\\` WHERE \\`CONSTRAINT_NAME\\` = 'PRIMARY' AND (${columnsCondition})`\n\n        const collationsSql = `SELECT \\`SCHEMA_NAME\\`, \\`DEFAULT_CHARACTER_SET_NAME\\` as \\`CHARSET\\`, \\`DEFAULT_COLLATION_NAME\\` AS \\`COLLATION\\` FROM \\`INFORMATION_SCHEMA\\`.\\`SCHEMATA\\``\n\n        const indicesCondition = dbTables\n            .map(({ TABLE_NAME, TABLE_SCHEMA }) => {\n                return `(\\`s\\`.\\`TABLE_SCHEMA\\` = '${TABLE_SCHEMA}' AND \\`s\\`.\\`TABLE_NAME\\` = '${TABLE_NAME}')`\n            })\n            .join(\" OR \")\n        const indicesSql =\n            `SELECT \\`s\\`.* FROM \\`INFORMATION_SCHEMA\\`.\\`STATISTICS\\` \\`s\\` ` +\n            `LEFT JOIN \\`INFORMATION_SCHEMA\\`.\\`REFERENTIAL_CONSTRAINTS\\` \\`rc\\` ON \\`s\\`.\\`INDEX_NAME\\` = \\`rc\\`.\\`CONSTRAINT_NAME\\` ` +\n            `WHERE (${indicesCondition}) AND \\`s\\`.\\`INDEX_NAME\\` != 'PRIMARY' AND \\`rc\\`.\\`CONSTRAINT_NAME\\` IS NULL`\n\n        const foreignKeysCondition = dbTables\n            .map(({ TABLE_NAME, TABLE_SCHEMA }) => {\n                return `(\\`kcu\\`.\\`TABLE_SCHEMA\\` = '${TABLE_SCHEMA}' AND \\`kcu\\`.\\`TABLE_NAME\\` = '${TABLE_NAME}')`\n            })\n            .join(\" OR \")\n        const foreignKeysSql =\n            `SELECT \\`kcu\\`.\\`TABLE_SCHEMA\\`, \\`kcu\\`.\\`TABLE_NAME\\`, \\`kcu\\`.\\`CONSTRAINT_NAME\\`, \\`kcu\\`.\\`COLUMN_NAME\\`, \\`kcu\\`.\\`REFERENCED_TABLE_SCHEMA\\`, ` +\n            `\\`kcu\\`.\\`REFERENCED_TABLE_NAME\\`, \\`kcu\\`.\\`REFERENCED_COLUMN_NAME\\`, \\`rc\\`.\\`DELETE_RULE\\` \\`ON_DELETE\\`, \\`rc\\`.\\`UPDATE_RULE\\` \\`ON_UPDATE\\` ` +\n            `FROM \\`INFORMATION_SCHEMA\\`.\\`KEY_COLUMN_USAGE\\` \\`kcu\\` ` +\n            `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`REFERENTIAL_CONSTRAINTS\\` \\`rc\\` ON \\`rc\\`.\\`constraint_name\\` = \\`kcu\\`.\\`constraint_name\\` ` +\n            `WHERE ` +\n            foreignKeysCondition\n        const [\n            dbColumns,\n            dbPrimaryKeys,\n            dbCollations,\n            dbIndices,\n            dbForeignKeys,\n        ]: ObjectLiteral[][] = await Promise.all([\n            this.query(columnsSql),\n            this.query(primaryKeySql),\n            this.query(collationsSql),\n            this.query(indicesSql),\n            this.query(foreignKeysSql),\n        ])\n\n        // create tables for loaded tables\n        return Promise.all(\n            dbTables.map(async (dbTable) => {\n                const table = new Table()\n\n                const dbCollation = dbCollations.find(\n                    (coll) => coll[\"SCHEMA_NAME\"] === dbTable[\"TABLE_SCHEMA\"],\n                )!\n                const defaultCollation = dbCollation[\"COLLATION\"]\n                const defaultCharset = dbCollation[\"CHARSET\"]\n\n                // We do not need to join database name, when database is by default.\n                const db =\n                    dbTable[\"TABLE_SCHEMA\"] === currentDatabase\n                        ? undefined\n                        : dbTable[\"TABLE_SCHEMA\"]\n                table.database = dbTable[\"TABLE_SCHEMA\"]\n                table.name = this.driver.buildTableName(\n                    dbTable[\"TABLE_NAME\"],\n                    undefined,\n                    db,\n                )\n\n                // create columns from the loaded columns\n                table.columns = dbColumns\n                    .filter(\n                        (dbColumn) =>\n                            dbColumn[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"] &&\n                            dbColumn[\"TABLE_SCHEMA\"] ===\n                                dbTable[\"TABLE_SCHEMA\"],\n                    )\n                    .map((dbColumn) => {\n                        const columnUniqueIndices = dbIndices.filter(\n                            (dbIndex) => {\n                                return (\n                                    dbIndex[\"TABLE_NAME\"] ===\n                                        dbTable[\"TABLE_NAME\"] &&\n                                    dbIndex[\"TABLE_SCHEMA\"] ===\n                                        dbTable[\"TABLE_SCHEMA\"] &&\n                                    dbIndex[\"COLUMN_NAME\"] ===\n                                        dbColumn[\"COLUMN_NAME\"] &&\n                                    parseInt(dbIndex[\"NON_UNIQUE\"], 10) === 0\n                                )\n                            },\n                        )\n\n                        const tableMetadata =\n                            this.connection.entityMetadatas.find(\n                                (metadata) =>\n                                    this.getTablePath(table) ===\n                                    this.getTablePath(metadata),\n                            )\n                        const hasIgnoredIndex =\n                            columnUniqueIndices.length > 0 &&\n                            tableMetadata &&\n                            tableMetadata.indices.some((index) => {\n                                return columnUniqueIndices.some(\n                                    (uniqueIndex) => {\n                                        return (\n                                            index.name ===\n                                                uniqueIndex[\"INDEX_NAME\"] &&\n                                            index.synchronize === false\n                                        )\n                                    },\n                                )\n                            })\n\n                        const isConstraintComposite = columnUniqueIndices.every(\n                            (uniqueIndex) => {\n                                return dbIndices.some(\n                                    (dbIndex) =>\n                                        dbIndex[\"INDEX_NAME\"] ===\n                                            uniqueIndex[\"INDEX_NAME\"] &&\n                                        dbIndex[\"COLUMN_NAME\"] !==\n                                            dbColumn[\"COLUMN_NAME\"],\n                                )\n                            },\n                        )\n\n                        const tableColumn = new TableColumn()\n                        tableColumn.name = dbColumn[\"COLUMN_NAME\"]\n                        tableColumn.type = dbColumn[\"DATA_TYPE\"].toLowerCase()\n\n                        // Unsigned columns are handled differently when it comes to width.\n                        // Hence, we need to set the unsigned attribute before we check the width.\n                        tableColumn.unsigned = tableColumn.zerofill\n                            ? true\n                            : dbColumn[\"COLUMN_TYPE\"].indexOf(\"unsigned\") !== -1\n\n                        if (\n                            this.driver.withWidthColumnTypes.indexOf(\n                                tableColumn.type as ColumnType,\n                            ) !== -1\n                        ) {\n                            const width = dbColumn[\"COLUMN_TYPE\"].substring(\n                                dbColumn[\"COLUMN_TYPE\"].indexOf(\"(\") + 1,\n                                dbColumn[\"COLUMN_TYPE\"].indexOf(\")\"),\n                            )\n                            tableColumn.width =\n                                width &&\n                                !this.isDefaultColumnWidth(\n                                    table,\n                                    tableColumn,\n                                    parseInt(width),\n                                )\n                                    ? parseInt(width)\n                                    : undefined\n                        }\n\n                        if (\n                            dbColumn[\"COLUMN_DEFAULT\"] === null ||\n                            dbColumn[\"COLUMN_DEFAULT\"] === undefined\n                        ) {\n                            tableColumn.default = undefined\n                        } else {\n                            tableColumn.default =\n                                dbColumn[\"COLUMN_DEFAULT\"] ===\n                                \"CURRENT_TIMESTAMP\"\n                                    ? dbColumn[\"COLUMN_DEFAULT\"]\n                                    : `'${dbColumn[\"COLUMN_DEFAULT\"]}'`\n                        }\n\n                        if (dbColumn[\"EXTRA\"].indexOf(\"on update\") !== -1) {\n                            tableColumn.onUpdate = dbColumn[\"EXTRA\"].substring(\n                                dbColumn[\"EXTRA\"].indexOf(\"on update\") + 10,\n                            )\n                        }\n\n                        if (dbColumn[\"GENERATION_EXPRESSION\"]) {\n                            tableColumn.asExpression =\n                                dbColumn[\"GENERATION_EXPRESSION\"]\n                            tableColumn.generatedType =\n                                dbColumn[\"EXTRA\"].indexOf(\"VIRTUAL\") !== -1\n                                    ? \"VIRTUAL\"\n                                    : \"STORED\"\n                        }\n\n                        tableColumn.isUnique =\n                            columnUniqueIndices.length > 0 &&\n                            !hasIgnoredIndex &&\n                            !isConstraintComposite\n                        tableColumn.isNullable =\n                            dbColumn[\"IS_NULLABLE\"] === \"YES\"\n                        tableColumn.isPrimary = dbPrimaryKeys.some(\n                            (dbPrimaryKey) => {\n                                return (\n                                    dbPrimaryKey[\"TABLE_NAME\"] ===\n                                        dbColumn[\"TABLE_NAME\"] &&\n                                    dbPrimaryKey[\"TABLE_SCHEMA\"] ===\n                                        dbColumn[\"TABLE_SCHEMA\"] &&\n                                    dbPrimaryKey[\"COLUMN_NAME\"] ===\n                                        dbColumn[\"COLUMN_NAME\"]\n                                )\n                            },\n                        )\n                        tableColumn.zerofill =\n                            dbColumn[\"COLUMN_TYPE\"].indexOf(\"zerofill\") !== -1\n                        tableColumn.isGenerated =\n                            dbColumn[\"EXTRA\"].indexOf(\"auto_increment\") !== -1\n                        if (tableColumn.isGenerated)\n                            tableColumn.generationStrategy = \"increment\"\n\n                        tableColumn.comment =\n                            typeof dbColumn[\"COLUMN_COMMENT\"] === \"string\" &&\n                            dbColumn[\"COLUMN_COMMENT\"].length === 0\n                                ? undefined\n                                : dbColumn[\"COLUMN_COMMENT\"]\n                        if (dbColumn[\"CHARACTER_SET_NAME\"])\n                            tableColumn.charset =\n                                dbColumn[\"CHARACTER_SET_NAME\"] ===\n                                defaultCharset\n                                    ? undefined\n                                    : dbColumn[\"CHARACTER_SET_NAME\"]\n                        if (dbColumn[\"COLLATION_NAME\"])\n                            tableColumn.collation =\n                                dbColumn[\"COLLATION_NAME\"] === defaultCollation\n                                    ? undefined\n                                    : dbColumn[\"COLLATION_NAME\"]\n\n                        // check only columns that have length property\n                        if (\n                            this.driver.withLengthColumnTypes.indexOf(\n                                tableColumn.type as ColumnType,\n                            ) !== -1 &&\n                            dbColumn[\"CHARACTER_MAXIMUM_LENGTH\"]\n                        ) {\n                            const length =\n                                dbColumn[\"CHARACTER_MAXIMUM_LENGTH\"].toString()\n                            tableColumn.length = !this.isDefaultColumnLength(\n                                table,\n                                tableColumn,\n                                length,\n                            )\n                                ? length\n                                : \"\"\n                        }\n\n                        if (\n                            tableColumn.type === \"decimal\" ||\n                            tableColumn.type === \"double\" ||\n                            tableColumn.type === \"float\"\n                        ) {\n                            if (\n                                dbColumn[\"NUMERIC_PRECISION\"] !== null &&\n                                !this.isDefaultColumnPrecision(\n                                    table,\n                                    tableColumn,\n                                    dbColumn[\"NUMERIC_PRECISION\"],\n                                )\n                            )\n                                tableColumn.precision = parseInt(\n                                    dbColumn[\"NUMERIC_PRECISION\"],\n                                )\n                            if (\n                                dbColumn[\"NUMERIC_SCALE\"] !== null &&\n                                !this.isDefaultColumnScale(\n                                    table,\n                                    tableColumn,\n                                    dbColumn[\"NUMERIC_SCALE\"],\n                                )\n                            )\n                                tableColumn.scale = parseInt(\n                                    dbColumn[\"NUMERIC_SCALE\"],\n                                )\n                        }\n\n                        if (\n                            tableColumn.type === \"enum\" ||\n                            tableColumn.type === \"simple-enum\" ||\n                            tableColumn.type === \"set\"\n                        ) {\n                            const colType = dbColumn[\"COLUMN_TYPE\"]\n                            const items = colType\n                                .substring(\n                                    colType.indexOf(\"(\") + 1,\n                                    colType.lastIndexOf(\")\"),\n                                )\n                                .split(\",\")\n                            tableColumn.enum = (items as string[]).map(\n                                (item) => {\n                                    return item.substring(1, item.length - 1)\n                                },\n                            )\n                            tableColumn.length = \"\"\n                        }\n\n                        if (\n                            (tableColumn.type === \"datetime\" ||\n                                tableColumn.type === \"time\" ||\n                                tableColumn.type === \"timestamp\") &&\n                            dbColumn[\"DATETIME_PRECISION\"] !== null &&\n                            dbColumn[\"DATETIME_PRECISION\"] !== undefined &&\n                            !this.isDefaultColumnPrecision(\n                                table,\n                                tableColumn,\n                                parseInt(dbColumn[\"DATETIME_PRECISION\"]),\n                            )\n                        ) {\n                            tableColumn.precision = parseInt(\n                                dbColumn[\"DATETIME_PRECISION\"],\n                            )\n                        }\n\n                        return tableColumn\n                    })\n\n                // find foreign key constraints of table, group them by constraint name and build TableForeignKey.\n                const tableForeignKeyConstraints = OrmUtils.uniq(\n                    dbForeignKeys.filter((dbForeignKey) => {\n                        return (\n                            dbForeignKey[\"TABLE_NAME\"] ===\n                                dbTable[\"TABLE_NAME\"] &&\n                            dbForeignKey[\"TABLE_SCHEMA\"] ===\n                                dbTable[\"TABLE_SCHEMA\"]\n                        )\n                    }),\n                    (dbForeignKey) => dbForeignKey[\"CONSTRAINT_NAME\"],\n                )\n\n                table.foreignKeys = tableForeignKeyConstraints.map(\n                    (dbForeignKey) => {\n                        const foreignKeys = dbForeignKeys.filter(\n                            (dbFk) =>\n                                dbFk[\"CONSTRAINT_NAME\"] ===\n                                dbForeignKey[\"CONSTRAINT_NAME\"],\n                        )\n\n                        // if referenced table located in currently used db, we don't need to concat db name to table name.\n                        const database =\n                            dbForeignKey[\"REFERENCED_TABLE_SCHEMA\"] ===\n                            currentDatabase\n                                ? undefined\n                                : dbForeignKey[\"REFERENCED_TABLE_SCHEMA\"]\n                        const referencedTableName = this.driver.buildTableName(\n                            dbForeignKey[\"REFERENCED_TABLE_NAME\"],\n                            undefined,\n                            database,\n                        )\n\n                        return new TableForeignKey({\n                            name: dbForeignKey[\"CONSTRAINT_NAME\"],\n                            columnNames: foreignKeys.map(\n                                (dbFk) => dbFk[\"COLUMN_NAME\"],\n                            ),\n                            referencedDatabase:\n                                dbForeignKey[\"REFERENCED_TABLE_SCHEMA\"],\n                            referencedTableName: referencedTableName,\n                            referencedColumnNames: foreignKeys.map(\n                                (dbFk) => dbFk[\"REFERENCED_COLUMN_NAME\"],\n                            ),\n                            onDelete: dbForeignKey[\"ON_DELETE\"],\n                            onUpdate: dbForeignKey[\"ON_UPDATE\"],\n                        })\n                    },\n                )\n\n                // find index constraints of table, group them by constraint name and build TableIndex.\n                const tableIndexConstraints = OrmUtils.uniq(\n                    dbIndices.filter((dbIndex) => {\n                        return (\n                            dbIndex[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"] &&\n                            dbIndex[\"TABLE_SCHEMA\"] === dbTable[\"TABLE_SCHEMA\"]\n                        )\n                    }),\n                    (dbIndex) => dbIndex[\"INDEX_NAME\"],\n                )\n\n                table.indices = tableIndexConstraints.map((constraint) => {\n                    const indices = dbIndices.filter((index) => {\n                        return (\n                            index[\"TABLE_SCHEMA\"] ===\n                                constraint[\"TABLE_SCHEMA\"] &&\n                            index[\"TABLE_NAME\"] === constraint[\"TABLE_NAME\"] &&\n                            index[\"INDEX_NAME\"] === constraint[\"INDEX_NAME\"]\n                        )\n                    })\n\n                    const nonUnique = parseInt(constraint[\"NON_UNIQUE\"], 10)\n\n                    return new TableIndex(<TableIndexOptions>{\n                        table: table,\n                        name: constraint[\"INDEX_NAME\"],\n                        columnNames: indices.map((i) => i[\"COLUMN_NAME\"]),\n                        isUnique: nonUnique === 0,\n                        isSpatial: constraint[\"INDEX_TYPE\"] === \"SPATIAL\",\n                        isFulltext: constraint[\"INDEX_TYPE\"] === \"FULLTEXT\",\n                    })\n                })\n\n                return table\n            }),\n        )\n    }\n\n    /**\n     * Builds create table sql\n     */\n    protected createTableSql(table: Table, createForeignKeys?: boolean): Query {\n        const columnDefinitions = table.columns\n            .map((column) => this.buildCreateColumnSql(column, true))\n            .join(\", \")\n        let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`\n\n        // we create unique indexes instead of unique constraints, because MySql does not have unique constraints.\n        // if we mark column as Unique, it means that we create UNIQUE INDEX.\n        table.columns\n            .filter((column) => column.isUnique)\n            .forEach((column) => {\n                const isUniqueIndexExist = table.indices.some((index) => {\n                    return (\n                        index.columnNames.length === 1 &&\n                        !!index.isUnique &&\n                        index.columnNames.indexOf(column.name) !== -1\n                    )\n                })\n                const isUniqueConstraintExist = table.uniques.some((unique) => {\n                    return (\n                        unique.columnNames.length === 1 &&\n                        unique.columnNames.indexOf(column.name) !== -1\n                    )\n                })\n                if (!isUniqueIndexExist && !isUniqueConstraintExist)\n                    table.indices.push(\n                        new TableIndex({\n                            name: this.connection.namingStrategy.uniqueConstraintName(\n                                table,\n                                [column.name],\n                            ),\n                            columnNames: [column.name],\n                            isUnique: true,\n                        }),\n                    )\n            })\n\n        // as MySql does not have unique constraints, we must create table indices from table uniques and mark them as unique.\n        if (table.uniques.length > 0) {\n            table.uniques.forEach((unique) => {\n                const uniqueExist = table.indices.some(\n                    (index) => index.name === unique.name,\n                )\n                if (!uniqueExist) {\n                    table.indices.push(\n                        new TableIndex({\n                            name: unique.name,\n                            columnNames: unique.columnNames,\n                            isUnique: true,\n                        }),\n                    )\n                }\n            })\n        }\n\n        if (table.indices.length > 0) {\n            const indicesSql = table.indices\n                .map((index) => {\n                    const columnNames = index.columnNames\n                        .map((columnName) => `\\`${columnName}\\``)\n                        .join(\", \")\n                    if (!index.name)\n                        index.name = this.connection.namingStrategy.indexName(\n                            table,\n                            index.columnNames,\n                            index.where,\n                        )\n\n                    let indexType = \"\"\n                    if (index.isUnique) indexType += \"UNIQUE \"\n                    if (index.isSpatial) indexType += \"SPATIAL \"\n                    if (index.isFulltext) indexType += \"FULLTEXT \"\n                    return `${indexType}INDEX \\`${index.name}\\` (${columnNames})`\n                })\n                .join(\", \")\n\n            sql += `, ${indicesSql}`\n        }\n\n        if (table.foreignKeys.length > 0 && createForeignKeys) {\n            const foreignKeysSql = table.foreignKeys\n                .map((fk) => {\n                    const columnNames = fk.columnNames\n                        .map((columnName) => `\\`${columnName}\\``)\n                        .join(\", \")\n                    if (!fk.name)\n                        fk.name = this.connection.namingStrategy.foreignKeyName(\n                            table,\n                            fk.columnNames,\n                        )\n                    const referencedColumnNames = fk.referencedColumnNames\n                        .map((columnName) => `\\`${columnName}\\``)\n                        .join(\", \")\n\n                    let constraint = `CONSTRAINT \\`${\n                        fk.name\n                    }\\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(\n                        this.getTablePath(fk),\n                    )} (${referencedColumnNames})`\n                    if (fk.onDelete) constraint += ` ON DELETE ${fk.onDelete}`\n                    if (fk.onUpdate) constraint += ` ON UPDATE ${fk.onUpdate}`\n\n                    return constraint\n                })\n                .join(\", \")\n\n            sql += `, ${foreignKeysSql}`\n        }\n\n        if (table.primaryColumns.length > 0) {\n            const columnNames = table.primaryColumns\n                .map((column) => `\\`${column.name}\\``)\n                .join(\", \")\n            sql += `, PRIMARY KEY (${columnNames})`\n        }\n\n        sql += `) ENGINE=${table.engine || \"InnoDB\"}`\n\n        return new Query(sql)\n    }\n\n    /**\n     * Builds drop table sql\n     */\n    protected dropTableSql(tableOrName: Table | string): Query {\n        return new Query(`DROP TABLE ${this.escapePath(tableOrName)}`)\n    }\n\n    protected createViewSql(view: View): Query {\n        if (typeof view.expression === \"string\") {\n            return new Query(\n                `CREATE VIEW ${this.escapePath(view)} AS ${view.expression}`,\n            )\n        } else {\n            return new Query(\n                `CREATE VIEW ${this.escapePath(view)} AS ${view\n                    .expression(this.connection)\n                    .getQuery()}`,\n            )\n        }\n    }\n\n    protected async insertViewDefinitionSql(view: View): Promise<Query> {\n        const currentDatabase = await this.getCurrentDatabase()\n        const expression =\n            typeof view.expression === \"string\"\n                ? view.expression.trim()\n                : view.expression(this.connection).getQuery()\n        return this.insertTypeormMetadataSql({\n            type: MetadataTableType.VIEW,\n            schema: currentDatabase,\n            name: view.name,\n            value: expression,\n        })\n    }\n\n    /**\n     * Builds drop view sql.\n     */\n    protected dropViewSql(viewOrPath: View | string): Query {\n        return new Query(`DROP VIEW ${this.escapePath(viewOrPath)}`)\n    }\n\n    /**\n     * Builds remove view sql.\n     */\n    protected async deleteViewDefinitionSql(\n        viewOrPath: View | string,\n    ): Promise<Query> {\n        const currentDatabase = await this.getCurrentDatabase()\n        const viewName = InstanceChecker.isView(viewOrPath)\n            ? viewOrPath.name\n            : viewOrPath\n        return this.deleteTypeormMetadataSql({\n            type: MetadataTableType.VIEW,\n            schema: currentDatabase,\n            name: viewName,\n        })\n    }\n\n    /**\n     * Builds create index sql.\n     */\n    protected createIndexSql(table: Table, index: TableIndex): Query {\n        const columns = index.columnNames\n            .map((columnName) => `\\`${columnName}\\``)\n            .join(\", \")\n        let indexType = \"\"\n        if (index.isUnique) indexType += \"UNIQUE \"\n        if (index.isSpatial) indexType += \"SPATIAL \"\n        if (index.isFulltext) indexType += \"FULLTEXT \"\n        return new Query(\n            `CREATE ${indexType}INDEX \\`${index.name}\\` ON ${this.escapePath(\n                table,\n            )} (${columns})`,\n        )\n    }\n\n    /**\n     * Builds drop index sql.\n     */\n    protected dropIndexSql(\n        table: Table,\n        indexOrName: TableIndex | string,\n    ): Query {\n        let indexName = InstanceChecker.isTableIndex(indexOrName)\n            ? indexOrName.name\n            : indexOrName\n        return new Query(\n            `DROP INDEX \\`${indexName}\\` ON ${this.escapePath(table)}`,\n        )\n    }\n\n    /**\n     * Builds create primary key sql.\n     */\n    protected createPrimaryKeySql(table: Table, columnNames: string[]): Query {\n        const columnNamesString = columnNames\n            .map((columnName) => `\\`${columnName}\\``)\n            .join(\", \")\n        return new Query(\n            `ALTER TABLE ${this.escapePath(\n                table,\n            )} ADD PRIMARY KEY (${columnNamesString})`,\n        )\n    }\n\n    /**\n     * Builds drop primary key sql.\n     */\n    protected dropPrimaryKeySql(table: Table): Query {\n        return new Query(\n            `ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`,\n        )\n    }\n\n    /**\n     * Builds create foreign key sql.\n     */\n    protected createForeignKeySql(\n        table: Table,\n        foreignKey: TableForeignKey,\n    ): Query {\n        const columnNames = foreignKey.columnNames\n            .map((column) => `\\`${column}\\``)\n            .join(\", \")\n        const referencedColumnNames = foreignKey.referencedColumnNames\n            .map((column) => `\\`${column}\\``)\n            .join(\",\")\n        let sql =\n            `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \\`${\n                foreignKey.name\n            }\\` FOREIGN KEY (${columnNames}) ` +\n            `REFERENCES ${this.escapePath(\n                this.getTablePath(foreignKey),\n            )}(${referencedColumnNames})`\n        if (foreignKey.onDelete) sql += ` ON DELETE ${foreignKey.onDelete}`\n        if (foreignKey.onUpdate) sql += ` ON UPDATE ${foreignKey.onUpdate}`\n\n        return new Query(sql)\n    }\n\n    /**\n     * Builds drop foreign key sql.\n     */\n    protected dropForeignKeySql(\n        table: Table,\n        foreignKeyOrName: TableForeignKey | string,\n    ): Query {\n        const foreignKeyName = InstanceChecker.isTableForeignKey(\n            foreignKeyOrName,\n        )\n            ? foreignKeyOrName.name\n            : foreignKeyOrName\n        return new Query(\n            `ALTER TABLE ${this.escapePath(\n                table,\n            )} DROP FOREIGN KEY \\`${foreignKeyName}\\``,\n        )\n    }\n\n    /**\n     * Escapes a given comment so it's safe to include in a query.\n     */\n    protected escapeComment(comment?: string) {\n        if (!comment || comment.length === 0) {\n            return `''`\n        }\n\n        comment = comment\n            .replace(/\\\\/g, \"\\\\\\\\\") // MySQL allows escaping characters via backslashes\n            .replace(/'/g, \"''\")\n            .replace(/\\u0000/g, \"\") // Null bytes aren't allowed in comments\n\n        return `'${comment}'`\n    }\n\n    /**\n     * Escapes given table or view path.\n     */\n    protected escapePath(target: Table | View | string): string {\n        const { database, tableName } = this.driver.parseTableName(target)\n\n        if (database && database !== this.driver.database) {\n            return `\\`${database}\\`.\\`${tableName}\\``\n        }\n\n        return `\\`${tableName}\\``\n    }\n\n    /**\n     * Builds a part of query to create/change a column.\n     */\n    protected buildCreateColumnSql(\n        column: TableColumn,\n        skipPrimary: boolean,\n        skipName: boolean = false,\n    ) {\n        let c = \"\"\n        if (skipName) {\n            c = this.connection.driver.createFullType(column)\n        } else {\n            c = `\\`${column.name}\\` ${this.connection.driver.createFullType(\n                column,\n            )}`\n        }\n        if (column.asExpression)\n            c += ` AS (${column.asExpression}) ${\n                column.generatedType ? column.generatedType : \"VIRTUAL\"\n            }`\n\n        // if you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to that column.\n        if (column.zerofill) {\n            c += \" ZEROFILL\"\n        } else if (column.unsigned) {\n            c += \" UNSIGNED\"\n        }\n        if (column.enum)\n            c += ` (${column.enum\n                .map((value) => \"'\" + value + \"'\")\n                .join(\", \")})`\n        if (column.charset) c += ` CHARACTER SET \"${column.charset}\"`\n        if (column.collation) c += ` COLLATE \"${column.collation}\"`\n        if (!column.isNullable) c += \" NOT NULL\"\n        if (column.isNullable) c += \" NULL\"\n        if (column.isPrimary && !skipPrimary) c += \" PRIMARY KEY\"\n        if (column.isGenerated && column.generationStrategy === \"increment\")\n            // don't use skipPrimary here since updates can update already exist primary without auto inc.\n            c += \" AUTO_INCREMENT\"\n        if (column.comment)\n            c += ` COMMENT ${this.escapeComment(column.comment)}`\n        if (column.default !== undefined && column.default !== null)\n            c += ` DEFAULT ${column.default}`\n        if (column.onUpdate) c += ` ON UPDATE ${column.onUpdate}`\n\n        return c\n    }\n\n    /**\n     * Checks if column display width is by default.\n     */\n    protected isDefaultColumnWidth(\n        table: Table,\n        column: TableColumn,\n        width: number,\n    ): boolean {\n        // if table have metadata, we check if length is specified in column metadata\n        if (this.connection.hasMetadata(table.name)) {\n            const metadata = this.connection.getMetadata(table.name)\n            const columnMetadata = metadata.findColumnWithDatabaseName(\n                column.name,\n            )\n            if (columnMetadata && columnMetadata.width) return false\n        }\n\n        const defaultWidthForType =\n            this.connection.driver.dataTypeDefaults &&\n            this.connection.driver.dataTypeDefaults[column.type] &&\n            this.connection.driver.dataTypeDefaults[column.type].width\n\n        if (defaultWidthForType) {\n            // In MariaDB & MySQL 5.7, the default widths of certain numeric types are 1 less than\n            // the usual defaults when the column is unsigned.\n            // This also applies to Aurora MySQL.\n            const typesWithReducedUnsignedDefault = [\n                \"int\",\n                \"tinyint\",\n                \"smallint\",\n                \"mediumint\",\n            ]\n            const needsAdjustment =\n                typesWithReducedUnsignedDefault.indexOf(column.type) !== -1\n            if (column.unsigned && needsAdjustment) {\n                return defaultWidthForType - 1 === width\n            } else {\n                return defaultWidthForType === width\n            }\n        }\n\n        return false\n    }\n\n    /**\n     * Change table comment.\n     */\n    changeTableComment(\n        tableOrName: Table | string,\n        comment?: string,\n    ): Promise<void> {\n        throw new TypeORMError(\n            `aurora-mysql driver does not support change table comment.`,\n        )\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}