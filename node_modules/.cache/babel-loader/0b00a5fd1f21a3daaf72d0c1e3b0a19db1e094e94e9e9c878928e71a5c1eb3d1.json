{"ast":null,"code":"import { TypeORMError } from \"../error\";\n/**\n * Contains all information about entity's embedded property.\n */\nexport class EmbeddedMetadata {\n  // ---------------------------------------------------------------------\n  // Constructor\n  // ---------------------------------------------------------------------\n  constructor(options) {\n    /**\n     * Columns inside this embed.\n     */\n    this.columns = [];\n    /**\n     * Relations inside this embed.\n     */\n    this.relations = [];\n    /**\n     * Entity listeners inside this embed.\n     */\n    this.listeners = [];\n    /**\n     * Indices applied to the embed columns.\n     */\n    this.indices = [];\n    /**\n     * Uniques applied to the embed columns.\n     */\n    this.uniques = [];\n    /**\n     * Relation ids inside this embed.\n     */\n    this.relationIds = [];\n    /**\n     * Relation counts inside this embed.\n     */\n    this.relationCounts = [];\n    /**\n     * Nested embeddable in this embeddable (which has current embedded as parent embedded).\n     */\n    this.embeddeds = [];\n    /**\n     * Indicates if the entity should be instantiated using the constructor\n     * or via allocating a new object via `Object.create()`.\n     */\n    this.isAlwaysUsingConstructor = true;\n    /**\n     * Indicates if this embedded is in array mode.\n     *\n     * This option works only in mongodb.\n     */\n    this.isArray = false;\n    /**\n     * Returns array of property names of current embed and all its parent embeds.\n     *\n     * example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeds\n     * we need to get value of \"id\" column from the post real entity object.\n     * this method will return [\"data\", \"information\", \"counters\"]\n     */\n    this.parentPropertyNames = [];\n    /**\n     * Returns array of prefixes of current embed and all its parent embeds.\n     */\n    this.parentPrefixes = [];\n    /**\n     * Returns embed metadatas from all levels of the parent tree.\n     *\n     * example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeds\n     * this method will return [embed metadata of data, embed metadata of information, embed metadata of counters]\n     */\n    this.embeddedMetadataTree = [];\n    /**\n     * Embed metadatas from all levels of the parent tree.\n     *\n     * example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeds\n     * this method will return [embed metadata of data, embed metadata of information, embed metadata of counters]\n     */\n    this.columnsFromTree = [];\n    /**\n     * Relations of this embed and all relations from its child embeds.\n     */\n    this.relationsFromTree = [];\n    /**\n     * Relations of this embed and all relations from its child embeds.\n     */\n    this.listenersFromTree = [];\n    /**\n     * Indices of this embed and all indices from its child embeds.\n     */\n    this.indicesFromTree = [];\n    /**\n     * Uniques of this embed and all uniques from its child embeds.\n     */\n    this.uniquesFromTree = [];\n    /**\n     * Relation ids of this embed and all relation ids from its child embeds.\n     */\n    this.relationIdsFromTree = [];\n    /**\n     * Relation counts of this embed and all relation counts from its child embeds.\n     */\n    this.relationCountsFromTree = [];\n    this.entityMetadata = options.entityMetadata;\n    this.type = options.args.type();\n    this.propertyName = options.args.propertyName;\n    this.customPrefix = options.args.prefix;\n    this.isArray = options.args.isArray;\n  }\n  // ---------------------------------------------------------------------\n  // Public Methods\n  // ---------------------------------------------------------------------\n  /**\n   * Creates a new embedded object.\n   */\n  create(options) {\n    if (!(typeof this.type === \"function\")) {\n      return {};\n    }\n    if (options?.fromDeserializer || !this.isAlwaysUsingConstructor) {\n      return Object.create(this.type.prototype);\n    } else {\n      return new this.type();\n    }\n  }\n  // ---------------------------------------------------------------------\n  // Builder Methods\n  // ---------------------------------------------------------------------\n  build(connection) {\n    this.embeddeds.forEach(embedded => embedded.build(connection));\n    this.prefix = this.buildPrefix(connection);\n    this.parentPropertyNames = this.buildParentPropertyNames();\n    this.parentPrefixes = this.buildParentPrefixes();\n    this.propertyPath = this.parentPropertyNames.join(\".\");\n    this.embeddedMetadataTree = this.buildEmbeddedMetadataTree();\n    this.columnsFromTree = this.buildColumnsFromTree();\n    this.relationsFromTree = this.buildRelationsFromTree();\n    this.listenersFromTree = this.buildListenersFromTree();\n    this.indicesFromTree = this.buildIndicesFromTree();\n    this.uniquesFromTree = this.buildUniquesFromTree();\n    this.relationIdsFromTree = this.buildRelationIdsFromTree();\n    this.relationCountsFromTree = this.buildRelationCountsFromTree();\n    if (connection.options.entitySkipConstructor) {\n      this.isAlwaysUsingConstructor = !connection.options.entitySkipConstructor;\n    }\n    return this;\n  }\n  // ---------------------------------------------------------------------\n  // Protected Methods\n  // ---------------------------------------------------------------------\n  buildPartialPrefix() {\n    // if prefix option was not set or explicitly set to true - default prefix\n    if (this.customPrefix === undefined || this.customPrefix === true) {\n      return [this.propertyName];\n    }\n    // if prefix option was set to empty string or explicity set to false - disable prefix\n    if (this.customPrefix === \"\" || this.customPrefix === false) {\n      return [];\n    }\n    // use custom prefix\n    if (typeof this.customPrefix === \"string\") {\n      return [this.customPrefix];\n    }\n    throw new TypeORMError(`Invalid prefix option given for ${this.entityMetadata.targetName}#${this.propertyName}`);\n  }\n  buildPrefix(connection) {\n    if (connection.driver.options.type === \"mongodb\") return this.propertyName;\n    let prefixes = [];\n    if (this.parentEmbeddedMetadata) prefixes.push(this.parentEmbeddedMetadata.buildPrefix(connection));\n    prefixes.push(...this.buildPartialPrefix());\n    return prefixes.join(\"_\"); // todo: use naming strategy instead of \"_\"  !!!\n  }\n  buildParentPropertyNames() {\n    return this.parentEmbeddedMetadata ? this.parentEmbeddedMetadata.buildParentPropertyNames().concat(this.propertyName) : [this.propertyName];\n  }\n  buildParentPrefixes() {\n    return this.parentEmbeddedMetadata ? this.parentEmbeddedMetadata.buildParentPrefixes().concat(this.buildPartialPrefix()) : this.buildPartialPrefix();\n  }\n  buildEmbeddedMetadataTree() {\n    return this.parentEmbeddedMetadata ? this.parentEmbeddedMetadata.buildEmbeddedMetadataTree().concat(this) : [this];\n  }\n  buildColumnsFromTree() {\n    return this.embeddeds.reduce((columns, embedded) => columns.concat(embedded.buildColumnsFromTree()), this.columns);\n  }\n  buildRelationsFromTree() {\n    return this.embeddeds.reduce((relations, embedded) => relations.concat(embedded.buildRelationsFromTree()), this.relations);\n  }\n  buildListenersFromTree() {\n    return this.embeddeds.reduce((relations, embedded) => relations.concat(embedded.buildListenersFromTree()), this.listeners);\n  }\n  buildIndicesFromTree() {\n    return this.embeddeds.reduce((relations, embedded) => relations.concat(embedded.buildIndicesFromTree()), this.indices);\n  }\n  buildUniquesFromTree() {\n    return this.embeddeds.reduce((relations, embedded) => relations.concat(embedded.buildUniquesFromTree()), this.uniques);\n  }\n  buildRelationIdsFromTree() {\n    return this.embeddeds.reduce((relations, embedded) => relations.concat(embedded.buildRelationIdsFromTree()), this.relationIds);\n  }\n  buildRelationCountsFromTree() {\n    return this.embeddeds.reduce((relations, embedded) => relations.concat(embedded.buildRelationCountsFromTree()), this.relationCounts);\n  }\n}","map":{"version":3,"names":["TypeORMError","EmbeddedMetadata","constructor","options","columns","relations","listeners","indices","uniques","relationIds","relationCounts","embeddeds","isAlwaysUsingConstructor","isArray","parentPropertyNames","parentPrefixes","embeddedMetadataTree","columnsFromTree","relationsFromTree","listenersFromTree","indicesFromTree","uniquesFromTree","relationIdsFromTree","relationCountsFromTree","entityMetadata","type","args","propertyName","customPrefix","prefix","create","fromDeserializer","Object","prototype","build","connection","forEach","embedded","buildPrefix","buildParentPropertyNames","buildParentPrefixes","propertyPath","join","buildEmbeddedMetadataTree","buildColumnsFromTree","buildRelationsFromTree","buildListenersFromTree","buildIndicesFromTree","buildUniquesFromTree","buildRelationIdsFromTree","buildRelationCountsFromTree","entitySkipConstructor","buildPartialPrefix","undefined","targetName","driver","prefixes","parentEmbeddedMetadata","push","concat","reduce"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\metadata\\EmbeddedMetadata.ts"],"sourcesContent":["import { ColumnMetadata } from \"./ColumnMetadata\"\nimport { RelationMetadata } from \"./RelationMetadata\"\nimport { EntityMetadata } from \"./EntityMetadata\"\nimport { EmbeddedMetadataArgs } from \"../metadata-args/EmbeddedMetadataArgs\"\nimport { RelationIdMetadata } from \"./RelationIdMetadata\"\nimport { RelationCountMetadata } from \"./RelationCountMetadata\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { EntityListenerMetadata } from \"./EntityListenerMetadata\"\nimport { IndexMetadata } from \"./IndexMetadata\"\nimport { UniqueMetadata } from \"./UniqueMetadata\"\nimport { TypeORMError } from \"../error\"\n\n/**\n * Contains all information about entity's embedded property.\n */\nexport class EmbeddedMetadata {\n    // ---------------------------------------------------------------------\n    // Public Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Entity metadata where this embedded is.\n     */\n    entityMetadata: EntityMetadata\n\n    /**\n     * Parent embedded in the case if this embedded inside other embedded.\n     */\n    parentEmbeddedMetadata?: EmbeddedMetadata\n\n    /**\n     * Embedded target type.\n     */\n    type: Function | string\n\n    /**\n     * Property name on which this embedded is attached.\n     */\n    propertyName: string\n\n    /**\n     * Gets full path to this embedded property (including embedded property name).\n     * Full path is relevant when embedded is used inside other embeds (one or multiple nested).\n     * For example it will return \"counters.subcounters\".\n     */\n    propertyPath: string\n\n    /**\n     * Columns inside this embed.\n     */\n    columns: ColumnMetadata[] = []\n\n    /**\n     * Relations inside this embed.\n     */\n    relations: RelationMetadata[] = []\n\n    /**\n     * Entity listeners inside this embed.\n     */\n    listeners: EntityListenerMetadata[] = []\n\n    /**\n     * Indices applied to the embed columns.\n     */\n    indices: IndexMetadata[] = []\n\n    /**\n     * Uniques applied to the embed columns.\n     */\n    uniques: UniqueMetadata[] = []\n\n    /**\n     * Relation ids inside this embed.\n     */\n    relationIds: RelationIdMetadata[] = []\n\n    /**\n     * Relation counts inside this embed.\n     */\n    relationCounts: RelationCountMetadata[] = []\n\n    /**\n     * Nested embeddable in this embeddable (which has current embedded as parent embedded).\n     */\n    embeddeds: EmbeddedMetadata[] = []\n\n    /**\n     * Indicates if the entity should be instantiated using the constructor\n     * or via allocating a new object via `Object.create()`.\n     */\n    isAlwaysUsingConstructor: boolean = true\n\n    /**\n     * Indicates if this embedded is in array mode.\n     *\n     * This option works only in mongodb.\n     */\n    isArray: boolean = false\n\n    /**\n     * Prefix of the embedded, used instead of propertyName.\n     * If set to empty string or false, then prefix is not set at all.\n     */\n    customPrefix: string | boolean | undefined\n\n    /**\n     * Gets the prefix of the columns.\n     * By default its a property name of the class where this prefix is.\n     * But if custom prefix is set then it takes its value as a prefix.\n     * However if custom prefix is set to empty string or false, then prefix to column is not applied at all.\n     */\n    prefix: string\n\n    /**\n     * Returns array of property names of current embed and all its parent embeds.\n     *\n     * example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeds\n     * we need to get value of \"id\" column from the post real entity object.\n     * this method will return [\"data\", \"information\", \"counters\"]\n     */\n    parentPropertyNames: string[] = []\n\n    /**\n     * Returns array of prefixes of current embed and all its parent embeds.\n     */\n    parentPrefixes: string[] = []\n\n    /**\n     * Returns embed metadatas from all levels of the parent tree.\n     *\n     * example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeds\n     * this method will return [embed metadata of data, embed metadata of information, embed metadata of counters]\n     */\n    embeddedMetadataTree: EmbeddedMetadata[] = []\n\n    /**\n     * Embed metadatas from all levels of the parent tree.\n     *\n     * example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeds\n     * this method will return [embed metadata of data, embed metadata of information, embed metadata of counters]\n     */\n    columnsFromTree: ColumnMetadata[] = []\n\n    /**\n     * Relations of this embed and all relations from its child embeds.\n     */\n    relationsFromTree: RelationMetadata[] = []\n\n    /**\n     * Relations of this embed and all relations from its child embeds.\n     */\n    listenersFromTree: EntityListenerMetadata[] = []\n\n    /**\n     * Indices of this embed and all indices from its child embeds.\n     */\n    indicesFromTree: IndexMetadata[] = []\n\n    /**\n     * Uniques of this embed and all uniques from its child embeds.\n     */\n    uniquesFromTree: UniqueMetadata[] = []\n\n    /**\n     * Relation ids of this embed and all relation ids from its child embeds.\n     */\n    relationIdsFromTree: RelationIdMetadata[] = []\n\n    /**\n     * Relation counts of this embed and all relation counts from its child embeds.\n     */\n    relationCountsFromTree: RelationCountMetadata[] = []\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(options: {\n        entityMetadata: EntityMetadata\n        args: EmbeddedMetadataArgs\n    }) {\n        this.entityMetadata = options.entityMetadata\n        this.type = options.args.type()\n        this.propertyName = options.args.propertyName\n        this.customPrefix = options.args.prefix\n        this.isArray = options.args.isArray\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Creates a new embedded object.\n     */\n    create(options?: { fromDeserializer?: boolean }): any {\n        if (!(typeof this.type === \"function\")) {\n            return {}\n        }\n\n        if (options?.fromDeserializer || !this.isAlwaysUsingConstructor) {\n            return Object.create(this.type.prototype)\n        } else {\n            return new (this.type as any)()\n        }\n    }\n\n    // ---------------------------------------------------------------------\n    // Builder Methods\n    // ---------------------------------------------------------------------\n\n    build(connection: DataSource): this {\n        this.embeddeds.forEach((embedded) => embedded.build(connection))\n        this.prefix = this.buildPrefix(connection)\n        this.parentPropertyNames = this.buildParentPropertyNames()\n        this.parentPrefixes = this.buildParentPrefixes()\n        this.propertyPath = this.parentPropertyNames.join(\".\")\n        this.embeddedMetadataTree = this.buildEmbeddedMetadataTree()\n        this.columnsFromTree = this.buildColumnsFromTree()\n        this.relationsFromTree = this.buildRelationsFromTree()\n        this.listenersFromTree = this.buildListenersFromTree()\n        this.indicesFromTree = this.buildIndicesFromTree()\n        this.uniquesFromTree = this.buildUniquesFromTree()\n        this.relationIdsFromTree = this.buildRelationIdsFromTree()\n        this.relationCountsFromTree = this.buildRelationCountsFromTree()\n\n        if (connection.options.entitySkipConstructor) {\n            this.isAlwaysUsingConstructor =\n                !connection.options.entitySkipConstructor\n        }\n\n        return this\n    }\n\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n\n    protected buildPartialPrefix(): string[] {\n        // if prefix option was not set or explicitly set to true - default prefix\n        if (this.customPrefix === undefined || this.customPrefix === true) {\n            return [this.propertyName]\n        }\n\n        // if prefix option was set to empty string or explicity set to false - disable prefix\n        if (this.customPrefix === \"\" || this.customPrefix === false) {\n            return []\n        }\n\n        // use custom prefix\n        if (typeof this.customPrefix === \"string\") {\n            return [this.customPrefix]\n        }\n\n        throw new TypeORMError(\n            `Invalid prefix option given for ${this.entityMetadata.targetName}#${this.propertyName}`,\n        )\n    }\n\n    protected buildPrefix(connection: DataSource): string {\n        if (connection.driver.options.type === \"mongodb\")\n            return this.propertyName\n\n        let prefixes: string[] = []\n        if (this.parentEmbeddedMetadata)\n            prefixes.push(this.parentEmbeddedMetadata.buildPrefix(connection))\n\n        prefixes.push(...this.buildPartialPrefix())\n\n        return prefixes.join(\"_\") // todo: use naming strategy instead of \"_\"  !!!\n    }\n\n    protected buildParentPropertyNames(): string[] {\n        return this.parentEmbeddedMetadata\n            ? this.parentEmbeddedMetadata\n                  .buildParentPropertyNames()\n                  .concat(this.propertyName)\n            : [this.propertyName]\n    }\n\n    protected buildParentPrefixes(): string[] {\n        return this.parentEmbeddedMetadata\n            ? this.parentEmbeddedMetadata\n                  .buildParentPrefixes()\n                  .concat(this.buildPartialPrefix())\n            : this.buildPartialPrefix()\n    }\n\n    protected buildEmbeddedMetadataTree(): EmbeddedMetadata[] {\n        return this.parentEmbeddedMetadata\n            ? this.parentEmbeddedMetadata\n                  .buildEmbeddedMetadataTree()\n                  .concat(this)\n            : [this]\n    }\n\n    protected buildColumnsFromTree(): ColumnMetadata[] {\n        return this.embeddeds.reduce(\n            (columns, embedded) =>\n                columns.concat(embedded.buildColumnsFromTree()),\n            this.columns,\n        )\n    }\n\n    protected buildRelationsFromTree(): RelationMetadata[] {\n        return this.embeddeds.reduce(\n            (relations, embedded) =>\n                relations.concat(embedded.buildRelationsFromTree()),\n            this.relations,\n        )\n    }\n\n    protected buildListenersFromTree(): EntityListenerMetadata[] {\n        return this.embeddeds.reduce(\n            (relations, embedded) =>\n                relations.concat(embedded.buildListenersFromTree()),\n            this.listeners,\n        )\n    }\n\n    protected buildIndicesFromTree(): IndexMetadata[] {\n        return this.embeddeds.reduce(\n            (relations, embedded) =>\n                relations.concat(embedded.buildIndicesFromTree()),\n            this.indices,\n        )\n    }\n\n    protected buildUniquesFromTree(): UniqueMetadata[] {\n        return this.embeddeds.reduce(\n            (relations, embedded) =>\n                relations.concat(embedded.buildUniquesFromTree()),\n            this.uniques,\n        )\n    }\n\n    protected buildRelationIdsFromTree(): RelationIdMetadata[] {\n        return this.embeddeds.reduce(\n            (relations, embedded) =>\n                relations.concat(embedded.buildRelationIdsFromTree()),\n            this.relationIds,\n        )\n    }\n\n    protected buildRelationCountsFromTree(): RelationCountMetadata[] {\n        return this.embeddeds.reduce(\n            (relations, embedded) =>\n                relations.concat(embedded.buildRelationCountsFromTree()),\n            this.relationCounts,\n        )\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}