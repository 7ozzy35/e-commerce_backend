{"ast":null,"code":"import { OrmUtils } from \"../../util/OrmUtils\";\nimport { DriverUtils } from \"../../driver/DriverUtils\";\nimport { ObjectUtils } from \"../../util/ObjectUtils\";\n/**\n * Transforms raw sql results returned from the database into entity object.\n * Entity is constructed based on its entity metadata.\n */\nexport class RawSqlResultsToEntityTransformer {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(expressionMap, driver, rawRelationIdResults, rawRelationCountResults, queryRunner) {\n    this.expressionMap = expressionMap;\n    this.driver = driver;\n    this.rawRelationIdResults = rawRelationIdResults;\n    this.rawRelationCountResults = rawRelationCountResults;\n    this.queryRunner = queryRunner;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated\n   * we need to group our result and we must have some unique id (primary key in our case)\n   */\n  transform(rawResults, alias) {\n    const group = this.group(rawResults, alias);\n    const entities = [];\n    group.forEach(results => {\n      const entity = this.transformRawResultsGroup(results, alias);\n      if (entity !== undefined && !Object.values(entity).every(value => value === null)) entities.push(entity);\n    });\n    return entities;\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Groups given raw results by ids of given alias.\n   */\n  group(rawResults, alias) {\n    const map = new Map();\n    const keys = [];\n    if (alias.metadata.tableType === \"view\") {\n      keys.push(...alias.metadata.columns.map(column => DriverUtils.buildAlias(this.driver, undefined, alias.name, column.databaseName)));\n    } else {\n      keys.push(...alias.metadata.primaryColumns.map(column => DriverUtils.buildAlias(this.driver, undefined, alias.name, column.databaseName)));\n    }\n    rawResults.forEach(rawResult => {\n      const id = keys.map(key => {\n        const keyValue = rawResult[key];\n        if (Buffer.isBuffer(keyValue)) {\n          return keyValue.toString(\"hex\");\n        }\n        if (ObjectUtils.isObject(keyValue)) {\n          return JSON.stringify(keyValue);\n        }\n        return keyValue;\n      }).join(\"_\"); // todo: check partial\n      const items = map.get(id);\n      if (!items) {\n        map.set(id, [rawResult]);\n      } else {\n        items.push(rawResult);\n      }\n    });\n    return map;\n  }\n  /**\n   * Transforms set of data results into single entity.\n   */\n  transformRawResultsGroup(rawResults, alias) {\n    // let hasColumns = false; // , hasEmbeddedColumns = false, hasParentColumns = false, hasParentEmbeddedColumns = false;\n    let metadata = alias.metadata;\n    if (metadata.discriminatorColumn) {\n      const discriminatorValues = rawResults.map(result => result[DriverUtils.buildAlias(this.driver, undefined, alias.name, alias.metadata.discriminatorColumn.databaseName)]);\n      const discriminatorMetadata = metadata.childEntityMetadatas.find(childEntityMetadata => {\n        return typeof discriminatorValues.find(value => value === childEntityMetadata.discriminatorValue) !== \"undefined\";\n      });\n      if (discriminatorMetadata) metadata = discriminatorMetadata;\n    }\n    let entity = metadata.create(this.queryRunner, {\n      fromDeserializer: true,\n      pojo: this.expressionMap.options.indexOf(\"create-pojo\") !== -1\n    });\n    // get value from columns selections and put them into newly created entity\n    const hasColumns = this.transformColumns(rawResults, alias, entity, metadata);\n    const hasRelations = this.transformJoins(rawResults, entity, alias, metadata);\n    const hasRelationIds = this.transformRelationIds(rawResults, alias, entity, metadata);\n    const hasRelationCounts = this.transformRelationCounts(rawResults, alias, entity);\n    // if we have at least one selected column then return this entity\n    // since entity must have at least primary columns to be really selected and transformed into entity\n    if (hasColumns) return entity;\n    // if we don't have any selected column we should not return entity,\n    // except for the case when entity only contain a primary column as a relation to another entity\n    // in this case its absolutely possible our entity to not have any columns except a single relation\n    const hasOnlyVirtualPrimaryColumns = metadata.primaryColumns.filter(column => column.isVirtual === false).length === 0; // todo: create metadata.hasOnlyVirtualPrimaryColumns\n    if (hasOnlyVirtualPrimaryColumns && (hasRelations || hasRelationIds || hasRelationCounts)) return entity;\n    return undefined;\n  }\n  // get value from columns selections and put them into object\n  transformColumns(rawResults, alias, entity, metadata) {\n    let hasData = false;\n    metadata.columns.forEach(column => {\n      // if table inheritance is used make sure this column is not child's column\n      if (metadata.childEntityMetadatas.length > 0 && metadata.childEntityMetadatas.findIndex(childMetadata => childMetadata.target === column.target) !== -1) return;\n      const value = rawResults[0][DriverUtils.buildAlias(this.driver, undefined, alias.name, column.databaseName)];\n      if (value === undefined || column.isVirtual) return;\n      // if user does not selected the whole entity or he used partial selection and does not select this particular column\n      // then we don't add this column and its value into the entity\n      if (!this.expressionMap.selects.find(select => select.selection === alias.name || select.selection === alias.name + \".\" + column.propertyPath)) return;\n      column.setEntityValue(entity, this.driver.prepareHydratedValue(value, column));\n      if (value !== null)\n        // we don't mark it as has data because if we will have all nulls in our object - we don't need such object\n        hasData = true;\n    });\n    return hasData;\n  }\n  /**\n   * Transforms joined entities in the given raw results by a given alias and stores to the given (parent) entity\n   */\n  transformJoins(rawResults, entity, alias, metadata) {\n    let hasData = false;\n    // let discriminatorValue: string = \"\";\n    // if (metadata.discriminatorColumn)\n    //     discriminatorValue = rawResults[0][DriverUtils.buildAlias(this.connection.driver, alias.name, alias.metadata.discriminatorColumn!.databaseName)];\n    this.expressionMap.joinAttributes.forEach(join => {\n      // todo: we have problem here - when inner joins are used without selects it still create empty array\n      // skip joins without metadata\n      if (!join.metadata) return;\n      // if simple left or inner join was performed without selection then we don't need to do anything\n      if (!join.isSelected) return;\n      // this check need to avoid setting properties than not belong to entity when single table inheritance used. (todo: check if we still need it)\n      // const metadata = metadata.childEntityMetadatas.find(childEntityMetadata => discriminatorValue === childEntityMetadata.discriminatorValue);\n      if (join.relation && !metadata.relations.find(relation => relation === join.relation)) return;\n      // some checks to make sure this join is for current alias\n      if (join.mapToProperty) {\n        if (join.mapToPropertyParentAlias !== alias.name) return;\n      } else {\n        if (!join.relation || join.parentAlias !== alias.name || join.relationPropertyPath !== join.relation.propertyPath) return;\n      }\n      // transform joined data into entities\n      let result = this.transform(rawResults, join.alias);\n      result = !join.isMany ? result[0] : result;\n      result = !join.isMany && result === undefined ? null : result; // this is needed to make relations to return null when its joined but nothing was found in the database\n      if (result === undefined)\n        // if nothing was joined then simply return\n        return;\n      // if join was mapped to some property then save result to that property\n      if (join.mapToPropertyPropertyName) {\n        entity[join.mapToPropertyPropertyName] = result; // todo: fix embeds\n      } else {\n        // otherwise set to relation\n        join.relation.setEntityValue(entity, result);\n      }\n      hasData = true;\n    });\n    return hasData;\n  }\n  transformRelationIds(rawSqlResults, alias, entity, metadata) {\n    let hasData = false;\n    this.rawRelationIdResults.forEach((rawRelationIdResult, index) => {\n      if (rawRelationIdResult.relationIdAttribute.parentAlias !== alias.name) return;\n      const relation = rawRelationIdResult.relationIdAttribute.relation;\n      const valueMap = this.createValueMapFromJoinColumns(relation, rawRelationIdResult.relationIdAttribute.parentAlias, rawSqlResults);\n      if (valueMap === undefined || valueMap === null) {\n        return;\n      }\n      // prepare common data for this call\n      this.prepareDataForTransformRelationIds();\n      // Extract idMaps from prepared data by hash\n      const hash = this.hashEntityIds(relation, valueMap);\n      const idMaps = this.relationIdMaps[index][hash] || [];\n      // Map data to properties\n      const properties = rawRelationIdResult.relationIdAttribute.mapToPropertyPropertyPath.split(\".\");\n      const mapToProperty = (properties, map, value) => {\n        const property = properties.shift();\n        if (property && properties.length === 0) {\n          map[property] = value;\n          return map;\n        }\n        if (property && properties.length > 0) {\n          mapToProperty(properties, map[property], value);\n        } else {\n          return map;\n        }\n      };\n      if (relation.isOneToOne || relation.isManyToOne) {\n        if (idMaps[0] !== undefined) {\n          mapToProperty(properties, entity, idMaps[0]);\n          hasData = true;\n        }\n      } else {\n        mapToProperty(properties, entity, idMaps);\n        hasData = hasData || idMaps.length > 0;\n      }\n    });\n    return hasData;\n  }\n  transformRelationCounts(rawSqlResults, alias, entity) {\n    let hasData = false;\n    this.rawRelationCountResults.filter(rawRelationCountResult => rawRelationCountResult.relationCountAttribute.parentAlias === alias.name).forEach(rawRelationCountResult => {\n      const relation = rawRelationCountResult.relationCountAttribute.relation;\n      let referenceColumnName;\n      if (relation.isOneToMany) {\n        referenceColumnName = relation.inverseRelation.joinColumns[0].referencedColumn.databaseName; // todo: fix joinColumns[0]\n      } else {\n        referenceColumnName = relation.isOwning ? relation.joinColumns[0].referencedColumn.databaseName : relation.inverseRelation.joinColumns[0].referencedColumn.databaseName;\n      }\n      const referenceColumnValue = rawSqlResults[0][DriverUtils.buildAlias(this.driver, undefined, alias.name, referenceColumnName)]; // we use zero index since its grouped data // todo: selection with alias for entity columns wont work\n      if (referenceColumnValue !== undefined && referenceColumnValue !== null) {\n        entity[rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName] = 0;\n        rawRelationCountResult.results.filter(result => result[\"parentId\"] === referenceColumnValue).forEach(result => {\n          entity[rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName] = parseInt(result[\"cnt\"]);\n          hasData = true;\n        });\n      }\n    });\n    return hasData;\n  }\n  createValueMapFromJoinColumns(relation, parentAlias, rawSqlResults) {\n    let columns;\n    if (relation.isManyToOne || relation.isOneToOneOwner) {\n      columns = relation.entityMetadata.primaryColumns.map(joinColumn => joinColumn);\n    } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n      columns = relation.inverseRelation.joinColumns.map(joinColumn => joinColumn);\n    } else {\n      if (relation.isOwning) {\n        columns = relation.joinColumns.map(joinColumn => joinColumn);\n      } else {\n        columns = relation.inverseRelation.inverseJoinColumns.map(joinColumn => joinColumn);\n      }\n    }\n    return columns.reduce((valueMap, column) => {\n      rawSqlResults.forEach(rawSqlResult => {\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\n          valueMap[column.databaseName] = this.driver.prepareHydratedValue(rawSqlResult[DriverUtils.buildAlias(this.driver, undefined, parentAlias, column.databaseName)], column);\n        } else {\n          valueMap[column.databaseName] = this.driver.prepareHydratedValue(rawSqlResult[DriverUtils.buildAlias(this.driver, undefined, parentAlias, column.referencedColumn.databaseName)], column.referencedColumn);\n        }\n      });\n      return valueMap;\n    }, {});\n  }\n  extractEntityPrimaryIds(relation, relationIdRawResult) {\n    let columns;\n    if (relation.isManyToOne || relation.isOneToOneOwner) {\n      columns = relation.entityMetadata.primaryColumns.map(joinColumn => joinColumn);\n    } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n      columns = relation.inverseRelation.joinColumns.map(joinColumn => joinColumn);\n    } else {\n      if (relation.isOwning) {\n        columns = relation.joinColumns.map(joinColumn => joinColumn);\n      } else {\n        columns = relation.inverseRelation.inverseJoinColumns.map(joinColumn => joinColumn);\n      }\n    }\n    return columns.reduce((data, column) => {\n      data[column.databaseName] = relationIdRawResult[column.databaseName];\n      return data;\n    }, {});\n  }\n  /*private removeVirtualColumns(entity: ObjectLiteral, alias: Alias) {\n      const virtualColumns = this.expressionMap.selects\n          .filter(select => select.virtual)\n          .map(select => select.selection.replace(alias.name + \".\", \"\"));\n       virtualColumns.forEach(virtualColumn => delete entity[virtualColumn]);\n  }*/\n  /** Prepare data to run #transformRelationIds, as a lot of result independent data is needed in every call */\n  prepareDataForTransformRelationIds() {\n    // Return early if the relationIdMaps were already calculated\n    if (this.relationIdMaps) {\n      return;\n    }\n    // Ensure this prepare function is only called once\n    this.relationIdMaps = this.rawRelationIdResults.map(rawRelationIdResult => {\n      const relation = rawRelationIdResult.relationIdAttribute.relation;\n      // Calculate column metadata\n      let columns;\n      if (relation.isManyToOne || relation.isOneToOneOwner) {\n        columns = relation.joinColumns;\n      } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n        columns = relation.inverseEntityMetadata.primaryColumns;\n      } else {\n        // ManyToMany\n        if (relation.isOwning) {\n          columns = relation.inverseJoinColumns;\n        } else {\n          columns = relation.inverseRelation.joinColumns;\n        }\n      }\n      // Calculate the idMaps for the rawRelationIdResult\n      return rawRelationIdResult.results.reduce((agg, result) => {\n        let idMap = columns.reduce((idMap, column) => {\n          let value = result[column.databaseName];\n          if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            if (column.isVirtual && column.referencedColumn && column.referencedColumn.propertyName !== column.propertyName) {\n              // if column is a relation\n              value = column.referencedColumn.createValueMap(value);\n            }\n            return OrmUtils.mergeDeep(idMap, column.createValueMap(value));\n          }\n          if (!column.isPrimary && column.referencedColumn.referencedColumn) {\n            // if column is a relation\n            value = column.referencedColumn.referencedColumn.createValueMap(value);\n          }\n          return OrmUtils.mergeDeep(idMap, column.referencedColumn.createValueMap(value));\n        }, {});\n        if (columns.length === 1 && !rawRelationIdResult.relationIdAttribute.disableMixedMap) {\n          if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            idMap = columns[0].getEntityValue(idMap);\n          } else {\n            idMap = columns[0].referencedColumn.getEntityValue(idMap);\n          }\n        }\n        // If an idMap is found, set it in the aggregator under the correct hash\n        if (idMap !== undefined) {\n          const hash = this.hashEntityIds(relation, result);\n          if (agg[hash]) {\n            agg[hash].push(idMap);\n          } else {\n            agg[hash] = [idMap];\n          }\n        }\n        return agg;\n      }, {});\n    });\n  }\n  /**\n   * Use a simple JSON.stringify to create a simple hash of the primary ids of an entity.\n   * As this.extractEntityPrimaryIds always creates the primary id object in the same order, if the same relation is\n   * given, a simple JSON.stringify should be enough to get a unique hash per entity!\n   */\n  hashEntityIds(relation, data) {\n    const entityPrimaryIds = this.extractEntityPrimaryIds(relation, data);\n    return JSON.stringify(entityPrimaryIds);\n  }\n}","map":{"version":3,"names":["OrmUtils","DriverUtils","ObjectUtils","RawSqlResultsToEntityTransformer","constructor","expressionMap","driver","rawRelationIdResults","rawRelationCountResults","queryRunner","transform","rawResults","alias","group","entities","forEach","results","entity","transformRawResultsGroup","undefined","Object","values","every","value","push","map","Map","keys","metadata","tableType","columns","column","buildAlias","name","databaseName","primaryColumns","rawResult","id","key","keyValue","Buffer","isBuffer","toString","isObject","JSON","stringify","join","items","get","set","discriminatorColumn","discriminatorValues","result","discriminatorMetadata","childEntityMetadatas","find","childEntityMetadata","discriminatorValue","create","fromDeserializer","pojo","options","indexOf","hasColumns","transformColumns","hasRelations","transformJoins","hasRelationIds","transformRelationIds","hasRelationCounts","transformRelationCounts","hasOnlyVirtualPrimaryColumns","filter","isVirtual","length","hasData","findIndex","childMetadata","target","selects","select","selection","propertyPath","setEntityValue","prepareHydratedValue","joinAttributes","isSelected","relation","relations","mapToProperty","mapToPropertyParentAlias","parentAlias","relationPropertyPath","isMany","mapToPropertyPropertyName","rawSqlResults","rawRelationIdResult","index","relationIdAttribute","valueMap","createValueMapFromJoinColumns","prepareDataForTransformRelationIds","hash","hashEntityIds","idMaps","relationIdMaps","properties","mapToPropertyPropertyPath","split","property","shift","isOneToOne","isManyToOne","rawRelationCountResult","relationCountAttribute","referenceColumnName","isOneToMany","inverseRelation","joinColumns","referencedColumn","isOwning","referenceColumnValue","parseInt","isOneToOneOwner","entityMetadata","joinColumn","isOneToOneNotOwner","inverseJoinColumns","reduce","rawSqlResult","extractEntityPrimaryIds","relationIdRawResult","data","inverseEntityMetadata","agg","idMap","propertyName","createValueMap","mergeDeep","isPrimary","disableMixedMap","getEntityValue","entityPrimaryIds"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\query-builder\\transformer\\RawSqlResultsToEntityTransformer.ts"],"sourcesContent":["import { Driver } from \"../../driver/Driver\"\nimport { RelationIdLoadResult } from \"../relation-id/RelationIdLoadResult\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { ColumnMetadata } from \"../../metadata/ColumnMetadata\"\nimport { Alias } from \"../Alias\"\nimport { RelationCountLoadResult } from \"../relation-count/RelationCountLoadResult\"\nimport { RelationMetadata } from \"../../metadata/RelationMetadata\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { QueryExpressionMap } from \"../QueryExpressionMap\"\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\"\nimport { QueryRunner } from \"../..\"\nimport { DriverUtils } from \"../../driver/DriverUtils\"\nimport { ObjectUtils } from \"../../util/ObjectUtils\"\n\n/**\n * Transforms raw sql results returned from the database into entity object.\n * Entity is constructed based on its entity metadata.\n */\nexport class RawSqlResultsToEntityTransformer {\n    /**\n     * Contains a hashmap for every rawRelationIdResults given.\n     * In the hashmap you will find the idMaps of a result under the hash of this.hashEntityIds for the result.\n     */\n    private relationIdMaps: Array<{ [idHash: string]: any[] }>\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        protected expressionMap: QueryExpressionMap,\n        protected driver: Driver,\n        protected rawRelationIdResults: RelationIdLoadResult[],\n        protected rawRelationCountResults: RelationCountLoadResult[],\n        protected queryRunner?: QueryRunner,\n    ) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated\n     * we need to group our result and we must have some unique id (primary key in our case)\n     */\n    transform(rawResults: any[], alias: Alias): any[] {\n        const group = this.group(rawResults, alias)\n        const entities: any[] = []\n        group.forEach((results) => {\n            const entity = this.transformRawResultsGroup(results, alias)\n            if (\n                entity !== undefined &&\n                !Object.values(entity).every((value) => value === null)\n            )\n                entities.push(entity)\n        })\n        return entities\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Groups given raw results by ids of given alias.\n     */\n    protected group(rawResults: any[], alias: Alias): Map<string, any[]> {\n        const map = new Map()\n        const keys: string[] = []\n        if (alias.metadata.tableType === \"view\") {\n            keys.push(\n                ...alias.metadata.columns.map((column) =>\n                    DriverUtils.buildAlias(\n                        this.driver,\n                        undefined,\n                        alias.name,\n                        column.databaseName,\n                    ),\n                ),\n            )\n        } else {\n            keys.push(\n                ...alias.metadata.primaryColumns.map((column) =>\n                    DriverUtils.buildAlias(\n                        this.driver,\n                        undefined,\n                        alias.name,\n                        column.databaseName,\n                    ),\n                ),\n            )\n        }\n        rawResults.forEach((rawResult) => {\n            const id = keys\n                .map((key) => {\n                    const keyValue = rawResult[key]\n\n                    if (Buffer.isBuffer(keyValue)) {\n                        return keyValue.toString(\"hex\")\n                    }\n\n                    if (ObjectUtils.isObject(keyValue)) {\n                        return JSON.stringify(keyValue)\n                    }\n\n                    return keyValue\n                })\n                .join(\"_\") // todo: check partial\n\n            const items = map.get(id)\n            if (!items) {\n                map.set(id, [rawResult])\n            } else {\n                items.push(rawResult)\n            }\n        })\n        return map\n    }\n\n    /**\n     * Transforms set of data results into single entity.\n     */\n    protected transformRawResultsGroup(\n        rawResults: any[],\n        alias: Alias,\n    ): ObjectLiteral | undefined {\n        // let hasColumns = false; // , hasEmbeddedColumns = false, hasParentColumns = false, hasParentEmbeddedColumns = false;\n        let metadata = alias.metadata\n\n        if (metadata.discriminatorColumn) {\n            const discriminatorValues = rawResults.map(\n                (result) =>\n                    result[\n                        DriverUtils.buildAlias(\n                            this.driver,\n                            undefined,\n                            alias.name,\n                            alias.metadata.discriminatorColumn!.databaseName,\n                        )\n                    ],\n            )\n            const discriminatorMetadata = metadata.childEntityMetadatas.find(\n                (childEntityMetadata) => {\n                    return (\n                        typeof discriminatorValues.find(\n                            (value) =>\n                                value ===\n                                childEntityMetadata.discriminatorValue,\n                        ) !== \"undefined\"\n                    )\n                },\n            )\n            if (discriminatorMetadata) metadata = discriminatorMetadata\n        }\n        let entity: any = metadata.create(this.queryRunner, {\n            fromDeserializer: true,\n            pojo: this.expressionMap.options.indexOf(\"create-pojo\") !== -1,\n        })\n\n        // get value from columns selections and put them into newly created entity\n        const hasColumns = this.transformColumns(\n            rawResults,\n            alias,\n            entity,\n            metadata,\n        )\n        const hasRelations = this.transformJoins(\n            rawResults,\n            entity,\n            alias,\n            metadata,\n        )\n        const hasRelationIds = this.transformRelationIds(\n            rawResults,\n            alias,\n            entity,\n            metadata,\n        )\n        const hasRelationCounts = this.transformRelationCounts(\n            rawResults,\n            alias,\n            entity,\n        )\n\n        // if we have at least one selected column then return this entity\n        // since entity must have at least primary columns to be really selected and transformed into entity\n        if (hasColumns) return entity\n\n        // if we don't have any selected column we should not return entity,\n        // except for the case when entity only contain a primary column as a relation to another entity\n        // in this case its absolutely possible our entity to not have any columns except a single relation\n        const hasOnlyVirtualPrimaryColumns =\n            metadata.primaryColumns.filter(\n                (column) => column.isVirtual === false,\n            ).length === 0 // todo: create metadata.hasOnlyVirtualPrimaryColumns\n        if (\n            hasOnlyVirtualPrimaryColumns &&\n            (hasRelations || hasRelationIds || hasRelationCounts)\n        )\n            return entity\n\n        return undefined\n    }\n\n    // get value from columns selections and put them into object\n    protected transformColumns(\n        rawResults: any[],\n        alias: Alias,\n        entity: ObjectLiteral,\n        metadata: EntityMetadata,\n    ): boolean {\n        let hasData = false\n        metadata.columns.forEach((column) => {\n            // if table inheritance is used make sure this column is not child's column\n            if (\n                metadata.childEntityMetadatas.length > 0 &&\n                metadata.childEntityMetadatas.findIndex(\n                    (childMetadata) => childMetadata.target === column.target,\n                ) !== -1\n            )\n                return\n\n            const value =\n                rawResults[0][\n                    DriverUtils.buildAlias(\n                        this.driver,\n                        undefined,\n                        alias.name,\n                        column.databaseName,\n                    )\n                ]\n            if (value === undefined || column.isVirtual) return\n\n            // if user does not selected the whole entity or he used partial selection and does not select this particular column\n            // then we don't add this column and its value into the entity\n            if (\n                !this.expressionMap.selects.find(\n                    (select) =>\n                        select.selection === alias.name ||\n                        select.selection ===\n                            alias.name + \".\" + column.propertyPath,\n                )\n            )\n                return\n\n            column.setEntityValue(\n                entity,\n                this.driver.prepareHydratedValue(value, column),\n            )\n            if (value !== null)\n                // we don't mark it as has data because if we will have all nulls in our object - we don't need such object\n                hasData = true\n        })\n        return hasData\n    }\n\n    /**\n     * Transforms joined entities in the given raw results by a given alias and stores to the given (parent) entity\n     */\n    protected transformJoins(\n        rawResults: any[],\n        entity: ObjectLiteral,\n        alias: Alias,\n        metadata: EntityMetadata,\n    ) {\n        let hasData = false\n\n        // let discriminatorValue: string = \"\";\n        // if (metadata.discriminatorColumn)\n        //     discriminatorValue = rawResults[0][DriverUtils.buildAlias(this.connection.driver, alias.name, alias.metadata.discriminatorColumn!.databaseName)];\n\n        this.expressionMap.joinAttributes.forEach((join) => {\n            // todo: we have problem here - when inner joins are used without selects it still create empty array\n\n            // skip joins without metadata\n            if (!join.metadata) return\n\n            // if simple left or inner join was performed without selection then we don't need to do anything\n            if (!join.isSelected) return\n\n            // this check need to avoid setting properties than not belong to entity when single table inheritance used. (todo: check if we still need it)\n            // const metadata = metadata.childEntityMetadatas.find(childEntityMetadata => discriminatorValue === childEntityMetadata.discriminatorValue);\n            if (\n                join.relation &&\n                !metadata.relations.find(\n                    (relation) => relation === join.relation,\n                )\n            )\n                return\n\n            // some checks to make sure this join is for current alias\n            if (join.mapToProperty) {\n                if (join.mapToPropertyParentAlias !== alias.name) return\n            } else {\n                if (\n                    !join.relation ||\n                    join.parentAlias !== alias.name ||\n                    join.relationPropertyPath !== join.relation!.propertyPath\n                )\n                    return\n            }\n\n            // transform joined data into entities\n            let result: any = this.transform(rawResults, join.alias)\n            result = !join.isMany ? result[0] : result\n            result = !join.isMany && result === undefined ? null : result // this is needed to make relations to return null when its joined but nothing was found in the database\n            if (result === undefined)\n                // if nothing was joined then simply return\n                return\n\n            // if join was mapped to some property then save result to that property\n            if (join.mapToPropertyPropertyName) {\n                entity[join.mapToPropertyPropertyName] = result // todo: fix embeds\n            } else {\n                // otherwise set to relation\n                join.relation!.setEntityValue(entity, result)\n            }\n\n            hasData = true\n        })\n        return hasData\n    }\n\n    protected transformRelationIds(\n        rawSqlResults: any[],\n        alias: Alias,\n        entity: ObjectLiteral,\n        metadata: EntityMetadata,\n    ): boolean {\n        let hasData = false\n        this.rawRelationIdResults.forEach((rawRelationIdResult, index) => {\n            if (\n                rawRelationIdResult.relationIdAttribute.parentAlias !==\n                alias.name\n            )\n                return\n\n            const relation = rawRelationIdResult.relationIdAttribute.relation\n            const valueMap = this.createValueMapFromJoinColumns(\n                relation,\n                rawRelationIdResult.relationIdAttribute.parentAlias,\n                rawSqlResults,\n            )\n            if (valueMap === undefined || valueMap === null) {\n                return\n            }\n\n            // prepare common data for this call\n            this.prepareDataForTransformRelationIds()\n\n            // Extract idMaps from prepared data by hash\n            const hash = this.hashEntityIds(relation, valueMap)\n            const idMaps = this.relationIdMaps[index][hash] || []\n\n            // Map data to properties\n            const properties =\n                rawRelationIdResult.relationIdAttribute.mapToPropertyPropertyPath.split(\n                    \".\",\n                )\n            const mapToProperty = (\n                properties: string[],\n                map: ObjectLiteral,\n                value: any,\n            ): any => {\n                const property = properties.shift()\n                if (property && properties.length === 0) {\n                    map[property] = value\n                    return map\n                }\n                if (property && properties.length > 0) {\n                    mapToProperty(properties, map[property], value)\n                } else {\n                    return map\n                }\n            }\n            if (relation.isOneToOne || relation.isManyToOne) {\n                if (idMaps[0] !== undefined) {\n                    mapToProperty(properties, entity, idMaps[0])\n                    hasData = true\n                }\n            } else {\n                mapToProperty(properties, entity, idMaps)\n                hasData = hasData || idMaps.length > 0\n            }\n        })\n\n        return hasData\n    }\n\n    protected transformRelationCounts(\n        rawSqlResults: any[],\n        alias: Alias,\n        entity: ObjectLiteral,\n    ): boolean {\n        let hasData = false\n        this.rawRelationCountResults\n            .filter(\n                (rawRelationCountResult) =>\n                    rawRelationCountResult.relationCountAttribute\n                        .parentAlias === alias.name,\n            )\n            .forEach((rawRelationCountResult) => {\n                const relation =\n                    rawRelationCountResult.relationCountAttribute.relation\n                let referenceColumnName: string\n\n                if (relation.isOneToMany) {\n                    referenceColumnName =\n                        relation.inverseRelation!.joinColumns[0]\n                            .referencedColumn!.databaseName // todo: fix joinColumns[0]\n                } else {\n                    referenceColumnName = relation.isOwning\n                        ? relation.joinColumns[0].referencedColumn!.databaseName\n                        : relation.inverseRelation!.joinColumns[0]\n                              .referencedColumn!.databaseName\n                }\n\n                const referenceColumnValue =\n                    rawSqlResults[0][\n                        DriverUtils.buildAlias(\n                            this.driver,\n                            undefined,\n                            alias.name,\n                            referenceColumnName,\n                        )\n                    ] // we use zero index since its grouped data // todo: selection with alias for entity columns wont work\n                if (\n                    referenceColumnValue !== undefined &&\n                    referenceColumnValue !== null\n                ) {\n                    entity[\n                        rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName\n                    ] = 0\n                    rawRelationCountResult.results\n                        .filter(\n                            (result) =>\n                                result[\"parentId\"] === referenceColumnValue,\n                        )\n                        .forEach((result) => {\n                            entity[\n                                rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName\n                            ] = parseInt(result[\"cnt\"])\n                            hasData = true\n                        })\n                }\n            })\n\n        return hasData\n    }\n\n    private createValueMapFromJoinColumns(\n        relation: RelationMetadata,\n        parentAlias: string,\n        rawSqlResults: any[],\n    ): ObjectLiteral {\n        let columns: ColumnMetadata[]\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\n            columns = relation.entityMetadata.primaryColumns.map(\n                (joinColumn) => joinColumn,\n            )\n        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            columns = relation.inverseRelation!.joinColumns.map(\n                (joinColumn) => joinColumn,\n            )\n        } else {\n            if (relation.isOwning) {\n                columns = relation.joinColumns.map((joinColumn) => joinColumn)\n            } else {\n                columns = relation.inverseRelation!.inverseJoinColumns.map(\n                    (joinColumn) => joinColumn,\n                )\n            }\n        }\n        return columns.reduce((valueMap, column) => {\n            rawSqlResults.forEach((rawSqlResult) => {\n                if (relation.isManyToOne || relation.isOneToOneOwner) {\n                    valueMap[column.databaseName] =\n                        this.driver.prepareHydratedValue(\n                            rawSqlResult[\n                                DriverUtils.buildAlias(\n                                    this.driver,\n                                    undefined,\n                                    parentAlias,\n                                    column.databaseName,\n                                )\n                            ],\n                            column,\n                        )\n                } else {\n                    valueMap[column.databaseName] =\n                        this.driver.prepareHydratedValue(\n                            rawSqlResult[\n                                DriverUtils.buildAlias(\n                                    this.driver,\n                                    undefined,\n                                    parentAlias,\n                                    column.referencedColumn!.databaseName,\n                                )\n                            ],\n                            column.referencedColumn!,\n                        )\n                }\n            })\n            return valueMap\n        }, {} as ObjectLiteral)\n    }\n\n    private extractEntityPrimaryIds(\n        relation: RelationMetadata,\n        relationIdRawResult: any,\n    ) {\n        let columns: ColumnMetadata[]\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\n            columns = relation.entityMetadata.primaryColumns.map(\n                (joinColumn) => joinColumn,\n            )\n        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            columns = relation.inverseRelation!.joinColumns.map(\n                (joinColumn) => joinColumn,\n            )\n        } else {\n            if (relation.isOwning) {\n                columns = relation.joinColumns.map((joinColumn) => joinColumn)\n            } else {\n                columns = relation.inverseRelation!.inverseJoinColumns.map(\n                    (joinColumn) => joinColumn,\n                )\n            }\n        }\n        return columns.reduce((data, column) => {\n            data[column.databaseName] = relationIdRawResult[column.databaseName]\n            return data\n        }, {} as ObjectLiteral)\n    }\n\n    /*private removeVirtualColumns(entity: ObjectLiteral, alias: Alias) {\n        const virtualColumns = this.expressionMap.selects\n            .filter(select => select.virtual)\n            .map(select => select.selection.replace(alias.name + \".\", \"\"));\n\n        virtualColumns.forEach(virtualColumn => delete entity[virtualColumn]);\n    }*/\n\n    /** Prepare data to run #transformRelationIds, as a lot of result independent data is needed in every call */\n    private prepareDataForTransformRelationIds() {\n        // Return early if the relationIdMaps were already calculated\n        if (this.relationIdMaps) {\n            return\n        }\n\n        // Ensure this prepare function is only called once\n        this.relationIdMaps = this.rawRelationIdResults.map(\n            (rawRelationIdResult) => {\n                const relation =\n                    rawRelationIdResult.relationIdAttribute.relation\n\n                // Calculate column metadata\n                let columns: ColumnMetadata[]\n                if (relation.isManyToOne || relation.isOneToOneOwner) {\n                    columns = relation.joinColumns\n                } else if (\n                    relation.isOneToMany ||\n                    relation.isOneToOneNotOwner\n                ) {\n                    columns = relation.inverseEntityMetadata.primaryColumns\n                } else {\n                    // ManyToMany\n                    if (relation.isOwning) {\n                        columns = relation.inverseJoinColumns\n                    } else {\n                        columns = relation.inverseRelation!.joinColumns\n                    }\n                }\n\n                // Calculate the idMaps for the rawRelationIdResult\n                return rawRelationIdResult.results.reduce((agg, result) => {\n                    let idMap = columns.reduce((idMap, column) => {\n                        let value = result[column.databaseName]\n                        if (\n                            relation.isOneToMany ||\n                            relation.isOneToOneNotOwner\n                        ) {\n                            if (\n                                column.isVirtual &&\n                                column.referencedColumn &&\n                                column.referencedColumn.propertyName !==\n                                    column.propertyName\n                            ) {\n                                // if column is a relation\n                                value =\n                                    column.referencedColumn.createValueMap(\n                                        value,\n                                    )\n                            }\n\n                            return OrmUtils.mergeDeep(\n                                idMap,\n                                column.createValueMap(value),\n                            )\n                        }\n                        if (\n                            !column.isPrimary &&\n                            column.referencedColumn!.referencedColumn\n                        ) {\n                            // if column is a relation\n                            value =\n                                column.referencedColumn!.referencedColumn!.createValueMap(\n                                    value,\n                                )\n                        }\n\n                        return OrmUtils.mergeDeep(\n                            idMap,\n                            column.referencedColumn!.createValueMap(value),\n                        )\n                    }, {} as ObjectLiteral)\n\n                    if (\n                        columns.length === 1 &&\n                        !rawRelationIdResult.relationIdAttribute.disableMixedMap\n                    ) {\n                        if (\n                            relation.isOneToMany ||\n                            relation.isOneToOneNotOwner\n                        ) {\n                            idMap = columns[0].getEntityValue(idMap)\n                        } else {\n                            idMap =\n                                columns[0].referencedColumn!.getEntityValue(\n                                    idMap,\n                                )\n                        }\n                    }\n\n                    // If an idMap is found, set it in the aggregator under the correct hash\n                    if (idMap !== undefined) {\n                        const hash = this.hashEntityIds(relation, result)\n\n                        if (agg[hash]) {\n                            agg[hash].push(idMap)\n                        } else {\n                            agg[hash] = [idMap]\n                        }\n                    }\n\n                    return agg\n                }, {})\n            },\n        )\n    }\n\n    /**\n     * Use a simple JSON.stringify to create a simple hash of the primary ids of an entity.\n     * As this.extractEntityPrimaryIds always creates the primary id object in the same order, if the same relation is\n     * given, a simple JSON.stringify should be enough to get a unique hash per entity!\n     */\n    private hashEntityIds(relation: RelationMetadata, data: ObjectLiteral) {\n        const entityPrimaryIds = this.extractEntityPrimaryIds(relation, data)\n        return JSON.stringify(entityPrimaryIds)\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}