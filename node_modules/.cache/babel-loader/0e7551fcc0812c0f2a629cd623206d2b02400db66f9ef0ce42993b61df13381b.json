{"ast":null,"code":"import { SubjectTopoligicalSorter } from \"./SubjectTopoligicalSorter\";\nimport { SubjectChangedColumnsComputer } from \"./SubjectChangedColumnsComputer\";\nimport { SubjectWithoutIdentifierError } from \"../error/SubjectWithoutIdentifierError\";\nimport { SubjectRemovedAndUpdatedError } from \"../error/SubjectRemovedAndUpdatedError\";\nimport { BroadcasterResult } from \"../subscriber/BroadcasterResult\";\nimport { NestedSetSubjectExecutor } from \"./tree/NestedSetSubjectExecutor\";\nimport { ClosureSubjectExecutor } from \"./tree/ClosureSubjectExecutor\";\nimport { MaterializedPathSubjectExecutor } from \"./tree/MaterializedPathSubjectExecutor\";\nimport { OrmUtils } from \"../util/OrmUtils\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\n/**\n * Executes all database operations (inserts, updated, deletes) that must be executed\n * with given persistence subjects.\n */\nexport class SubjectExecutor {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(queryRunner, subjects, options) {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n    /**\n     * Indicates if executor has any operations to execute (e.g. has insert / update / delete operations to be executed).\n     */\n    this.hasExecutableOperations = false;\n    /**\n     * Subjects that must be inserted.\n     */\n    this.insertSubjects = [];\n    /**\n     * Subjects that must be updated.\n     */\n    this.updateSubjects = [];\n    /**\n     * Subjects that must be removed.\n     */\n    this.removeSubjects = [];\n    /**\n     * Subjects that must be soft-removed.\n     */\n    this.softRemoveSubjects = [];\n    /**\n     * Subjects that must be recovered.\n     */\n    this.recoverSubjects = [];\n    this.queryRunner = queryRunner;\n    this.allSubjects = subjects;\n    this.options = options;\n    this.validate();\n    this.recompute();\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Executes all operations over given array of subjects.\n   * Executes queries using given query runner.\n   */\n  async execute() {\n    // console.time(\"SubjectExecutor.execute\");\n    // broadcast \"before\" events before we start insert / update / remove operations\n    let broadcasterResult = undefined;\n    if (!this.options || this.options.listeners !== false) {\n      // console.time(\".broadcastBeforeEventsForAll\");\n      broadcasterResult = this.broadcastBeforeEventsForAll();\n      if (broadcasterResult.promises.length > 0) await Promise.all(broadcasterResult.promises);\n      // console.timeEnd(\".broadcastBeforeEventsForAll\");\n    }\n    // since event listeners and subscribers can call save methods and/or trigger entity changes we need to recompute operational subjects\n    // recompute only in the case if any listener or subscriber was really executed\n    if (broadcasterResult && broadcasterResult.count > 0) {\n      // console.time(\".recompute\");\n      this.insertSubjects.forEach(subject => subject.recompute());\n      this.updateSubjects.forEach(subject => subject.recompute());\n      this.removeSubjects.forEach(subject => subject.recompute());\n      this.softRemoveSubjects.forEach(subject => subject.recompute());\n      this.recoverSubjects.forEach(subject => subject.recompute());\n      this.recompute();\n      // console.timeEnd(\".recompute\");\n    }\n    // make sure our insert subjects are sorted (using topological sorting) to make cascade inserts work properly\n    // console.timeEnd(\"prepare\");\n    // execute all insert operations\n    // console.time(\".insertion\");\n    this.insertSubjects = new SubjectTopoligicalSorter(this.insertSubjects).sort(\"insert\");\n    await this.executeInsertOperations();\n    // console.timeEnd(\".insertion\");\n    // recompute update operations since insertion can create updation operations for the\n    // properties it wasn't able to handle on its own (referenced columns)\n    this.updateSubjects = this.allSubjects.filter(subject => subject.mustBeUpdated);\n    // execute update operations\n    // console.time(\".updation\");\n    await this.executeUpdateOperations();\n    // console.timeEnd(\".updation\");\n    // make sure our remove subjects are sorted (using topological sorting) when multiple entities are passed for the removal\n    // console.time(\".removal\");\n    this.removeSubjects = new SubjectTopoligicalSorter(this.removeSubjects).sort(\"delete\");\n    await this.executeRemoveOperations();\n    // console.timeEnd(\".removal\");\n    // recompute soft-remove operations\n    this.softRemoveSubjects = this.allSubjects.filter(subject => subject.mustBeSoftRemoved);\n    // execute soft-remove operations\n    await this.executeSoftRemoveOperations();\n    // recompute recover operations\n    this.recoverSubjects = this.allSubjects.filter(subject => subject.mustBeRecovered);\n    // execute recover operations\n    await this.executeRecoverOperations();\n    // update all special columns in persisted entities, like inserted id or remove ids from the removed entities\n    // console.time(\".updateSpecialColumnsInPersistedEntities\");\n    this.updateSpecialColumnsInPersistedEntities();\n    // console.timeEnd(\".updateSpecialColumnsInPersistedEntities\");\n    // finally broadcast \"after\" events after we finish insert / update / remove operations\n    if (!this.options || this.options.listeners !== false) {\n      // console.time(\".broadcastAfterEventsForAll\");\n      broadcasterResult = this.broadcastAfterEventsForAll();\n      if (broadcasterResult.promises.length > 0) await Promise.all(broadcasterResult.promises);\n      // console.timeEnd(\".broadcastAfterEventsForAll\");\n    }\n    // console.timeEnd(\"SubjectExecutor.execute\");\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Validates all given subjects.\n   */\n  validate() {\n    this.allSubjects.forEach(subject => {\n      if (subject.mustBeUpdated && subject.mustBeRemoved) throw new SubjectRemovedAndUpdatedError(subject);\n    });\n  }\n  /**\n   * Performs entity re-computations - finds changed columns, re-builds insert/update/remove subjects.\n   */\n  recompute() {\n    new SubjectChangedColumnsComputer().compute(this.allSubjects);\n    this.insertSubjects = this.allSubjects.filter(subject => subject.mustBeInserted);\n    this.updateSubjects = this.allSubjects.filter(subject => subject.mustBeUpdated);\n    this.removeSubjects = this.allSubjects.filter(subject => subject.mustBeRemoved);\n    this.softRemoveSubjects = this.allSubjects.filter(subject => subject.mustBeSoftRemoved);\n    this.recoverSubjects = this.allSubjects.filter(subject => subject.mustBeRecovered);\n    this.hasExecutableOperations = this.insertSubjects.length > 0 || this.updateSubjects.length > 0 || this.removeSubjects.length > 0 || this.softRemoveSubjects.length > 0 || this.recoverSubjects.length > 0;\n  }\n  /**\n   * Broadcasts \"BEFORE_INSERT\", \"BEFORE_UPDATE\", \"BEFORE_REMOVE\", \"BEFORE_SOFT_REMOVE\", \"BEFORE_RECOVER\" events for all given subjects.\n   */\n  broadcastBeforeEventsForAll() {\n    const result = new BroadcasterResult();\n    if (this.insertSubjects.length) this.insertSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeInsertEvent(result, subject.metadata, subject.entity));\n    if (this.updateSubjects.length) this.updateSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeUpdateEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.diffColumns, subject.diffRelations));\n    if (this.removeSubjects.length) this.removeSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));\n    if (this.softRemoveSubjects.length) this.softRemoveSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeSoftRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));\n    if (this.recoverSubjects.length) this.recoverSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeRecoverEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));\n    return result;\n  }\n  /**\n   * Broadcasts \"AFTER_INSERT\", \"AFTER_UPDATE\", \"AFTER_REMOVE\", \"AFTER_SOFT_REMOVE\", \"AFTER_RECOVER\" events for all given subjects.\n   * Returns void if there wasn't any listener or subscriber executed.\n   * Note: this method has a performance-optimized code organization.\n   */\n  broadcastAfterEventsForAll() {\n    const result = new BroadcasterResult();\n    if (this.insertSubjects.length) this.insertSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterInsertEvent(result, subject.metadata, subject.entity, subject.identifier));\n    if (this.updateSubjects.length) this.updateSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterUpdateEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.diffColumns, subject.diffRelations));\n    if (this.removeSubjects.length) this.removeSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));\n    if (this.softRemoveSubjects.length) this.softRemoveSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterSoftRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));\n    if (this.recoverSubjects.length) this.recoverSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterRecoverEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));\n    return result;\n  }\n  /**\n   * Executes insert operations.\n   */\n  async executeInsertOperations() {\n    // group insertion subjects to make bulk insertions\n    const [groupedInsertSubjects, groupedInsertSubjectKeys] = this.groupBulkSubjects(this.insertSubjects, \"insert\");\n    // then we run insertion in the sequential order which is important since we have an ordered subjects\n    for (const groupName of groupedInsertSubjectKeys) {\n      const subjects = groupedInsertSubjects[groupName];\n      // we must separately insert entities which does not have any values to insert\n      // because its not possible to insert multiple entities with only default values in bulk\n      const bulkInsertMaps = [];\n      const bulkInsertSubjects = [];\n      const singleInsertSubjects = [];\n      if (this.queryRunner.connection.driver.options.type === \"mongodb\") {\n        subjects.forEach(subject => {\n          if (subject.metadata.createDateColumn && subject.entity) {\n            subject.entity[subject.metadata.createDateColumn.databaseName] = new Date();\n          }\n          if (subject.metadata.updateDateColumn && subject.entity) {\n            subject.entity[subject.metadata.updateDateColumn.databaseName] = new Date();\n          }\n          subject.createValueSetAndPopChangeMap();\n          bulkInsertSubjects.push(subject);\n          bulkInsertMaps.push(subject.entity);\n        });\n      } else if (this.queryRunner.connection.driver.options.type === \"oracle\") {\n        subjects.forEach(subject => {\n          singleInsertSubjects.push(subject);\n        });\n      } else {\n        subjects.forEach(subject => {\n          // we do not insert in bulk in following cases:\n          // - when there is no values in insert (only defaults are inserted), since we cannot use DEFAULT VALUES expression for multiple inserted rows\n          // - when entity is a tree table, since tree tables require extra operation per each inserted row\n          // - when oracle is used, since oracle's bulk insertion is very bad\n          if (subject.changeMaps.length === 0 || subject.metadata.treeType || this.queryRunner.connection.driver.options.type === \"oracle\" || this.queryRunner.connection.driver.options.type === \"sap\") {\n            singleInsertSubjects.push(subject);\n          } else {\n            bulkInsertSubjects.push(subject);\n            bulkInsertMaps.push(subject.createValueSetAndPopChangeMap());\n          }\n        });\n      }\n      // for mongodb we have a bit different insertion logic\n      if (InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {\n        const insertResult = await this.queryRunner.manager.insert(subjects[0].metadata.target, bulkInsertMaps);\n        subjects.forEach((subject, index) => {\n          subject.identifier = insertResult.identifiers[index];\n          subject.generatedMap = insertResult.generatedMaps[index];\n          subject.insertedValueSet = bulkInsertMaps[index];\n        });\n      } else {\n        // here we execute our insertion query\n        // we need to enable entity updation because we DO need to have updated insertedMap\n        // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n        // also, we disable listeners because we call them on our own in persistence layer\n        if (bulkInsertMaps.length > 0) {\n          const insertResult = await this.queryRunner.manager.createQueryBuilder().insert().into(subjects[0].metadata.target).values(bulkInsertMaps).updateEntity(this.options && this.options.reload === false ? false : true).callListeners(false).execute();\n          bulkInsertSubjects.forEach((subject, index) => {\n            subject.identifier = insertResult.identifiers[index];\n            subject.generatedMap = insertResult.generatedMaps[index];\n            subject.insertedValueSet = bulkInsertMaps[index];\n          });\n        }\n        // insert subjects which must be inserted in separate requests (all default values)\n        if (singleInsertSubjects.length > 0) {\n          for (const subject of singleInsertSubjects) {\n            subject.insertedValueSet = subject.createValueSetAndPopChangeMap(); // important to have because query builder sets inserted values into it\n            // for nested set we execute additional queries\n            if (subject.metadata.treeType === \"nested-set\") await new NestedSetSubjectExecutor(this.queryRunner).insert(subject);\n            await this.queryRunner.manager.createQueryBuilder().insert().into(subject.metadata.target).values(subject.insertedValueSet).updateEntity(this.options && this.options.reload === false ? false : true).callListeners(false).execute().then(insertResult => {\n              subject.identifier = insertResult.identifiers[0];\n              subject.generatedMap = insertResult.generatedMaps[0];\n            });\n            // for tree tables we execute additional queries\n            if (subject.metadata.treeType === \"closure-table\") {\n              await new ClosureSubjectExecutor(this.queryRunner).insert(subject);\n            } else if (subject.metadata.treeType === \"materialized-path\") {\n              await new MaterializedPathSubjectExecutor(this.queryRunner).insert(subject);\n            }\n          }\n        }\n      }\n      subjects.forEach(subject => {\n        if (subject.generatedMap) {\n          subject.metadata.columns.forEach(column => {\n            const value = column.getEntityValue(subject.generatedMap);\n            if (value !== undefined && value !== null) {\n              const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);\n              column.setEntityValue(subject.generatedMap, preparedValue);\n            }\n          });\n        }\n      });\n    }\n  }\n  /**\n   * Updates all given subjects in the database.\n   */\n  async executeUpdateOperations() {\n    const updateSubject = async subject => {\n      if (!subject.identifier) throw new SubjectWithoutIdentifierError(subject);\n      // for mongodb we have a bit different updation logic\n      if (InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {\n        const partialEntity = this.cloneMongoSubjectEntity(subject);\n        if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {\n          delete partialEntity[subject.metadata.objectIdColumn.propertyName];\n        }\n        if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {\n          delete partialEntity[subject.metadata.createDateColumn.propertyName];\n        }\n        if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {\n          partialEntity[subject.metadata.updateDateColumn.propertyName] = new Date();\n        }\n        const manager = this.queryRunner.manager;\n        await manager.update(subject.metadata.target, subject.identifier, partialEntity);\n      } else {\n        const updateMap = subject.createValueSetAndPopChangeMap();\n        // for tree tables we execute additional queries\n        switch (subject.metadata.treeType) {\n          case \"nested-set\":\n            await new NestedSetSubjectExecutor(this.queryRunner).update(subject);\n            break;\n          case \"closure-table\":\n            await new ClosureSubjectExecutor(this.queryRunner).update(subject);\n            break;\n          case \"materialized-path\":\n            await new MaterializedPathSubjectExecutor(this.queryRunner).update(subject);\n            break;\n        }\n        // here we execute our updation query\n        // we need to enable entity updation because we update a subject identifier\n        // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n        // also, we disable listeners because we call them on our own in persistence layer\n        const updateQueryBuilder = this.queryRunner.manager.createQueryBuilder().update(subject.metadata.target).set(updateMap).updateEntity(this.options && this.options.reload === false ? false : true).callListeners(false);\n        if (subject.entity) {\n          updateQueryBuilder.whereEntity(subject.identifier);\n        } else {\n          // in this case identifier is just conditions object to update by\n          updateQueryBuilder.where(subject.identifier);\n        }\n        const updateResult = await updateQueryBuilder.execute();\n        let updateGeneratedMap = updateResult.generatedMaps[0];\n        if (updateGeneratedMap) {\n          subject.metadata.columns.forEach(column => {\n            const value = column.getEntityValue(updateGeneratedMap);\n            if (value !== undefined && value !== null) {\n              const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);\n              column.setEntityValue(updateGeneratedMap, preparedValue);\n            }\n          });\n          if (!subject.generatedMap) {\n            subject.generatedMap = {};\n          }\n          Object.assign(subject.generatedMap, updateGeneratedMap);\n        }\n      }\n    };\n    // Nested sets need to be updated one by one\n    // Split array in two, one with nested set subjects and the other with the remaining subjects\n    const nestedSetSubjects = [];\n    const remainingSubjects = [];\n    for (const subject of this.updateSubjects) {\n      if (subject.metadata.treeType === \"nested-set\") {\n        nestedSetSubjects.push(subject);\n      } else {\n        remainingSubjects.push(subject);\n      }\n    }\n    // Run nested set updates one by one\n    const nestedSetPromise = new Promise(async (ok, fail) => {\n      for (const subject of nestedSetSubjects) {\n        try {\n          await updateSubject(subject);\n        } catch (error) {\n          fail(error);\n        }\n      }\n      ok();\n    });\n    // Run all remaining subjects in parallel\n    await Promise.all([...remainingSubjects.map(updateSubject), nestedSetPromise]);\n  }\n  /**\n   * Removes all given subjects from the database.\n   *\n   * todo: we need to apply topological sort here as well\n   */\n  async executeRemoveOperations() {\n    // group insertion subjects to make bulk insertions\n    const [groupedRemoveSubjects, groupedRemoveSubjectKeys] = this.groupBulkSubjects(this.removeSubjects, \"delete\");\n    for (const groupName of groupedRemoveSubjectKeys) {\n      const subjects = groupedRemoveSubjects[groupName];\n      const deleteMaps = subjects.map(subject => {\n        if (!subject.identifier) throw new SubjectWithoutIdentifierError(subject);\n        return subject.identifier;\n      });\n      // for mongodb we have a bit different updation logic\n      if (InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {\n        const manager = this.queryRunner.manager;\n        await manager.delete(subjects[0].metadata.target, deleteMaps);\n      } else {\n        // for tree tables we execute additional queries\n        switch (subjects[0].metadata.treeType) {\n          case \"nested-set\":\n            await new NestedSetSubjectExecutor(this.queryRunner).remove(subjects);\n            break;\n          case \"closure-table\":\n            await new ClosureSubjectExecutor(this.queryRunner).remove(subjects);\n            break;\n        }\n        // here we execute our deletion query\n        // we don't need to specify entities and set update entity to true since the only thing query builder\n        // will do for use is a primary keys deletion which is handled by us later once persistence is finished\n        // also, we disable listeners because we call them on our own in persistence layer\n        await this.queryRunner.manager.createQueryBuilder().delete().from(subjects[0].metadata.target).where(deleteMaps).callListeners(false).execute();\n      }\n    }\n  }\n  cloneMongoSubjectEntity(subject) {\n    const target = {};\n    if (subject.entity) {\n      for (const column of subject.metadata.columns) {\n        OrmUtils.mergeDeep(target, column.getEntityValueMap(subject.entity));\n      }\n    }\n    return target;\n  }\n  /**\n   * Soft-removes all given subjects in the database.\n   */\n  async executeSoftRemoveOperations() {\n    await Promise.all(this.softRemoveSubjects.map(async subject => {\n      if (!subject.identifier) throw new SubjectWithoutIdentifierError(subject);\n      let updateResult;\n      // for mongodb we have a bit different updation logic\n      if (InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {\n        const partialEntity = this.cloneMongoSubjectEntity(subject);\n        if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {\n          delete partialEntity[subject.metadata.objectIdColumn.propertyName];\n        }\n        if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {\n          delete partialEntity[subject.metadata.createDateColumn.propertyName];\n        }\n        if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {\n          partialEntity[subject.metadata.updateDateColumn.propertyName] = new Date();\n        }\n        if (subject.metadata.deleteDateColumn && subject.metadata.deleteDateColumn.propertyName) {\n          partialEntity[subject.metadata.deleteDateColumn.propertyName] = new Date();\n        }\n        const manager = this.queryRunner.manager;\n        updateResult = await manager.update(subject.metadata.target, subject.identifier, partialEntity);\n      } else {\n        // here we execute our soft-deletion query\n        // we need to enable entity soft-deletion because we update a subject identifier\n        // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n        // also, we disable listeners because we call them on our own in persistence layer\n        const softDeleteQueryBuilder = this.queryRunner.manager.createQueryBuilder().softDelete().from(subject.metadata.target).updateEntity(this.options && this.options.reload === false ? false : true).callListeners(false);\n        if (subject.entity) {\n          softDeleteQueryBuilder.whereEntity(subject.identifier);\n        } else {\n          // in this case identifier is just conditions object to update by\n          softDeleteQueryBuilder.where(subject.identifier);\n        }\n        updateResult = await softDeleteQueryBuilder.execute();\n      }\n      subject.generatedMap = updateResult.generatedMaps[0];\n      if (subject.generatedMap) {\n        subject.metadata.columns.forEach(column => {\n          const value = column.getEntityValue(subject.generatedMap);\n          if (value !== undefined && value !== null) {\n            const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);\n            column.setEntityValue(subject.generatedMap, preparedValue);\n          }\n        });\n      }\n      // experiments, remove probably, need to implement tree tables children removal\n      // if (subject.updatedRelationMaps.length > 0) {\n      //     await Promise.all(subject.updatedRelationMaps.map(async updatedRelation => {\n      //         if (!updatedRelation.relation.isTreeParent) return;\n      //         if (!updatedRelation.value !== null) return;\n      //\n      //         if (subject.metadata.treeType === \"closure-table\") {\n      //             await new ClosureSubjectExecutor(this.queryRunner).deleteChildrenOf(subject);\n      //         }\n      //     }));\n      // }\n    }));\n  }\n  /**\n   * Recovers all given subjects in the database.\n   */\n  async executeRecoverOperations() {\n    await Promise.all(this.recoverSubjects.map(async subject => {\n      if (!subject.identifier) throw new SubjectWithoutIdentifierError(subject);\n      let updateResult;\n      // for mongodb we have a bit different updation logic\n      if (InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {\n        const partialEntity = this.cloneMongoSubjectEntity(subject);\n        if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {\n          delete partialEntity[subject.metadata.objectIdColumn.propertyName];\n        }\n        if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {\n          delete partialEntity[subject.metadata.createDateColumn.propertyName];\n        }\n        if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {\n          partialEntity[subject.metadata.updateDateColumn.propertyName] = new Date();\n        }\n        if (subject.metadata.deleteDateColumn && subject.metadata.deleteDateColumn.propertyName) {\n          partialEntity[subject.metadata.deleteDateColumn.propertyName] = null;\n        }\n        const manager = this.queryRunner.manager;\n        updateResult = await manager.update(subject.metadata.target, subject.identifier, partialEntity);\n      } else {\n        // here we execute our restory query\n        // we need to enable entity restory because we update a subject identifier\n        // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n        // also, we disable listeners because we call them on our own in persistence layer\n        const softDeleteQueryBuilder = this.queryRunner.manager.createQueryBuilder().restore().from(subject.metadata.target).updateEntity(this.options && this.options.reload === false ? false : true).callListeners(false);\n        if (subject.entity) {\n          softDeleteQueryBuilder.whereEntity(subject.identifier);\n        } else {\n          // in this case identifier is just conditions object to update by\n          softDeleteQueryBuilder.where(subject.identifier);\n        }\n        updateResult = await softDeleteQueryBuilder.execute();\n      }\n      subject.generatedMap = updateResult.generatedMaps[0];\n      if (subject.generatedMap) {\n        subject.metadata.columns.forEach(column => {\n          const value = column.getEntityValue(subject.generatedMap);\n          if (value !== undefined && value !== null) {\n            const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);\n            column.setEntityValue(subject.generatedMap, preparedValue);\n          }\n        });\n      }\n      // experiments, remove probably, need to implement tree tables children removal\n      // if (subject.updatedRelationMaps.length > 0) {\n      //     await Promise.all(subject.updatedRelationMaps.map(async updatedRelation => {\n      //         if (!updatedRelation.relation.isTreeParent) return;\n      //         if (!updatedRelation.value !== null) return;\n      //\n      //         if (subject.metadata.treeType === \"closure-table\") {\n      //             await new ClosureSubjectExecutor(this.queryRunner).deleteChildrenOf(subject);\n      //         }\n      //     }));\n      // }\n    }));\n  }\n  /**\n   * Updates all special columns of the saving entities (create date, update date, version, etc.).\n   * Also updates nullable columns and columns with default values.\n   */\n  updateSpecialColumnsInPersistedEntities() {\n    // update inserted entity properties\n    if (this.insertSubjects.length) this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.insertSubjects);\n    // update updated entity properties\n    if (this.updateSubjects.length) this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.updateSubjects);\n    // update soft-removed entity properties\n    if (this.softRemoveSubjects.length) this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.softRemoveSubjects);\n    // update recovered entity properties\n    if (this.recoverSubjects.length) this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.recoverSubjects);\n    // remove ids from the entities that were removed\n    if (this.removeSubjects.length) {\n      this.removeSubjects.forEach(subject => {\n        if (!subject.entity) return;\n        subject.metadata.primaryColumns.forEach(primaryColumn => {\n          primaryColumn.setEntityValue(subject.entity, undefined);\n        });\n      });\n    }\n    // other post-persist updations\n    this.allSubjects.forEach(subject => {\n      if (!subject.entity) return;\n      subject.metadata.relationIds.forEach(relationId => {\n        relationId.setValue(subject.entity);\n      });\n      // mongo _id remove\n      if (InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {\n        if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.databaseName && subject.metadata.objectIdColumn.databaseName !== subject.metadata.objectIdColumn.propertyName) {\n          delete subject.entity[subject.metadata.objectIdColumn.databaseName];\n        }\n      }\n    });\n  }\n  /**\n   * Updates all special columns of the saving entities (create date, update date, version, etc.).\n   * Also updates nullable columns and columns with default values.\n   */\n  updateSpecialColumnsInInsertedAndUpdatedEntities(subjects) {\n    subjects.forEach(subject => {\n      if (!subject.entity) return;\n      // set values to \"null\" for nullable columns that did not have values\n      subject.metadata.columns.forEach(column => {\n        // if table inheritance is used make sure this column is not child's column\n        if (subject.metadata.childEntityMetadatas.length > 0 && subject.metadata.childEntityMetadatas.map(metadata => metadata.target).indexOf(column.target) !== -1) return;\n        // entities does not have virtual columns\n        if (column.isVirtual) return;\n        // if column is deletedAt\n        if (column.isDeleteDate) return;\n        // update nullable columns\n        if (column.isNullable) {\n          const columnValue = column.getEntityValue(subject.entity);\n          if (columnValue === undefined) column.setEntityValue(subject.entity, null);\n        }\n        // update relational columns\n        if (subject.updatedRelationMaps.length > 0) {\n          subject.updatedRelationMaps.forEach(updatedRelationMap => {\n            updatedRelationMap.relation.joinColumns.forEach(column => {\n              if (column.isVirtual === true) return;\n              column.setEntityValue(subject.entity, ObjectUtils.isObject(updatedRelationMap.value) ? column.referencedColumn.getEntityValue(updatedRelationMap.value) : updatedRelationMap.value);\n            });\n          });\n        }\n      });\n      // merge into entity all generated values returned by a database\n      if (subject.generatedMap) this.queryRunner.manager.merge(subject.metadata.target, subject.entity, subject.generatedMap);\n    });\n  }\n  /**\n   * Groups subjects by metadata names (by tables) to make bulk insertions and deletions possible.\n   * However there are some limitations with bulk insertions of data into tables with generated (increment) columns\n   * in some drivers. Some drivers like mysql and sqlite does not support returning multiple generated columns\n   * after insertion and can only return a single generated column value, that's why its not possible to do bulk insertion,\n   * because it breaks insertion result's generatedMap and leads to problems when this subject is used in other subjects saves.\n   * That's why we only support bulking in junction tables for those drivers.\n   *\n   * Other drivers like postgres and sql server support RETURNING / OUTPUT statement which allows to return generated\n   * id for each inserted row, that's why bulk insertion is not limited to junction tables in there.\n   */\n  groupBulkSubjects(subjects, type) {\n    const group = {};\n    const keys = [];\n    const hasReturningDependColumns = subjects.some(subject => {\n      return subject.metadata.getInsertionReturningColumns().length > 0;\n    });\n    const groupingAllowed = type === \"delete\" || this.queryRunner.connection.driver.isReturningSqlSupported(\"insert\") || hasReturningDependColumns === false;\n    subjects.forEach((subject, index) => {\n      const key = groupingAllowed || subject.metadata.isJunction ? subject.metadata.name : subject.metadata.name + \"_\" + index;\n      if (!group[key]) {\n        group[key] = [subject];\n        keys.push(key);\n      } else {\n        group[key].push(subject);\n      }\n    });\n    return [group, keys];\n  }\n}","map":{"version":3,"names":["SubjectTopoligicalSorter","SubjectChangedColumnsComputer","SubjectWithoutIdentifierError","SubjectRemovedAndUpdatedError","BroadcasterResult","NestedSetSubjectExecutor","ClosureSubjectExecutor","MaterializedPathSubjectExecutor","OrmUtils","ObjectUtils","InstanceChecker","SubjectExecutor","constructor","queryRunner","subjects","options","hasExecutableOperations","insertSubjects","updateSubjects","removeSubjects","softRemoveSubjects","recoverSubjects","allSubjects","validate","recompute","execute","broadcasterResult","undefined","listeners","broadcastBeforeEventsForAll","promises","length","Promise","all","count","forEach","subject","sort","executeInsertOperations","filter","mustBeUpdated","executeUpdateOperations","executeRemoveOperations","mustBeSoftRemoved","executeSoftRemoveOperations","mustBeRecovered","executeRecoverOperations","updateSpecialColumnsInPersistedEntities","broadcastAfterEventsForAll","mustBeRemoved","compute","mustBeInserted","result","broadcaster","broadcastBeforeInsertEvent","metadata","entity","broadcastBeforeUpdateEvent","databaseEntity","diffColumns","diffRelations","broadcastBeforeRemoveEvent","identifier","broadcastBeforeSoftRemoveEvent","broadcastBeforeRecoverEvent","broadcastAfterInsertEvent","broadcastAfterUpdateEvent","broadcastAfterRemoveEvent","broadcastAfterSoftRemoveEvent","broadcastAfterRecoverEvent","groupedInsertSubjects","groupedInsertSubjectKeys","groupBulkSubjects","groupName","bulkInsertMaps","bulkInsertSubjects","singleInsertSubjects","connection","driver","type","createDateColumn","databaseName","Date","updateDateColumn","createValueSetAndPopChangeMap","push","changeMaps","treeType","isMongoEntityManager","manager","insertResult","insert","target","index","identifiers","generatedMap","generatedMaps","insertedValueSet","createQueryBuilder","into","values","updateEntity","reload","callListeners","then","columns","column","value","getEntityValue","preparedValue","prepareHydratedValue","setEntityValue","updateSubject","partialEntity","cloneMongoSubjectEntity","objectIdColumn","propertyName","update","updateMap","updateQueryBuilder","set","whereEntity","where","updateResult","updateGeneratedMap","Object","assign","nestedSetSubjects","remainingSubjects","nestedSetPromise","ok","fail","error","map","groupedRemoveSubjects","groupedRemoveSubjectKeys","deleteMaps","delete","remove","from","mergeDeep","getEntityValueMap","deleteDateColumn","softDeleteQueryBuilder","softDelete","restore","updateSpecialColumnsInInsertedAndUpdatedEntities","primaryColumns","primaryColumn","relationIds","relationId","setValue","childEntityMetadatas","indexOf","isVirtual","isDeleteDate","isNullable","columnValue","updatedRelationMaps","updatedRelationMap","relation","joinColumns","isObject","referencedColumn","merge","group","keys","hasReturningDependColumns","some","getInsertionReturningColumns","groupingAllowed","isReturningSqlSupported","key","isJunction","name"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\persistence\\SubjectExecutor.ts"],"sourcesContent":["import { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { Subject } from \"./Subject\"\nimport { SubjectTopoligicalSorter } from \"./SubjectTopoligicalSorter\"\nimport { SubjectChangedColumnsComputer } from \"./SubjectChangedColumnsComputer\"\nimport { SubjectWithoutIdentifierError } from \"../error/SubjectWithoutIdentifierError\"\nimport { SubjectRemovedAndUpdatedError } from \"../error/SubjectRemovedAndUpdatedError\"\nimport { MongoEntityManager } from \"../entity-manager/MongoEntityManager\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { SaveOptions } from \"../repository/SaveOptions\"\nimport { RemoveOptions } from \"../repository/RemoveOptions\"\nimport { BroadcasterResult } from \"../subscriber/BroadcasterResult\"\nimport { NestedSetSubjectExecutor } from \"./tree/NestedSetSubjectExecutor\"\nimport { ClosureSubjectExecutor } from \"./tree/ClosureSubjectExecutor\"\nimport { MaterializedPathSubjectExecutor } from \"./tree/MaterializedPathSubjectExecutor\"\nimport { OrmUtils } from \"../util/OrmUtils\"\nimport { UpdateResult } from \"../query-builder/result/UpdateResult\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\n\n/**\n * Executes all database operations (inserts, updated, deletes) that must be executed\n * with given persistence subjects.\n */\nexport class SubjectExecutor {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Indicates if executor has any operations to execute (e.g. has insert / update / delete operations to be executed).\n     */\n    hasExecutableOperations: boolean = false\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * QueryRunner used to execute all queries with a given subjects.\n     */\n    protected queryRunner: QueryRunner\n\n    /**\n     * Persistence options.\n     */\n    protected options?: SaveOptions & RemoveOptions\n\n    /**\n     * All subjects that needs to be operated.\n     */\n    protected allSubjects: Subject[]\n\n    /**\n     * Subjects that must be inserted.\n     */\n    protected insertSubjects: Subject[] = []\n\n    /**\n     * Subjects that must be updated.\n     */\n    protected updateSubjects: Subject[] = []\n\n    /**\n     * Subjects that must be removed.\n     */\n    protected removeSubjects: Subject[] = []\n\n    /**\n     * Subjects that must be soft-removed.\n     */\n    protected softRemoveSubjects: Subject[] = []\n\n    /**\n     * Subjects that must be recovered.\n     */\n    protected recoverSubjects: Subject[] = []\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        queryRunner: QueryRunner,\n        subjects: Subject[],\n        options?: SaveOptions & RemoveOptions,\n    ) {\n        this.queryRunner = queryRunner\n        this.allSubjects = subjects\n        this.options = options\n        this.validate()\n        this.recompute()\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes all operations over given array of subjects.\n     * Executes queries using given query runner.\n     */\n    async execute(): Promise<void> {\n        // console.time(\"SubjectExecutor.execute\");\n\n        // broadcast \"before\" events before we start insert / update / remove operations\n        let broadcasterResult: BroadcasterResult | undefined = undefined\n        if (!this.options || this.options.listeners !== false) {\n            // console.time(\".broadcastBeforeEventsForAll\");\n            broadcasterResult = this.broadcastBeforeEventsForAll()\n            if (broadcasterResult.promises.length > 0)\n                await Promise.all(broadcasterResult.promises)\n            // console.timeEnd(\".broadcastBeforeEventsForAll\");\n        }\n\n        // since event listeners and subscribers can call save methods and/or trigger entity changes we need to recompute operational subjects\n        // recompute only in the case if any listener or subscriber was really executed\n        if (broadcasterResult && broadcasterResult.count > 0) {\n            // console.time(\".recompute\");\n            this.insertSubjects.forEach((subject) => subject.recompute())\n            this.updateSubjects.forEach((subject) => subject.recompute())\n            this.removeSubjects.forEach((subject) => subject.recompute())\n            this.softRemoveSubjects.forEach((subject) => subject.recompute())\n            this.recoverSubjects.forEach((subject) => subject.recompute())\n            this.recompute()\n            // console.timeEnd(\".recompute\");\n        }\n\n        // make sure our insert subjects are sorted (using topological sorting) to make cascade inserts work properly\n\n        // console.timeEnd(\"prepare\");\n\n        // execute all insert operations\n        // console.time(\".insertion\");\n        this.insertSubjects = new SubjectTopoligicalSorter(\n            this.insertSubjects,\n        ).sort(\"insert\")\n        await this.executeInsertOperations()\n        // console.timeEnd(\".insertion\");\n\n        // recompute update operations since insertion can create updation operations for the\n        // properties it wasn't able to handle on its own (referenced columns)\n        this.updateSubjects = this.allSubjects.filter(\n            (subject) => subject.mustBeUpdated,\n        )\n\n        // execute update operations\n        // console.time(\".updation\");\n        await this.executeUpdateOperations()\n        // console.timeEnd(\".updation\");\n\n        // make sure our remove subjects are sorted (using topological sorting) when multiple entities are passed for the removal\n        // console.time(\".removal\");\n        this.removeSubjects = new SubjectTopoligicalSorter(\n            this.removeSubjects,\n        ).sort(\"delete\")\n        await this.executeRemoveOperations()\n        // console.timeEnd(\".removal\");\n\n        // recompute soft-remove operations\n        this.softRemoveSubjects = this.allSubjects.filter(\n            (subject) => subject.mustBeSoftRemoved,\n        )\n\n        // execute soft-remove operations\n        await this.executeSoftRemoveOperations()\n\n        // recompute recover operations\n        this.recoverSubjects = this.allSubjects.filter(\n            (subject) => subject.mustBeRecovered,\n        )\n\n        // execute recover operations\n        await this.executeRecoverOperations()\n\n        // update all special columns in persisted entities, like inserted id or remove ids from the removed entities\n        // console.time(\".updateSpecialColumnsInPersistedEntities\");\n        this.updateSpecialColumnsInPersistedEntities()\n        // console.timeEnd(\".updateSpecialColumnsInPersistedEntities\");\n\n        // finally broadcast \"after\" events after we finish insert / update / remove operations\n        if (!this.options || this.options.listeners !== false) {\n            // console.time(\".broadcastAfterEventsForAll\");\n            broadcasterResult = this.broadcastAfterEventsForAll()\n            if (broadcasterResult.promises.length > 0)\n                await Promise.all(broadcasterResult.promises)\n            // console.timeEnd(\".broadcastAfterEventsForAll\");\n        }\n        // console.timeEnd(\"SubjectExecutor.execute\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Validates all given subjects.\n     */\n    protected validate() {\n        this.allSubjects.forEach((subject) => {\n            if (subject.mustBeUpdated && subject.mustBeRemoved)\n                throw new SubjectRemovedAndUpdatedError(subject)\n        })\n    }\n\n    /**\n     * Performs entity re-computations - finds changed columns, re-builds insert/update/remove subjects.\n     */\n    protected recompute(): void {\n        new SubjectChangedColumnsComputer().compute(this.allSubjects)\n        this.insertSubjects = this.allSubjects.filter(\n            (subject) => subject.mustBeInserted,\n        )\n        this.updateSubjects = this.allSubjects.filter(\n            (subject) => subject.mustBeUpdated,\n        )\n        this.removeSubjects = this.allSubjects.filter(\n            (subject) => subject.mustBeRemoved,\n        )\n        this.softRemoveSubjects = this.allSubjects.filter(\n            (subject) => subject.mustBeSoftRemoved,\n        )\n        this.recoverSubjects = this.allSubjects.filter(\n            (subject) => subject.mustBeRecovered,\n        )\n        this.hasExecutableOperations =\n            this.insertSubjects.length > 0 ||\n            this.updateSubjects.length > 0 ||\n            this.removeSubjects.length > 0 ||\n            this.softRemoveSubjects.length > 0 ||\n            this.recoverSubjects.length > 0\n    }\n\n    /**\n     * Broadcasts \"BEFORE_INSERT\", \"BEFORE_UPDATE\", \"BEFORE_REMOVE\", \"BEFORE_SOFT_REMOVE\", \"BEFORE_RECOVER\" events for all given subjects.\n     */\n    protected broadcastBeforeEventsForAll(): BroadcasterResult {\n        const result = new BroadcasterResult()\n        if (this.insertSubjects.length)\n            this.insertSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastBeforeInsertEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                ),\n            )\n        if (this.updateSubjects.length)\n            this.updateSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastBeforeUpdateEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                    subject.databaseEntity,\n                    subject.diffColumns,\n                    subject.diffRelations,\n                ),\n            )\n        if (this.removeSubjects.length)\n            this.removeSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastBeforeRemoveEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                    subject.databaseEntity,\n                    subject.identifier,\n                ),\n            )\n        if (this.softRemoveSubjects.length)\n            this.softRemoveSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastBeforeSoftRemoveEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                    subject.databaseEntity,\n                    subject.identifier,\n                ),\n            )\n        if (this.recoverSubjects.length)\n            this.recoverSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastBeforeRecoverEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                    subject.databaseEntity,\n                    subject.identifier,\n                ),\n            )\n        return result\n    }\n\n    /**\n     * Broadcasts \"AFTER_INSERT\", \"AFTER_UPDATE\", \"AFTER_REMOVE\", \"AFTER_SOFT_REMOVE\", \"AFTER_RECOVER\" events for all given subjects.\n     * Returns void if there wasn't any listener or subscriber executed.\n     * Note: this method has a performance-optimized code organization.\n     */\n    protected broadcastAfterEventsForAll(): BroadcasterResult {\n        const result = new BroadcasterResult()\n        if (this.insertSubjects.length)\n            this.insertSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastAfterInsertEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                    subject.identifier,\n                ),\n            )\n        if (this.updateSubjects.length)\n            this.updateSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastAfterUpdateEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                    subject.databaseEntity,\n                    subject.diffColumns,\n                    subject.diffRelations,\n                ),\n            )\n        if (this.removeSubjects.length)\n            this.removeSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastAfterRemoveEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                    subject.databaseEntity,\n                    subject.identifier,\n                ),\n            )\n        if (this.softRemoveSubjects.length)\n            this.softRemoveSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastAfterSoftRemoveEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                    subject.databaseEntity,\n                    subject.identifier,\n                ),\n            )\n        if (this.recoverSubjects.length)\n            this.recoverSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastAfterRecoverEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                    subject.databaseEntity,\n                    subject.identifier,\n                ),\n            )\n        return result\n    }\n\n    /**\n     * Executes insert operations.\n     */\n    protected async executeInsertOperations(): Promise<void> {\n        // group insertion subjects to make bulk insertions\n        const [groupedInsertSubjects, groupedInsertSubjectKeys] =\n            this.groupBulkSubjects(this.insertSubjects, \"insert\")\n\n        // then we run insertion in the sequential order which is important since we have an ordered subjects\n        for (const groupName of groupedInsertSubjectKeys) {\n            const subjects = groupedInsertSubjects[groupName]\n\n            // we must separately insert entities which does not have any values to insert\n            // because its not possible to insert multiple entities with only default values in bulk\n            const bulkInsertMaps: ObjectLiteral[] = []\n            const bulkInsertSubjects: Subject[] = []\n            const singleInsertSubjects: Subject[] = []\n            if (this.queryRunner.connection.driver.options.type === \"mongodb\") {\n                subjects.forEach((subject) => {\n                    if (subject.metadata.createDateColumn && subject.entity) {\n                        subject.entity[\n                            subject.metadata.createDateColumn.databaseName\n                        ] = new Date()\n                    }\n\n                    if (subject.metadata.updateDateColumn && subject.entity) {\n                        subject.entity[\n                            subject.metadata.updateDateColumn.databaseName\n                        ] = new Date()\n                    }\n\n                    subject.createValueSetAndPopChangeMap()\n\n                    bulkInsertSubjects.push(subject)\n                    bulkInsertMaps.push(subject.entity!)\n                })\n            } else if (\n                this.queryRunner.connection.driver.options.type === \"oracle\"\n            ) {\n                subjects.forEach((subject) => {\n                    singleInsertSubjects.push(subject)\n                })\n            } else {\n                subjects.forEach((subject) => {\n                    // we do not insert in bulk in following cases:\n                    // - when there is no values in insert (only defaults are inserted), since we cannot use DEFAULT VALUES expression for multiple inserted rows\n                    // - when entity is a tree table, since tree tables require extra operation per each inserted row\n                    // - when oracle is used, since oracle's bulk insertion is very bad\n                    if (\n                        subject.changeMaps.length === 0 ||\n                        subject.metadata.treeType ||\n                        this.queryRunner.connection.driver.options.type ===\n                            \"oracle\" ||\n                        this.queryRunner.connection.driver.options.type ===\n                            \"sap\"\n                    ) {\n                        singleInsertSubjects.push(subject)\n                    } else {\n                        bulkInsertSubjects.push(subject)\n                        bulkInsertMaps.push(\n                            subject.createValueSetAndPopChangeMap(),\n                        )\n                    }\n                })\n            }\n\n            // for mongodb we have a bit different insertion logic\n            if (\n                InstanceChecker.isMongoEntityManager(this.queryRunner.manager)\n            ) {\n                const insertResult = await this.queryRunner.manager.insert(\n                    subjects[0].metadata.target,\n                    bulkInsertMaps,\n                )\n                subjects.forEach((subject, index) => {\n                    subject.identifier = insertResult.identifiers[index]\n                    subject.generatedMap = insertResult.generatedMaps[index]\n                    subject.insertedValueSet = bulkInsertMaps[index]\n                })\n            } else {\n                // here we execute our insertion query\n                // we need to enable entity updation because we DO need to have updated insertedMap\n                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                // also, we disable listeners because we call them on our own in persistence layer\n                if (bulkInsertMaps.length > 0) {\n                    const insertResult = await this.queryRunner.manager\n                        .createQueryBuilder()\n                        .insert()\n                        .into(subjects[0].metadata.target)\n                        .values(bulkInsertMaps)\n                        .updateEntity(\n                            this.options && this.options.reload === false\n                                ? false\n                                : true,\n                        )\n                        .callListeners(false)\n                        .execute()\n\n                    bulkInsertSubjects.forEach((subject, index) => {\n                        subject.identifier = insertResult.identifiers[index]\n                        subject.generatedMap = insertResult.generatedMaps[index]\n                        subject.insertedValueSet = bulkInsertMaps[index]\n                    })\n                }\n\n                // insert subjects which must be inserted in separate requests (all default values)\n                if (singleInsertSubjects.length > 0) {\n                    for (const subject of singleInsertSubjects) {\n                        subject.insertedValueSet =\n                            subject.createValueSetAndPopChangeMap() // important to have because query builder sets inserted values into it\n\n                        // for nested set we execute additional queries\n                        if (subject.metadata.treeType === \"nested-set\")\n                            await new NestedSetSubjectExecutor(\n                                this.queryRunner,\n                            ).insert(subject)\n\n                        await this.queryRunner.manager\n                            .createQueryBuilder()\n                            .insert()\n                            .into(subject.metadata.target)\n                            .values(subject.insertedValueSet)\n                            .updateEntity(\n                                this.options && this.options.reload === false\n                                    ? false\n                                    : true,\n                            )\n                            .callListeners(false)\n                            .execute()\n                            .then((insertResult) => {\n                                subject.identifier = insertResult.identifiers[0]\n                                subject.generatedMap =\n                                    insertResult.generatedMaps[0]\n                            })\n\n                        // for tree tables we execute additional queries\n                        if (subject.metadata.treeType === \"closure-table\") {\n                            await new ClosureSubjectExecutor(\n                                this.queryRunner,\n                            ).insert(subject)\n                        } else if (\n                            subject.metadata.treeType === \"materialized-path\"\n                        ) {\n                            await new MaterializedPathSubjectExecutor(\n                                this.queryRunner,\n                            ).insert(subject)\n                        }\n                    }\n                }\n            }\n\n            subjects.forEach((subject) => {\n                if (subject.generatedMap) {\n                    subject.metadata.columns.forEach((column) => {\n                        const value = column.getEntityValue(\n                            subject.generatedMap!,\n                        )\n                        if (value !== undefined && value !== null) {\n                            const preparedValue =\n                                this.queryRunner.connection.driver.prepareHydratedValue(\n                                    value,\n                                    column,\n                                )\n                            column.setEntityValue(\n                                subject.generatedMap!,\n                                preparedValue,\n                            )\n                        }\n                    })\n                }\n            })\n        }\n    }\n\n    /**\n     * Updates all given subjects in the database.\n     */\n    protected async executeUpdateOperations(): Promise<void> {\n        const updateSubject = async (subject: Subject) => {\n            if (!subject.identifier)\n                throw new SubjectWithoutIdentifierError(subject)\n\n            // for mongodb we have a bit different updation logic\n            if (\n                InstanceChecker.isMongoEntityManager(this.queryRunner.manager)\n            ) {\n                const partialEntity = this.cloneMongoSubjectEntity(subject)\n                if (\n                    subject.metadata.objectIdColumn &&\n                    subject.metadata.objectIdColumn.propertyName\n                ) {\n                    delete partialEntity[\n                        subject.metadata.objectIdColumn.propertyName\n                    ]\n                }\n\n                if (\n                    subject.metadata.createDateColumn &&\n                    subject.metadata.createDateColumn.propertyName\n                ) {\n                    delete partialEntity[\n                        subject.metadata.createDateColumn.propertyName\n                    ]\n                }\n\n                if (\n                    subject.metadata.updateDateColumn &&\n                    subject.metadata.updateDateColumn.propertyName\n                ) {\n                    partialEntity[\n                        subject.metadata.updateDateColumn.propertyName\n                    ] = new Date()\n                }\n\n                const manager = this.queryRunner.manager as MongoEntityManager\n\n                await manager.update(\n                    subject.metadata.target,\n                    subject.identifier,\n                    partialEntity,\n                )\n            } else {\n                const updateMap: ObjectLiteral =\n                    subject.createValueSetAndPopChangeMap()\n\n                // for tree tables we execute additional queries\n                switch (subject.metadata.treeType) {\n                    case \"nested-set\":\n                        await new NestedSetSubjectExecutor(\n                            this.queryRunner,\n                        ).update(subject)\n                        break\n\n                    case \"closure-table\":\n                        await new ClosureSubjectExecutor(\n                            this.queryRunner,\n                        ).update(subject)\n                        break\n\n                    case \"materialized-path\":\n                        await new MaterializedPathSubjectExecutor(\n                            this.queryRunner,\n                        ).update(subject)\n                        break\n                }\n\n                // here we execute our updation query\n                // we need to enable entity updation because we update a subject identifier\n                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                // also, we disable listeners because we call them on our own in persistence layer\n                const updateQueryBuilder = this.queryRunner.manager\n                    .createQueryBuilder()\n                    .update(subject.metadata.target)\n                    .set(updateMap)\n                    .updateEntity(\n                        this.options && this.options.reload === false\n                            ? false\n                            : true,\n                    )\n                    .callListeners(false)\n\n                if (subject.entity) {\n                    updateQueryBuilder.whereEntity(subject.identifier)\n                } else {\n                    // in this case identifier is just conditions object to update by\n                    updateQueryBuilder.where(subject.identifier)\n                }\n\n                const updateResult = await updateQueryBuilder.execute()\n                let updateGeneratedMap = updateResult.generatedMaps[0]\n                if (updateGeneratedMap) {\n                    subject.metadata.columns.forEach((column) => {\n                        const value = column.getEntityValue(updateGeneratedMap!)\n                        if (value !== undefined && value !== null) {\n                            const preparedValue =\n                                this.queryRunner.connection.driver.prepareHydratedValue(\n                                    value,\n                                    column,\n                                )\n                            column.setEntityValue(\n                                updateGeneratedMap!,\n                                preparedValue,\n                            )\n                        }\n                    })\n                    if (!subject.generatedMap) {\n                        subject.generatedMap = {}\n                    }\n                    Object.assign(subject.generatedMap, updateGeneratedMap)\n                }\n            }\n        }\n\n        // Nested sets need to be updated one by one\n        // Split array in two, one with nested set subjects and the other with the remaining subjects\n        const nestedSetSubjects: Subject[] = []\n        const remainingSubjects: Subject[] = []\n\n        for (const subject of this.updateSubjects) {\n            if (subject.metadata.treeType === \"nested-set\") {\n                nestedSetSubjects.push(subject)\n            } else {\n                remainingSubjects.push(subject)\n            }\n        }\n\n        // Run nested set updates one by one\n        const nestedSetPromise = new Promise<void>(async (ok, fail) => {\n            for (const subject of nestedSetSubjects) {\n                try {\n                    await updateSubject(subject)\n                } catch (error) {\n                    fail(error)\n                }\n            }\n            ok()\n        })\n\n        // Run all remaining subjects in parallel\n        await Promise.all([\n            ...remainingSubjects.map(updateSubject),\n            nestedSetPromise,\n        ])\n    }\n\n    /**\n     * Removes all given subjects from the database.\n     *\n     * todo: we need to apply topological sort here as well\n     */\n    protected async executeRemoveOperations(): Promise<void> {\n        // group insertion subjects to make bulk insertions\n        const [groupedRemoveSubjects, groupedRemoveSubjectKeys] =\n            this.groupBulkSubjects(this.removeSubjects, \"delete\")\n\n        for (const groupName of groupedRemoveSubjectKeys) {\n            const subjects = groupedRemoveSubjects[groupName]\n            const deleteMaps = subjects.map((subject) => {\n                if (!subject.identifier)\n                    throw new SubjectWithoutIdentifierError(subject)\n\n                return subject.identifier\n            })\n\n            // for mongodb we have a bit different updation logic\n            if (\n                InstanceChecker.isMongoEntityManager(this.queryRunner.manager)\n            ) {\n                const manager = this.queryRunner.manager as MongoEntityManager\n                await manager.delete(subjects[0].metadata.target, deleteMaps)\n            } else {\n                // for tree tables we execute additional queries\n                switch (subjects[0].metadata.treeType) {\n                    case \"nested-set\":\n                        await new NestedSetSubjectExecutor(\n                            this.queryRunner,\n                        ).remove(subjects)\n                        break\n\n                    case \"closure-table\":\n                        await new ClosureSubjectExecutor(\n                            this.queryRunner,\n                        ).remove(subjects)\n                        break\n                }\n\n                // here we execute our deletion query\n                // we don't need to specify entities and set update entity to true since the only thing query builder\n                // will do for use is a primary keys deletion which is handled by us later once persistence is finished\n                // also, we disable listeners because we call them on our own in persistence layer\n                await this.queryRunner.manager\n                    .createQueryBuilder()\n                    .delete()\n                    .from(subjects[0].metadata.target)\n                    .where(deleteMaps)\n                    .callListeners(false)\n                    .execute()\n            }\n        }\n    }\n\n    private cloneMongoSubjectEntity(subject: Subject): ObjectLiteral {\n        const target: ObjectLiteral = {}\n\n        if (subject.entity) {\n            for (const column of subject.metadata.columns) {\n                OrmUtils.mergeDeep(\n                    target,\n                    column.getEntityValueMap(subject.entity),\n                )\n            }\n        }\n\n        return target\n    }\n\n    /**\n     * Soft-removes all given subjects in the database.\n     */\n    protected async executeSoftRemoveOperations(): Promise<void> {\n        await Promise.all(\n            this.softRemoveSubjects.map(async (subject) => {\n                if (!subject.identifier)\n                    throw new SubjectWithoutIdentifierError(subject)\n\n                let updateResult: UpdateResult\n\n                // for mongodb we have a bit different updation logic\n                if (\n                    InstanceChecker.isMongoEntityManager(\n                        this.queryRunner.manager,\n                    )\n                ) {\n                    const partialEntity = this.cloneMongoSubjectEntity(subject)\n                    if (\n                        subject.metadata.objectIdColumn &&\n                        subject.metadata.objectIdColumn.propertyName\n                    ) {\n                        delete partialEntity[\n                            subject.metadata.objectIdColumn.propertyName\n                        ]\n                    }\n\n                    if (\n                        subject.metadata.createDateColumn &&\n                        subject.metadata.createDateColumn.propertyName\n                    ) {\n                        delete partialEntity[\n                            subject.metadata.createDateColumn.propertyName\n                        ]\n                    }\n\n                    if (\n                        subject.metadata.updateDateColumn &&\n                        subject.metadata.updateDateColumn.propertyName\n                    ) {\n                        partialEntity[\n                            subject.metadata.updateDateColumn.propertyName\n                        ] = new Date()\n                    }\n\n                    if (\n                        subject.metadata.deleteDateColumn &&\n                        subject.metadata.deleteDateColumn.propertyName\n                    ) {\n                        partialEntity[\n                            subject.metadata.deleteDateColumn.propertyName\n                        ] = new Date()\n                    }\n\n                    const manager = this.queryRunner\n                        .manager as MongoEntityManager\n\n                    updateResult = await manager.update(\n                        subject.metadata.target,\n                        subject.identifier,\n                        partialEntity,\n                    )\n                } else {\n                    // here we execute our soft-deletion query\n                    // we need to enable entity soft-deletion because we update a subject identifier\n                    // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                    // also, we disable listeners because we call them on our own in persistence layer\n                    const softDeleteQueryBuilder = this.queryRunner.manager\n                        .createQueryBuilder()\n                        .softDelete()\n                        .from(subject.metadata.target)\n                        .updateEntity(\n                            this.options && this.options.reload === false\n                                ? false\n                                : true,\n                        )\n                        .callListeners(false)\n\n                    if (subject.entity) {\n                        softDeleteQueryBuilder.whereEntity(subject.identifier)\n                    } else {\n                        // in this case identifier is just conditions object to update by\n                        softDeleteQueryBuilder.where(subject.identifier)\n                    }\n\n                    updateResult = await softDeleteQueryBuilder.execute()\n                }\n\n                subject.generatedMap = updateResult.generatedMaps[0]\n                if (subject.generatedMap) {\n                    subject.metadata.columns.forEach((column) => {\n                        const value = column.getEntityValue(\n                            subject.generatedMap!,\n                        )\n                        if (value !== undefined && value !== null) {\n                            const preparedValue =\n                                this.queryRunner.connection.driver.prepareHydratedValue(\n                                    value,\n                                    column,\n                                )\n                            column.setEntityValue(\n                                subject.generatedMap!,\n                                preparedValue,\n                            )\n                        }\n                    })\n                }\n\n                // experiments, remove probably, need to implement tree tables children removal\n                // if (subject.updatedRelationMaps.length > 0) {\n                //     await Promise.all(subject.updatedRelationMaps.map(async updatedRelation => {\n                //         if (!updatedRelation.relation.isTreeParent) return;\n                //         if (!updatedRelation.value !== null) return;\n                //\n                //         if (subject.metadata.treeType === \"closure-table\") {\n                //             await new ClosureSubjectExecutor(this.queryRunner).deleteChildrenOf(subject);\n                //         }\n                //     }));\n                // }\n            }),\n        )\n    }\n\n    /**\n     * Recovers all given subjects in the database.\n     */\n    protected async executeRecoverOperations(): Promise<void> {\n        await Promise.all(\n            this.recoverSubjects.map(async (subject) => {\n                if (!subject.identifier)\n                    throw new SubjectWithoutIdentifierError(subject)\n\n                let updateResult: UpdateResult\n\n                // for mongodb we have a bit different updation logic\n                if (\n                    InstanceChecker.isMongoEntityManager(\n                        this.queryRunner.manager,\n                    )\n                ) {\n                    const partialEntity = this.cloneMongoSubjectEntity(subject)\n                    if (\n                        subject.metadata.objectIdColumn &&\n                        subject.metadata.objectIdColumn.propertyName\n                    ) {\n                        delete partialEntity[\n                            subject.metadata.objectIdColumn.propertyName\n                        ]\n                    }\n\n                    if (\n                        subject.metadata.createDateColumn &&\n                        subject.metadata.createDateColumn.propertyName\n                    ) {\n                        delete partialEntity[\n                            subject.metadata.createDateColumn.propertyName\n                        ]\n                    }\n\n                    if (\n                        subject.metadata.updateDateColumn &&\n                        subject.metadata.updateDateColumn.propertyName\n                    ) {\n                        partialEntity[\n                            subject.metadata.updateDateColumn.propertyName\n                        ] = new Date()\n                    }\n\n                    if (\n                        subject.metadata.deleteDateColumn &&\n                        subject.metadata.deleteDateColumn.propertyName\n                    ) {\n                        partialEntity[\n                            subject.metadata.deleteDateColumn.propertyName\n                        ] = null\n                    }\n\n                    const manager = this.queryRunner\n                        .manager as MongoEntityManager\n\n                    updateResult = await manager.update(\n                        subject.metadata.target,\n                        subject.identifier,\n                        partialEntity,\n                    )\n                } else {\n                    // here we execute our restory query\n                    // we need to enable entity restory because we update a subject identifier\n                    // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                    // also, we disable listeners because we call them on our own in persistence layer\n                    const softDeleteQueryBuilder = this.queryRunner.manager\n                        .createQueryBuilder()\n                        .restore()\n                        .from(subject.metadata.target)\n                        .updateEntity(\n                            this.options && this.options.reload === false\n                                ? false\n                                : true,\n                        )\n                        .callListeners(false)\n\n                    if (subject.entity) {\n                        softDeleteQueryBuilder.whereEntity(subject.identifier)\n                    } else {\n                        // in this case identifier is just conditions object to update by\n                        softDeleteQueryBuilder.where(subject.identifier)\n                    }\n\n                    updateResult = await softDeleteQueryBuilder.execute()\n                }\n\n                subject.generatedMap = updateResult.generatedMaps[0]\n                if (subject.generatedMap) {\n                    subject.metadata.columns.forEach((column) => {\n                        const value = column.getEntityValue(\n                            subject.generatedMap!,\n                        )\n                        if (value !== undefined && value !== null) {\n                            const preparedValue =\n                                this.queryRunner.connection.driver.prepareHydratedValue(\n                                    value,\n                                    column,\n                                )\n                            column.setEntityValue(\n                                subject.generatedMap!,\n                                preparedValue,\n                            )\n                        }\n                    })\n                }\n\n                // experiments, remove probably, need to implement tree tables children removal\n                // if (subject.updatedRelationMaps.length > 0) {\n                //     await Promise.all(subject.updatedRelationMaps.map(async updatedRelation => {\n                //         if (!updatedRelation.relation.isTreeParent) return;\n                //         if (!updatedRelation.value !== null) return;\n                //\n                //         if (subject.metadata.treeType === \"closure-table\") {\n                //             await new ClosureSubjectExecutor(this.queryRunner).deleteChildrenOf(subject);\n                //         }\n                //     }));\n                // }\n            }),\n        )\n    }\n\n    /**\n     * Updates all special columns of the saving entities (create date, update date, version, etc.).\n     * Also updates nullable columns and columns with default values.\n     */\n    protected updateSpecialColumnsInPersistedEntities(): void {\n        // update inserted entity properties\n        if (this.insertSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(\n                this.insertSubjects,\n            )\n\n        // update updated entity properties\n        if (this.updateSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(\n                this.updateSubjects,\n            )\n\n        // update soft-removed entity properties\n        if (this.softRemoveSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(\n                this.softRemoveSubjects,\n            )\n\n        // update recovered entity properties\n        if (this.recoverSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(\n                this.recoverSubjects,\n            )\n\n        // remove ids from the entities that were removed\n        if (this.removeSubjects.length) {\n            this.removeSubjects.forEach((subject) => {\n                if (!subject.entity) return\n\n                subject.metadata.primaryColumns.forEach((primaryColumn) => {\n                    primaryColumn.setEntityValue(subject.entity!, undefined)\n                })\n            })\n        }\n\n        // other post-persist updations\n        this.allSubjects.forEach((subject) => {\n            if (!subject.entity) return\n\n            subject.metadata.relationIds.forEach((relationId) => {\n                relationId.setValue(subject.entity!)\n            })\n\n            // mongo _id remove\n            if (\n                InstanceChecker.isMongoEntityManager(this.queryRunner.manager)\n            ) {\n                if (\n                    subject.metadata.objectIdColumn &&\n                    subject.metadata.objectIdColumn.databaseName &&\n                    subject.metadata.objectIdColumn.databaseName !==\n                        subject.metadata.objectIdColumn.propertyName\n                ) {\n                    delete subject.entity[\n                        subject.metadata.objectIdColumn.databaseName\n                    ]\n                }\n            }\n        })\n    }\n\n    /**\n     * Updates all special columns of the saving entities (create date, update date, version, etc.).\n     * Also updates nullable columns and columns with default values.\n     */\n    protected updateSpecialColumnsInInsertedAndUpdatedEntities(\n        subjects: Subject[],\n    ): void {\n        subjects.forEach((subject) => {\n            if (!subject.entity) return\n\n            // set values to \"null\" for nullable columns that did not have values\n            subject.metadata.columns.forEach((column) => {\n                // if table inheritance is used make sure this column is not child's column\n                if (\n                    subject.metadata.childEntityMetadatas.length > 0 &&\n                    subject.metadata.childEntityMetadatas\n                        .map((metadata) => metadata.target)\n                        .indexOf(column.target) !== -1\n                )\n                    return\n\n                // entities does not have virtual columns\n                if (column.isVirtual) return\n\n                // if column is deletedAt\n                if (column.isDeleteDate) return\n\n                // update nullable columns\n                if (column.isNullable) {\n                    const columnValue = column.getEntityValue(subject.entity!)\n                    if (columnValue === undefined)\n                        column.setEntityValue(subject.entity!, null)\n                }\n\n                // update relational columns\n                if (subject.updatedRelationMaps.length > 0) {\n                    subject.updatedRelationMaps.forEach(\n                        (updatedRelationMap) => {\n                            updatedRelationMap.relation.joinColumns.forEach(\n                                (column) => {\n                                    if (column.isVirtual === true) return\n\n                                    column.setEntityValue(\n                                        subject.entity!,\n                                        ObjectUtils.isObject(\n                                            updatedRelationMap.value,\n                                        )\n                                            ? column.referencedColumn!.getEntityValue(\n                                                  updatedRelationMap.value,\n                                              )\n                                            : updatedRelationMap.value,\n                                    )\n                                },\n                            )\n                        },\n                    )\n                }\n            })\n\n            // merge into entity all generated values returned by a database\n            if (subject.generatedMap)\n                this.queryRunner.manager.merge(\n                    subject.metadata.target as any,\n                    subject.entity,\n                    subject.generatedMap,\n                )\n        })\n    }\n\n    /**\n     * Groups subjects by metadata names (by tables) to make bulk insertions and deletions possible.\n     * However there are some limitations with bulk insertions of data into tables with generated (increment) columns\n     * in some drivers. Some drivers like mysql and sqlite does not support returning multiple generated columns\n     * after insertion and can only return a single generated column value, that's why its not possible to do bulk insertion,\n     * because it breaks insertion result's generatedMap and leads to problems when this subject is used in other subjects saves.\n     * That's why we only support bulking in junction tables for those drivers.\n     *\n     * Other drivers like postgres and sql server support RETURNING / OUTPUT statement which allows to return generated\n     * id for each inserted row, that's why bulk insertion is not limited to junction tables in there.\n     */\n    protected groupBulkSubjects(\n        subjects: Subject[],\n        type: \"insert\" | \"delete\",\n    ): [{ [key: string]: Subject[] }, string[]] {\n        const group: { [key: string]: Subject[] } = {}\n        const keys: string[] = []\n        const hasReturningDependColumns = subjects.some((subject) => {\n            return subject.metadata.getInsertionReturningColumns().length > 0\n        })\n        const groupingAllowed =\n            type === \"delete\" ||\n            this.queryRunner.connection.driver.isReturningSqlSupported(\n                \"insert\",\n            ) ||\n            hasReturningDependColumns === false\n\n        subjects.forEach((subject, index) => {\n            const key =\n                groupingAllowed || subject.metadata.isJunction\n                    ? subject.metadata.name\n                    : subject.metadata.name + \"_\" + index\n            if (!group[key]) {\n                group[key] = [subject]\n                keys.push(key)\n            } else {\n                group[key].push(subject)\n            }\n        })\n\n        return [group, keys]\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}