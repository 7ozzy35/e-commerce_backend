{"ast":null,"code":"import { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Loads relation ids for the given entities.\n */\nexport class RelationIdLoader {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection, queryRunner) {\n    this.connection = connection;\n    this.queryRunner = queryRunner;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Loads relation ids of the given entity or entities.\n   */\n  load(relation, entityOrEntities, relatedEntityOrRelatedEntities) {\n    const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];\n    const relatedEntities = Array.isArray(relatedEntityOrRelatedEntities) ? relatedEntityOrRelatedEntities : relatedEntityOrRelatedEntities ? [relatedEntityOrRelatedEntities] : undefined;\n    // load relation ids depend of relation type\n    if (relation.isManyToMany) {\n      return this.loadForManyToMany(relation, entities, relatedEntities);\n    } else if (relation.isManyToOne || relation.isOneToOneOwner) {\n      return this.loadForManyToOneAndOneToOneOwner(relation, entities, relatedEntities);\n    } else {\n      // if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n      return this.loadForOneToManyAndOneToOneNotOwner(relation, entities, relatedEntities);\n    }\n  }\n  /**\n   * Loads relation ids of the given entities and groups them into the object with parent and children.\n   *\n   * todo: extract this method?\n   */\n  async loadManyToManyRelationIdsAndGroup(relation, entitiesOrEntities, relatedEntityOrEntities, queryBuilder) {\n    // console.log(\"relation:\", relation.propertyName);\n    // console.log(\"entitiesOrEntities\", entitiesOrEntities);\n    const isMany = relation.isManyToMany || relation.isOneToMany;\n    const entities = Array.isArray(entitiesOrEntities) ? entitiesOrEntities : [entitiesOrEntities];\n    if (!relatedEntityOrEntities) {\n      relatedEntityOrEntities = await this.connection.relationLoader.load(relation, entitiesOrEntities, this.queryRunner, queryBuilder);\n      if (!relatedEntityOrEntities.length) return entities.map(entity => ({\n        entity: entity,\n        related: isMany ? [] : undefined\n      }));\n    }\n    // const relationIds = await this.load(relation, relatedEntityOrEntities!, entitiesOrEntities);\n    const relationIds = await this.load(relation, entitiesOrEntities, relatedEntityOrEntities);\n    // console.log(\"entities\", entities);\n    // console.log(\"relatedEntityOrEntities\", relatedEntityOrEntities);\n    // console.log(\"relationIds\", relationIds);\n    const relatedEntities = Array.isArray(relatedEntityOrEntities) ? relatedEntityOrEntities : [relatedEntityOrEntities];\n    let columns = [],\n      inverseColumns = [];\n    if (relation.isManyToManyOwner) {\n      columns = relation.junctionEntityMetadata.inverseColumns.map(column => column.referencedColumn);\n      inverseColumns = relation.junctionEntityMetadata.ownerColumns.map(column => column.referencedColumn);\n    } else if (relation.isManyToManyNotOwner) {\n      columns = relation.junctionEntityMetadata.ownerColumns.map(column => column.referencedColumn);\n      inverseColumns = relation.junctionEntityMetadata.inverseColumns.map(column => column.referencedColumn);\n    } else if (relation.isManyToOne || relation.isOneToOneOwner) {\n      columns = relation.joinColumns.map(column => column.referencedColumn);\n      inverseColumns = relation.entityMetadata.primaryColumns;\n    } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n      columns = relation.inverseRelation.entityMetadata.primaryColumns;\n      inverseColumns = relation.inverseRelation.joinColumns.map(column => column.referencedColumn);\n    } else {}\n    return entities.map(entity => {\n      const group = {\n        entity: entity,\n        related: isMany ? [] : undefined\n      };\n      const entityRelationIds = relationIds.filter(relationId => {\n        return inverseColumns.every(column => {\n          return column.compareEntityValue(entity, relationId[column.entityMetadata.name + \"_\" + column.propertyAliasName]);\n        });\n      });\n      if (!entityRelationIds.length) return group;\n      relatedEntities.forEach(relatedEntity => {\n        entityRelationIds.forEach(relationId => {\n          const relatedEntityMatched = columns.every(column => {\n            return column.compareEntityValue(relatedEntity, relationId[DriverUtils.buildAlias(this.connection.driver, undefined, column.entityMetadata.name + \"_\" + relation.propertyPath.replace(\".\", \"_\") + \"_\" + column.propertyPath.replace(\".\", \"_\"))]);\n          });\n          if (relatedEntityMatched) {\n            if (isMany) {\n              ;\n              group.related.push(relatedEntity);\n            } else {\n              group.related = relatedEntity;\n            }\n          }\n        });\n      });\n      return group;\n    });\n  }\n  /**\n   * Loads relation ids of the given entities and maps them into the given entity property.\n   async loadManyToManyRelationIdsAndMap(\n   relation: RelationMetadata,\n   entityOrEntities: ObjectLiteral|ObjectLiteral[],\n   mapToEntityOrEntities: ObjectLiteral|ObjectLiteral[],\n   propertyName: string\n   ): Promise<void> {\n      const relationIds = await this.loadManyToManyRelationIds(relation, entityOrEntities, mapToEntityOrEntities);\n      const mapToEntities = mapToEntityOrEntities instanceof Array ? mapToEntityOrEntities : [mapToEntityOrEntities];\n      const junctionMetadata = relation.junctionEntityMetadata!;\n      const mainAlias = junctionMetadata.name;\n      const columns = relation.isOwning ? junctionMetadata.inverseColumns : junctionMetadata.ownerColumns;\n      const inverseColumns = relation.isOwning ? junctionMetadata.ownerColumns : junctionMetadata.inverseColumns;\n      mapToEntities.forEach(mapToEntity => {\n          mapToEntity[propertyName] = [];\n          relationIds.forEach(relationId => {\n              const match = inverseColumns.every(column => {\n                  return column.referencedColumn!.getEntityValue(mapToEntity) === relationId[mainAlias + \"_\" + column.propertyName];\n              });\n              if (match) {\n                  if (columns.length === 1) {\n                      mapToEntity[propertyName].push(relationId[mainAlias + \"_\" + columns[0].propertyName]);\n                  } else {\n                      const value = {};\n                      columns.forEach(column => {\n                          column.referencedColumn!.setEntityValue(value, relationId[mainAlias + \"_\" + column.propertyName]);\n                      });\n                      mapToEntity[propertyName].push(value);\n                  }\n              }\n          });\n      });\n  }*/\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Loads relation ids for the many-to-many relation.\n   */\n  loadForManyToMany(relation, entities, relatedEntities) {\n    const junctionMetadata = relation.junctionEntityMetadata;\n    const mainAlias = junctionMetadata.name;\n    const columns = relation.isOwning ? junctionMetadata.ownerColumns : junctionMetadata.inverseColumns;\n    const inverseColumns = relation.isOwning ? junctionMetadata.inverseColumns : junctionMetadata.ownerColumns;\n    const qb = this.connection.createQueryBuilder(this.queryRunner);\n    // select all columns from junction table\n    columns.forEach(column => {\n      const columnName = DriverUtils.buildAlias(this.connection.driver, undefined, column.referencedColumn.entityMetadata.name + \"_\" + column.referencedColumn.propertyPath.replace(\".\", \"_\"));\n      qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName);\n    });\n    inverseColumns.forEach(column => {\n      const columnName = DriverUtils.buildAlias(this.connection.driver, undefined, column.referencedColumn.entityMetadata.name + \"_\" + relation.propertyPath.replace(\".\", \"_\") + \"_\" + column.referencedColumn.propertyPath.replace(\".\", \"_\"));\n      qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName);\n    });\n    // add conditions for the given entities\n    let condition1 = \"\";\n    if (columns.length === 1) {\n      const values = entities.map(entity => columns[0].referencedColumn.getEntityValue(entity));\n      const areAllNumbers = values.every(value => typeof value === \"number\");\n      if (areAllNumbers) {\n        condition1 = `${mainAlias}.${columns[0].propertyPath} IN (${values.join(\", \")})`;\n      } else {\n        qb.setParameter(\"values1\", values);\n        condition1 = mainAlias + \".\" + columns[0].propertyPath + \" IN (:...values1)\"; // todo: use ANY for postgres\n      }\n    } else {\n      condition1 = \"(\" + entities.map((entity, entityIndex) => {\n        return columns.map(column => {\n          const paramName = \"entity1_\" + entityIndex + \"_\" + column.propertyName;\n          qb.setParameter(paramName, column.referencedColumn.getEntityValue(entity));\n          return mainAlias + \".\" + column.propertyPath + \" = :\" + paramName;\n        }).join(\" AND \");\n      }).map(condition => \"(\" + condition + \")\").join(\" OR \") + \")\";\n    }\n    // add conditions for the given inverse entities\n    let condition2 = \"\";\n    if (relatedEntities) {\n      if (inverseColumns.length === 1) {\n        const values = relatedEntities.map(entity => inverseColumns[0].referencedColumn.getEntityValue(entity));\n        const areAllNumbers = values.every(value => typeof value === \"number\");\n        if (areAllNumbers) {\n          condition2 = `${mainAlias}.${inverseColumns[0].propertyPath} IN (${values.join(\", \")})`;\n        } else {\n          qb.setParameter(\"values2\", values);\n          condition2 = mainAlias + \".\" + inverseColumns[0].propertyPath + \" IN (:...values2)\"; // todo: use ANY for postgres\n        }\n      } else {\n        condition2 = \"(\" + relatedEntities.map((entity, entityIndex) => {\n          return inverseColumns.map(column => {\n            const paramName = \"entity2_\" + entityIndex + \"_\" + column.propertyName;\n            qb.setParameter(paramName, column.referencedColumn.getEntityValue(entity));\n            return mainAlias + \".\" + column.propertyPath + \" = :\" + paramName;\n          }).join(\" AND \");\n        }).map(condition => \"(\" + condition + \")\").join(\" OR \") + \")\";\n      }\n    }\n    // qb.from(junctionMetadata.target, mainAlias)\n    //     .where(condition1 + (condition2 ? \" AND \" + condition2 : \"\"));\n    //\n    // // execute query\n    // const { values1, values2 } = qb.getParameters();\n    // console.log(`I can do it`, { values1, values2 });\n    // if (inverseColumns.length === 1 &&\n    //     columns.length === 1 &&\n    //     this.connection.driver instanceof SqliteDriver &&\n    //     (values1.length + values2.length) > 500 &&\n    //     values1.length === values2.length) {\n    //     console.log(`I can do it`);\n    //     return qb.getRawMany();\n    //\n    // } else {\n    //     return qb.getRawMany();\n    // }\n    // execute query\n    const condition = [condition1, condition2].filter(v => v.length > 0).join(\" AND \");\n    return qb.from(junctionMetadata.target, mainAlias).where(condition).getRawMany();\n  }\n  /**\n   * Loads relation ids for the many-to-one and one-to-one owner relations.\n   */\n  loadForManyToOneAndOneToOneOwner(relation, entities, relatedEntities) {\n    const mainAlias = relation.entityMetadata.targetName;\n    // console.log(\"entitiesx\", entities);\n    // console.log(\"relatedEntitiesx\", relatedEntities);\n    const hasAllJoinColumnsInEntity = relation.joinColumns.every(joinColumn => {\n      return !!relation.entityMetadata.nonVirtualColumns.find(column => column === joinColumn);\n    });\n    if (relatedEntities && hasAllJoinColumnsInEntity) {\n      let relationIdMaps = [];\n      entities.forEach(entity => {\n        let relationIdMap = {};\n        relation.entityMetadata.primaryColumns.forEach(primaryColumn => {\n          const key = primaryColumn.entityMetadata.name + \"_\" + primaryColumn.propertyPath.replace(\".\", \"_\");\n          relationIdMap[key] = primaryColumn.getEntityValue(entity);\n        });\n        relatedEntities.forEach(relatedEntity => {\n          relation.joinColumns.forEach(joinColumn => {\n            const entityColumnValue = joinColumn.getEntityValue(entity);\n            const relatedEntityColumnValue = joinColumn.referencedColumn.getEntityValue(relatedEntity);\n            if (entityColumnValue === undefined || relatedEntityColumnValue === undefined) return;\n            if (entityColumnValue === relatedEntityColumnValue) {\n              const key = joinColumn.referencedColumn.entityMetadata.name + \"_\" + relation.propertyPath.replace(\".\", \"_\") + \"_\" + joinColumn.referencedColumn.propertyPath.replace(\".\", \"_\");\n              relationIdMap[key] = relatedEntityColumnValue;\n            }\n          });\n        });\n        if (Object.keys(relationIdMap).length === relation.entityMetadata.primaryColumns.length + relation.joinColumns.length) {\n          relationIdMaps.push(relationIdMap);\n        }\n      });\n      // console.log(\"relationIdMap\", relationIdMaps);\n      // console.log(\"entities.length\", entities.length);\n      if (relationIdMaps.length === entities.length) return Promise.resolve(relationIdMaps);\n    }\n    // select all columns we need\n    const qb = this.connection.createQueryBuilder(this.queryRunner);\n    relation.entityMetadata.primaryColumns.forEach(primaryColumn => {\n      const columnName = DriverUtils.buildAlias(this.connection.driver, undefined, primaryColumn.entityMetadata.name + \"_\" + primaryColumn.propertyPath.replace(\".\", \"_\"));\n      qb.addSelect(mainAlias + \".\" + primaryColumn.propertyPath, columnName);\n    });\n    relation.joinColumns.forEach(column => {\n      const columnName = DriverUtils.buildAlias(this.connection.driver, undefined, column.referencedColumn.entityMetadata.name + \"_\" + relation.propertyPath.replace(\".\", \"_\") + \"_\" + column.referencedColumn.propertyPath.replace(\".\", \"_\"));\n      qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName);\n    });\n    // add condition for entities\n    let condition = \"\";\n    if (relation.entityMetadata.primaryColumns.length === 1) {\n      const values = entities.map(entity => relation.entityMetadata.primaryColumns[0].getEntityValue(entity));\n      const areAllNumbers = values.every(value => typeof value === \"number\");\n      if (areAllNumbers) {\n        condition = `${mainAlias}.${relation.entityMetadata.primaryColumns[0].propertyPath} IN (${values.join(\", \")})`;\n      } else {\n        qb.setParameter(\"values\", values);\n        condition = mainAlias + \".\" + relation.entityMetadata.primaryColumns[0].propertyPath + \" IN (:...values)\"; // todo: use ANY for postgres\n      }\n    } else {\n      condition = entities.map((entity, entityIndex) => {\n        return relation.entityMetadata.primaryColumns.map((column, columnIndex) => {\n          const paramName = \"entity\" + entityIndex + \"_\" + columnIndex;\n          qb.setParameter(paramName, column.getEntityValue(entity));\n          return mainAlias + \".\" + column.propertyPath + \" = :\" + paramName;\n        }).join(\" AND \");\n      }).map(condition => \"(\" + condition + \")\").join(\" OR \");\n    }\n    // execute query\n    return qb.from(relation.entityMetadata.target, mainAlias).where(condition).getRawMany();\n  }\n  /**\n   * Loads relation ids for the one-to-many and one-to-one not owner relations.\n   */\n  loadForOneToManyAndOneToOneNotOwner(relation, entities, relatedEntities) {\n    relation = relation.inverseRelation;\n    if (relation.entityMetadata.primaryColumns.length === relation.joinColumns.length) {\n      const sameReferencedColumns = relation.entityMetadata.primaryColumns.every(column => {\n        return relation.joinColumns.indexOf(column) !== -1;\n      });\n      if (sameReferencedColumns) {\n        return Promise.resolve(entities.map(entity => {\n          const result = {};\n          relation.joinColumns.forEach(function (joinColumn) {\n            const value = joinColumn.referencedColumn.getEntityValue(entity);\n            const joinColumnName = joinColumn.referencedColumn.entityMetadata.name + \"_\" + joinColumn.referencedColumn.propertyPath.replace(\".\", \"_\");\n            const primaryColumnName = joinColumn.entityMetadata.name + \"_\" + relation.inverseRelation.propertyPath.replace(\".\", \"_\") + \"_\" + joinColumn.propertyPath.replace(\".\", \"_\");\n            result[joinColumnName] = value;\n            result[primaryColumnName] = value;\n          });\n          return result;\n        }));\n      }\n    }\n    const mainAlias = relation.entityMetadata.targetName;\n    // select all columns we need\n    const qb = this.connection.createQueryBuilder(this.queryRunner);\n    relation.entityMetadata.primaryColumns.forEach(primaryColumn => {\n      const columnName = DriverUtils.buildAlias(this.connection.driver, undefined, primaryColumn.entityMetadata.name + \"_\" + relation.inverseRelation.propertyPath.replace(\".\", \"_\") + \"_\" + primaryColumn.propertyPath.replace(\".\", \"_\"));\n      qb.addSelect(mainAlias + \".\" + primaryColumn.propertyPath, columnName);\n    });\n    relation.joinColumns.forEach(column => {\n      const columnName = DriverUtils.buildAlias(this.connection.driver, undefined, column.referencedColumn.entityMetadata.name + \"_\" + column.referencedColumn.propertyPath.replace(\".\", \"_\"));\n      qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName);\n    });\n    // add condition for entities\n    let condition = \"\";\n    if (relation.joinColumns.length === 1) {\n      const values = entities.map(entity => relation.joinColumns[0].referencedColumn.getEntityValue(entity));\n      const areAllNumbers = values.every(value => typeof value === \"number\");\n      if (areAllNumbers) {\n        condition = `${mainAlias}.${relation.joinColumns[0].propertyPath} IN (${values.join(\", \")})`;\n      } else {\n        qb.setParameter(\"values\", values);\n        condition = mainAlias + \".\" + relation.joinColumns[0].propertyPath + \" IN (:...values)\"; // todo: use ANY for postgres\n      }\n    } else {\n      condition = entities.map((entity, entityIndex) => {\n        return relation.joinColumns.map((joinColumn, joinColumnIndex) => {\n          const paramName = \"entity\" + entityIndex + \"_\" + joinColumnIndex;\n          qb.setParameter(paramName, joinColumn.referencedColumn.getEntityValue(entity));\n          return mainAlias + \".\" + joinColumn.propertyPath + \" = :\" + paramName;\n        }).join(\" AND \");\n      }).map(condition => \"(\" + condition + \")\").join(\" OR \");\n    }\n    // execute query\n    return qb.from(relation.entityMetadata.target, mainAlias).where(condition).getRawMany();\n  }\n}","map":{"version":3,"names":["DriverUtils","RelationIdLoader","constructor","connection","queryRunner","load","relation","entityOrEntities","relatedEntityOrRelatedEntities","entities","Array","isArray","relatedEntities","undefined","isManyToMany","loadForManyToMany","isManyToOne","isOneToOneOwner","loadForManyToOneAndOneToOneOwner","loadForOneToManyAndOneToOneNotOwner","loadManyToManyRelationIdsAndGroup","entitiesOrEntities","relatedEntityOrEntities","queryBuilder","isMany","isOneToMany","relationLoader","length","map","entity","related","relationIds","columns","inverseColumns","isManyToManyOwner","junctionEntityMetadata","column","referencedColumn","ownerColumns","isManyToManyNotOwner","joinColumns","entityMetadata","primaryColumns","isOneToOneNotOwner","inverseRelation","group","entityRelationIds","filter","relationId","every","compareEntityValue","name","propertyAliasName","forEach","relatedEntity","relatedEntityMatched","buildAlias","driver","propertyPath","replace","push","junctionMetadata","mainAlias","isOwning","qb","createQueryBuilder","columnName","addSelect","condition1","values","getEntityValue","areAllNumbers","value","join","setParameter","entityIndex","paramName","propertyName","condition","condition2","v","from","target","where","getRawMany","targetName","hasAllJoinColumnsInEntity","joinColumn","nonVirtualColumns","find","relationIdMaps","relationIdMap","primaryColumn","key","entityColumnValue","relatedEntityColumnValue","Object","keys","Promise","resolve","columnIndex","sameReferencedColumns","indexOf","result","joinColumnName","primaryColumnName","joinColumnIndex"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\query-builder\\RelationIdLoader.ts"],"sourcesContent":["import { RelationMetadata } from \"../metadata/RelationMetadata\"\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { SelectQueryBuilder } from \"./SelectQueryBuilder\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\n\n/**\n * Loads relation ids for the given entities.\n */\nexport class RelationIdLoader {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        private connection: DataSource,\n        protected queryRunner?: QueryRunner | undefined,\n    ) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Loads relation ids of the given entity or entities.\n     */\n    load(\n        relation: RelationMetadata,\n        entityOrEntities: ObjectLiteral | ObjectLiteral[],\n        relatedEntityOrRelatedEntities?: ObjectLiteral | ObjectLiteral[],\n    ): Promise<any[]> {\n        const entities = Array.isArray(entityOrEntities)\n            ? entityOrEntities\n            : [entityOrEntities]\n        const relatedEntities = Array.isArray(relatedEntityOrRelatedEntities)\n            ? relatedEntityOrRelatedEntities\n            : relatedEntityOrRelatedEntities\n            ? [relatedEntityOrRelatedEntities]\n            : undefined\n\n        // load relation ids depend of relation type\n        if (relation.isManyToMany) {\n            return this.loadForManyToMany(relation, entities, relatedEntities)\n        } else if (relation.isManyToOne || relation.isOneToOneOwner) {\n            return this.loadForManyToOneAndOneToOneOwner(\n                relation,\n                entities,\n                relatedEntities,\n            )\n        } else {\n            // if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            return this.loadForOneToManyAndOneToOneNotOwner(\n                relation,\n                entities,\n                relatedEntities,\n            )\n        }\n    }\n\n    /**\n     * Loads relation ids of the given entities and groups them into the object with parent and children.\n     *\n     * todo: extract this method?\n     */\n    async loadManyToManyRelationIdsAndGroup<\n        E1 extends ObjectLiteral,\n        E2 extends ObjectLiteral,\n    >(\n        relation: RelationMetadata,\n        entitiesOrEntities: E1 | E1[],\n        relatedEntityOrEntities?: E2 | E2[],\n        queryBuilder?: SelectQueryBuilder<any>,\n    ): Promise<{ entity: E1; related?: E2 | E2[] }[]> {\n        // console.log(\"relation:\", relation.propertyName);\n        // console.log(\"entitiesOrEntities\", entitiesOrEntities);\n        const isMany = relation.isManyToMany || relation.isOneToMany\n        const entities: E1[] = Array.isArray(entitiesOrEntities)\n            ? entitiesOrEntities\n            : [entitiesOrEntities]\n\n        if (!relatedEntityOrEntities) {\n            relatedEntityOrEntities = await this.connection.relationLoader.load(\n                relation,\n                entitiesOrEntities,\n                this.queryRunner,\n                queryBuilder,\n            )\n            if (!relatedEntityOrEntities.length)\n                return entities.map((entity) => ({\n                    entity: entity,\n                    related: isMany ? [] : undefined,\n                }))\n        }\n        // const relationIds = await this.load(relation, relatedEntityOrEntities!, entitiesOrEntities);\n        const relationIds = await this.load(\n            relation,\n            entitiesOrEntities,\n            relatedEntityOrEntities,\n        )\n        // console.log(\"entities\", entities);\n        // console.log(\"relatedEntityOrEntities\", relatedEntityOrEntities);\n        // console.log(\"relationIds\", relationIds);\n\n        const relatedEntities: E2[] = Array.isArray(relatedEntityOrEntities)\n            ? relatedEntityOrEntities\n            : [relatedEntityOrEntities!]\n\n        let columns: ColumnMetadata[] = [],\n            inverseColumns: ColumnMetadata[] = []\n        if (relation.isManyToManyOwner) {\n            columns = relation.junctionEntityMetadata!.inverseColumns.map(\n                (column) => column.referencedColumn!,\n            )\n            inverseColumns = relation.junctionEntityMetadata!.ownerColumns.map(\n                (column) => column.referencedColumn!,\n            )\n        } else if (relation.isManyToManyNotOwner) {\n            columns = relation.junctionEntityMetadata!.ownerColumns.map(\n                (column) => column.referencedColumn!,\n            )\n            inverseColumns =\n                relation.junctionEntityMetadata!.inverseColumns.map(\n                    (column) => column.referencedColumn!,\n                )\n        } else if (relation.isManyToOne || relation.isOneToOneOwner) {\n            columns = relation.joinColumns.map(\n                (column) => column.referencedColumn!,\n            )\n            inverseColumns = relation.entityMetadata.primaryColumns\n        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            columns = relation.inverseRelation!.entityMetadata.primaryColumns\n            inverseColumns = relation.inverseRelation!.joinColumns.map(\n                (column) => column.referencedColumn!,\n            )\n        } else {\n        }\n\n        return entities.map((entity) => {\n            const group: { entity: E1; related?: E2 | E2[] } = {\n                entity: entity,\n                related: isMany ? [] : undefined,\n            }\n\n            const entityRelationIds = relationIds.filter((relationId) => {\n                return inverseColumns.every((column) => {\n                    return column.compareEntityValue(\n                        entity,\n                        relationId[\n                            column.entityMetadata.name +\n                                \"_\" +\n                                column.propertyAliasName\n                        ],\n                    )\n                })\n            })\n            if (!entityRelationIds.length) return group\n\n            relatedEntities.forEach((relatedEntity) => {\n                entityRelationIds.forEach((relationId) => {\n                    const relatedEntityMatched = columns.every((column) => {\n                        return column.compareEntityValue(\n                            relatedEntity,\n                            relationId[\n                                DriverUtils.buildAlias(\n                                    this.connection.driver,\n                                    undefined,\n                                    column.entityMetadata.name +\n                                        \"_\" +\n                                        relation.propertyPath.replace(\n                                            \".\",\n                                            \"_\",\n                                        ) +\n                                        \"_\" +\n                                        column.propertyPath.replace(\".\", \"_\"),\n                                )\n                            ],\n                        )\n                    })\n                    if (relatedEntityMatched) {\n                        if (isMany) {\n                            ;(group.related as E2[]).push(relatedEntity)\n                        } else {\n                            group.related = relatedEntity\n                        }\n                    }\n                })\n            })\n            return group\n        })\n    }\n\n    /**\n     * Loads relation ids of the given entities and maps them into the given entity property.\n     async loadManyToManyRelationIdsAndMap(\n     relation: RelationMetadata,\n     entityOrEntities: ObjectLiteral|ObjectLiteral[],\n     mapToEntityOrEntities: ObjectLiteral|ObjectLiteral[],\n     propertyName: string\n     ): Promise<void> {\n        const relationIds = await this.loadManyToManyRelationIds(relation, entityOrEntities, mapToEntityOrEntities);\n        const mapToEntities = mapToEntityOrEntities instanceof Array ? mapToEntityOrEntities : [mapToEntityOrEntities];\n        const junctionMetadata = relation.junctionEntityMetadata!;\n        const mainAlias = junctionMetadata.name;\n        const columns = relation.isOwning ? junctionMetadata.inverseColumns : junctionMetadata.ownerColumns;\n        const inverseColumns = relation.isOwning ? junctionMetadata.ownerColumns : junctionMetadata.inverseColumns;\n        mapToEntities.forEach(mapToEntity => {\n            mapToEntity[propertyName] = [];\n            relationIds.forEach(relationId => {\n                const match = inverseColumns.every(column => {\n                    return column.referencedColumn!.getEntityValue(mapToEntity) === relationId[mainAlias + \"_\" + column.propertyName];\n                });\n                if (match) {\n                    if (columns.length === 1) {\n                        mapToEntity[propertyName].push(relationId[mainAlias + \"_\" + columns[0].propertyName]);\n                    } else {\n                        const value = {};\n                        columns.forEach(column => {\n                            column.referencedColumn!.setEntityValue(value, relationId[mainAlias + \"_\" + column.propertyName]);\n                        });\n                        mapToEntity[propertyName].push(value);\n                    }\n                }\n            });\n        });\n    }*/\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Loads relation ids for the many-to-many relation.\n     */\n    protected loadForManyToMany(\n        relation: RelationMetadata,\n        entities: ObjectLiteral[],\n        relatedEntities?: ObjectLiteral[],\n    ) {\n        const junctionMetadata = relation.junctionEntityMetadata!\n        const mainAlias = junctionMetadata.name\n        const columns = relation.isOwning\n            ? junctionMetadata.ownerColumns\n            : junctionMetadata.inverseColumns\n        const inverseColumns = relation.isOwning\n            ? junctionMetadata.inverseColumns\n            : junctionMetadata.ownerColumns\n        const qb = this.connection.createQueryBuilder(this.queryRunner)\n\n        // select all columns from junction table\n        columns.forEach((column) => {\n            const columnName = DriverUtils.buildAlias(\n                this.connection.driver,\n                undefined,\n                column.referencedColumn!.entityMetadata.name +\n                    \"_\" +\n                    column.referencedColumn!.propertyPath.replace(\".\", \"_\"),\n            )\n            qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName)\n        })\n        inverseColumns.forEach((column) => {\n            const columnName = DriverUtils.buildAlias(\n                this.connection.driver,\n                undefined,\n                column.referencedColumn!.entityMetadata.name +\n                    \"_\" +\n                    relation.propertyPath.replace(\".\", \"_\") +\n                    \"_\" +\n                    column.referencedColumn!.propertyPath.replace(\".\", \"_\"),\n            )\n            qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName)\n        })\n\n        // add conditions for the given entities\n        let condition1 = \"\"\n        if (columns.length === 1) {\n            const values = entities.map((entity) =>\n                columns[0].referencedColumn!.getEntityValue(entity),\n            )\n            const areAllNumbers = values.every(\n                (value) => typeof value === \"number\",\n            )\n\n            if (areAllNumbers) {\n                condition1 = `${mainAlias}.${\n                    columns[0].propertyPath\n                } IN (${values.join(\", \")})`\n            } else {\n                qb.setParameter(\"values1\", values)\n                condition1 =\n                    mainAlias +\n                    \".\" +\n                    columns[0].propertyPath +\n                    \" IN (:...values1)\" // todo: use ANY for postgres\n            }\n        } else {\n            condition1 =\n                \"(\" +\n                entities\n                    .map((entity, entityIndex) => {\n                        return columns\n                            .map((column) => {\n                                const paramName =\n                                    \"entity1_\" +\n                                    entityIndex +\n                                    \"_\" +\n                                    column.propertyName\n                                qb.setParameter(\n                                    paramName,\n                                    column.referencedColumn!.getEntityValue(\n                                        entity,\n                                    ),\n                                )\n                                return (\n                                    mainAlias +\n                                    \".\" +\n                                    column.propertyPath +\n                                    \" = :\" +\n                                    paramName\n                                )\n                            })\n                            .join(\" AND \")\n                    })\n                    .map((condition) => \"(\" + condition + \")\")\n                    .join(\" OR \") +\n                \")\"\n        }\n\n        // add conditions for the given inverse entities\n        let condition2 = \"\"\n        if (relatedEntities) {\n            if (inverseColumns.length === 1) {\n                const values = relatedEntities.map((entity) =>\n                    inverseColumns[0].referencedColumn!.getEntityValue(entity),\n                )\n                const areAllNumbers = values.every(\n                    (value) => typeof value === \"number\",\n                )\n\n                if (areAllNumbers) {\n                    condition2 = `${mainAlias}.${\n                        inverseColumns[0].propertyPath\n                    } IN (${values.join(\", \")})`\n                } else {\n                    qb.setParameter(\"values2\", values)\n                    condition2 =\n                        mainAlias +\n                        \".\" +\n                        inverseColumns[0].propertyPath +\n                        \" IN (:...values2)\" // todo: use ANY for postgres\n                }\n            } else {\n                condition2 =\n                    \"(\" +\n                    relatedEntities\n                        .map((entity, entityIndex) => {\n                            return inverseColumns\n                                .map((column) => {\n                                    const paramName =\n                                        \"entity2_\" +\n                                        entityIndex +\n                                        \"_\" +\n                                        column.propertyName\n                                    qb.setParameter(\n                                        paramName,\n                                        column.referencedColumn!.getEntityValue(\n                                            entity,\n                                        ),\n                                    )\n                                    return (\n                                        mainAlias +\n                                        \".\" +\n                                        column.propertyPath +\n                                        \" = :\" +\n                                        paramName\n                                    )\n                                })\n                                .join(\" AND \")\n                        })\n                        .map((condition) => \"(\" + condition + \")\")\n                        .join(\" OR \") +\n                    \")\"\n            }\n        }\n\n        // qb.from(junctionMetadata.target, mainAlias)\n        //     .where(condition1 + (condition2 ? \" AND \" + condition2 : \"\"));\n        //\n        // // execute query\n        // const { values1, values2 } = qb.getParameters();\n        // console.log(`I can do it`, { values1, values2 });\n        // if (inverseColumns.length === 1 &&\n        //     columns.length === 1 &&\n        //     this.connection.driver instanceof SqliteDriver &&\n        //     (values1.length + values2.length) > 500 &&\n        //     values1.length === values2.length) {\n        //     console.log(`I can do it`);\n        //     return qb.getRawMany();\n        //\n        // } else {\n        //     return qb.getRawMany();\n        // }\n\n        // execute query\n        const condition = [condition1, condition2]\n            .filter((v) => v.length > 0)\n            .join(\" AND \")\n        return qb\n            .from(junctionMetadata.target, mainAlias)\n            .where(condition)\n            .getRawMany()\n    }\n\n    /**\n     * Loads relation ids for the many-to-one and one-to-one owner relations.\n     */\n    protected loadForManyToOneAndOneToOneOwner(\n        relation: RelationMetadata,\n        entities: ObjectLiteral[],\n        relatedEntities?: ObjectLiteral[],\n    ) {\n        const mainAlias = relation.entityMetadata.targetName\n\n        // console.log(\"entitiesx\", entities);\n        // console.log(\"relatedEntitiesx\", relatedEntities);\n        const hasAllJoinColumnsInEntity = relation.joinColumns.every(\n            (joinColumn) => {\n                return !!relation.entityMetadata.nonVirtualColumns.find(\n                    (column) => column === joinColumn,\n                )\n            },\n        )\n        if (relatedEntities && hasAllJoinColumnsInEntity) {\n            let relationIdMaps: ObjectLiteral[] = []\n            entities.forEach((entity) => {\n                let relationIdMap: ObjectLiteral = {}\n                relation.entityMetadata.primaryColumns.forEach(\n                    (primaryColumn) => {\n                        const key =\n                            primaryColumn.entityMetadata.name +\n                            \"_\" +\n                            primaryColumn.propertyPath.replace(\".\", \"_\")\n                        relationIdMap[key] =\n                            primaryColumn.getEntityValue(entity)\n                    },\n                )\n\n                relatedEntities.forEach((relatedEntity) => {\n                    relation.joinColumns.forEach((joinColumn) => {\n                        const entityColumnValue =\n                            joinColumn.getEntityValue(entity)\n                        const relatedEntityColumnValue =\n                            joinColumn.referencedColumn!.getEntityValue(\n                                relatedEntity,\n                            )\n                        if (\n                            entityColumnValue === undefined ||\n                            relatedEntityColumnValue === undefined\n                        )\n                            return\n\n                        if (entityColumnValue === relatedEntityColumnValue) {\n                            const key =\n                                joinColumn.referencedColumn!.entityMetadata\n                                    .name +\n                                \"_\" +\n                                relation.propertyPath.replace(\".\", \"_\") +\n                                \"_\" +\n                                joinColumn.referencedColumn!.propertyPath.replace(\n                                    \".\",\n                                    \"_\",\n                                )\n                            relationIdMap[key] = relatedEntityColumnValue\n                        }\n                    })\n                })\n                if (\n                    Object.keys(relationIdMap).length ===\n                    relation.entityMetadata.primaryColumns.length +\n                        relation.joinColumns.length\n                ) {\n                    relationIdMaps.push(relationIdMap)\n                }\n            })\n            // console.log(\"relationIdMap\", relationIdMaps);\n            // console.log(\"entities.length\", entities.length);\n            if (relationIdMaps.length === entities.length)\n                return Promise.resolve(relationIdMaps)\n        }\n\n        // select all columns we need\n        const qb = this.connection.createQueryBuilder(this.queryRunner)\n        relation.entityMetadata.primaryColumns.forEach((primaryColumn) => {\n            const columnName = DriverUtils.buildAlias(\n                this.connection.driver,\n                undefined,\n                primaryColumn.entityMetadata.name +\n                    \"_\" +\n                    primaryColumn.propertyPath.replace(\".\", \"_\"),\n            )\n            qb.addSelect(\n                mainAlias + \".\" + primaryColumn.propertyPath,\n                columnName,\n            )\n        })\n        relation.joinColumns.forEach((column) => {\n            const columnName = DriverUtils.buildAlias(\n                this.connection.driver,\n                undefined,\n                column.referencedColumn!.entityMetadata.name +\n                    \"_\" +\n                    relation.propertyPath.replace(\".\", \"_\") +\n                    \"_\" +\n                    column.referencedColumn!.propertyPath.replace(\".\", \"_\"),\n            )\n            qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName)\n        })\n\n        // add condition for entities\n        let condition: string = \"\"\n        if (relation.entityMetadata.primaryColumns.length === 1) {\n            const values = entities.map((entity) =>\n                relation.entityMetadata.primaryColumns[0].getEntityValue(\n                    entity,\n                ),\n            )\n            const areAllNumbers = values.every(\n                (value) => typeof value === \"number\",\n            )\n\n            if (areAllNumbers) {\n                condition = `${mainAlias}.${\n                    relation.entityMetadata.primaryColumns[0].propertyPath\n                } IN (${values.join(\", \")})`\n            } else {\n                qb.setParameter(\"values\", values)\n                condition =\n                    mainAlias +\n                    \".\" +\n                    relation.entityMetadata.primaryColumns[0].propertyPath +\n                    \" IN (:...values)\" // todo: use ANY for postgres\n            }\n        } else {\n            condition = entities\n                .map((entity, entityIndex) => {\n                    return relation.entityMetadata.primaryColumns\n                        .map((column, columnIndex) => {\n                            const paramName =\n                                \"entity\" + entityIndex + \"_\" + columnIndex\n                            qb.setParameter(\n                                paramName,\n                                column.getEntityValue(entity),\n                            )\n                            return (\n                                mainAlias +\n                                \".\" +\n                                column.propertyPath +\n                                \" = :\" +\n                                paramName\n                            )\n                        })\n                        .join(\" AND \")\n                })\n                .map((condition) => \"(\" + condition + \")\")\n                .join(\" OR \")\n        }\n\n        // execute query\n        return qb\n            .from(relation.entityMetadata.target, mainAlias)\n            .where(condition)\n            .getRawMany()\n    }\n\n    /**\n     * Loads relation ids for the one-to-many and one-to-one not owner relations.\n     */\n    protected loadForOneToManyAndOneToOneNotOwner(\n        relation: RelationMetadata,\n        entities: ObjectLiteral[],\n        relatedEntities?: ObjectLiteral[],\n    ) {\n        relation = relation.inverseRelation!\n\n        if (\n            relation.entityMetadata.primaryColumns.length ===\n            relation.joinColumns.length\n        ) {\n            const sameReferencedColumns =\n                relation.entityMetadata.primaryColumns.every((column) => {\n                    return relation.joinColumns.indexOf(column) !== -1\n                })\n            if (sameReferencedColumns) {\n                return Promise.resolve(\n                    entities.map((entity) => {\n                        const result: ObjectLiteral = {}\n                        relation.joinColumns.forEach(function (joinColumn) {\n                            const value =\n                                joinColumn.referencedColumn!.getEntityValue(\n                                    entity,\n                                )\n                            const joinColumnName =\n                                joinColumn.referencedColumn!.entityMetadata\n                                    .name +\n                                \"_\" +\n                                joinColumn.referencedColumn!.propertyPath.replace(\n                                    \".\",\n                                    \"_\",\n                                )\n                            const primaryColumnName =\n                                joinColumn.entityMetadata.name +\n                                \"_\" +\n                                relation.inverseRelation!.propertyPath.replace(\n                                    \".\",\n                                    \"_\",\n                                ) +\n                                \"_\" +\n                                joinColumn.propertyPath.replace(\".\", \"_\")\n                            result[joinColumnName] = value\n                            result[primaryColumnName] = value\n                        })\n                        return result\n                    }),\n                )\n            }\n        }\n\n        const mainAlias = relation.entityMetadata.targetName\n\n        // select all columns we need\n        const qb = this.connection.createQueryBuilder(this.queryRunner)\n        relation.entityMetadata.primaryColumns.forEach((primaryColumn) => {\n            const columnName = DriverUtils.buildAlias(\n                this.connection.driver,\n                undefined,\n                primaryColumn.entityMetadata.name +\n                    \"_\" +\n                    relation.inverseRelation!.propertyPath.replace(\".\", \"_\") +\n                    \"_\" +\n                    primaryColumn.propertyPath.replace(\".\", \"_\"),\n            )\n            qb.addSelect(\n                mainAlias + \".\" + primaryColumn.propertyPath,\n                columnName,\n            )\n        })\n        relation.joinColumns.forEach((column) => {\n            const columnName = DriverUtils.buildAlias(\n                this.connection.driver,\n                undefined,\n                column.referencedColumn!.entityMetadata.name +\n                    \"_\" +\n                    column.referencedColumn!.propertyPath.replace(\".\", \"_\"),\n            )\n            qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName)\n        })\n\n        // add condition for entities\n        let condition: string = \"\"\n        if (relation.joinColumns.length === 1) {\n            const values = entities.map((entity) =>\n                relation.joinColumns[0].referencedColumn!.getEntityValue(\n                    entity,\n                ),\n            )\n            const areAllNumbers = values.every(\n                (value) => typeof value === \"number\",\n            )\n\n            if (areAllNumbers) {\n                condition = `${mainAlias}.${\n                    relation.joinColumns[0].propertyPath\n                } IN (${values.join(\", \")})`\n            } else {\n                qb.setParameter(\"values\", values)\n                condition =\n                    mainAlias +\n                    \".\" +\n                    relation.joinColumns[0].propertyPath +\n                    \" IN (:...values)\" // todo: use ANY for postgres\n            }\n        } else {\n            condition = entities\n                .map((entity, entityIndex) => {\n                    return relation.joinColumns\n                        .map((joinColumn, joinColumnIndex) => {\n                            const paramName =\n                                \"entity\" + entityIndex + \"_\" + joinColumnIndex\n                            qb.setParameter(\n                                paramName,\n                                joinColumn.referencedColumn!.getEntityValue(\n                                    entity,\n                                ),\n                            )\n                            return (\n                                mainAlias +\n                                \".\" +\n                                joinColumn.propertyPath +\n                                \" = :\" +\n                                paramName\n                            )\n                        })\n                        .join(\" AND \")\n                })\n                .map((condition) => \"(\" + condition + \")\")\n                .join(\" OR \")\n        }\n\n        // execute query\n        return qb\n            .from(relation.entityMetadata.target, mainAlias)\n            .where(condition)\n            .getRawMany()\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}