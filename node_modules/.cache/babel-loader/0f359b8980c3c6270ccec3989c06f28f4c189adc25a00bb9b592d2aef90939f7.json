{"ast":null,"code":"import { MssqlParameter } from \"../driver/sqlserver/MssqlParameter\";\nimport { Table } from \"../schema-builder/table/Table\";\nimport { v4 as uuidv4 } from \"uuid\";\n/**\n * Caches query result into current database, into separate table called \"query-result-cache\".\n */\nexport class DbQueryResultCache {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    this.connection = connection;\n    const {\n      schema\n    } = this.connection.driver.options;\n    const database = this.connection.driver.database;\n    const cacheOptions = typeof this.connection.options.cache === \"object\" ? this.connection.options.cache : {};\n    const cacheTableName = cacheOptions.tableName || \"query-result-cache\";\n    this.queryResultCacheDatabase = database;\n    this.queryResultCacheSchema = schema;\n    this.queryResultCacheTable = this.connection.driver.buildTableName(cacheTableName, schema, database);\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates a connection with given cache provider.\n   */\n  async connect() {}\n  /**\n   * Disconnects with given cache provider.\n   */\n  async disconnect() {}\n  /**\n   * Creates table for storing cache if it does not exist yet.\n   */\n  async synchronize(queryRunner) {\n    queryRunner = this.getQueryRunner(queryRunner);\n    const driver = this.connection.driver;\n    const tableExist = await queryRunner.hasTable(this.queryResultCacheTable); // todo: table name should be configurable\n    if (tableExist) return;\n    await queryRunner.createTable(new Table({\n      database: this.queryResultCacheDatabase,\n      schema: this.queryResultCacheSchema,\n      name: this.queryResultCacheTable,\n      columns: [{\n        name: \"id\",\n        isPrimary: true,\n        isNullable: false,\n        type: driver.normalizeType({\n          type: driver.mappedDataTypes.cacheId\n        }),\n        generationStrategy: driver.options.type === \"spanner\" ? \"uuid\" : \"increment\",\n        isGenerated: true\n      }, {\n        name: \"identifier\",\n        type: driver.normalizeType({\n          type: driver.mappedDataTypes.cacheIdentifier\n        }),\n        isNullable: true\n      }, {\n        name: \"time\",\n        type: driver.normalizeType({\n          type: driver.mappedDataTypes.cacheTime\n        }),\n        isPrimary: false,\n        isNullable: false\n      }, {\n        name: \"duration\",\n        type: driver.normalizeType({\n          type: driver.mappedDataTypes.cacheDuration\n        }),\n        isPrimary: false,\n        isNullable: false\n      }, {\n        name: \"query\",\n        type: driver.normalizeType({\n          type: driver.mappedDataTypes.cacheQuery\n        }),\n        isPrimary: false,\n        isNullable: false\n      }, {\n        name: \"result\",\n        type: driver.normalizeType({\n          type: driver.mappedDataTypes.cacheResult\n        }),\n        isNullable: false\n      }]\n    }));\n  }\n  /**\n   * Get data from cache.\n   * Returns cache result if found.\n   * Returns undefined if result is not cached.\n   */\n  getFromCache(options, queryRunner) {\n    queryRunner = this.getQueryRunner(queryRunner);\n    const qb = this.connection.createQueryBuilder(queryRunner).select().from(this.queryResultCacheTable, \"cache\");\n    if (options.identifier) {\n      return qb.where(`${qb.escape(\"cache\")}.${qb.escape(\"identifier\")} = :identifier`).setParameters({\n        identifier: this.connection.driver.options.type === \"mssql\" ? new MssqlParameter(options.identifier, \"nvarchar\") : options.identifier\n      }).cache(false) // disable cache to avoid infinite loops when cache is alwaysEnable\n      .getRawOne();\n    } else if (options.query) {\n      if (this.connection.driver.options.type === \"oracle\") {\n        return qb.where(`dbms_lob.compare(${qb.escape(\"cache\")}.${qb.escape(\"query\")}, :query) = 0`, {\n          query: options.query\n        }).cache(false) // disable cache to avoid infinite loops when cache is alwaysEnable\n        .getRawOne();\n      }\n      return qb.where(`${qb.escape(\"cache\")}.${qb.escape(\"query\")} = :query`).setParameters({\n        query: this.connection.driver.options.type === \"mssql\" ? new MssqlParameter(options.query, \"nvarchar\") : options.query\n      }).cache(false) // disable cache to avoid infinite loops when cache is alwaysEnable\n      .getRawOne();\n    }\n    return Promise.resolve(undefined);\n  }\n  /**\n   * Checks if cache is expired or not.\n   */\n  isExpired(savedCache) {\n    const duration = typeof savedCache.duration === \"string\" ? parseInt(savedCache.duration) : savedCache.duration;\n    return (typeof savedCache.time === \"string\" ? parseInt(savedCache.time) : savedCache.time) + duration < new Date().getTime();\n  }\n  /**\n   * Stores given query result in the cache.\n   */\n  async storeInCache(options, savedCache, queryRunner) {\n    const shouldCreateQueryRunner = queryRunner === undefined || queryRunner?.getReplicationMode() === \"slave\";\n    if (queryRunner === undefined || shouldCreateQueryRunner) {\n      queryRunner = this.connection.createQueryRunner(\"master\");\n    }\n    let insertedValues = options;\n    if (this.connection.driver.options.type === \"mssql\") {\n      // todo: bad abstraction, re-implement this part, probably better if we create an entity metadata for cache table\n      insertedValues = {\n        identifier: new MssqlParameter(options.identifier, \"nvarchar\"),\n        time: new MssqlParameter(options.time, \"bigint\"),\n        duration: new MssqlParameter(options.duration, \"int\"),\n        query: new MssqlParameter(options.query, \"nvarchar\"),\n        result: new MssqlParameter(options.result, \"nvarchar\")\n      };\n    }\n    if (savedCache && savedCache.identifier) {\n      // if exist then update\n      const qb = queryRunner.manager.createQueryBuilder().update(this.queryResultCacheTable).set(insertedValues);\n      qb.where(`${qb.escape(\"identifier\")} = :condition`, {\n        condition: insertedValues.identifier\n      });\n      await qb.execute();\n    } else if (savedCache && savedCache.query) {\n      // if exist then update\n      const qb = queryRunner.manager.createQueryBuilder().update(this.queryResultCacheTable).set(insertedValues);\n      if (this.connection.driver.options.type === \"oracle\") {\n        qb.where(`dbms_lob.compare(\"query\", :condition) = 0`, {\n          condition: insertedValues.query\n        });\n      } else {\n        qb.where(`${qb.escape(\"query\")} = :condition`, {\n          condition: insertedValues.query\n        });\n      }\n      await qb.execute();\n    } else {\n      // Spanner does not support auto-generated columns\n      if (this.connection.driver.options.type === \"spanner\" && !insertedValues.id) {\n        insertedValues.id = uuidv4();\n      }\n      // otherwise insert\n      await queryRunner.manager.createQueryBuilder().insert().into(this.queryResultCacheTable).values(insertedValues).execute();\n    }\n    if (shouldCreateQueryRunner) {\n      await queryRunner.release();\n    }\n  }\n  /**\n   * Clears everything stored in the cache.\n   */\n  async clear(queryRunner) {\n    return this.getQueryRunner(queryRunner).clearTable(this.queryResultCacheTable);\n  }\n  /**\n   * Removes all cached results by given identifiers from cache.\n   */\n  async remove(identifiers, queryRunner) {\n    let _queryRunner = queryRunner || this.getQueryRunner();\n    await Promise.all(identifiers.map(identifier => {\n      const qb = _queryRunner.manager.createQueryBuilder();\n      return qb.delete().from(this.queryResultCacheTable).where(`${qb.escape(\"identifier\")} = :identifier`, {\n        identifier\n      }).execute();\n    }));\n    if (!queryRunner) {\n      await _queryRunner.release();\n    }\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Gets a query runner to work with.\n   */\n  getQueryRunner(queryRunner) {\n    if (queryRunner) return queryRunner;\n    return this.connection.createQueryRunner();\n  }\n}","map":{"version":3,"names":["MssqlParameter","Table","v4","uuidv4","DbQueryResultCache","constructor","connection","schema","driver","options","database","cacheOptions","cache","cacheTableName","tableName","queryResultCacheDatabase","queryResultCacheSchema","queryResultCacheTable","buildTableName","connect","disconnect","synchronize","queryRunner","getQueryRunner","tableExist","hasTable","createTable","name","columns","isPrimary","isNullable","type","normalizeType","mappedDataTypes","cacheId","generationStrategy","isGenerated","cacheIdentifier","cacheTime","cacheDuration","cacheQuery","cacheResult","getFromCache","qb","createQueryBuilder","select","from","identifier","where","escape","setParameters","getRawOne","query","Promise","resolve","undefined","isExpired","savedCache","duration","parseInt","time","Date","getTime","storeInCache","shouldCreateQueryRunner","getReplicationMode","createQueryRunner","insertedValues","result","manager","update","set","condition","execute","id","insert","into","values","release","clear","clearTable","remove","identifiers","_queryRunner","all","map","delete"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\cache\\DbQueryResultCache.ts"],"sourcesContent":["import { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { MssqlParameter } from \"../driver/sqlserver/MssqlParameter\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { Table } from \"../schema-builder/table/Table\"\nimport { QueryResultCache } from \"./QueryResultCache\"\nimport { QueryResultCacheOptions } from \"./QueryResultCacheOptions\"\nimport { v4 as uuidv4 } from \"uuid\"\n\n/**\n * Caches query result into current database, into separate table called \"query-result-cache\".\n */\nexport class DbQueryResultCache implements QueryResultCache {\n    // -------------------------------------------------------------------------\n    // Private properties\n    // -------------------------------------------------------------------------\n\n    private queryResultCacheTable: string\n\n    private queryResultCacheDatabase?: string\n\n    private queryResultCacheSchema?: string\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected connection: DataSource) {\n        const { schema } = this.connection.driver.options as any\n        const database = this.connection.driver.database\n        const cacheOptions =\n            typeof this.connection.options.cache === \"object\"\n                ? this.connection.options.cache\n                : {}\n        const cacheTableName = cacheOptions.tableName || \"query-result-cache\"\n\n        this.queryResultCacheDatabase = database\n        this.queryResultCacheSchema = schema\n        this.queryResultCacheTable = this.connection.driver.buildTableName(\n            cacheTableName,\n            schema,\n            database,\n        )\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a connection with given cache provider.\n     */\n    async connect(): Promise<void> {}\n\n    /**\n     * Disconnects with given cache provider.\n     */\n    async disconnect(): Promise<void> {}\n\n    /**\n     * Creates table for storing cache if it does not exist yet.\n     */\n    async synchronize(queryRunner?: QueryRunner): Promise<void> {\n        queryRunner = this.getQueryRunner(queryRunner)\n        const driver = this.connection.driver\n        const tableExist = await queryRunner.hasTable(\n            this.queryResultCacheTable,\n        ) // todo: table name should be configurable\n        if (tableExist) return\n\n        await queryRunner.createTable(\n            new Table({\n                database: this.queryResultCacheDatabase,\n                schema: this.queryResultCacheSchema,\n                name: this.queryResultCacheTable,\n                columns: [\n                    {\n                        name: \"id\",\n                        isPrimary: true,\n                        isNullable: false,\n                        type: driver.normalizeType({\n                            type: driver.mappedDataTypes.cacheId,\n                        }),\n                        generationStrategy:\n                            driver.options.type === \"spanner\"\n                                ? \"uuid\"\n                                : \"increment\",\n                        isGenerated: true,\n                    },\n                    {\n                        name: \"identifier\",\n                        type: driver.normalizeType({\n                            type: driver.mappedDataTypes.cacheIdentifier,\n                        }),\n                        isNullable: true,\n                    },\n                    {\n                        name: \"time\",\n                        type: driver.normalizeType({\n                            type: driver.mappedDataTypes.cacheTime,\n                        }),\n                        isPrimary: false,\n                        isNullable: false,\n                    },\n                    {\n                        name: \"duration\",\n                        type: driver.normalizeType({\n                            type: driver.mappedDataTypes.cacheDuration,\n                        }),\n                        isPrimary: false,\n                        isNullable: false,\n                    },\n                    {\n                        name: \"query\",\n                        type: driver.normalizeType({\n                            type: driver.mappedDataTypes.cacheQuery,\n                        }),\n                        isPrimary: false,\n                        isNullable: false,\n                    },\n                    {\n                        name: \"result\",\n                        type: driver.normalizeType({\n                            type: driver.mappedDataTypes.cacheResult,\n                        }),\n                        isNullable: false,\n                    },\n                ],\n            }),\n        )\n    }\n\n    /**\n     * Get data from cache.\n     * Returns cache result if found.\n     * Returns undefined if result is not cached.\n     */\n    getFromCache(\n        options: QueryResultCacheOptions,\n        queryRunner?: QueryRunner,\n    ): Promise<QueryResultCacheOptions | undefined> {\n        queryRunner = this.getQueryRunner(queryRunner)\n        const qb = this.connection\n            .createQueryBuilder(queryRunner)\n            .select()\n            .from(this.queryResultCacheTable, \"cache\")\n\n        if (options.identifier) {\n            return qb\n                .where(\n                    `${qb.escape(\"cache\")}.${qb.escape(\n                        \"identifier\",\n                    )} = :identifier`,\n                )\n                .setParameters({\n                    identifier:\n                        this.connection.driver.options.type === \"mssql\"\n                            ? new MssqlParameter(options.identifier, \"nvarchar\")\n                            : options.identifier,\n                })\n                .cache(false) // disable cache to avoid infinite loops when cache is alwaysEnable\n                .getRawOne()\n        } else if (options.query) {\n            if (this.connection.driver.options.type === \"oracle\") {\n                return qb\n                    .where(\n                        `dbms_lob.compare(${qb.escape(\"cache\")}.${qb.escape(\n                            \"query\",\n                        )}, :query) = 0`,\n                        { query: options.query },\n                    )\n                    .cache(false) // disable cache to avoid infinite loops when cache is alwaysEnable\n                    .getRawOne()\n            }\n\n            return qb\n                .where(`${qb.escape(\"cache\")}.${qb.escape(\"query\")} = :query`)\n                .setParameters({\n                    query:\n                        this.connection.driver.options.type === \"mssql\"\n                            ? new MssqlParameter(options.query, \"nvarchar\")\n                            : options.query,\n                })\n                .cache(false) // disable cache to avoid infinite loops when cache is alwaysEnable\n                .getRawOne()\n        }\n\n        return Promise.resolve(undefined)\n    }\n\n    /**\n     * Checks if cache is expired or not.\n     */\n    isExpired(savedCache: QueryResultCacheOptions): boolean {\n        const duration =\n            typeof savedCache.duration === \"string\"\n                ? parseInt(savedCache.duration)\n                : savedCache.duration\n        return (\n            (typeof savedCache.time === \"string\"\n                ? parseInt(savedCache.time as any)\n                : savedCache.time)! +\n                duration <\n            new Date().getTime()\n        )\n    }\n\n    /**\n     * Stores given query result in the cache.\n     */\n    async storeInCache(\n        options: QueryResultCacheOptions,\n        savedCache: QueryResultCacheOptions | undefined,\n        queryRunner?: QueryRunner,\n    ): Promise<void> {\n        const shouldCreateQueryRunner =\n            queryRunner === undefined ||\n            queryRunner?.getReplicationMode() === \"slave\"\n\n        if (queryRunner === undefined || shouldCreateQueryRunner) {\n            queryRunner = this.connection.createQueryRunner(\"master\")\n        }\n\n        let insertedValues: ObjectLiteral = options\n        if (this.connection.driver.options.type === \"mssql\") {\n            // todo: bad abstraction, re-implement this part, probably better if we create an entity metadata for cache table\n            insertedValues = {\n                identifier: new MssqlParameter(options.identifier, \"nvarchar\"),\n                time: new MssqlParameter(options.time, \"bigint\"),\n                duration: new MssqlParameter(options.duration, \"int\"),\n                query: new MssqlParameter(options.query, \"nvarchar\"),\n                result: new MssqlParameter(options.result, \"nvarchar\"),\n            }\n        }\n\n        if (savedCache && savedCache.identifier) {\n            // if exist then update\n            const qb = queryRunner.manager\n                .createQueryBuilder()\n                .update(this.queryResultCacheTable)\n                .set(insertedValues)\n\n            qb.where(`${qb.escape(\"identifier\")} = :condition`, {\n                condition: insertedValues.identifier,\n            })\n            await qb.execute()\n        } else if (savedCache && savedCache.query) {\n            // if exist then update\n            const qb = queryRunner.manager\n                .createQueryBuilder()\n                .update(this.queryResultCacheTable)\n                .set(insertedValues)\n\n            if (this.connection.driver.options.type === \"oracle\") {\n                qb.where(`dbms_lob.compare(\"query\", :condition) = 0`, {\n                    condition: insertedValues.query,\n                })\n            } else {\n                qb.where(`${qb.escape(\"query\")} = :condition`, {\n                    condition: insertedValues.query,\n                })\n            }\n\n            await qb.execute()\n        } else {\n            // Spanner does not support auto-generated columns\n            if (\n                this.connection.driver.options.type === \"spanner\" &&\n                !insertedValues.id\n            ) {\n                insertedValues.id = uuidv4()\n            }\n\n            // otherwise insert\n            await queryRunner.manager\n                .createQueryBuilder()\n                .insert()\n                .into(this.queryResultCacheTable)\n                .values(insertedValues)\n                .execute()\n        }\n\n        if (shouldCreateQueryRunner) {\n            await queryRunner.release()\n        }\n    }\n\n    /**\n     * Clears everything stored in the cache.\n     */\n    async clear(queryRunner: QueryRunner): Promise<void> {\n        return this.getQueryRunner(queryRunner).clearTable(\n            this.queryResultCacheTable,\n        )\n    }\n\n    /**\n     * Removes all cached results by given identifiers from cache.\n     */\n    async remove(\n        identifiers: string[],\n        queryRunner?: QueryRunner,\n    ): Promise<void> {\n        let _queryRunner: QueryRunner = queryRunner || this.getQueryRunner()\n        await Promise.all(\n            identifiers.map((identifier) => {\n                const qb = _queryRunner.manager.createQueryBuilder()\n                return qb\n                    .delete()\n                    .from(this.queryResultCacheTable)\n                    .where(`${qb.escape(\"identifier\")} = :identifier`, {\n                        identifier,\n                    })\n                    .execute()\n            }),\n        )\n\n        if (!queryRunner) {\n            await _queryRunner.release()\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets a query runner to work with.\n     */\n    protected getQueryRunner(queryRunner?: QueryRunner): QueryRunner {\n        if (queryRunner) return queryRunner\n\n        return this.connection.createQueryRunner()\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}