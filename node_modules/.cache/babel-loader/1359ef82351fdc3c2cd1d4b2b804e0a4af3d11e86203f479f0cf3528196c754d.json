{"ast":null,"code":"import { OrmUtils } from \"../../util/OrmUtils\";\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\";\nimport { Brackets } from \"../../query-builder/Brackets\";\n/**\n * Executes subject operations for materialized-path tree entities.\n */\nexport class MaterializedPathSubjectExecutor {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(queryRunner) {\n    this.queryRunner = queryRunner;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Executes operations when subject is being inserted.\n   */\n  async insert(subject) {\n    let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent\n    if (!parent && subject.parentSubject && subject.parentSubject.entity)\n      // if entity was attached via children\n      parent = subject.parentSubject.insertedValueSet ? subject.parentSubject.insertedValueSet : subject.parentSubject.entity;\n    const parentId = subject.metadata.getEntityIdMap(parent);\n    let parentPath = \"\";\n    if (parentId) {\n      parentPath = await this.getEntityPath(subject, parentId);\n    }\n    const insertedEntityId = subject.metadata.treeParentRelation.joinColumns.map(joinColumn => {\n      return joinColumn.referencedColumn.getEntityValue(subject.insertedValueSet);\n    }).join(\"_\");\n    await this.queryRunner.manager.createQueryBuilder().update(subject.metadata.target).set({\n      [subject.metadata.materializedPathColumn.propertyPath]: parentPath + insertedEntityId + \".\"\n    }).where(subject.identifier).execute();\n  }\n  /**\n   * Executes operations when subject is being updated.\n   */\n  async update(subject) {\n    let newParent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent\n    if (!newParent && subject.parentSubject && subject.parentSubject.entity)\n      // if entity was attached via children\n      newParent = subject.parentSubject.entity;\n    let entity = subject.databaseEntity; // if entity was attached via parent\n    if (!entity && newParent)\n      // if entity was attached via children\n      entity = subject.metadata.treeChildrenRelation.getEntityValue(newParent).find(child => {\n        return Object.entries(subject.identifier).every(([key, value]) => child[key] === value);\n      });\n    const oldParent = subject.metadata.treeParentRelation.getEntityValue(entity);\n    const oldParentId = this.getEntityParentReferencedColumnMap(subject, oldParent);\n    const newParentId = this.getEntityParentReferencedColumnMap(subject, newParent);\n    // Exit if the new and old parents are the same\n    if (OrmUtils.compareIds(oldParentId, newParentId)) {\n      return;\n    }\n    let newParentPath = \"\";\n    if (newParentId) {\n      newParentPath = await this.getEntityPath(subject, newParentId);\n    }\n    let oldParentPath = \"\";\n    if (oldParentId) {\n      oldParentPath = (await this.getEntityPath(subject, oldParentId)) || \"\";\n    }\n    const entityPath = subject.metadata.treeParentRelation.joinColumns.map(joinColumn => {\n      return joinColumn.referencedColumn.getEntityValue(entity);\n    }).join(\"_\");\n    const propertyPath = subject.metadata.materializedPathColumn.propertyPath;\n    await this.queryRunner.manager.createQueryBuilder().update(subject.metadata.target).set({\n      [propertyPath]: () => `REPLACE(${this.queryRunner.connection.driver.escape(propertyPath)}, '${oldParentPath}${entityPath}.', '${newParentPath}${entityPath}.')`\n    }).where(`${propertyPath} LIKE :path`, {\n      path: `${oldParentPath}${entityPath}.%`\n    }).execute();\n  }\n  getEntityParentReferencedColumnMap(subject, entity) {\n    if (!entity) return undefined;\n    return EntityMetadata.getValueMap(entity, subject.metadata.treeParentRelation.joinColumns.map(column => column.referencedColumn).filter(v => v != null), {\n      skipNulls: true\n    });\n  }\n  getEntityPath(subject, id) {\n    const metadata = subject.metadata;\n    const normalized = (Array.isArray(id) ? id : [id]).map(id => metadata.ensureEntityIdMap(id));\n    return this.queryRunner.manager.createQueryBuilder().select(subject.metadata.targetName + \".\" + subject.metadata.materializedPathColumn.propertyPath, \"path\").from(subject.metadata.target, subject.metadata.targetName).where(new Brackets(qb => {\n      for (const data of normalized) {\n        qb.orWhere(new Brackets(qb => qb.where(data)));\n      }\n    })).getRawOne().then(result => result ? result[\"path\"] : \"\");\n  }\n}","map":{"version":3,"names":["OrmUtils","EntityMetadata","Brackets","MaterializedPathSubjectExecutor","constructor","queryRunner","insert","subject","parent","metadata","treeParentRelation","getEntityValue","entity","parentSubject","insertedValueSet","parentId","getEntityIdMap","parentPath","getEntityPath","insertedEntityId","joinColumns","map","joinColumn","referencedColumn","join","manager","createQueryBuilder","update","target","set","materializedPathColumn","propertyPath","where","identifier","execute","newParent","databaseEntity","treeChildrenRelation","find","child","Object","entries","every","key","value","oldParent","oldParentId","getEntityParentReferencedColumnMap","newParentId","compareIds","newParentPath","oldParentPath","entityPath","connection","driver","escape","path","undefined","getValueMap","column","filter","v","skipNulls","id","normalized","Array","isArray","ensureEntityIdMap","select","targetName","from","qb","data","orWhere","getRawOne","then","result"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\persistence\\tree\\MaterializedPathSubjectExecutor.ts"],"sourcesContent":["import { Subject } from \"../Subject\"\nimport { QueryRunner } from \"../../query-runner/QueryRunner\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { ColumnMetadata } from \"../../metadata/ColumnMetadata\"\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\"\nimport { Brackets } from \"../../query-builder/Brackets\"\n\n/**\n * Executes subject operations for materialized-path tree entities.\n */\nexport class MaterializedPathSubjectExecutor {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected queryRunner: QueryRunner) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes operations when subject is being inserted.\n     */\n    async insert(subject: Subject): Promise<void> {\n        let parent = subject.metadata.treeParentRelation!.getEntityValue(\n            subject.entity!,\n        ) // if entity was attached via parent\n        if (!parent && subject.parentSubject && subject.parentSubject.entity)\n            // if entity was attached via children\n            parent = subject.parentSubject.insertedValueSet\n                ? subject.parentSubject.insertedValueSet\n                : subject.parentSubject.entity\n\n        const parentId = subject.metadata.getEntityIdMap(parent)\n\n        let parentPath: string = \"\"\n        if (parentId) {\n            parentPath = await this.getEntityPath(subject, parentId)\n        }\n\n        const insertedEntityId = subject.metadata\n            .treeParentRelation!.joinColumns.map((joinColumn) => {\n                return joinColumn.referencedColumn!.getEntityValue(\n                    subject.insertedValueSet!,\n                )\n            })\n            .join(\"_\")\n\n        await this.queryRunner.manager\n            .createQueryBuilder()\n            .update(subject.metadata.target)\n            .set({\n                [subject.metadata.materializedPathColumn!.propertyPath]:\n                    parentPath + insertedEntityId + \".\",\n            } as any)\n            .where(subject.identifier!)\n            .execute()\n    }\n\n    /**\n     * Executes operations when subject is being updated.\n     */\n    async update(subject: Subject): Promise<void> {\n        let newParent = subject.metadata.treeParentRelation!.getEntityValue(\n            subject.entity!,\n        ) // if entity was attached via parent\n        if (!newParent && subject.parentSubject && subject.parentSubject.entity)\n            // if entity was attached via children\n            newParent = subject.parentSubject.entity\n\n        let entity = subject.databaseEntity // if entity was attached via parent\n        if (!entity && newParent)\n            // if entity was attached via children\n            entity = subject.metadata\n                .treeChildrenRelation!.getEntityValue(newParent)\n                .find((child: any) => {\n                    return Object.entries(subject.identifier!).every(\n                        ([key, value]) => child[key] === value,\n                    )\n                })\n\n        const oldParent = subject.metadata.treeParentRelation!.getEntityValue(\n            entity!,\n        )\n        const oldParentId = this.getEntityParentReferencedColumnMap(\n            subject,\n            oldParent,\n        )\n        const newParentId = this.getEntityParentReferencedColumnMap(\n            subject,\n            newParent,\n        )\n\n        // Exit if the new and old parents are the same\n        if (OrmUtils.compareIds(oldParentId, newParentId)) {\n            return\n        }\n\n        let newParentPath: string = \"\"\n        if (newParentId) {\n            newParentPath = await this.getEntityPath(subject, newParentId)\n        }\n\n        let oldParentPath: string = \"\"\n        if (oldParentId) {\n            oldParentPath =\n                (await this.getEntityPath(subject, oldParentId)) || \"\"\n        }\n\n        const entityPath = subject.metadata\n            .treeParentRelation!.joinColumns.map((joinColumn) => {\n                return joinColumn.referencedColumn!.getEntityValue(entity!)\n            })\n            .join(\"_\")\n\n        const propertyPath =\n            subject.metadata.materializedPathColumn!.propertyPath\n        await this.queryRunner.manager\n            .createQueryBuilder()\n            .update(subject.metadata.target)\n            .set({\n                [propertyPath]: () =>\n                    `REPLACE(${this.queryRunner.connection.driver.escape(\n                        propertyPath,\n                    )}, '${oldParentPath}${entityPath}.', '${newParentPath}${entityPath}.')`,\n            } as any)\n            .where(`${propertyPath} LIKE :path`, {\n                path: `${oldParentPath}${entityPath}.%`,\n            })\n            .execute()\n    }\n\n    private getEntityParentReferencedColumnMap(\n        subject: Subject,\n        entity: ObjectLiteral | undefined,\n    ): ObjectLiteral | undefined {\n        if (!entity) return undefined\n        return EntityMetadata.getValueMap(\n            entity,\n            subject.metadata\n                .treeParentRelation!.joinColumns.map(\n                    (column) => column.referencedColumn,\n                )\n                .filter((v) => v != null) as ColumnMetadata[],\n            { skipNulls: true },\n        )\n    }\n\n    private getEntityPath(\n        subject: Subject,\n        id: ObjectLiteral,\n    ): Promise<string> {\n        const metadata = subject.metadata\n        const normalized = (Array.isArray(id) ? id : [id]).map((id) =>\n            metadata.ensureEntityIdMap(id),\n        )\n        return this.queryRunner.manager\n            .createQueryBuilder()\n            .select(\n                subject.metadata.targetName +\n                    \".\" +\n                    subject.metadata.materializedPathColumn!.propertyPath,\n                \"path\",\n            )\n            .from(subject.metadata.target, subject.metadata.targetName)\n            .where(\n                new Brackets((qb) => {\n                    for (const data of normalized) {\n                        qb.orWhere(new Brackets((qb) => qb.where(data)))\n                    }\n                }),\n            )\n            .getRawOne()\n            .then((result) => (result ? result[\"path\"] : \"\"))\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}