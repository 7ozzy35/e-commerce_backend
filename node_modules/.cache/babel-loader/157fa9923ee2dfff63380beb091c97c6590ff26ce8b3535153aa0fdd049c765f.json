{"ast":null,"code":"/**\n * This source code is from https://github.com/jriecken/dependency-graph\n * Just added \"any\" types here, wrapper everything into exported class.\n * We cant use a package itself because we want to package \"everything-in-it\" for the frontend users of TypeORM.\n */\n/**\n * A simple dependency graph\n */\nimport { TypeORMError } from \"../error\";\n/**\n * Helper for creating a Depth-First-Search on\n * a set of edges.\n *\n * Detects cycles and throws an Error if one is detected.\n *\n * @param edges The set of edges to DFS through\n * @param leavesOnly Whether to only return \"leaf\" nodes (ones who have no edges)\n * @param result An array in which the results will be populated\n */\nfunction createDFS(edges, leavesOnly, result) {\n  let currentPath = [];\n  let visited = {};\n  return function DFS(currentNode) {\n    visited[currentNode] = true;\n    currentPath.push(currentNode);\n    edges[currentNode].forEach(function (node) {\n      if (!visited[node]) {\n        DFS(node);\n      } else if (currentPath.indexOf(node) >= 0) {\n        currentPath.push(node);\n        throw new TypeORMError(`Dependency Cycle Found: ${currentPath.join(\" -> \")}`);\n      }\n    });\n    currentPath.pop();\n    if ((!leavesOnly || edges[currentNode].length === 0) && result.indexOf(currentNode) === -1) {\n      result.push(currentNode);\n    }\n  };\n}\nexport class DepGraph {\n  constructor() {\n    this.nodes = {};\n    this.outgoingEdges = {}; // Node -> [Dependency Node]\n    this.incomingEdges = {}; // Node -> [Dependant Node]\n  }\n  /**\n   * Add a node to the dependency graph. If a node already exists, this method will do nothing.\n   */\n  addNode(node, data) {\n    if (!this.hasNode(node)) {\n      // Checking the arguments length allows the user to add a node with undefined data\n      if (arguments.length === 2) {\n        this.nodes[node] = data;\n      } else {\n        this.nodes[node] = node;\n      }\n      this.outgoingEdges[node] = [];\n      this.incomingEdges[node] = [];\n    }\n  }\n  /**\n   * Remove a node from the dependency graph. If a node does not exist, this method will do nothing.\n   */\n  removeNode(node) {\n    if (this.hasNode(node)) {\n      delete this.nodes[node];\n      delete this.outgoingEdges[node];\n      delete this.incomingEdges[node];\n      [this.incomingEdges, this.outgoingEdges].forEach(function (edgeList) {\n        Object.keys(edgeList).forEach(function (key) {\n          const idx = edgeList[key].indexOf(node);\n          if (idx >= 0) {\n            edgeList[key].splice(idx, 1);\n          }\n        });\n      });\n    }\n  }\n  /**\n   * Check if a node exists in the graph\n   */\n  hasNode(node) {\n    return this.nodes.hasOwnProperty(node);\n  }\n  /**\n   * Get the data associated with a node name\n   */\n  getNodeData(node) {\n    if (this.hasNode(node)) {\n      return this.nodes[node];\n    } else {\n      throw new TypeORMError(`Node does not exist: ${node}`);\n    }\n  }\n  /**\n   * Set the associated data for a given node name. If the node does not exist, this method will throw an error\n   */\n  setNodeData(node, data) {\n    if (this.hasNode(node)) {\n      this.nodes[node] = data;\n    } else {\n      throw new TypeORMError(`Node does not exist: ${node}`);\n    }\n  }\n  /**\n   * Add a dependency between two nodes. If either of the nodes does not exist,\n   * an Error will be thrown.\n   */\n  addDependency(from, to) {\n    if (!this.hasNode(from)) {\n      throw new TypeORMError(`Node does not exist: ${from}`);\n    }\n    if (!this.hasNode(to)) {\n      throw new TypeORMError(`Node does not exist: ${to}`);\n    }\n    if (this.outgoingEdges[from].indexOf(to) === -1) {\n      this.outgoingEdges[from].push(to);\n    }\n    if (this.incomingEdges[to].indexOf(from) === -1) {\n      this.incomingEdges[to].push(from);\n    }\n    return true;\n  }\n  /**\n   * Remove a dependency between two nodes.\n   */\n  removeDependency(from, to) {\n    let idx;\n    if (this.hasNode(from)) {\n      idx = this.outgoingEdges[from].indexOf(to);\n      if (idx >= 0) {\n        this.outgoingEdges[from].splice(idx, 1);\n      }\n    }\n    if (this.hasNode(to)) {\n      idx = this.incomingEdges[to].indexOf(from);\n      if (idx >= 0) {\n        this.incomingEdges[to].splice(idx, 1);\n      }\n    }\n  }\n  /**\n   * Get an array containing the nodes that the specified node depends on (transitively).\n   *\n   * Throws an Error if the graph has a cycle, or the specified node does not exist.\n   *\n   * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned\n   * in the array.\n   */\n  dependenciesOf(node, leavesOnly) {\n    if (this.hasNode(node)) {\n      let result = [];\n      let DFS = createDFS(this.outgoingEdges, leavesOnly, result);\n      DFS(node);\n      let idx = result.indexOf(node);\n      if (idx >= 0) {\n        result.splice(idx, 1);\n      }\n      return result;\n    } else {\n      throw new TypeORMError(`Node does not exist: ${node}`);\n    }\n  }\n  /**\n   * get an array containing the nodes that depend on the specified node (transitively).\n   *\n   * Throws an Error if the graph has a cycle, or the specified node does not exist.\n   *\n   * If `leavesOnly` is true, only nodes that do not have any dependants will be returned in the array.\n   */\n  dependantsOf(node, leavesOnly) {\n    if (this.hasNode(node)) {\n      let result = [];\n      let DFS = createDFS(this.incomingEdges, leavesOnly, result);\n      DFS(node);\n      let idx = result.indexOf(node);\n      if (idx >= 0) {\n        result.splice(idx, 1);\n      }\n      return result;\n    } else {\n      throw new TypeORMError(`Node does not exist: ${node}`);\n    }\n  }\n  /**\n   * Construct the overall processing order for the dependency graph.\n   *\n   * Throws an Error if the graph has a cycle.\n   *\n   * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned.\n   */\n  overallOrder(leavesOnly) {\n    let self = this;\n    let result = [];\n    let keys = Object.keys(this.nodes);\n    if (keys.length === 0) {\n      return result; // Empty graph\n    } else {\n      // Look for cycles - we run the DFS starting at all the nodes in case there\n      // are several disconnected subgraphs inside this dependency graph.\n      let CycleDFS = createDFS(this.outgoingEdges, false, []);\n      keys.forEach(function (n) {\n        CycleDFS(n);\n      });\n      let DFS = createDFS(this.outgoingEdges, leavesOnly, result);\n      // Find all potential starting points (nodes with nothing depending on them) an\n      // run a DFS starting at these points to get the order\n      keys.filter(function (node) {\n        return self.incomingEdges[node].length === 0;\n      }).forEach(function (n) {\n        DFS(n);\n      });\n      return result;\n    }\n  }\n}","map":{"version":3,"names":["TypeORMError","createDFS","edges","leavesOnly","result","currentPath","visited","DFS","currentNode","push","forEach","node","indexOf","join","pop","length","DepGraph","constructor","nodes","outgoingEdges","incomingEdges","addNode","data","hasNode","arguments","removeNode","edgeList","Object","keys","key","idx","splice","hasOwnProperty","getNodeData","setNodeData","addDependency","from","to","removeDependency","dependenciesOf","dependantsOf","overallOrder","self","CycleDFS","n","filter"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\util\\DepGraph.ts"],"sourcesContent":["/**\n * This source code is from https://github.com/jriecken/dependency-graph\n * Just added \"any\" types here, wrapper everything into exported class.\n * We cant use a package itself because we want to package \"everything-in-it\" for the frontend users of TypeORM.\n */\n\n/**\n * A simple dependency graph\n */\n\nimport { TypeORMError } from \"../error\"\n\n/**\n * Helper for creating a Depth-First-Search on\n * a set of edges.\n *\n * Detects cycles and throws an Error if one is detected.\n *\n * @param edges The set of edges to DFS through\n * @param leavesOnly Whether to only return \"leaf\" nodes (ones who have no edges)\n * @param result An array in which the results will be populated\n */\nfunction createDFS(edges: any, leavesOnly: any, result: any) {\n    let currentPath: any[] = []\n    let visited: any = {}\n    return function DFS(currentNode: any) {\n        visited[currentNode] = true\n        currentPath.push(currentNode)\n        edges[currentNode].forEach(function (node: any) {\n            if (!visited[node]) {\n                DFS(node)\n            } else if (currentPath.indexOf(node) >= 0) {\n                currentPath.push(node)\n                throw new TypeORMError(\n                    `Dependency Cycle Found: ${currentPath.join(\" -> \")}`,\n                )\n            }\n        })\n        currentPath.pop()\n        if (\n            (!leavesOnly || edges[currentNode].length === 0) &&\n            result.indexOf(currentNode) === -1\n        ) {\n            result.push(currentNode)\n        }\n    }\n}\n\nexport class DepGraph {\n    nodes: any = {}\n    outgoingEdges: any = {} // Node -> [Dependency Node]\n    incomingEdges: any = {} // Node -> [Dependant Node]\n\n    /**\n     * Add a node to the dependency graph. If a node already exists, this method will do nothing.\n     */\n    addNode(node: any, data?: any) {\n        if (!this.hasNode(node)) {\n            // Checking the arguments length allows the user to add a node with undefined data\n            if (arguments.length === 2) {\n                this.nodes[node] = data\n            } else {\n                this.nodes[node] = node\n            }\n            this.outgoingEdges[node] = []\n            this.incomingEdges[node] = []\n        }\n    }\n\n    /**\n     * Remove a node from the dependency graph. If a node does not exist, this method will do nothing.\n     */\n    removeNode(node: any) {\n        if (this.hasNode(node)) {\n            delete this.nodes[node]\n            delete this.outgoingEdges[node]\n            delete this.incomingEdges[node]\n            ;[this.incomingEdges, this.outgoingEdges].forEach(function (\n                edgeList,\n            ) {\n                Object.keys(edgeList).forEach(function (key: any) {\n                    const idx = edgeList[key].indexOf(node)\n                    if (idx >= 0) {\n                        edgeList[key].splice(idx, 1)\n                    }\n                })\n            })\n        }\n    }\n\n    /**\n     * Check if a node exists in the graph\n     */\n    hasNode(node: any) {\n        return this.nodes.hasOwnProperty(node)\n    }\n\n    /**\n     * Get the data associated with a node name\n     */\n    getNodeData(node: any) {\n        if (this.hasNode(node)) {\n            return this.nodes[node]\n        } else {\n            throw new TypeORMError(`Node does not exist: ${node}`)\n        }\n    }\n\n    /**\n     * Set the associated data for a given node name. If the node does not exist, this method will throw an error\n     */\n    setNodeData(node: any, data: any) {\n        if (this.hasNode(node)) {\n            this.nodes[node] = data\n        } else {\n            throw new TypeORMError(`Node does not exist: ${node}`)\n        }\n    }\n\n    /**\n     * Add a dependency between two nodes. If either of the nodes does not exist,\n     * an Error will be thrown.\n     */\n    addDependency(from: any, to: any) {\n        if (!this.hasNode(from)) {\n            throw new TypeORMError(`Node does not exist: ${from}`)\n        }\n        if (!this.hasNode(to)) {\n            throw new TypeORMError(`Node does not exist: ${to}`)\n        }\n        if (this.outgoingEdges[from].indexOf(to) === -1) {\n            this.outgoingEdges[from].push(to)\n        }\n        if (this.incomingEdges[to].indexOf(from) === -1) {\n            this.incomingEdges[to].push(from)\n        }\n        return true\n    }\n\n    /**\n     * Remove a dependency between two nodes.\n     */\n    removeDependency(from: any, to: any) {\n        let idx: any\n        if (this.hasNode(from)) {\n            idx = this.outgoingEdges[from].indexOf(to)\n            if (idx >= 0) {\n                this.outgoingEdges[from].splice(idx, 1)\n            }\n        }\n\n        if (this.hasNode(to)) {\n            idx = this.incomingEdges[to].indexOf(from)\n            if (idx >= 0) {\n                this.incomingEdges[to].splice(idx, 1)\n            }\n        }\n    }\n\n    /**\n     * Get an array containing the nodes that the specified node depends on (transitively).\n     *\n     * Throws an Error if the graph has a cycle, or the specified node does not exist.\n     *\n     * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned\n     * in the array.\n     */\n    dependenciesOf(node: any, leavesOnly: any) {\n        if (this.hasNode(node)) {\n            let result: any[] = []\n            let DFS = createDFS(this.outgoingEdges, leavesOnly, result)\n            DFS(node)\n            let idx = result.indexOf(node)\n            if (idx >= 0) {\n                result.splice(idx, 1)\n            }\n            return result\n        } else {\n            throw new TypeORMError(`Node does not exist: ${node}`)\n        }\n    }\n\n    /**\n     * get an array containing the nodes that depend on the specified node (transitively).\n     *\n     * Throws an Error if the graph has a cycle, or the specified node does not exist.\n     *\n     * If `leavesOnly` is true, only nodes that do not have any dependants will be returned in the array.\n     */\n    dependantsOf(node: any, leavesOnly: any) {\n        if (this.hasNode(node)) {\n            let result: any[] = []\n            let DFS = createDFS(this.incomingEdges, leavesOnly, result)\n            DFS(node)\n            let idx = result.indexOf(node)\n            if (idx >= 0) {\n                result.splice(idx, 1)\n            }\n            return result\n        } else {\n            throw new TypeORMError(`Node does not exist: ${node}`)\n        }\n    }\n\n    /**\n     * Construct the overall processing order for the dependency graph.\n     *\n     * Throws an Error if the graph has a cycle.\n     *\n     * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned.\n     */\n    overallOrder(leavesOnly?: any) {\n        let self = this\n        let result: any[] = []\n        let keys = Object.keys(this.nodes)\n        if (keys.length === 0) {\n            return result // Empty graph\n        } else {\n            // Look for cycles - we run the DFS starting at all the nodes in case there\n            // are several disconnected subgraphs inside this dependency graph.\n            let CycleDFS = createDFS(this.outgoingEdges, false, [])\n            keys.forEach(function (n: any) {\n                CycleDFS(n)\n            })\n\n            let DFS = createDFS(this.outgoingEdges, leavesOnly, result)\n            // Find all potential starting points (nodes with nothing depending on them) an\n            // run a DFS starting at these points to get the order\n            keys.filter(function (node) {\n                return self.incomingEdges[node].length === 0\n            }).forEach(function (n) {\n                DFS(n)\n            })\n\n            return result\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}