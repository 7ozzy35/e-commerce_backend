{"ast":null,"code":"import { QueryBuilder } from \"./QueryBuilder\";\nimport { RelationUpdater } from \"./RelationUpdater\";\nimport { RelationRemover } from \"./RelationRemover\";\nimport { TypeORMError } from \"../error\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\n/**\n * Allows to work with entity relations and perform specific operations with those relations.\n *\n * todo: add transactions everywhere\n */\nexport class RelationQueryBuilder extends QueryBuilder {\n  constructor() {\n    super(...arguments);\n    this[\"@instanceof\"] = Symbol.for(\"RelationQueryBuilder\");\n  }\n  // -------------------------------------------------------------------------\n  // Public Implemented Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Gets generated SQL query without parameters being replaced.\n   */\n  getQuery() {\n    return \"\";\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Sets entity (target) which relations will be updated.\n   */\n  of(entity) {\n    this.expressionMap.of = entity;\n    return this;\n  }\n  /**\n   * Sets entity relation's value.\n   * Value can be entity, entity id or entity id map (if entity has composite ids).\n   * Works only for many-to-one and one-to-one relations.\n   * For many-to-many and one-to-many relations use #add and #remove methods instead.\n   */\n  async set(value) {\n    const relation = this.expressionMap.relationMetadata;\n    if (!this.expressionMap.of)\n      // todo: move this check before relation query builder creation?\n      throw new TypeORMError(`Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`);\n    if (relation.isManyToMany || relation.isOneToMany) throw new TypeORMError(`Set operation is only supported for many-to-one and one-to-one relations. ` + `However given \"${relation.propertyPath}\" has ${relation.relationType} relation. ` + `Use .add() method instead.`);\n    // if there are multiple join columns then user must send id map as \"value\" argument. check if he really did it\n    if (relation.joinColumns && relation.joinColumns.length > 1 && (!ObjectUtils.isObject(value) || Object.keys(value).length < relation.joinColumns.length)) throw new TypeORMError(`Value to be set into the relation must be a map of relation ids, for example: .set({ firstName: \"...\", lastName: \"...\" })`);\n    const updater = new RelationUpdater(this, this.expressionMap);\n    return updater.update(value);\n  }\n  /**\n   * Adds (binds) given value to entity relation.\n   * Value can be entity, entity id or entity id map (if entity has composite ids).\n   * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).\n   * Works only for many-to-many and one-to-many relations.\n   * For many-to-one and one-to-one use #set method instead.\n   */\n  async add(value) {\n    if (Array.isArray(value) && value.length === 0) return;\n    const relation = this.expressionMap.relationMetadata;\n    if (!this.expressionMap.of)\n      // todo: move this check before relation query builder creation?\n      throw new TypeORMError(`Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`);\n    if (relation.isManyToOne || relation.isOneToOne) throw new TypeORMError(`Add operation is only supported for many-to-many and one-to-many relations. ` + `However given \"${relation.propertyPath}\" has ${relation.relationType} relation. ` + `Use .set() method instead.`);\n    // if there are multiple join columns then user must send id map as \"value\" argument. check if he really did it\n    if (relation.joinColumns && relation.joinColumns.length > 1 && (!ObjectUtils.isObject(value) || Object.keys(value).length < relation.joinColumns.length)) throw new TypeORMError(`Value to be set into the relation must be a map of relation ids, for example: .set({ firstName: \"...\", lastName: \"...\" })`);\n    const updater = new RelationUpdater(this, this.expressionMap);\n    return updater.update(value);\n  }\n  /**\n   * Removes (unbinds) given value from entity relation.\n   * Value can be entity, entity id or entity id map (if entity has composite ids).\n   * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).\n   * Works only for many-to-many and one-to-many relations.\n   * For many-to-one and one-to-one use #set method instead.\n   */\n  async remove(value) {\n    if (Array.isArray(value) && value.length === 0) return;\n    const relation = this.expressionMap.relationMetadata;\n    if (!this.expressionMap.of)\n      // todo: move this check before relation query builder creation?\n      throw new TypeORMError(`Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`);\n    if (relation.isManyToOne || relation.isOneToOne) throw new TypeORMError(`Add operation is only supported for many-to-many and one-to-many relations. ` + `However given \"${relation.propertyPath}\" has ${relation.relationType} relation. ` + `Use .set(null) method instead.`);\n    const remover = new RelationRemover(this, this.expressionMap);\n    return remover.remove(value);\n  }\n  /**\n   * Adds (binds) and removes (unbinds) given values to/from entity relation.\n   * Value can be entity, entity id or entity id map (if entity has composite ids).\n   * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).\n   * Works only for many-to-many and one-to-many relations.\n   * For many-to-one and one-to-one use #set method instead.\n   */\n  async addAndRemove(added, removed) {\n    await this.remove(removed);\n    await this.add(added);\n  }\n  /**\n   * Gets entity's relation id.\n  async getId(): Promise<any> {\n   }*/\n  /**\n   * Gets entity's relation ids.\n  async getIds(): Promise<any[]> {\n      return [];\n  }*/\n  /**\n   * Loads a single entity (relational) from the relation.\n   * You can also provide id of relational entity to filter by.\n   */\n  async loadOne() {\n    return this.loadMany().then(results => results[0]);\n  }\n  /**\n   * Loads many entities (relational) from the relation.\n   * You can also provide ids of relational entities to filter by.\n   */\n  async loadMany() {\n    let of = this.expressionMap.of;\n    if (!ObjectUtils.isObject(of)) {\n      const metadata = this.expressionMap.mainAlias.metadata;\n      if (metadata.hasMultiplePrimaryKeys) throw new TypeORMError(`Cannot load entity because only one primary key was specified, however entity contains multiple primary keys`);\n      of = metadata.primaryColumns[0].createValueMap(of);\n    }\n    return this.connection.relationLoader.load(this.expressionMap.relationMetadata, of, this.queryRunner);\n  }\n}","map":{"version":3,"names":["QueryBuilder","RelationUpdater","RelationRemover","TypeORMError","ObjectUtils","RelationQueryBuilder","constructor","Symbol","for","getQuery","of","entity","expressionMap","set","value","relation","relationMetadata","isManyToMany","isOneToMany","propertyPath","relationType","joinColumns","length","isObject","Object","keys","updater","update","add","Array","isArray","isManyToOne","isOneToOne","remove","remover","addAndRemove","added","removed","loadOne","loadMany","then","results","metadata","mainAlias","hasMultiplePrimaryKeys","primaryColumns","createValueMap","connection","relationLoader","load","queryRunner"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\query-builder\\RelationQueryBuilder.ts"],"sourcesContent":["import { QueryBuilder } from \"./QueryBuilder\"\nimport { RelationUpdater } from \"./RelationUpdater\"\nimport { RelationRemover } from \"./RelationRemover\"\nimport { TypeORMError } from \"../error\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\n\n/**\n * Allows to work with entity relations and perform specific operations with those relations.\n *\n * todo: add transactions everywhere\n */\nexport class RelationQueryBuilder<\n    Entity extends ObjectLiteral,\n> extends QueryBuilder<Entity> {\n    readonly \"@instanceof\" = Symbol.for(\"RelationQueryBuilder\")\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets generated SQL query without parameters being replaced.\n     */\n    getQuery(): string {\n        return \"\"\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Sets entity (target) which relations will be updated.\n     */\n    of(entity: any | any[]): this {\n        this.expressionMap.of = entity\n        return this\n    }\n\n    /**\n     * Sets entity relation's value.\n     * Value can be entity, entity id or entity id map (if entity has composite ids).\n     * Works only for many-to-one and one-to-one relations.\n     * For many-to-many and one-to-many relations use #add and #remove methods instead.\n     */\n    async set(value: any): Promise<void> {\n        const relation = this.expressionMap.relationMetadata\n\n        if (!this.expressionMap.of)\n            // todo: move this check before relation query builder creation?\n            throw new TypeORMError(\n                `Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`,\n            )\n\n        if (relation.isManyToMany || relation.isOneToMany)\n            throw new TypeORMError(\n                `Set operation is only supported for many-to-one and one-to-one relations. ` +\n                    `However given \"${relation.propertyPath}\" has ${relation.relationType} relation. ` +\n                    `Use .add() method instead.`,\n            )\n\n        // if there are multiple join columns then user must send id map as \"value\" argument. check if he really did it\n        if (\n            relation.joinColumns &&\n            relation.joinColumns.length > 1 &&\n            (!ObjectUtils.isObject(value) ||\n                Object.keys(value).length < relation.joinColumns.length)\n        )\n            throw new TypeORMError(\n                `Value to be set into the relation must be a map of relation ids, for example: .set({ firstName: \"...\", lastName: \"...\" })`,\n            )\n\n        const updater = new RelationUpdater(this, this.expressionMap)\n        return updater.update(value)\n    }\n\n    /**\n     * Adds (binds) given value to entity relation.\n     * Value can be entity, entity id or entity id map (if entity has composite ids).\n     * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).\n     * Works only for many-to-many and one-to-many relations.\n     * For many-to-one and one-to-one use #set method instead.\n     */\n    async add(value: any | any[]): Promise<void> {\n        if (Array.isArray(value) && value.length === 0) return\n\n        const relation = this.expressionMap.relationMetadata\n\n        if (!this.expressionMap.of)\n            // todo: move this check before relation query builder creation?\n            throw new TypeORMError(\n                `Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`,\n            )\n\n        if (relation.isManyToOne || relation.isOneToOne)\n            throw new TypeORMError(\n                `Add operation is only supported for many-to-many and one-to-many relations. ` +\n                    `However given \"${relation.propertyPath}\" has ${relation.relationType} relation. ` +\n                    `Use .set() method instead.`,\n            )\n\n        // if there are multiple join columns then user must send id map as \"value\" argument. check if he really did it\n        if (\n            relation.joinColumns &&\n            relation.joinColumns.length > 1 &&\n            (!ObjectUtils.isObject(value) ||\n                Object.keys(value).length < relation.joinColumns.length)\n        )\n            throw new TypeORMError(\n                `Value to be set into the relation must be a map of relation ids, for example: .set({ firstName: \"...\", lastName: \"...\" })`,\n            )\n\n        const updater = new RelationUpdater(this, this.expressionMap)\n        return updater.update(value)\n    }\n\n    /**\n     * Removes (unbinds) given value from entity relation.\n     * Value can be entity, entity id or entity id map (if entity has composite ids).\n     * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).\n     * Works only for many-to-many and one-to-many relations.\n     * For many-to-one and one-to-one use #set method instead.\n     */\n    async remove(value: any | any[]): Promise<void> {\n        if (Array.isArray(value) && value.length === 0) return\n\n        const relation = this.expressionMap.relationMetadata\n\n        if (!this.expressionMap.of)\n            // todo: move this check before relation query builder creation?\n            throw new TypeORMError(\n                `Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`,\n            )\n\n        if (relation.isManyToOne || relation.isOneToOne)\n            throw new TypeORMError(\n                `Add operation is only supported for many-to-many and one-to-many relations. ` +\n                    `However given \"${relation.propertyPath}\" has ${relation.relationType} relation. ` +\n                    `Use .set(null) method instead.`,\n            )\n\n        const remover = new RelationRemover(this, this.expressionMap)\n        return remover.remove(value)\n    }\n\n    /**\n     * Adds (binds) and removes (unbinds) given values to/from entity relation.\n     * Value can be entity, entity id or entity id map (if entity has composite ids).\n     * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).\n     * Works only for many-to-many and one-to-many relations.\n     * For many-to-one and one-to-one use #set method instead.\n     */\n    async addAndRemove(\n        added: any | any[],\n        removed: any | any[],\n    ): Promise<void> {\n        await this.remove(removed)\n        await this.add(added)\n    }\n\n    /**\n     * Gets entity's relation id.\n    async getId(): Promise<any> {\n\n    }*/\n\n    /**\n     * Gets entity's relation ids.\n    async getIds(): Promise<any[]> {\n        return [];\n    }*/\n\n    /**\n     * Loads a single entity (relational) from the relation.\n     * You can also provide id of relational entity to filter by.\n     */\n    async loadOne<T = any>(): Promise<T | undefined> {\n        return this.loadMany<T>().then((results) => results[0])\n    }\n\n    /**\n     * Loads many entities (relational) from the relation.\n     * You can also provide ids of relational entities to filter by.\n     */\n    async loadMany<T = any>(): Promise<T[]> {\n        let of = this.expressionMap.of\n        if (!ObjectUtils.isObject(of)) {\n            const metadata = this.expressionMap.mainAlias!.metadata\n            if (metadata.hasMultiplePrimaryKeys)\n                throw new TypeORMError(\n                    `Cannot load entity because only one primary key was specified, however entity contains multiple primary keys`,\n                )\n\n            of = metadata.primaryColumns[0].createValueMap(of)\n        }\n\n        return this.connection.relationLoader.load(\n            this.expressionMap.relationMetadata,\n            of,\n            this.queryRunner,\n        )\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}