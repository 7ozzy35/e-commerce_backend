{"ast":null,"code":"import { MetadataUtils } from \"../metadata-builder/MetadataUtils\";\n/**\n * Storage all metadatas args of all available types: tables, columns, subscribers, relations, etc.\n * Each metadata args represents some specifications of what it represents.\n * MetadataArgs used to create a real Metadata objects.\n */\nexport class MetadataArgsStorage {\n  constructor() {\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n    this.tables = [];\n    this.trees = [];\n    this.entityRepositories = [];\n    this.transactionEntityManagers = [];\n    this.transactionRepositories = [];\n    this.namingStrategies = [];\n    this.entitySubscribers = [];\n    this.indices = [];\n    this.uniques = [];\n    this.checks = [];\n    this.exclusions = [];\n    this.columns = [];\n    this.generations = [];\n    this.relations = [];\n    this.joinColumns = [];\n    this.joinTables = [];\n    this.entityListeners = [];\n    this.relationCounts = [];\n    this.relationIds = [];\n    this.embeddeds = [];\n    this.inheritances = [];\n    this.discriminatorValues = [];\n  }\n  filterTables(target) {\n    return this.filterByTarget(this.tables, target);\n  }\n  filterColumns(target) {\n    return this.filterByTargetAndWithoutDuplicateProperties(this.columns, target);\n  }\n  findGenerated(target, propertyName) {\n    return this.generations.find(generated => {\n      return (Array.isArray(target) ? target.indexOf(generated.target) !== -1 : generated.target === target) && generated.propertyName === propertyName;\n    });\n  }\n  findTree(target) {\n    return this.trees.find(tree => {\n      return Array.isArray(target) ? target.indexOf(tree.target) !== -1 : tree.target === target;\n    });\n  }\n  filterRelations(target) {\n    return this.filterByTargetAndWithoutDuplicateRelationProperties(this.relations, target);\n  }\n  filterRelationIds(target) {\n    return this.filterByTargetAndWithoutDuplicateProperties(this.relationIds, target);\n  }\n  filterRelationCounts(target) {\n    return this.filterByTargetAndWithoutDuplicateProperties(this.relationCounts, target);\n  }\n  filterIndices(target) {\n    // todo: implement parent-entity overrides?\n    return this.indices.filter(index => {\n      return Array.isArray(target) ? target.indexOf(index.target) !== -1 : index.target === target;\n    });\n  }\n  filterUniques(target) {\n    return this.uniques.filter(unique => {\n      return Array.isArray(target) ? target.indexOf(unique.target) !== -1 : unique.target === target;\n    });\n  }\n  filterChecks(target) {\n    return this.checks.filter(check => {\n      return Array.isArray(target) ? target.indexOf(check.target) !== -1 : check.target === target;\n    });\n  }\n  filterExclusions(target) {\n    return this.exclusions.filter(exclusion => {\n      return Array.isArray(target) ? target.indexOf(exclusion.target) !== -1 : exclusion.target === target;\n    });\n  }\n  filterListeners(target) {\n    return this.filterByTarget(this.entityListeners, target);\n  }\n  filterEmbeddeds(target) {\n    return this.filterByTargetAndWithoutDuplicateEmbeddedProperties(this.embeddeds, target);\n  }\n  findJoinTable(target, propertyName) {\n    return this.joinTables.find(joinTable => {\n      return joinTable.target === target && joinTable.propertyName === propertyName;\n    });\n  }\n  filterJoinColumns(target, propertyName) {\n    // todo: implement parent-entity overrides?\n    return this.joinColumns.filter(joinColumn => {\n      return joinColumn.target === target && joinColumn.propertyName === propertyName;\n    });\n  }\n  filterSubscribers(target) {\n    return this.filterByTarget(this.entitySubscribers, target);\n  }\n  filterNamingStrategies(target) {\n    return this.filterByTarget(this.namingStrategies, target);\n  }\n  filterTransactionEntityManagers(target, propertyName) {\n    return this.transactionEntityManagers.filter(transactionEm => {\n      return (Array.isArray(target) ? target.indexOf(transactionEm.target) !== -1 : transactionEm.target === target) && transactionEm.methodName === propertyName;\n    });\n  }\n  filterTransactionRepository(target, propertyName) {\n    return this.transactionRepositories.filter(transactionEm => {\n      return (Array.isArray(target) ? target.indexOf(transactionEm.target) !== -1 : transactionEm.target === target) && transactionEm.methodName === propertyName;\n    });\n  }\n  filterSingleTableChildren(target) {\n    return this.tables.filter(table => {\n      return typeof table.target === \"function\" && typeof target === \"function\" && MetadataUtils.isInherited(table.target, target) && table.type === \"entity-child\";\n    });\n  }\n  findInheritanceType(target) {\n    return this.inheritances.find(inheritance => inheritance.target === target);\n  }\n  findDiscriminatorValue(target) {\n    return this.discriminatorValues.find(discriminatorValue => discriminatorValue.target === target);\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Filters given array by a given target or targets.\n   */\n  filterByTarget(array, target) {\n    return array.filter(table => {\n      return Array.isArray(target) ? target.indexOf(table.target) !== -1 : table.target === target;\n    });\n  }\n  /**\n   * Filters given array by a given target or targets and prevents duplicate property names.\n   */\n  filterByTargetAndWithoutDuplicateProperties(array, target) {\n    const newArray = [];\n    array.forEach(item => {\n      const sameTarget = Array.isArray(target) ? target.indexOf(item.target) !== -1 : item.target === target;\n      if (sameTarget) {\n        if (!newArray.find(newItem => newItem.propertyName === item.propertyName)) newArray.push(item);\n      }\n    });\n    return newArray;\n  }\n  /**\n   * Filters given array by a given target or targets and prevents duplicate relation property names.\n   */\n  filterByTargetAndWithoutDuplicateRelationProperties(array, target) {\n    const newArray = [];\n    array.forEach(item => {\n      const sameTarget = Array.isArray(target) ? target.indexOf(item.target) !== -1 : item.target === target;\n      if (sameTarget) {\n        const existingIndex = newArray.findIndex(newItem => newItem.propertyName === item.propertyName);\n        if (Array.isArray(target) && existingIndex !== -1 && target.indexOf(item.target) < target.indexOf(newArray[existingIndex].target)) {\n          const clone = Object.create(newArray[existingIndex]);\n          clone.type = item.type;\n          newArray[existingIndex] = clone;\n        } else if (existingIndex === -1) {\n          newArray.push(item);\n        }\n      }\n    });\n    return newArray;\n  }\n  /**\n   * Filters given array by a given target or targets and prevents duplicate embedded property names.\n   */\n  filterByTargetAndWithoutDuplicateEmbeddedProperties(array, target) {\n    const newArray = [];\n    array.forEach(item => {\n      const sameTarget = Array.isArray(target) ? target.indexOf(item.target) !== -1 : item.target === target;\n      if (sameTarget) {\n        const isDuplicateEmbeddedProperty = newArray.find(newItem => newItem.prefix === item.prefix && newItem.propertyName === item.propertyName);\n        if (!isDuplicateEmbeddedProperty) newArray.push(item);\n      }\n    });\n    return newArray;\n  }\n}","map":{"version":3,"names":["MetadataUtils","MetadataArgsStorage","constructor","tables","trees","entityRepositories","transactionEntityManagers","transactionRepositories","namingStrategies","entitySubscribers","indices","uniques","checks","exclusions","columns","generations","relations","joinColumns","joinTables","entityListeners","relationCounts","relationIds","embeddeds","inheritances","discriminatorValues","filterTables","target","filterByTarget","filterColumns","filterByTargetAndWithoutDuplicateProperties","findGenerated","propertyName","find","generated","Array","isArray","indexOf","findTree","tree","filterRelations","filterByTargetAndWithoutDuplicateRelationProperties","filterRelationIds","filterRelationCounts","filterIndices","filter","index","filterUniques","unique","filterChecks","check","filterExclusions","exclusion","filterListeners","filterEmbeddeds","filterByTargetAndWithoutDuplicateEmbeddedProperties","findJoinTable","joinTable","filterJoinColumns","joinColumn","filterSubscribers","filterNamingStrategies","filterTransactionEntityManagers","transactionEm","methodName","filterTransactionRepository","filterSingleTableChildren","table","isInherited","type","findInheritanceType","inheritance","findDiscriminatorValue","discriminatorValue","array","newArray","forEach","item","sameTarget","newItem","push","existingIndex","findIndex","clone","Object","create","isDuplicateEmbeddedProperty","prefix"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\metadata-args\\MetadataArgsStorage.ts"],"sourcesContent":["import { RelationMetadataArgs } from \"./RelationMetadataArgs\"\nimport { ColumnMetadataArgs } from \"./ColumnMetadataArgs\"\nimport { RelationCountMetadataArgs } from \"./RelationCountMetadataArgs\"\nimport { IndexMetadataArgs } from \"./IndexMetadataArgs\"\nimport { EntityListenerMetadataArgs } from \"./EntityListenerMetadataArgs\"\nimport { TableMetadataArgs } from \"./TableMetadataArgs\"\nimport { NamingStrategyMetadataArgs } from \"./NamingStrategyMetadataArgs\"\nimport { JoinTableMetadataArgs } from \"./JoinTableMetadataArgs\"\nimport { JoinColumnMetadataArgs } from \"./JoinColumnMetadataArgs\"\nimport { EmbeddedMetadataArgs } from \"./EmbeddedMetadataArgs\"\nimport { EntitySubscriberMetadataArgs } from \"./EntitySubscriberMetadataArgs\"\nimport { RelationIdMetadataArgs } from \"./RelationIdMetadataArgs\"\nimport { InheritanceMetadataArgs } from \"./InheritanceMetadataArgs\"\nimport { DiscriminatorValueMetadataArgs } from \"./DiscriminatorValueMetadataArgs\"\nimport { EntityRepositoryMetadataArgs } from \"./EntityRepositoryMetadataArgs\"\nimport { TransactionEntityMetadataArgs } from \"./TransactionEntityMetadataArgs\"\nimport { TransactionRepositoryMetadataArgs } from \"./TransactionRepositoryMetadataArgs\"\nimport { MetadataUtils } from \"../metadata-builder/MetadataUtils\"\nimport { GeneratedMetadataArgs } from \"./GeneratedMetadataArgs\"\nimport { TreeMetadataArgs } from \"./TreeMetadataArgs\"\nimport { UniqueMetadataArgs } from \"./UniqueMetadataArgs\"\nimport { CheckMetadataArgs } from \"./CheckMetadataArgs\"\nimport { ExclusionMetadataArgs } from \"./ExclusionMetadataArgs\"\n\n/**\n * Storage all metadatas args of all available types: tables, columns, subscribers, relations, etc.\n * Each metadata args represents some specifications of what it represents.\n * MetadataArgs used to create a real Metadata objects.\n */\nexport class MetadataArgsStorage {\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    readonly tables: TableMetadataArgs[] = []\n    readonly trees: TreeMetadataArgs[] = []\n    readonly entityRepositories: EntityRepositoryMetadataArgs[] = []\n    readonly transactionEntityManagers: TransactionEntityMetadataArgs[] = []\n    readonly transactionRepositories: TransactionRepositoryMetadataArgs[] = []\n    readonly namingStrategies: NamingStrategyMetadataArgs[] = []\n    readonly entitySubscribers: EntitySubscriberMetadataArgs[] = []\n    readonly indices: IndexMetadataArgs[] = []\n    readonly uniques: UniqueMetadataArgs[] = []\n    readonly checks: CheckMetadataArgs[] = []\n    readonly exclusions: ExclusionMetadataArgs[] = []\n    readonly columns: ColumnMetadataArgs[] = []\n    readonly generations: GeneratedMetadataArgs[] = []\n    readonly relations: RelationMetadataArgs[] = []\n    readonly joinColumns: JoinColumnMetadataArgs[] = []\n    readonly joinTables: JoinTableMetadataArgs[] = []\n    readonly entityListeners: EntityListenerMetadataArgs[] = []\n    readonly relationCounts: RelationCountMetadataArgs[] = []\n    readonly relationIds: RelationIdMetadataArgs[] = []\n    readonly embeddeds: EmbeddedMetadataArgs[] = []\n    readonly inheritances: InheritanceMetadataArgs[] = []\n    readonly discriminatorValues: DiscriminatorValueMetadataArgs[] = []\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    filterTables(target: Function | string): TableMetadataArgs[]\n    filterTables(target: (Function | string)[]): TableMetadataArgs[]\n    filterTables(\n        target: (Function | string) | (Function | string)[],\n    ): TableMetadataArgs[] {\n        return this.filterByTarget(this.tables, target)\n    }\n\n    filterColumns(target: Function | string): ColumnMetadataArgs[]\n    filterColumns(target: (Function | string)[]): ColumnMetadataArgs[]\n    filterColumns(\n        target: (Function | string) | (Function | string)[],\n    ): ColumnMetadataArgs[] {\n        return this.filterByTargetAndWithoutDuplicateProperties(\n            this.columns,\n            target,\n        )\n    }\n\n    findGenerated(\n        target: Function | string,\n        propertyName: string,\n    ): GeneratedMetadataArgs | undefined\n    findGenerated(\n        target: (Function | string)[],\n        propertyName: string,\n    ): GeneratedMetadataArgs | undefined\n    findGenerated(\n        target: (Function | string) | (Function | string)[],\n        propertyName: string,\n    ): GeneratedMetadataArgs | undefined {\n        return this.generations.find((generated) => {\n            return (\n                (Array.isArray(target)\n                    ? target.indexOf(generated.target) !== -1\n                    : generated.target === target) &&\n                generated.propertyName === propertyName\n            )\n        })\n    }\n\n    findTree(\n        target: (Function | string) | (Function | string)[],\n    ): TreeMetadataArgs | undefined {\n        return this.trees.find((tree) => {\n            return Array.isArray(target)\n                ? target.indexOf(tree.target) !== -1\n                : tree.target === target\n        })\n    }\n\n    filterRelations(target: Function | string): RelationMetadataArgs[]\n    filterRelations(target: (Function | string)[]): RelationMetadataArgs[]\n    filterRelations(\n        target: (Function | string) | (Function | string)[],\n    ): RelationMetadataArgs[] {\n        return this.filterByTargetAndWithoutDuplicateRelationProperties(\n            this.relations,\n            target,\n        )\n    }\n\n    filterRelationIds(target: Function | string): RelationIdMetadataArgs[]\n    filterRelationIds(target: (Function | string)[]): RelationIdMetadataArgs[]\n    filterRelationIds(\n        target: (Function | string) | (Function | string)[],\n    ): RelationIdMetadataArgs[] {\n        return this.filterByTargetAndWithoutDuplicateProperties(\n            this.relationIds,\n            target,\n        )\n    }\n\n    filterRelationCounts(target: Function | string): RelationCountMetadataArgs[]\n    filterRelationCounts(\n        target: (Function | string)[],\n    ): RelationCountMetadataArgs[]\n    filterRelationCounts(\n        target: (Function | string) | (Function | string)[],\n    ): RelationCountMetadataArgs[] {\n        return this.filterByTargetAndWithoutDuplicateProperties(\n            this.relationCounts,\n            target,\n        )\n    }\n\n    filterIndices(target: Function | string): IndexMetadataArgs[]\n    filterIndices(target: (Function | string)[]): IndexMetadataArgs[]\n    filterIndices(\n        target: (Function | string) | (Function | string)[],\n    ): IndexMetadataArgs[] {\n        // todo: implement parent-entity overrides?\n        return this.indices.filter((index) => {\n            return Array.isArray(target)\n                ? target.indexOf(index.target) !== -1\n                : index.target === target\n        })\n    }\n\n    filterUniques(target: Function | string): UniqueMetadataArgs[]\n    filterUniques(target: (Function | string)[]): UniqueMetadataArgs[]\n    filterUniques(\n        target: (Function | string) | (Function | string)[],\n    ): UniqueMetadataArgs[] {\n        return this.uniques.filter((unique) => {\n            return Array.isArray(target)\n                ? target.indexOf(unique.target) !== -1\n                : unique.target === target\n        })\n    }\n\n    filterChecks(target: Function | string): CheckMetadataArgs[]\n    filterChecks(target: (Function | string)[]): CheckMetadataArgs[]\n    filterChecks(\n        target: (Function | string) | (Function | string)[],\n    ): CheckMetadataArgs[] {\n        return this.checks.filter((check) => {\n            return Array.isArray(target)\n                ? target.indexOf(check.target) !== -1\n                : check.target === target\n        })\n    }\n\n    filterExclusions(target: Function | string): ExclusionMetadataArgs[]\n    filterExclusions(target: (Function | string)[]): ExclusionMetadataArgs[]\n    filterExclusions(\n        target: (Function | string) | (Function | string)[],\n    ): ExclusionMetadataArgs[] {\n        return this.exclusions.filter((exclusion) => {\n            return Array.isArray(target)\n                ? target.indexOf(exclusion.target) !== -1\n                : exclusion.target === target\n        })\n    }\n\n    filterListeners(target: Function | string): EntityListenerMetadataArgs[]\n    filterListeners(target: (Function | string)[]): EntityListenerMetadataArgs[]\n    filterListeners(\n        target: (Function | string) | (Function | string)[],\n    ): EntityListenerMetadataArgs[] {\n        return this.filterByTarget(this.entityListeners, target)\n    }\n\n    filterEmbeddeds(target: Function | string): EmbeddedMetadataArgs[]\n    filterEmbeddeds(target: (Function | string)[]): EmbeddedMetadataArgs[]\n    filterEmbeddeds(\n        target: (Function | string) | (Function | string)[],\n    ): EmbeddedMetadataArgs[] {\n        return this.filterByTargetAndWithoutDuplicateEmbeddedProperties(\n            this.embeddeds,\n            target,\n        )\n    }\n\n    findJoinTable(\n        target: Function | string,\n        propertyName: string,\n    ): JoinTableMetadataArgs | undefined {\n        return this.joinTables.find((joinTable) => {\n            return (\n                joinTable.target === target &&\n                joinTable.propertyName === propertyName\n            )\n        })\n    }\n\n    filterJoinColumns(\n        target: Function | string,\n        propertyName: string,\n    ): JoinColumnMetadataArgs[] {\n        // todo: implement parent-entity overrides?\n        return this.joinColumns.filter((joinColumn) => {\n            return (\n                joinColumn.target === target &&\n                joinColumn.propertyName === propertyName\n            )\n        })\n    }\n\n    filterSubscribers(target: Function | string): EntitySubscriberMetadataArgs[]\n    filterSubscribers(\n        target: (Function | string)[],\n    ): EntitySubscriberMetadataArgs[]\n    filterSubscribers(\n        target: (Function | string) | (Function | string)[],\n    ): EntitySubscriberMetadataArgs[] {\n        return this.filterByTarget(this.entitySubscribers, target)\n    }\n\n    filterNamingStrategies(\n        target: Function | string,\n    ): NamingStrategyMetadataArgs[]\n    filterNamingStrategies(\n        target: (Function | string)[],\n    ): NamingStrategyMetadataArgs[]\n    filterNamingStrategies(\n        target: (Function | string) | (Function | string)[],\n    ): NamingStrategyMetadataArgs[] {\n        return this.filterByTarget(this.namingStrategies, target)\n    }\n\n    filterTransactionEntityManagers(\n        target: Function | string,\n        propertyName: string,\n    ): TransactionEntityMetadataArgs[] {\n        return this.transactionEntityManagers.filter((transactionEm) => {\n            return (\n                (Array.isArray(target)\n                    ? target.indexOf(transactionEm.target) !== -1\n                    : transactionEm.target === target) &&\n                transactionEm.methodName === propertyName\n            )\n        })\n    }\n\n    filterTransactionRepository(\n        target: Function | string,\n        propertyName: string,\n    ): TransactionRepositoryMetadataArgs[] {\n        return this.transactionRepositories.filter((transactionEm) => {\n            return (\n                (Array.isArray(target)\n                    ? target.indexOf(transactionEm.target) !== -1\n                    : transactionEm.target === target) &&\n                transactionEm.methodName === propertyName\n            )\n        })\n    }\n\n    filterSingleTableChildren(target: Function | string): TableMetadataArgs[] {\n        return this.tables.filter((table) => {\n            return (\n                typeof table.target === \"function\" &&\n                typeof target === \"function\" &&\n                MetadataUtils.isInherited(table.target, target) &&\n                table.type === \"entity-child\"\n            )\n        })\n    }\n\n    findInheritanceType(\n        target: Function | string,\n    ): InheritanceMetadataArgs | undefined {\n        return this.inheritances.find(\n            (inheritance) => inheritance.target === target,\n        )\n    }\n\n    findDiscriminatorValue(\n        target: Function | string,\n    ): DiscriminatorValueMetadataArgs | undefined {\n        return this.discriminatorValues.find(\n            (discriminatorValue) => discriminatorValue.target === target,\n        )\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Filters given array by a given target or targets.\n     */\n    protected filterByTarget<T extends { target: Function | string }>(\n        array: T[],\n        target: (Function | string) | (Function | string)[],\n    ): T[] {\n        return array.filter((table) => {\n            return Array.isArray(target)\n                ? target.indexOf(table.target) !== -1\n                : table.target === target\n        })\n    }\n\n    /**\n     * Filters given array by a given target or targets and prevents duplicate property names.\n     */\n    protected filterByTargetAndWithoutDuplicateProperties<\n        T extends { target: Function | string; propertyName: string },\n    >(array: T[], target: (Function | string) | (Function | string)[]): T[] {\n        const newArray: T[] = []\n        array.forEach((item) => {\n            const sameTarget = Array.isArray(target)\n                ? target.indexOf(item.target) !== -1\n                : item.target === target\n            if (sameTarget) {\n                if (\n                    !newArray.find(\n                        (newItem) => newItem.propertyName === item.propertyName,\n                    )\n                )\n                    newArray.push(item)\n            }\n        })\n        return newArray\n    }\n\n    /**\n     * Filters given array by a given target or targets and prevents duplicate relation property names.\n     */\n    protected filterByTargetAndWithoutDuplicateRelationProperties<\n        T extends RelationMetadataArgs,\n    >(array: T[], target: (Function | string) | (Function | string)[]): T[] {\n        const newArray: T[] = []\n        array.forEach((item) => {\n            const sameTarget = Array.isArray(target)\n                ? target.indexOf(item.target) !== -1\n                : item.target === target\n            if (sameTarget) {\n                const existingIndex = newArray.findIndex(\n                    (newItem) => newItem.propertyName === item.propertyName,\n                )\n                if (\n                    Array.isArray(target) &&\n                    existingIndex !== -1 &&\n                    target.indexOf(item.target) <\n                        target.indexOf(newArray[existingIndex].target)\n                ) {\n                    const clone = Object.create(newArray[existingIndex])\n                    clone.type = item.type\n                    newArray[existingIndex] = clone\n                } else if (existingIndex === -1) {\n                    newArray.push(item)\n                }\n            }\n        })\n        return newArray\n    }\n\n    /**\n     * Filters given array by a given target or targets and prevents duplicate embedded property names.\n     */\n    protected filterByTargetAndWithoutDuplicateEmbeddedProperties<\n        T extends EmbeddedMetadataArgs,\n    >(array: T[], target: (Function | string) | (Function | string)[]): T[] {\n        const newArray: T[] = []\n        array.forEach((item) => {\n            const sameTarget = Array.isArray(target)\n                ? target.indexOf(item.target) !== -1\n                : item.target === target\n            if (sameTarget) {\n                const isDuplicateEmbeddedProperty = newArray.find(\n                    (newItem: EmbeddedMetadataArgs): boolean =>\n                        newItem.prefix === item.prefix &&\n                        newItem.propertyName === item.propertyName,\n                )\n                if (!isDuplicateEmbeddedProperty) newArray.push(item)\n            }\n        })\n        return newArray\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}