{"ast":null,"code":"import { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\";\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\";\nimport { Table } from \"../../schema-builder/table/Table\";\nimport { TableIndex } from \"../../schema-builder/table/TableIndex\";\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\";\nimport { View } from \"../../schema-builder/view/View\";\nimport { Query } from \"../Query\";\nimport { TableUnique } from \"../../schema-builder/table/TableUnique\";\nimport { BaseQueryRunner } from \"../../query-runner/BaseQueryRunner\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { TableCheck } from \"../../schema-builder/table/TableCheck\";\nimport { TransactionAlreadyStartedError, TypeORMError } from \"../../error\";\nimport { MetadataTableType } from \"../types/MetadataTableType\";\nimport { InstanceChecker } from \"../../util/InstanceChecker\";\n/**\n * Runs queries on a single sqlite database connection.\n */\nexport class AbstractSqliteQueryRunner extends BaseQueryRunner {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor() {\n    super();\n    this.transactionPromise = null;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates/uses database connection from the connection pool to perform further operations.\n   * Returns obtained database connection.\n   */\n  connect() {\n    return Promise.resolve(this.driver.databaseConnection);\n  }\n  /**\n   * Releases used database connection.\n   * We just clear loaded tables and sql in memory, because sqlite do not support multiple connections thus query runners.\n   */\n  release() {\n    this.loadedTables = [];\n    this.clearSqlMemory();\n    return Promise.resolve();\n  }\n  /**\n   * Starts transaction.\n   */\n  async startTransaction(isolationLevel) {\n    if (this.driver.transactionSupport === \"none\") throw new TypeORMError(`Transactions aren't supported by ${this.connection.driver.options.type}.`);\n    if (this.isTransactionActive && this.driver.transactionSupport === \"simple\") throw new TransactionAlreadyStartedError();\n    if (isolationLevel && isolationLevel !== \"READ UNCOMMITTED\" && isolationLevel !== \"SERIALIZABLE\") throw new TypeORMError(`SQLite only supports SERIALIZABLE and READ UNCOMMITTED isolation`);\n    this.isTransactionActive = true;\n    try {\n      await this.broadcaster.broadcast(\"BeforeTransactionStart\");\n    } catch (err) {\n      this.isTransactionActive = false;\n      throw err;\n    }\n    if (this.transactionDepth === 0) {\n      this.transactionDepth += 1;\n      if (isolationLevel) {\n        if (isolationLevel === \"READ UNCOMMITTED\") {\n          await this.query(\"PRAGMA read_uncommitted = true\");\n        } else {\n          await this.query(\"PRAGMA read_uncommitted = false\");\n        }\n      }\n      await this.query(\"BEGIN TRANSACTION\");\n    } else {\n      this.transactionDepth += 1;\n      await this.query(`SAVEPOINT typeorm_${this.transactionDepth - 1}`);\n    }\n    await this.broadcaster.broadcast(\"AfterTransactionStart\");\n  }\n  /**\n   * Commits transaction.\n   * Error will be thrown if transaction was not started.\n   */\n  async commitTransaction() {\n    if (!this.isTransactionActive) throw new TransactionNotStartedError();\n    await this.broadcaster.broadcast(\"BeforeTransactionCommit\");\n    if (this.transactionDepth > 1) {\n      this.transactionDepth -= 1;\n      await this.query(`RELEASE SAVEPOINT typeorm_${this.transactionDepth}`);\n    } else {\n      this.transactionDepth -= 1;\n      await this.query(\"COMMIT\");\n      this.isTransactionActive = false;\n    }\n    await this.broadcaster.broadcast(\"AfterTransactionCommit\");\n  }\n  /**\n   * Rollbacks transaction.\n   * Error will be thrown if transaction was not started.\n   */\n  async rollbackTransaction() {\n    if (!this.isTransactionActive) throw new TransactionNotStartedError();\n    await this.broadcaster.broadcast(\"BeforeTransactionRollback\");\n    if (this.transactionDepth > 1) {\n      this.transactionDepth -= 1;\n      await this.query(`ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth}`);\n    } else {\n      this.transactionDepth -= 1;\n      await this.query(\"ROLLBACK\");\n      this.isTransactionActive = false;\n    }\n    await this.broadcaster.broadcast(\"AfterTransactionRollback\");\n  }\n  /**\n   * Returns raw data stream.\n   */\n  stream(query, parameters, onEnd, onError) {\n    throw new TypeORMError(`Stream is not supported by sqlite driver.`);\n  }\n  /**\n   * Returns all available database names including system databases.\n   */\n  async getDatabases() {\n    return Promise.resolve([]);\n  }\n  /**\n   * Returns all available schema names including system schemas.\n   * If database parameter specified, returns schemas of that database.\n   */\n  async getSchemas(database) {\n    return Promise.resolve([]);\n  }\n  /**\n   * Checks if database with the given name exist.\n   */\n  async hasDatabase(database) {\n    return Promise.resolve(false);\n  }\n  /**\n   * Loads currently using database\n   */\n  async getCurrentDatabase() {\n    return Promise.resolve(undefined);\n  }\n  /**\n   * Checks if schema with the given name exist.\n   */\n  async hasSchema(schema) {\n    throw new TypeORMError(`This driver does not support table schemas`);\n  }\n  /**\n   * Loads currently using database schema\n   */\n  async getCurrentSchema() {\n    return Promise.resolve(undefined);\n  }\n  /**\n   * Checks if table with the given name exist in the database.\n   */\n  async hasTable(tableOrName) {\n    const tableName = InstanceChecker.isTable(tableOrName) ? tableOrName.name : tableOrName;\n    const sql = `SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" = '${tableName}'`;\n    const result = await this.query(sql);\n    return result.length ? true : false;\n  }\n  /**\n   * Checks if column with the given name exist in the given table.\n   */\n  async hasColumn(tableOrName, columnName) {\n    const tableName = InstanceChecker.isTable(tableOrName) ? tableOrName.name : tableOrName;\n    const sql = `PRAGMA table_xinfo(${this.escapePath(tableName)})`;\n    const columns = await this.query(sql);\n    return !!columns.find(column => column[\"name\"] === columnName);\n  }\n  /**\n   * Creates a new database.\n   */\n  async createDatabase(database, ifNotExist) {\n    return Promise.resolve();\n  }\n  /**\n   * Drops database.\n   */\n  async dropDatabase(database, ifExist) {\n    return Promise.resolve();\n  }\n  /**\n   * Creates a new table schema.\n   */\n  async createSchema(schemaPath, ifNotExist) {\n    return Promise.resolve();\n  }\n  /**\n   * Drops table schema.\n   */\n  async dropSchema(schemaPath, ifExist) {\n    return Promise.resolve();\n  }\n  /**\n   * Creates a new table.\n   */\n  async createTable(table, ifNotExist = false, createForeignKeys = true, createIndices = true) {\n    const upQueries = [];\n    const downQueries = [];\n    if (ifNotExist) {\n      const isTableExist = await this.hasTable(table);\n      if (isTableExist) return Promise.resolve();\n    }\n    upQueries.push(this.createTableSql(table, createForeignKeys));\n    downQueries.push(this.dropTableSql(table));\n    if (createIndices) {\n      table.indices.forEach(index => {\n        // new index may be passed without name. In this case we generate index name manually.\n        if (!index.name) index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);\n        upQueries.push(this.createIndexSql(table, index));\n        downQueries.push(this.dropIndexSql(index));\n      });\n    }\n    // if table have column with generated type, we must add the expression to the metadata table\n    const generatedColumns = table.columns.filter(column => column.generatedType && column.asExpression);\n    for (const column of generatedColumns) {\n      const insertQuery = this.insertTypeormMetadataSql({\n        table: table.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name,\n        value: column.asExpression\n      });\n      const deleteQuery = this.deleteTypeormMetadataSql({\n        table: table.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name\n      });\n      upQueries.push(insertQuery);\n      downQueries.push(deleteQuery);\n    }\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Drops the table.\n   */\n  async dropTable(tableOrName, ifExist, dropForeignKeys = true, dropIndices = true) {\n    if (ifExist) {\n      const isTableExist = await this.hasTable(tableOrName);\n      if (!isTableExist) return Promise.resolve();\n    }\n    // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.\n    const createForeignKeys = dropForeignKeys;\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const upQueries = [];\n    const downQueries = [];\n    if (dropIndices) {\n      table.indices.forEach(index => {\n        upQueries.push(this.dropIndexSql(index));\n        downQueries.push(this.createIndexSql(table, index));\n      });\n    }\n    upQueries.push(this.dropTableSql(table, ifExist));\n    downQueries.push(this.createTableSql(table, createForeignKeys));\n    // if table had columns with generated type, we must remove the expression from the metadata table\n    const generatedColumns = table.columns.filter(column => column.generatedType && column.asExpression);\n    for (const column of generatedColumns) {\n      const deleteQuery = this.deleteTypeormMetadataSql({\n        table: table.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name\n      });\n      const insertQuery = this.insertTypeormMetadataSql({\n        table: table.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name,\n        value: column.asExpression\n      });\n      upQueries.push(deleteQuery);\n      downQueries.push(insertQuery);\n    }\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Creates a new view.\n   */\n  async createView(view, syncWithMetadata = false) {\n    const upQueries = [];\n    const downQueries = [];\n    upQueries.push(this.createViewSql(view));\n    if (syncWithMetadata) upQueries.push(this.insertViewDefinitionSql(view));\n    downQueries.push(this.dropViewSql(view));\n    if (syncWithMetadata) downQueries.push(this.deleteViewDefinitionSql(view));\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Drops the view.\n   */\n  async dropView(target) {\n    const viewName = InstanceChecker.isView(target) ? target.name : target;\n    const view = await this.getCachedView(viewName);\n    const upQueries = [];\n    const downQueries = [];\n    upQueries.push(this.deleteViewDefinitionSql(view));\n    upQueries.push(this.dropViewSql(view));\n    downQueries.push(this.insertViewDefinitionSql(view));\n    downQueries.push(this.createViewSql(view));\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Renames the given table.\n   */\n  async renameTable(oldTableOrName, newTableName) {\n    const oldTable = InstanceChecker.isTable(oldTableOrName) ? oldTableOrName : await this.getCachedTable(oldTableOrName);\n    const newTable = oldTable.clone();\n    newTable.name = newTableName;\n    // rename table\n    const up = new Query(`ALTER TABLE ${this.escapePath(oldTable.name)} RENAME TO ${this.escapePath(newTableName)}`);\n    const down = new Query(`ALTER TABLE ${this.escapePath(newTableName)} RENAME TO ${this.escapePath(oldTable.name)}`);\n    await this.executeQueries(up, down);\n    // rename unique constraints\n    newTable.uniques.forEach(unique => {\n      const oldUniqueName = this.connection.namingStrategy.uniqueConstraintName(oldTable, unique.columnNames);\n      // Skip renaming if Unique has user defined constraint name\n      if (unique.name !== oldUniqueName) return;\n      unique.name = this.connection.namingStrategy.uniqueConstraintName(newTable, unique.columnNames);\n    });\n    // rename foreign key constraints\n    newTable.foreignKeys.forEach(foreignKey => {\n      const oldForeignKeyName = this.connection.namingStrategy.foreignKeyName(oldTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n      // Skip renaming if foreign key has user defined constraint name\n      if (foreignKey.name !== oldForeignKeyName) return;\n      foreignKey.name = this.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n    });\n    // rename indices\n    newTable.indices.forEach(index => {\n      const oldIndexName = this.connection.namingStrategy.indexName(oldTable, index.columnNames, index.where);\n      // Skip renaming if Index has user defined constraint name\n      if (index.name !== oldIndexName) return;\n      index.name = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);\n    });\n    // rename old table;\n    oldTable.name = newTable.name;\n    // recreate table with new constraint names\n    await this.recreateTable(newTable, oldTable);\n  }\n  /**\n   * Creates a new column from the column in the table.\n   */\n  async addColumn(tableOrName, column) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    return this.addColumns(table, [column]);\n  }\n  /**\n   * Creates a new columns from the column in the table.\n   */\n  async addColumns(tableOrName, columns) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const changedTable = table.clone();\n    columns.forEach(column => changedTable.addColumn(column));\n    await this.recreateTable(changedTable, table);\n  }\n  /**\n   * Renames column in the given table.\n   */\n  async renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find(c => c.name === oldTableColumnOrName);\n    if (!oldColumn) throw new TypeORMError(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n    let newColumn = undefined;\n    if (InstanceChecker.isTableColumn(newTableColumnOrName)) {\n      newColumn = newTableColumnOrName;\n    } else {\n      newColumn = oldColumn.clone();\n      newColumn.name = newTableColumnOrName;\n    }\n    return this.changeColumn(table, oldColumn, newColumn);\n  }\n  /**\n   * Changes a column in the table.\n   */\n  async changeColumn(tableOrName, oldTableColumnOrName, newColumn) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find(c => c.name === oldTableColumnOrName);\n    if (!oldColumn) throw new TypeORMError(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n    await this.changeColumns(table, [{\n      oldColumn,\n      newColumn\n    }]);\n  }\n  /**\n   * Changes a column in the table.\n   * Changed column looses all its keys in the db.\n   */\n  async changeColumns(tableOrName, changedColumns) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const changedTable = table.clone();\n    changedColumns.forEach(changedColumnSet => {\n      if (changedColumnSet.newColumn.name !== changedColumnSet.oldColumn.name) {\n        changedTable.findColumnUniques(changedColumnSet.oldColumn).forEach(unique => {\n          const uniqueName = this.connection.namingStrategy.uniqueConstraintName(table, unique.columnNames);\n          unique.columnNames.splice(unique.columnNames.indexOf(changedColumnSet.oldColumn.name), 1);\n          unique.columnNames.push(changedColumnSet.newColumn.name);\n          // rename Unique only if it has default constraint name\n          if (unique.name === uniqueName) {\n            unique.name = this.connection.namingStrategy.uniqueConstraintName(changedTable, unique.columnNames);\n          }\n        });\n        changedTable.findColumnForeignKeys(changedColumnSet.oldColumn).forEach(foreignKey => {\n          const foreignKeyName = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n          foreignKey.columnNames.splice(foreignKey.columnNames.indexOf(changedColumnSet.oldColumn.name), 1);\n          foreignKey.columnNames.push(changedColumnSet.newColumn.name);\n          // rename FK only if it has default constraint name\n          if (foreignKey.name === foreignKeyName) {\n            foreignKey.name = this.connection.namingStrategy.foreignKeyName(changedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n          }\n        });\n        changedTable.findColumnIndices(changedColumnSet.oldColumn).forEach(index => {\n          const indexName = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);\n          index.columnNames.splice(index.columnNames.indexOf(changedColumnSet.oldColumn.name), 1);\n          index.columnNames.push(changedColumnSet.newColumn.name);\n          // rename Index only if it has default constraint name\n          if (index.name === indexName) {\n            index.name = this.connection.namingStrategy.indexName(changedTable, index.columnNames, index.where);\n          }\n        });\n      }\n      const originalColumn = changedTable.columns.find(column => column.name === changedColumnSet.oldColumn.name);\n      if (originalColumn) changedTable.columns[changedTable.columns.indexOf(originalColumn)] = changedColumnSet.newColumn;\n    });\n    await this.recreateTable(changedTable, table);\n  }\n  /**\n   * Drops column in the table.\n   */\n  async dropColumn(tableOrName, columnOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const column = InstanceChecker.isTableColumn(columnOrName) ? columnOrName : table.findColumnByName(columnOrName);\n    if (!column) throw new TypeORMError(`Column \"${columnOrName}\" was not found in table \"${table.name}\"`);\n    await this.dropColumns(table, [column]);\n  }\n  /**\n   * Drops the columns in the table.\n   */\n  async dropColumns(tableOrName, columns) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    // clone original table and remove column and its constraints from cloned table\n    const changedTable = table.clone();\n    columns.forEach(column => {\n      const columnInstance = InstanceChecker.isTableColumn(column) ? column : table.findColumnByName(column);\n      if (!columnInstance) throw new Error(`Column \"${column}\" was not found in table \"${table.name}\"`);\n      changedTable.removeColumn(columnInstance);\n      changedTable.findColumnUniques(columnInstance).forEach(unique => changedTable.removeUniqueConstraint(unique));\n      changedTable.findColumnIndices(columnInstance).forEach(index => changedTable.removeIndex(index));\n      changedTable.findColumnForeignKeys(columnInstance).forEach(fk => changedTable.removeForeignKey(fk));\n    });\n    await this.recreateTable(changedTable, table);\n  }\n  /**\n   * Creates a new primary key.\n   */\n  async createPrimaryKey(tableOrName, columnNames) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    // clone original table and mark columns as primary\n    const changedTable = table.clone();\n    changedTable.columns.forEach(column => {\n      if (columnNames.find(columnName => columnName === column.name)) column.isPrimary = true;\n    });\n    await this.recreateTable(changedTable, table);\n    // mark columns as primary in original table\n    table.columns.forEach(column => {\n      if (columnNames.find(columnName => columnName === column.name)) column.isPrimary = true;\n    });\n  }\n  /**\n   * Updates composite primary keys.\n   */\n  async updatePrimaryKeys(tableOrName, columns) {\n    await Promise.resolve();\n  }\n  /**\n   * Drops a primary key.\n   */\n  async dropPrimaryKey(tableOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    // clone original table and mark primary columns as non-primary\n    const changedTable = table.clone();\n    changedTable.primaryColumns.forEach(column => {\n      column.isPrimary = false;\n    });\n    await this.recreateTable(changedTable, table);\n    // mark primary columns as non-primary in original table\n    table.primaryColumns.forEach(column => {\n      column.isPrimary = false;\n    });\n  }\n  /**\n   * Creates a new unique constraint.\n   */\n  async createUniqueConstraint(tableOrName, uniqueConstraint) {\n    await this.createUniqueConstraints(tableOrName, [uniqueConstraint]);\n  }\n  /**\n   * Creates a new unique constraints.\n   */\n  async createUniqueConstraints(tableOrName, uniqueConstraints) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    // clone original table and add unique constraints in to cloned table\n    const changedTable = table.clone();\n    uniqueConstraints.forEach(uniqueConstraint => changedTable.addUniqueConstraint(uniqueConstraint));\n    await this.recreateTable(changedTable, table);\n  }\n  /**\n   * Drops an unique constraint.\n   */\n  async dropUniqueConstraint(tableOrName, uniqueOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const uniqueConstraint = InstanceChecker.isTableUnique(uniqueOrName) ? uniqueOrName : table.uniques.find(u => u.name === uniqueOrName);\n    if (!uniqueConstraint) throw new TypeORMError(`Supplied unique constraint was not found in table ${table.name}`);\n    await this.dropUniqueConstraints(table, [uniqueConstraint]);\n  }\n  /**\n   * Creates an unique constraints.\n   */\n  async dropUniqueConstraints(tableOrName, uniqueConstraints) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    // clone original table and remove unique constraints from cloned table\n    const changedTable = table.clone();\n    uniqueConstraints.forEach(uniqueConstraint => changedTable.removeUniqueConstraint(uniqueConstraint));\n    await this.recreateTable(changedTable, table);\n  }\n  /**\n   * Creates new check constraint.\n   */\n  async createCheckConstraint(tableOrName, checkConstraint) {\n    await this.createCheckConstraints(tableOrName, [checkConstraint]);\n  }\n  /**\n   * Creates new check constraints.\n   */\n  async createCheckConstraints(tableOrName, checkConstraints) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    // clone original table and add check constraints in to cloned table\n    const changedTable = table.clone();\n    checkConstraints.forEach(checkConstraint => changedTable.addCheckConstraint(checkConstraint));\n    await this.recreateTable(changedTable, table);\n  }\n  /**\n   * Drops check constraint.\n   */\n  async dropCheckConstraint(tableOrName, checkOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const checkConstraint = InstanceChecker.isTableCheck(checkOrName) ? checkOrName : table.checks.find(c => c.name === checkOrName);\n    if (!checkConstraint) throw new TypeORMError(`Supplied check constraint was not found in table ${table.name}`);\n    await this.dropCheckConstraints(table, [checkConstraint]);\n  }\n  /**\n   * Drops check constraints.\n   */\n  async dropCheckConstraints(tableOrName, checkConstraints) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    // clone original table and remove check constraints from cloned table\n    const changedTable = table.clone();\n    checkConstraints.forEach(checkConstraint => changedTable.removeCheckConstraint(checkConstraint));\n    await this.recreateTable(changedTable, table);\n  }\n  /**\n   * Creates a new exclusion constraint.\n   */\n  async createExclusionConstraint(tableOrName, exclusionConstraint) {\n    throw new TypeORMError(`Sqlite does not support exclusion constraints.`);\n  }\n  /**\n   * Creates a new exclusion constraints.\n   */\n  async createExclusionConstraints(tableOrName, exclusionConstraints) {\n    throw new TypeORMError(`Sqlite does not support exclusion constraints.`);\n  }\n  /**\n   * Drops exclusion constraint.\n   */\n  async dropExclusionConstraint(tableOrName, exclusionOrName) {\n    throw new TypeORMError(`Sqlite does not support exclusion constraints.`);\n  }\n  /**\n   * Drops exclusion constraints.\n   */\n  async dropExclusionConstraints(tableOrName, exclusionConstraints) {\n    throw new TypeORMError(`Sqlite does not support exclusion constraints.`);\n  }\n  /**\n   * Creates a new foreign key.\n   */\n  async createForeignKey(tableOrName, foreignKey) {\n    await this.createForeignKeys(tableOrName, [foreignKey]);\n  }\n  /**\n   * Creates a new foreign keys.\n   */\n  async createForeignKeys(tableOrName, foreignKeys) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    // clone original table and add foreign keys in to cloned table\n    const changedTable = table.clone();\n    foreignKeys.forEach(foreignKey => changedTable.addForeignKey(foreignKey));\n    await this.recreateTable(changedTable, table);\n  }\n  /**\n   * Drops a foreign key from the table.\n   */\n  async dropForeignKey(tableOrName, foreignKeyOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const foreignKey = InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName : table.foreignKeys.find(fk => fk.name === foreignKeyOrName);\n    if (!foreignKey) throw new TypeORMError(`Supplied foreign key was not found in table ${table.name}`);\n    await this.dropForeignKeys(tableOrName, [foreignKey]);\n  }\n  /**\n   * Drops a foreign keys from the table.\n   */\n  async dropForeignKeys(tableOrName, foreignKeys) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    // clone original table and remove foreign keys from cloned table\n    const changedTable = table.clone();\n    foreignKeys.forEach(foreignKey => changedTable.removeForeignKey(foreignKey));\n    await this.recreateTable(changedTable, table);\n  }\n  /**\n   * Creates a new index.\n   */\n  async createIndex(tableOrName, index) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    // new index may be passed without name. In this case we generate index name manually.\n    if (!index.name) index.name = this.generateIndexName(table, index);\n    const up = this.createIndexSql(table, index);\n    const down = this.dropIndexSql(index);\n    await this.executeQueries(up, down);\n    table.addIndex(index);\n  }\n  /**\n   * Creates a new indices\n   */\n  async createIndices(tableOrName, indices) {\n    const promises = indices.map(index => this.createIndex(tableOrName, index));\n    await Promise.all(promises);\n  }\n  /**\n   * Drops an index from the table.\n   */\n  async dropIndex(tableOrName, indexOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const index = InstanceChecker.isTableIndex(indexOrName) ? indexOrName : table.indices.find(i => i.name === indexOrName);\n    if (!index) throw new TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`);\n    // old index may be passed without name. In this case we generate index name manually.\n    if (!index.name) index.name = this.generateIndexName(table, index);\n    const up = this.dropIndexSql(index);\n    const down = this.createIndexSql(table, index);\n    await this.executeQueries(up, down);\n    table.removeIndex(index);\n  }\n  /**\n   * Drops an indices from the table.\n   */\n  async dropIndices(tableOrName, indices) {\n    const promises = indices.map(index => this.dropIndex(tableOrName, index));\n    await Promise.all(promises);\n  }\n  /**\n   * Clears all table contents.\n   * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.\n   */\n  async clearTable(tableName) {\n    await this.query(`DELETE FROM ${this.escapePath(tableName)}`);\n  }\n  /**\n   * Removes all tables from the currently connected database.\n   */\n  async clearDatabase(database) {\n    let dbPath = undefined;\n    if (database && this.driver.getAttachedDatabaseHandleByRelativePath(database)) {\n      dbPath = this.driver.getAttachedDatabaseHandleByRelativePath(database);\n    }\n    await this.query(`PRAGMA foreign_keys = OFF`);\n    const isAnotherTransactionActive = this.isTransactionActive;\n    if (!isAnotherTransactionActive) await this.startTransaction();\n    try {\n      const selectViewDropsQuery = dbPath ? `SELECT 'DROP VIEW \"${dbPath}\".\"' || name || '\";' as query FROM \"${dbPath}\".\"sqlite_master\" WHERE \"type\" = 'view'` : `SELECT 'DROP VIEW \"' || name || '\";' as query FROM \"sqlite_master\" WHERE \"type\" = 'view'`;\n      const dropViewQueries = await this.query(selectViewDropsQuery);\n      await Promise.all(dropViewQueries.map(q => this.query(q[\"query\"])));\n      const selectTableDropsQuery = dbPath ? `SELECT 'DROP TABLE \"${dbPath}\".\"' || name || '\";' as query FROM \"${dbPath}\".\"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" != 'sqlite_sequence'` : `SELECT 'DROP TABLE \"' || name || '\";' as query FROM \"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" != 'sqlite_sequence'`;\n      const dropTableQueries = await this.query(selectTableDropsQuery);\n      await Promise.all(dropTableQueries.map(q => this.query(q[\"query\"])));\n      if (!isAnotherTransactionActive) await this.commitTransaction();\n    } catch (error) {\n      try {\n        // we throw original error even if rollback thrown an error\n        if (!isAnotherTransactionActive) await this.rollbackTransaction();\n      } catch (rollbackError) {}\n      throw error;\n    } finally {\n      await this.query(`PRAGMA foreign_keys = ON`);\n    }\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  async loadViews(viewNames) {\n    const hasTable = await this.hasTable(this.getTypeormMetadataTableName());\n    if (!hasTable) {\n      return [];\n    }\n    if (!viewNames) {\n      viewNames = [];\n    }\n    const viewNamesString = viewNames.map(name => \"'\" + name + \"'\").join(\", \");\n    let query = `SELECT \"t\".* FROM \"${this.getTypeormMetadataTableName()}\" \"t\" INNER JOIN \"sqlite_master\" s ON \"s\".\"name\" = \"t\".\"name\" AND \"s\".\"type\" = 'view' WHERE \"t\".\"type\" = '${MetadataTableType.VIEW}'`;\n    if (viewNamesString.length > 0) query += ` AND \"t\".\"name\" IN (${viewNamesString})`;\n    const dbViews = await this.query(query);\n    return dbViews.map(dbView => {\n      const view = new View();\n      view.name = dbView[\"name\"];\n      view.expression = dbView[\"value\"];\n      return view;\n    });\n  }\n  async loadTableRecords(tablePath, tableOrIndex) {\n    let database = undefined;\n    const [schema, tableName] = this.splitTablePath(tablePath);\n    if (schema && this.driver.getAttachedDatabasePathRelativeByHandle(schema)) {\n      database = this.driver.getAttachedDatabasePathRelativeByHandle(schema);\n    }\n    return this.query(`SELECT ${database ? `'${database}'` : null} as database, ${schema ? `'${schema}'` : null} as schema, * FROM ${schema ? `\"${schema}\".` : \"\"}${this.escapePath(`sqlite_master`)} WHERE \"type\" = '${tableOrIndex}' AND \"${tableOrIndex === \"table\" ? \"name\" : \"tbl_name\"}\" IN ('${tableName}')`);\n  }\n  async loadPragmaRecords(tablePath, pragma) {\n    const [, tableName] = this.splitTablePath(tablePath);\n    return this.query(`PRAGMA ${pragma}(\"${tableName}\")`);\n  }\n  /**\n   * Loads all tables (with given names) from the database and creates a Table from them.\n   */\n  async loadTables(tableNames) {\n    // if no tables given then no need to proceed\n    if (tableNames && tableNames.length === 0) {\n      return [];\n    }\n    let dbTables = [];\n    let dbIndicesDef;\n    if (!tableNames) {\n      const tablesSql = `SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'table'`;\n      dbTables.push(...(await this.query(tablesSql)));\n      const tableNamesString = dbTables.map(({\n        name\n      }) => `'${name}'`).join(\", \");\n      dbIndicesDef = await this.query(`SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'index' AND \"tbl_name\" IN (${tableNamesString})`);\n    } else {\n      const tableNamesWithoutDot = tableNames.filter(tableName => {\n        return tableName.split(\".\").length === 1;\n      }).map(tableName => `'${tableName}'`);\n      const tableNamesWithDot = tableNames.filter(tableName => {\n        return tableName.split(\".\").length > 1;\n      });\n      const queryPromises = type => {\n        const promises = [...tableNamesWithDot.map(tableName => this.loadTableRecords(tableName, type))];\n        if (tableNamesWithoutDot.length) {\n          promises.push(this.query(`SELECT * FROM \"sqlite_master\" WHERE \"type\" = '${type}' AND \"${type === \"table\" ? \"name\" : \"tbl_name\"}\" IN (${tableNamesWithoutDot})`));\n        }\n        return promises;\n      };\n      dbTables = (await Promise.all(queryPromises(\"table\"))).reduce((acc, res) => [...acc, ...res], []).filter(Boolean);\n      dbIndicesDef = (await Promise.all(queryPromises(\"index\"))).reduce((acc, res) => [...acc, ...res], []).filter(Boolean);\n    }\n    // if tables were not found in the db, no need to proceed\n    if (dbTables.length === 0) {\n      return [];\n    }\n    // create table schemas for loaded tables\n    return Promise.all(dbTables.map(async dbTable => {\n      const tablePath = dbTable[\"database\"] && this.driver.getAttachedDatabaseHandleByRelativePath(dbTable[\"database\"]) ? `${this.driver.getAttachedDatabaseHandleByRelativePath(dbTable[\"database\"])}.${dbTable[\"name\"]}` : dbTable[\"name\"];\n      const sql = dbTable[\"sql\"];\n      const withoutRowid = sql.includes(\"WITHOUT ROWID\");\n      const table = new Table({\n        name: tablePath,\n        withoutRowid\n      });\n      // load columns and indices\n      const [dbColumns, dbIndices, dbForeignKeys] = await Promise.all([this.loadPragmaRecords(tablePath, `table_xinfo`), this.loadPragmaRecords(tablePath, `index_list`), this.loadPragmaRecords(tablePath, `foreign_key_list`)]);\n      // find column name with auto increment\n      let autoIncrementColumnName = undefined;\n      const tableSql = dbTable[\"sql\"];\n      let autoIncrementIndex = tableSql.toUpperCase().indexOf(\"AUTOINCREMENT\");\n      if (autoIncrementIndex !== -1) {\n        autoIncrementColumnName = tableSql.substr(0, autoIncrementIndex);\n        const comma = autoIncrementColumnName.lastIndexOf(\",\");\n        const bracket = autoIncrementColumnName.lastIndexOf(\"(\");\n        if (comma !== -1) {\n          autoIncrementColumnName = autoIncrementColumnName.substr(comma);\n          autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf('\"'));\n          autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf('\"') + 1);\n        } else if (bracket !== -1) {\n          autoIncrementColumnName = autoIncrementColumnName.substr(bracket);\n          autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf('\"'));\n          autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf('\"') + 1);\n        }\n      }\n      // create columns from the loaded columns\n      table.columns = await Promise.all(dbColumns.map(async dbColumn => {\n        const tableColumn = new TableColumn();\n        tableColumn.name = dbColumn[\"name\"];\n        tableColumn.type = dbColumn[\"type\"].toLowerCase();\n        tableColumn.default = dbColumn[\"dflt_value\"] !== null && dbColumn[\"dflt_value\"] !== undefined ? dbColumn[\"dflt_value\"] : undefined;\n        tableColumn.isNullable = dbColumn[\"notnull\"] === 0;\n        // primary keys are numbered starting with 1, columns that aren't primary keys are marked with 0\n        tableColumn.isPrimary = dbColumn[\"pk\"] > 0;\n        tableColumn.comment = \"\"; // SQLite does not support column comments\n        tableColumn.isGenerated = autoIncrementColumnName === dbColumn[\"name\"];\n        if (tableColumn.isGenerated) {\n          tableColumn.generationStrategy = \"increment\";\n        }\n        if (dbColumn[\"hidden\"] === 2 || dbColumn[\"hidden\"] === 3) {\n          tableColumn.generatedType = dbColumn[\"hidden\"] === 2 ? \"VIRTUAL\" : \"STORED\";\n          const asExpressionQuery = this.selectTypeormMetadataSql({\n            table: table.name,\n            type: MetadataTableType.GENERATED_COLUMN,\n            name: tableColumn.name\n          });\n          const results = await this.query(asExpressionQuery.query, asExpressionQuery.parameters);\n          if (results[0] && results[0].value) {\n            tableColumn.asExpression = results[0].value;\n          } else {\n            tableColumn.asExpression = \"\";\n          }\n        }\n        if (tableColumn.type === \"varchar\") {\n          tableColumn.enum = OrmUtils.parseSqlCheckExpression(sql, tableColumn.name);\n        }\n        // parse datatype and attempt to retrieve length, precision and scale\n        let pos = tableColumn.type.indexOf(\"(\");\n        if (pos !== -1) {\n          const fullType = tableColumn.type;\n          let dataType = fullType.substr(0, pos);\n          if (this.driver.withLengthColumnTypes.find(col => col === dataType)) {\n            let len = parseInt(fullType.substring(pos + 1, fullType.length - 1));\n            if (len) {\n              tableColumn.length = len.toString();\n              tableColumn.type = dataType; // remove the length part from the datatype\n            }\n          }\n          if (this.driver.withPrecisionColumnTypes.find(col => col === dataType)) {\n            const re = new RegExp(`^${dataType}\\\\((\\\\d+),?\\\\s?(\\\\d+)?\\\\)`);\n            const matches = fullType.match(re);\n            if (matches && matches[1]) {\n              tableColumn.precision = +matches[1];\n            }\n            if (this.driver.withScaleColumnTypes.find(col => col === dataType)) {\n              if (matches && matches[2]) {\n                tableColumn.scale = +matches[2];\n              }\n            }\n            tableColumn.type = dataType; // remove the precision/scale part from the datatype\n          }\n        }\n        return tableColumn;\n      }));\n      // find foreign key constraints from CREATE TABLE sql\n      let fkResult;\n      const fkMappings = [];\n      const fkRegex = /CONSTRAINT \"([^\"]*)\" FOREIGN KEY ?\\((.*?)\\) REFERENCES \"([^\"]*)\"/g;\n      while ((fkResult = fkRegex.exec(sql)) !== null) {\n        fkMappings.push({\n          name: fkResult[1],\n          columns: fkResult[2].substr(1, fkResult[2].length - 2).split(`\", \"`),\n          referencedTableName: fkResult[3]\n        });\n      }\n      // build foreign keys\n      const tableForeignKeyConstraints = OrmUtils.uniq(dbForeignKeys, dbForeignKey => dbForeignKey[\"id\"]);\n      table.foreignKeys = tableForeignKeyConstraints.map(foreignKey => {\n        const ownForeignKeys = dbForeignKeys.filter(dbForeignKey => dbForeignKey[\"id\"] === foreignKey[\"id\"] && dbForeignKey[\"table\"] === foreignKey[\"table\"]);\n        const columnNames = ownForeignKeys.map(dbForeignKey => dbForeignKey[\"from\"]);\n        const referencedColumnNames = ownForeignKeys.map(dbForeignKey => dbForeignKey[\"to\"]);\n        // find related foreign key mapping\n        const fkMapping = fkMappings.find(it => it.referencedTableName === foreignKey[\"table\"] && it.columns.every(column => columnNames.indexOf(column) !== -1));\n        return new TableForeignKey({\n          name: fkMapping?.name,\n          columnNames: columnNames,\n          referencedTableName: foreignKey[\"table\"],\n          referencedColumnNames: referencedColumnNames,\n          onDelete: foreignKey[\"on_delete\"],\n          onUpdate: foreignKey[\"on_update\"]\n        });\n      });\n      // find unique constraints from CREATE TABLE sql\n      let uniqueRegexResult;\n      const uniqueMappings = [];\n      const uniqueRegex = /CONSTRAINT \"([^\"]*)\" UNIQUE ?\\((.*?)\\)/g;\n      while ((uniqueRegexResult = uniqueRegex.exec(sql)) !== null) {\n        uniqueMappings.push({\n          name: uniqueRegexResult[1],\n          columns: uniqueRegexResult[2].substr(1, uniqueRegexResult[2].length - 2).split(`\", \"`)\n        });\n      }\n      // build unique constraints\n      const tableUniquePromises = dbIndices.filter(dbIndex => dbIndex[\"origin\"] === \"u\").map(dbIndex => dbIndex[\"name\"]).filter((value, index, self) => self.indexOf(value) === index).map(async dbIndexName => {\n        const dbIndex = dbIndices.find(dbIndex => dbIndex[\"name\"] === dbIndexName);\n        const indexInfos = await this.query(`PRAGMA index_info(\"${dbIndex[\"name\"]}\")`);\n        const indexColumns = indexInfos.sort((indexInfo1, indexInfo2) => parseInt(indexInfo1[\"seqno\"]) - parseInt(indexInfo2[\"seqno\"])).map(indexInfo => indexInfo[\"name\"]);\n        if (indexColumns.length === 1) {\n          const column = table.columns.find(column => {\n            return !!indexColumns.find(indexColumn => indexColumn === column.name);\n          });\n          if (column) column.isUnique = true;\n        }\n        // find existent mapping by a column names\n        const foundMapping = uniqueMappings.find(mapping => {\n          return mapping.columns.every(column => indexColumns.indexOf(column) !== -1);\n        });\n        return new TableUnique({\n          name: foundMapping ? foundMapping.name : this.connection.namingStrategy.uniqueConstraintName(table, indexColumns),\n          columnNames: indexColumns\n        });\n      });\n      table.uniques = await Promise.all(tableUniquePromises);\n      // build checks\n      let result;\n      const regexp = /CONSTRAINT \"([^\"]*)\" CHECK ?(\\(.*?\\))([,]|[)]$)/g;\n      while ((result = regexp.exec(sql)) !== null) {\n        table.checks.push(new TableCheck({\n          name: result[1],\n          expression: result[2]\n        }));\n      }\n      // build indices\n      const indicesPromises = dbIndices.filter(dbIndex => dbIndex[\"origin\"] === \"c\").map(dbIndex => dbIndex[\"name\"]).filter((value, index, self) => self.indexOf(value) === index) // unqiue\n      .map(async dbIndexName => {\n        const indexDef = dbIndicesDef.find(dbIndexDef => dbIndexDef[\"name\"] === dbIndexName);\n        const condition = /WHERE (.*)/.exec(indexDef[\"sql\"]);\n        const dbIndex = dbIndices.find(dbIndex => dbIndex[\"name\"] === dbIndexName);\n        const indexInfos = await this.query(`PRAGMA index_info(\"${dbIndex[\"name\"]}\")`);\n        const indexColumns = indexInfos.sort((indexInfo1, indexInfo2) => parseInt(indexInfo1[\"seqno\"]) - parseInt(indexInfo2[\"seqno\"])).map(indexInfo => indexInfo[\"name\"]);\n        const dbIndexPath = `${dbTable[\"database\"] ? `${dbTable[\"database\"]}.` : \"\"}${dbIndex[\"name\"]}`;\n        const isUnique = dbIndex[\"unique\"] === \"1\" || dbIndex[\"unique\"] === 1;\n        return new TableIndex({\n          table: table,\n          name: dbIndexPath,\n          columnNames: indexColumns,\n          isUnique: isUnique,\n          where: condition ? condition[1] : undefined\n        });\n      });\n      const indices = await Promise.all(indicesPromises);\n      table.indices = indices.filter(index => !!index);\n      return table;\n    }));\n  }\n  /**\n   * Builds create table sql.\n   */\n  createTableSql(table, createForeignKeys, temporaryTable) {\n    const primaryColumns = table.columns.filter(column => column.isPrimary);\n    const hasAutoIncrement = primaryColumns.find(column => column.isGenerated && column.generationStrategy === \"increment\");\n    const skipPrimary = primaryColumns.length > 1;\n    if (skipPrimary && hasAutoIncrement) throw new TypeORMError(`Sqlite does not support AUTOINCREMENT on composite primary key`);\n    const columnDefinitions = table.columns.map(column => this.buildCreateColumnSql(column, skipPrimary)).join(\", \");\n    const [database] = this.splitTablePath(table.name);\n    let sql = `CREATE TABLE ${this.escapePath(table.name)} (${columnDefinitions}`;\n    let [databaseNew, tableName] = this.splitTablePath(table.name);\n    const newTableName = temporaryTable ? `${databaseNew ? `${databaseNew}.` : \"\"}${tableName.replace(/^temporary_/, \"\")}` : table.name;\n    // need for `addColumn()` method, because it recreates table.\n    table.columns.filter(column => column.isUnique).forEach(column => {\n      const isUniqueExist = table.uniques.some(unique => unique.columnNames.length === 1 && unique.columnNames[0] === column.name);\n      if (!isUniqueExist) table.uniques.push(new TableUnique({\n        name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),\n        columnNames: [column.name]\n      }));\n    });\n    if (table.uniques.length > 0) {\n      const uniquesSql = table.uniques.map(unique => {\n        const uniqueName = unique.name ? unique.name : this.connection.namingStrategy.uniqueConstraintName(newTableName, unique.columnNames);\n        const columnNames = unique.columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n        return `CONSTRAINT \"${uniqueName}\" UNIQUE (${columnNames})`;\n      }).join(\", \");\n      sql += `, ${uniquesSql}`;\n    }\n    if (table.checks.length > 0) {\n      const checksSql = table.checks.map(check => {\n        const checkName = check.name ? check.name : this.connection.namingStrategy.checkConstraintName(newTableName, check.expression);\n        return `CONSTRAINT \"${checkName}\" CHECK (${check.expression})`;\n      }).join(\", \");\n      sql += `, ${checksSql}`;\n    }\n    if (table.foreignKeys.length > 0 && createForeignKeys) {\n      const foreignKeysSql = table.foreignKeys.filter(fk => {\n        const [referencedDatabase] = this.splitTablePath(fk.referencedTableName);\n        if (referencedDatabase !== database) {\n          return false;\n        }\n        return true;\n      }).map(fk => {\n        const [, referencedTable] = this.splitTablePath(fk.referencedTableName);\n        const columnNames = fk.columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n        if (!fk.name) fk.name = this.connection.namingStrategy.foreignKeyName(newTableName, fk.columnNames, this.getTablePath(fk), fk.referencedColumnNames);\n        const referencedColumnNames = fk.referencedColumnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n        let constraint = `CONSTRAINT \"${fk.name}\" FOREIGN KEY (${columnNames}) REFERENCES \"${referencedTable}\" (${referencedColumnNames})`;\n        if (fk.onDelete) constraint += ` ON DELETE ${fk.onDelete}`;\n        if (fk.onUpdate) constraint += ` ON UPDATE ${fk.onUpdate}`;\n        if (fk.deferrable) constraint += ` DEFERRABLE ${fk.deferrable}`;\n        return constraint;\n      }).join(\", \");\n      sql += `, ${foreignKeysSql}`;\n    }\n    if (primaryColumns.length > 1) {\n      const columnNames = primaryColumns.map(column => `\"${column.name}\"`).join(\", \");\n      sql += `, PRIMARY KEY (${columnNames})`;\n    }\n    sql += `)`;\n    if (table.withoutRowid) {\n      sql += \" WITHOUT ROWID\";\n    }\n    return new Query(sql);\n  }\n  /**\n   * Builds drop table sql.\n   */\n  dropTableSql(tableOrName, ifExist) {\n    const tableName = InstanceChecker.isTable(tableOrName) ? tableOrName.name : tableOrName;\n    const query = ifExist ? `DROP TABLE IF EXISTS ${this.escapePath(tableName)}` : `DROP TABLE ${this.escapePath(tableName)}`;\n    return new Query(query);\n  }\n  createViewSql(view) {\n    if (typeof view.expression === \"string\") {\n      return new Query(`CREATE VIEW \"${view.name}\" AS ${view.expression}`);\n    } else {\n      return new Query(`CREATE VIEW \"${view.name}\" AS ${view.expression(this.connection).getQuery()}`);\n    }\n  }\n  insertViewDefinitionSql(view) {\n    const expression = typeof view.expression === \"string\" ? view.expression.trim() : view.expression(this.connection).getQuery();\n    return this.insertTypeormMetadataSql({\n      type: MetadataTableType.VIEW,\n      name: view.name,\n      value: expression\n    });\n  }\n  /**\n   * Builds drop view sql.\n   */\n  dropViewSql(viewOrPath) {\n    const viewName = InstanceChecker.isView(viewOrPath) ? viewOrPath.name : viewOrPath;\n    return new Query(`DROP VIEW \"${viewName}\"`);\n  }\n  /**\n   * Builds remove view sql.\n   */\n  deleteViewDefinitionSql(viewOrPath) {\n    const viewName = InstanceChecker.isView(viewOrPath) ? viewOrPath.name : viewOrPath;\n    return this.deleteTypeormMetadataSql({\n      type: MetadataTableType.VIEW,\n      name: viewName\n    });\n  }\n  /**\n   * Builds create index sql.\n   */\n  createIndexSql(table, index) {\n    const columns = index.columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n    const [database, tableName] = this.splitTablePath(table.name);\n    return new Query(`CREATE ${index.isUnique ? \"UNIQUE \" : \"\"}INDEX ${database ? `\"${database}\".` : \"\"}${this.escapePath(index.name)} ON \"${tableName}\" (${columns}) ${index.where ? \"WHERE \" + index.where : \"\"}`);\n  }\n  /**\n   * Builds drop index sql.\n   */\n  dropIndexSql(indexOrName) {\n    let indexName = InstanceChecker.isTableIndex(indexOrName) ? indexOrName.name : indexOrName;\n    return new Query(`DROP INDEX ${this.escapePath(indexName)}`);\n  }\n  /**\n   * Builds a query for create column.\n   */\n  buildCreateColumnSql(column, skipPrimary) {\n    let c = '\"' + column.name + '\"';\n    if (InstanceChecker.isColumnMetadata(column)) {\n      c += \" \" + this.driver.normalizeType(column);\n    } else {\n      c += \" \" + this.connection.driver.createFullType(column);\n    }\n    if (column.enum) c += ' CHECK( \"' + column.name + '\" IN (' + column.enum.map(val => \"'\" + val + \"'\").join(\",\") + \") )\";\n    if (column.isPrimary && !skipPrimary) c += \" PRIMARY KEY\";\n    if (column.isGenerated === true && column.generationStrategy === \"increment\")\n      // don't use skipPrimary here since updates can update already exist primary without auto inc.\n      c += \" AUTOINCREMENT\";\n    if (column.collation) c += \" COLLATE \" + column.collation;\n    if (column.isNullable !== true) c += \" NOT NULL\";\n    if (column.asExpression) {\n      c += ` AS (${column.asExpression}) ${column.generatedType ? column.generatedType : \"VIRTUAL\"}`;\n    } else {\n      if (column.default !== undefined && column.default !== null) c += \" DEFAULT (\" + column.default + \")\";\n    }\n    return c;\n  }\n  async recreateTable(newTable, oldTable, migrateData = true) {\n    const upQueries = [];\n    const downQueries = [];\n    // drop old table indices\n    oldTable.indices.forEach(index => {\n      upQueries.push(this.dropIndexSql(index));\n      downQueries.push(this.createIndexSql(oldTable, index));\n    });\n    // change table name into 'temporary_table'\n    let [databaseNew, tableNameNew] = this.splitTablePath(newTable.name);\n    let [, tableNameOld] = this.splitTablePath(oldTable.name);\n    newTable.name = tableNameNew = `${databaseNew ? `${databaseNew}.` : \"\"}temporary_${tableNameNew}`;\n    // create new table\n    upQueries.push(this.createTableSql(newTable, true, true));\n    downQueries.push(this.dropTableSql(newTable));\n    // migrate all data from the old table into new table\n    if (migrateData) {\n      let newColumnNames = newTable.columns.filter(column => !column.generatedType).map(column => `\"${column.name}\"`);\n      let oldColumnNames = oldTable.columns.filter(column => !column.generatedType).map(column => `\"${column.name}\"`);\n      if (oldColumnNames.length < newColumnNames.length) {\n        newColumnNames = newTable.columns.filter(column => {\n          const oldColumn = oldTable.columns.find(c => c.name === column.name);\n          if (oldColumn && oldColumn.generatedType) return false;\n          return !column.generatedType && oldColumn;\n        }).map(column => `\"${column.name}\"`);\n      } else if (oldColumnNames.length > newColumnNames.length) {\n        oldColumnNames = oldTable.columns.filter(column => {\n          return !column.generatedType && newTable.columns.find(c => c.name === column.name);\n        }).map(column => `\"${column.name}\"`);\n      }\n      upQueries.push(new Query(`INSERT INTO ${this.escapePath(newTable.name)}(${newColumnNames.join(\", \")}) SELECT ${oldColumnNames.join(\", \")} FROM ${this.escapePath(oldTable.name)}`));\n      downQueries.push(new Query(`INSERT INTO ${this.escapePath(oldTable.name)}(${oldColumnNames.join(\", \")}) SELECT ${newColumnNames.join(\", \")} FROM ${this.escapePath(newTable.name)}`));\n    }\n    // drop old table\n    upQueries.push(this.dropTableSql(oldTable));\n    downQueries.push(this.createTableSql(oldTable, true));\n    // rename old table\n    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable.name)} RENAME TO ${this.escapePath(tableNameOld)}`));\n    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(oldTable.name)} RENAME TO ${this.escapePath(tableNameNew)}`));\n    newTable.name = oldTable.name;\n    // recreate table indices\n    newTable.indices.forEach(index => {\n      // new index may be passed without name. In this case we generate index name manually.\n      if (!index.name) index.name = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);\n      upQueries.push(this.createIndexSql(newTable, index));\n      downQueries.push(this.dropIndexSql(index));\n    });\n    // update generated columns in \"typeorm_metadata\" table\n    // Step 1: clear data for removed generated columns\n    oldTable.columns.filter(column => {\n      const newTableColumn = newTable.columns.find(c => c.name === column.name);\n      // we should delete record from \"typeorm_metadata\" if generated column was removed\n      // or it was changed to non-generated\n      return column.generatedType && column.asExpression && (!newTableColumn || !newTableColumn.generatedType && !newTableColumn.asExpression);\n    }).forEach(column => {\n      const deleteQuery = this.deleteTypeormMetadataSql({\n        table: oldTable.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name\n      });\n      const insertQuery = this.insertTypeormMetadataSql({\n        table: oldTable.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name,\n        value: column.asExpression\n      });\n      upQueries.push(deleteQuery);\n      downQueries.push(insertQuery);\n    });\n    // Step 2: add data for new generated columns\n    newTable.columns.filter(column => column.generatedType && column.asExpression && !oldTable.columns.some(c => c.name === column.name)).forEach(column => {\n      const insertQuery = this.insertTypeormMetadataSql({\n        table: newTable.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name,\n        value: column.asExpression\n      });\n      const deleteQuery = this.deleteTypeormMetadataSql({\n        table: newTable.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name\n      });\n      upQueries.push(insertQuery);\n      downQueries.push(deleteQuery);\n    });\n    // Step 3: update changed expressions\n    newTable.columns.filter(column => column.generatedType && column.asExpression).forEach(column => {\n      const oldColumn = oldTable.columns.find(c => c.name === column.name && c.generatedType && column.generatedType && c.asExpression !== column.asExpression);\n      if (!oldColumn) return;\n      // update expression\n      const deleteQuery = this.deleteTypeormMetadataSql({\n        table: oldTable.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: oldColumn.name\n      });\n      const insertQuery = this.insertTypeormMetadataSql({\n        table: newTable.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name,\n        value: column.asExpression\n      });\n      upQueries.push(deleteQuery);\n      upQueries.push(insertQuery);\n      // revert update\n      const revertInsertQuery = this.insertTypeormMetadataSql({\n        table: newTable.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: oldColumn.name,\n        value: oldColumn.asExpression\n      });\n      const revertDeleteQuery = this.deleteTypeormMetadataSql({\n        table: oldTable.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name\n      });\n      downQueries.push(revertInsertQuery);\n      downQueries.push(revertDeleteQuery);\n    });\n    await this.executeQueries(upQueries, downQueries);\n    this.replaceCachedTable(oldTable, newTable);\n  }\n  /**\n   * tablePath e.g. \"myDB.myTable\", \"myTable\"\n   */\n  splitTablePath(tablePath) {\n    return tablePath.indexOf(\".\") !== -1 ? tablePath.split(\".\") : [undefined, tablePath];\n  }\n  /**\n   * Escapes given table or view path. Tolerates leading/trailing dots\n   */\n  escapePath(target, disableEscape) {\n    const tableName = InstanceChecker.isTable(target) || InstanceChecker.isView(target) ? target.name : target;\n    return tableName.replace(/^\\.+|\\.+$/g, \"\").split(\".\").map(i => disableEscape ? i : `\"${i}\"`).join(\".\");\n  }\n  /**\n   * Change table comment.\n   */\n  changeTableComment(tableOrName, comment) {\n    throw new TypeORMError(`sqlit driver does not support change comment.`);\n  }\n}","map":{"version":3,"names":["TransactionNotStartedError","TableColumn","Table","TableIndex","TableForeignKey","View","Query","TableUnique","BaseQueryRunner","OrmUtils","TableCheck","TransactionAlreadyStartedError","TypeORMError","MetadataTableType","InstanceChecker","AbstractSqliteQueryRunner","constructor","transactionPromise","connect","Promise","resolve","driver","databaseConnection","release","loadedTables","clearSqlMemory","startTransaction","isolationLevel","transactionSupport","connection","options","type","isTransactionActive","broadcaster","broadcast","err","transactionDepth","query","commitTransaction","rollbackTransaction","stream","parameters","onEnd","onError","getDatabases","getSchemas","database","hasDatabase","getCurrentDatabase","undefined","hasSchema","schema","getCurrentSchema","hasTable","tableOrName","tableName","isTable","name","sql","result","length","hasColumn","columnName","escapePath","columns","find","column","createDatabase","ifNotExist","dropDatabase","ifExist","createSchema","schemaPath","dropSchema","createTable","table","createForeignKeys","createIndices","upQueries","downQueries","isTableExist","push","createTableSql","dropTableSql","indices","forEach","index","namingStrategy","indexName","columnNames","where","createIndexSql","dropIndexSql","generatedColumns","filter","generatedType","asExpression","insertQuery","insertTypeormMetadataSql","GENERATED_COLUMN","value","deleteQuery","deleteTypeormMetadataSql","executeQueries","dropTable","dropForeignKeys","dropIndices","getCachedTable","createView","view","syncWithMetadata","createViewSql","insertViewDefinitionSql","dropViewSql","deleteViewDefinitionSql","dropView","target","viewName","isView","getCachedView","renameTable","oldTableOrName","newTableName","oldTable","newTable","clone","up","down","uniques","unique","oldUniqueName","uniqueConstraintName","foreignKeys","foreignKey","oldForeignKeyName","foreignKeyName","getTablePath","referencedColumnNames","oldIndexName","recreateTable","addColumn","addColumns","changedTable","renameColumn","oldTableColumnOrName","newTableColumnOrName","oldColumn","isTableColumn","c","newColumn","changeColumn","changeColumns","changedColumns","changedColumnSet","findColumnUniques","uniqueName","splice","indexOf","findColumnForeignKeys","findColumnIndices","originalColumn","dropColumn","columnOrName","findColumnByName","dropColumns","columnInstance","Error","removeColumn","removeUniqueConstraint","removeIndex","fk","removeForeignKey","createPrimaryKey","isPrimary","updatePrimaryKeys","dropPrimaryKey","primaryColumns","createUniqueConstraint","uniqueConstraint","createUniqueConstraints","uniqueConstraints","addUniqueConstraint","dropUniqueConstraint","uniqueOrName","isTableUnique","u","dropUniqueConstraints","createCheckConstraint","checkConstraint","createCheckConstraints","checkConstraints","addCheckConstraint","dropCheckConstraint","checkOrName","isTableCheck","checks","dropCheckConstraints","removeCheckConstraint","createExclusionConstraint","exclusionConstraint","createExclusionConstraints","exclusionConstraints","dropExclusionConstraint","exclusionOrName","dropExclusionConstraints","createForeignKey","addForeignKey","dropForeignKey","foreignKeyOrName","isTableForeignKey","createIndex","generateIndexName","addIndex","promises","map","all","dropIndex","indexOrName","isTableIndex","i","clearTable","clearDatabase","dbPath","getAttachedDatabaseHandleByRelativePath","isAnotherTransactionActive","selectViewDropsQuery","dropViewQueries","q","selectTableDropsQuery","dropTableQueries","error","rollbackError","loadViews","viewNames","getTypeormMetadataTableName","viewNamesString","join","VIEW","dbViews","dbView","expression","loadTableRecords","tablePath","tableOrIndex","splitTablePath","getAttachedDatabasePathRelativeByHandle","loadPragmaRecords","pragma","loadTables","tableNames","dbTables","dbIndicesDef","tablesSql","tableNamesString","tableNamesWithoutDot","split","tableNamesWithDot","queryPromises","reduce","acc","res","Boolean","dbTable","withoutRowid","includes","dbColumns","dbIndices","dbForeignKeys","autoIncrementColumnName","tableSql","autoIncrementIndex","toUpperCase","substr","comma","lastIndexOf","bracket","dbColumn","tableColumn","toLowerCase","default","isNullable","comment","isGenerated","generationStrategy","asExpressionQuery","selectTypeormMetadataSql","results","enum","parseSqlCheckExpression","pos","fullType","dataType","withLengthColumnTypes","col","len","parseInt","substring","toString","withPrecisionColumnTypes","re","RegExp","matches","match","precision","withScaleColumnTypes","scale","fkResult","fkMappings","fkRegex","exec","referencedTableName","tableForeignKeyConstraints","uniq","dbForeignKey","ownForeignKeys","fkMapping","it","every","onDelete","onUpdate","uniqueRegexResult","uniqueMappings","uniqueRegex","tableUniquePromises","dbIndex","self","dbIndexName","indexInfos","indexColumns","sort","indexInfo1","indexInfo2","indexInfo","indexColumn","isUnique","foundMapping","mapping","regexp","indicesPromises","indexDef","dbIndexDef","condition","dbIndexPath","temporaryTable","hasAutoIncrement","skipPrimary","columnDefinitions","buildCreateColumnSql","databaseNew","replace","isUniqueExist","some","uniquesSql","checksSql","check","checkName","checkConstraintName","foreignKeysSql","referencedDatabase","referencedTable","constraint","deferrable","getQuery","trim","viewOrPath","isColumnMetadata","normalizeType","createFullType","val","collation","migrateData","tableNameNew","tableNameOld","newColumnNames","oldColumnNames","newTableColumn","revertInsertQuery","revertDeleteQuery","replaceCachedTable","disableEscape","changeTableComment"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\driver\\sqlite-abstract\\AbstractSqliteQueryRunner.ts"],"sourcesContent":["import { QueryRunner } from \"../../query-runner/QueryRunner\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\"\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\"\nimport { Table } from \"../../schema-builder/table/Table\"\nimport { TableIndex } from \"../../schema-builder/table/TableIndex\"\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\"\nimport { View } from \"../../schema-builder/view/View\"\nimport { Query } from \"../Query\"\nimport { AbstractSqliteDriver } from \"./AbstractSqliteDriver\"\nimport { ReadStream } from \"../../platform/PlatformTools\"\nimport { TableIndexOptions } from \"../../schema-builder/options/TableIndexOptions\"\nimport { TableUnique } from \"../../schema-builder/table/TableUnique\"\nimport { BaseQueryRunner } from \"../../query-runner/BaseQueryRunner\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { TableCheck } from \"../../schema-builder/table/TableCheck\"\nimport { IsolationLevel } from \"../types/IsolationLevel\"\nimport { TableExclusion } from \"../../schema-builder/table/TableExclusion\"\nimport { TransactionAlreadyStartedError, TypeORMError } from \"../../error\"\nimport { MetadataTableType } from \"../types/MetadataTableType\"\nimport { InstanceChecker } from \"../../util/InstanceChecker\"\n\n/**\n * Runs queries on a single sqlite database connection.\n */\nexport abstract class AbstractSqliteQueryRunner\n    extends BaseQueryRunner\n    implements QueryRunner\n{\n    // -------------------------------------------------------------------------\n    // Public Implemented Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Database driver used by connection.\n     */\n    driver: AbstractSqliteDriver\n\n    protected transactionPromise: Promise<any> | null = null\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor() {\n        super()\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates/uses database connection from the connection pool to perform further operations.\n     * Returns obtained database connection.\n     */\n    connect(): Promise<any> {\n        return Promise.resolve(this.driver.databaseConnection)\n    }\n\n    /**\n     * Releases used database connection.\n     * We just clear loaded tables and sql in memory, because sqlite do not support multiple connections thus query runners.\n     */\n    release(): Promise<void> {\n        this.loadedTables = []\n        this.clearSqlMemory()\n        return Promise.resolve()\n    }\n\n    /**\n     * Starts transaction.\n     */\n    async startTransaction(isolationLevel?: IsolationLevel): Promise<void> {\n        if (this.driver.transactionSupport === \"none\")\n            throw new TypeORMError(\n                `Transactions aren't supported by ${this.connection.driver.options.type}.`,\n            )\n\n        if (\n            this.isTransactionActive &&\n            this.driver.transactionSupport === \"simple\"\n        )\n            throw new TransactionAlreadyStartedError()\n\n        if (\n            isolationLevel &&\n            isolationLevel !== \"READ UNCOMMITTED\" &&\n            isolationLevel !== \"SERIALIZABLE\"\n        )\n            throw new TypeORMError(\n                `SQLite only supports SERIALIZABLE and READ UNCOMMITTED isolation`,\n            )\n\n        this.isTransactionActive = true\n        try {\n            await this.broadcaster.broadcast(\"BeforeTransactionStart\")\n        } catch (err) {\n            this.isTransactionActive = false\n            throw err\n        }\n\n        if (this.transactionDepth === 0) {\n            this.transactionDepth += 1\n            if (isolationLevel) {\n                if (isolationLevel === \"READ UNCOMMITTED\") {\n                    await this.query(\"PRAGMA read_uncommitted = true\")\n                } else {\n                    await this.query(\"PRAGMA read_uncommitted = false\")\n                }\n            }\n            await this.query(\"BEGIN TRANSACTION\")\n        } else {\n            this.transactionDepth += 1\n            await this.query(`SAVEPOINT typeorm_${this.transactionDepth - 1}`)\n        }\n\n        await this.broadcaster.broadcast(\"AfterTransactionStart\")\n    }\n\n    /**\n     * Commits transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async commitTransaction(): Promise<void> {\n        if (!this.isTransactionActive) throw new TransactionNotStartedError()\n\n        await this.broadcaster.broadcast(\"BeforeTransactionCommit\")\n\n        if (this.transactionDepth > 1) {\n            this.transactionDepth -= 1\n            await this.query(\n                `RELEASE SAVEPOINT typeorm_${this.transactionDepth}`,\n            )\n        } else {\n            this.transactionDepth -= 1\n            await this.query(\"COMMIT\")\n            this.isTransactionActive = false\n        }\n\n        await this.broadcaster.broadcast(\"AfterTransactionCommit\")\n    }\n\n    /**\n     * Rollbacks transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async rollbackTransaction(): Promise<void> {\n        if (!this.isTransactionActive) throw new TransactionNotStartedError()\n\n        await this.broadcaster.broadcast(\"BeforeTransactionRollback\")\n\n        if (this.transactionDepth > 1) {\n            this.transactionDepth -= 1\n            await this.query(\n                `ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth}`,\n            )\n        } else {\n            this.transactionDepth -= 1\n            await this.query(\"ROLLBACK\")\n            this.isTransactionActive = false\n        }\n\n        await this.broadcaster.broadcast(\"AfterTransactionRollback\")\n    }\n\n    /**\n     * Returns raw data stream.\n     */\n    stream(\n        query: string,\n        parameters?: any[],\n        onEnd?: Function,\n        onError?: Function,\n    ): Promise<ReadStream> {\n        throw new TypeORMError(`Stream is not supported by sqlite driver.`)\n    }\n\n    /**\n     * Returns all available database names including system databases.\n     */\n    async getDatabases(): Promise<string[]> {\n        return Promise.resolve([])\n    }\n\n    /**\n     * Returns all available schema names including system schemas.\n     * If database parameter specified, returns schemas of that database.\n     */\n    async getSchemas(database?: string): Promise<string[]> {\n        return Promise.resolve([])\n    }\n\n    /**\n     * Checks if database with the given name exist.\n     */\n    async hasDatabase(database: string): Promise<boolean> {\n        return Promise.resolve(false)\n    }\n\n    /**\n     * Loads currently using database\n     */\n    async getCurrentDatabase(): Promise<undefined> {\n        return Promise.resolve(undefined)\n    }\n\n    /**\n     * Checks if schema with the given name exist.\n     */\n    async hasSchema(schema: string): Promise<boolean> {\n        throw new TypeORMError(`This driver does not support table schemas`)\n    }\n\n    /**\n     * Loads currently using database schema\n     */\n    async getCurrentSchema(): Promise<undefined> {\n        return Promise.resolve(undefined)\n    }\n\n    /**\n     * Checks if table with the given name exist in the database.\n     */\n    async hasTable(tableOrName: Table | string): Promise<boolean> {\n        const tableName = InstanceChecker.isTable(tableOrName)\n            ? tableOrName.name\n            : tableOrName\n        const sql = `SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" = '${tableName}'`\n        const result = await this.query(sql)\n        return result.length ? true : false\n    }\n\n    /**\n     * Checks if column with the given name exist in the given table.\n     */\n    async hasColumn(\n        tableOrName: Table | string,\n        columnName: string,\n    ): Promise<boolean> {\n        const tableName = InstanceChecker.isTable(tableOrName)\n            ? tableOrName.name\n            : tableOrName\n        const sql = `PRAGMA table_xinfo(${this.escapePath(tableName)})`\n        const columns: ObjectLiteral[] = await this.query(sql)\n        return !!columns.find((column) => column[\"name\"] === columnName)\n    }\n\n    /**\n     * Creates a new database.\n     */\n    async createDatabase(\n        database: string,\n        ifNotExist?: boolean,\n    ): Promise<void> {\n        return Promise.resolve()\n    }\n\n    /**\n     * Drops database.\n     */\n    async dropDatabase(database: string, ifExist?: boolean): Promise<void> {\n        return Promise.resolve()\n    }\n\n    /**\n     * Creates a new table schema.\n     */\n    async createSchema(\n        schemaPath: string,\n        ifNotExist?: boolean,\n    ): Promise<void> {\n        return Promise.resolve()\n    }\n\n    /**\n     * Drops table schema.\n     */\n    async dropSchema(schemaPath: string, ifExist?: boolean): Promise<void> {\n        return Promise.resolve()\n    }\n\n    /**\n     * Creates a new table.\n     */\n    async createTable(\n        table: Table,\n        ifNotExist: boolean = false,\n        createForeignKeys: boolean = true,\n        createIndices: boolean = true,\n    ): Promise<void> {\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        if (ifNotExist) {\n            const isTableExist = await this.hasTable(table)\n            if (isTableExist) return Promise.resolve()\n        }\n\n        upQueries.push(this.createTableSql(table, createForeignKeys))\n        downQueries.push(this.dropTableSql(table))\n\n        if (createIndices) {\n            table.indices.forEach((index) => {\n                // new index may be passed without name. In this case we generate index name manually.\n                if (!index.name)\n                    index.name = this.connection.namingStrategy.indexName(\n                        table,\n                        index.columnNames,\n                        index.where,\n                    )\n                upQueries.push(this.createIndexSql(table, index))\n                downQueries.push(this.dropIndexSql(index))\n            })\n        }\n\n        // if table have column with generated type, we must add the expression to the metadata table\n        const generatedColumns = table.columns.filter(\n            (column) => column.generatedType && column.asExpression,\n        )\n\n        for (const column of generatedColumns) {\n            const insertQuery = this.insertTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            })\n\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            })\n\n            upQueries.push(insertQuery)\n            downQueries.push(deleteQuery)\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Drops the table.\n     */\n    async dropTable(\n        tableOrName: Table | string,\n        ifExist?: boolean,\n        dropForeignKeys: boolean = true,\n        dropIndices: boolean = true,\n    ): Promise<void> {\n        if (ifExist) {\n            const isTableExist = await this.hasTable(tableOrName)\n            if (!isTableExist) return Promise.resolve()\n        }\n\n        // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.\n        const createForeignKeys: boolean = dropForeignKeys\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        if (dropIndices) {\n            table.indices.forEach((index) => {\n                upQueries.push(this.dropIndexSql(index))\n                downQueries.push(this.createIndexSql(table, index))\n            })\n        }\n\n        upQueries.push(this.dropTableSql(table, ifExist))\n        downQueries.push(this.createTableSql(table, createForeignKeys))\n\n        // if table had columns with generated type, we must remove the expression from the metadata table\n        const generatedColumns = table.columns.filter(\n            (column) => column.generatedType && column.asExpression,\n        )\n\n        for (const column of generatedColumns) {\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            })\n\n            const insertQuery = this.insertTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            })\n\n            upQueries.push(deleteQuery)\n            downQueries.push(insertQuery)\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Creates a new view.\n     */\n    async createView(\n        view: View,\n        syncWithMetadata: boolean = false,\n    ): Promise<void> {\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n        upQueries.push(this.createViewSql(view))\n        if (syncWithMetadata) upQueries.push(this.insertViewDefinitionSql(view))\n        downQueries.push(this.dropViewSql(view))\n        if (syncWithMetadata)\n            downQueries.push(this.deleteViewDefinitionSql(view))\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Drops the view.\n     */\n    async dropView(target: View | string): Promise<void> {\n        const viewName = InstanceChecker.isView(target) ? target.name : target\n        const view = await this.getCachedView(viewName)\n\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n        upQueries.push(this.deleteViewDefinitionSql(view))\n        upQueries.push(this.dropViewSql(view))\n        downQueries.push(this.insertViewDefinitionSql(view))\n        downQueries.push(this.createViewSql(view))\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Renames the given table.\n     */\n    async renameTable(\n        oldTableOrName: Table | string,\n        newTableName: string,\n    ): Promise<void> {\n        const oldTable = InstanceChecker.isTable(oldTableOrName)\n            ? oldTableOrName\n            : await this.getCachedTable(oldTableOrName)\n        const newTable = oldTable.clone()\n\n        newTable.name = newTableName\n\n        // rename table\n        const up = new Query(\n            `ALTER TABLE ${this.escapePath(\n                oldTable.name,\n            )} RENAME TO ${this.escapePath(newTableName)}`,\n        )\n        const down = new Query(\n            `ALTER TABLE ${this.escapePath(\n                newTableName,\n            )} RENAME TO ${this.escapePath(oldTable.name)}`,\n        )\n        await this.executeQueries(up, down)\n\n        // rename unique constraints\n        newTable.uniques.forEach((unique) => {\n            const oldUniqueName =\n                this.connection.namingStrategy.uniqueConstraintName(\n                    oldTable,\n                    unique.columnNames,\n                )\n\n            // Skip renaming if Unique has user defined constraint name\n            if (unique.name !== oldUniqueName) return\n\n            unique.name = this.connection.namingStrategy.uniqueConstraintName(\n                newTable,\n                unique.columnNames,\n            )\n        })\n\n        // rename foreign key constraints\n        newTable.foreignKeys.forEach((foreignKey) => {\n            const oldForeignKeyName =\n                this.connection.namingStrategy.foreignKeyName(\n                    oldTable,\n                    foreignKey.columnNames,\n                    this.getTablePath(foreignKey),\n                    foreignKey.referencedColumnNames,\n                )\n\n            // Skip renaming if foreign key has user defined constraint name\n            if (foreignKey.name !== oldForeignKeyName) return\n\n            foreignKey.name = this.connection.namingStrategy.foreignKeyName(\n                newTable,\n                foreignKey.columnNames,\n                this.getTablePath(foreignKey),\n                foreignKey.referencedColumnNames,\n            )\n        })\n\n        // rename indices\n        newTable.indices.forEach((index) => {\n            const oldIndexName = this.connection.namingStrategy.indexName(\n                oldTable,\n                index.columnNames,\n                index.where,\n            )\n\n            // Skip renaming if Index has user defined constraint name\n            if (index.name !== oldIndexName) return\n\n            index.name = this.connection.namingStrategy.indexName(\n                newTable,\n                index.columnNames,\n                index.where,\n            )\n        })\n\n        // rename old table;\n        oldTable.name = newTable.name\n\n        // recreate table with new constraint names\n        await this.recreateTable(newTable, oldTable)\n    }\n\n    /**\n     * Creates a new column from the column in the table.\n     */\n    async addColumn(\n        tableOrName: Table | string,\n        column: TableColumn,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        return this.addColumns(table!, [column])\n    }\n\n    /**\n     * Creates a new columns from the column in the table.\n     */\n    async addColumns(\n        tableOrName: Table | string,\n        columns: TableColumn[],\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const changedTable = table.clone()\n        columns.forEach((column) => changedTable.addColumn(column))\n        await this.recreateTable(changedTable, table)\n    }\n\n    /**\n     * Renames column in the given table.\n     */\n    async renameColumn(\n        tableOrName: Table | string,\n        oldTableColumnOrName: TableColumn | string,\n        newTableColumnOrName: TableColumn | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName)\n            ? oldTableColumnOrName\n            : table.columns.find((c) => c.name === oldTableColumnOrName)\n        if (!oldColumn)\n            throw new TypeORMError(\n                `Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`,\n            )\n\n        let newColumn: TableColumn | undefined = undefined\n        if (InstanceChecker.isTableColumn(newTableColumnOrName)) {\n            newColumn = newTableColumnOrName\n        } else {\n            newColumn = oldColumn.clone()\n            newColumn.name = newTableColumnOrName\n        }\n\n        return this.changeColumn(table, oldColumn, newColumn)\n    }\n\n    /**\n     * Changes a column in the table.\n     */\n    async changeColumn(\n        tableOrName: Table | string,\n        oldTableColumnOrName: TableColumn | string,\n        newColumn: TableColumn,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName)\n            ? oldTableColumnOrName\n            : table.columns.find((c) => c.name === oldTableColumnOrName)\n        if (!oldColumn)\n            throw new TypeORMError(\n                `Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`,\n            )\n\n        await this.changeColumns(table, [{ oldColumn, newColumn }])\n    }\n\n    /**\n     * Changes a column in the table.\n     * Changed column looses all its keys in the db.\n     */\n    async changeColumns(\n        tableOrName: Table | string,\n        changedColumns: { oldColumn: TableColumn; newColumn: TableColumn }[],\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const changedTable = table.clone()\n        changedColumns.forEach((changedColumnSet) => {\n            if (\n                changedColumnSet.newColumn.name !==\n                changedColumnSet.oldColumn.name\n            ) {\n                changedTable\n                    .findColumnUniques(changedColumnSet.oldColumn)\n                    .forEach((unique) => {\n                        const uniqueName =\n                            this.connection.namingStrategy.uniqueConstraintName(\n                                table,\n                                unique.columnNames,\n                            )\n\n                        unique.columnNames.splice(\n                            unique.columnNames.indexOf(\n                                changedColumnSet.oldColumn.name,\n                            ),\n                            1,\n                        )\n                        unique.columnNames.push(changedColumnSet.newColumn.name)\n\n                        // rename Unique only if it has default constraint name\n                        if (unique.name === uniqueName) {\n                            unique.name =\n                                this.connection.namingStrategy.uniqueConstraintName(\n                                    changedTable,\n                                    unique.columnNames,\n                                )\n                        }\n                    })\n\n                changedTable\n                    .findColumnForeignKeys(changedColumnSet.oldColumn)\n                    .forEach((foreignKey) => {\n                        const foreignKeyName =\n                            this.connection.namingStrategy.foreignKeyName(\n                                table,\n                                foreignKey.columnNames,\n                                this.getTablePath(foreignKey),\n                                foreignKey.referencedColumnNames,\n                            )\n\n                        foreignKey.columnNames.splice(\n                            foreignKey.columnNames.indexOf(\n                                changedColumnSet.oldColumn.name,\n                            ),\n                            1,\n                        )\n                        foreignKey.columnNames.push(\n                            changedColumnSet.newColumn.name,\n                        )\n\n                        // rename FK only if it has default constraint name\n                        if (foreignKey.name === foreignKeyName) {\n                            foreignKey.name =\n                                this.connection.namingStrategy.foreignKeyName(\n                                    changedTable,\n                                    foreignKey.columnNames,\n                                    this.getTablePath(foreignKey),\n                                    foreignKey.referencedColumnNames,\n                                )\n                        }\n                    })\n\n                changedTable\n                    .findColumnIndices(changedColumnSet.oldColumn)\n                    .forEach((index) => {\n                        const indexName =\n                            this.connection.namingStrategy.indexName(\n                                table,\n                                index.columnNames,\n                                index.where,\n                            )\n\n                        index.columnNames.splice(\n                            index.columnNames.indexOf(\n                                changedColumnSet.oldColumn.name,\n                            ),\n                            1,\n                        )\n                        index.columnNames.push(changedColumnSet.newColumn.name)\n\n                        // rename Index only if it has default constraint name\n                        if (index.name === indexName) {\n                            index.name =\n                                this.connection.namingStrategy.indexName(\n                                    changedTable,\n                                    index.columnNames,\n                                    index.where,\n                                )\n                        }\n                    })\n            }\n            const originalColumn = changedTable.columns.find(\n                (column) => column.name === changedColumnSet.oldColumn.name,\n            )\n            if (originalColumn)\n                changedTable.columns[\n                    changedTable.columns.indexOf(originalColumn)\n                ] = changedColumnSet.newColumn\n        })\n\n        await this.recreateTable(changedTable, table)\n    }\n\n    /**\n     * Drops column in the table.\n     */\n    async dropColumn(\n        tableOrName: Table | string,\n        columnOrName: TableColumn | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const column = InstanceChecker.isTableColumn(columnOrName)\n            ? columnOrName\n            : table.findColumnByName(columnOrName)\n        if (!column)\n            throw new TypeORMError(\n                `Column \"${columnOrName}\" was not found in table \"${table.name}\"`,\n            )\n\n        await this.dropColumns(table, [column])\n    }\n\n    /**\n     * Drops the columns in the table.\n     */\n    async dropColumns(\n        tableOrName: Table | string,\n        columns: TableColumn[] | string[],\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // clone original table and remove column and its constraints from cloned table\n        const changedTable = table.clone()\n        columns.forEach((column: TableColumn | string) => {\n            const columnInstance = InstanceChecker.isTableColumn(column)\n                ? column\n                : table.findColumnByName(column)\n            if (!columnInstance)\n                throw new Error(\n                    `Column \"${column}\" was not found in table \"${table.name}\"`,\n                )\n\n            changedTable.removeColumn(columnInstance)\n            changedTable\n                .findColumnUniques(columnInstance)\n                .forEach((unique) =>\n                    changedTable.removeUniqueConstraint(unique),\n                )\n            changedTable\n                .findColumnIndices(columnInstance)\n                .forEach((index) => changedTable.removeIndex(index))\n            changedTable\n                .findColumnForeignKeys(columnInstance)\n                .forEach((fk) => changedTable.removeForeignKey(fk))\n        })\n\n        await this.recreateTable(changedTable, table)\n    }\n\n    /**\n     * Creates a new primary key.\n     */\n    async createPrimaryKey(\n        tableOrName: Table | string,\n        columnNames: string[],\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        // clone original table and mark columns as primary\n        const changedTable = table.clone()\n        changedTable.columns.forEach((column) => {\n            if (columnNames.find((columnName) => columnName === column.name))\n                column.isPrimary = true\n        })\n\n        await this.recreateTable(changedTable, table)\n        // mark columns as primary in original table\n        table.columns.forEach((column) => {\n            if (columnNames.find((columnName) => columnName === column.name))\n                column.isPrimary = true\n        })\n    }\n\n    /**\n     * Updates composite primary keys.\n     */\n    async updatePrimaryKeys(\n        tableOrName: Table | string,\n        columns: TableColumn[],\n    ): Promise<void> {\n        await Promise.resolve()\n    }\n\n    /**\n     * Drops a primary key.\n     */\n    async dropPrimaryKey(tableOrName: Table | string): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        // clone original table and mark primary columns as non-primary\n        const changedTable = table.clone()\n        changedTable.primaryColumns.forEach((column) => {\n            column.isPrimary = false\n        })\n\n        await this.recreateTable(changedTable, table)\n        // mark primary columns as non-primary in original table\n        table.primaryColumns.forEach((column) => {\n            column.isPrimary = false\n        })\n    }\n\n    /**\n     * Creates a new unique constraint.\n     */\n    async createUniqueConstraint(\n        tableOrName: Table | string,\n        uniqueConstraint: TableUnique,\n    ): Promise<void> {\n        await this.createUniqueConstraints(tableOrName, [uniqueConstraint])\n    }\n\n    /**\n     * Creates a new unique constraints.\n     */\n    async createUniqueConstraints(\n        tableOrName: Table | string,\n        uniqueConstraints: TableUnique[],\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // clone original table and add unique constraints in to cloned table\n        const changedTable = table.clone()\n        uniqueConstraints.forEach((uniqueConstraint) =>\n            changedTable.addUniqueConstraint(uniqueConstraint),\n        )\n        await this.recreateTable(changedTable, table)\n    }\n\n    /**\n     * Drops an unique constraint.\n     */\n    async dropUniqueConstraint(\n        tableOrName: Table | string,\n        uniqueOrName: TableUnique | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const uniqueConstraint = InstanceChecker.isTableUnique(uniqueOrName)\n            ? uniqueOrName\n            : table.uniques.find((u) => u.name === uniqueOrName)\n        if (!uniqueConstraint)\n            throw new TypeORMError(\n                `Supplied unique constraint was not found in table ${table.name}`,\n            )\n\n        await this.dropUniqueConstraints(table, [uniqueConstraint])\n    }\n\n    /**\n     * Creates an unique constraints.\n     */\n    async dropUniqueConstraints(\n        tableOrName: Table | string,\n        uniqueConstraints: TableUnique[],\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // clone original table and remove unique constraints from cloned table\n        const changedTable = table.clone()\n        uniqueConstraints.forEach((uniqueConstraint) =>\n            changedTable.removeUniqueConstraint(uniqueConstraint),\n        )\n\n        await this.recreateTable(changedTable, table)\n    }\n\n    /**\n     * Creates new check constraint.\n     */\n    async createCheckConstraint(\n        tableOrName: Table | string,\n        checkConstraint: TableCheck,\n    ): Promise<void> {\n        await this.createCheckConstraints(tableOrName, [checkConstraint])\n    }\n\n    /**\n     * Creates new check constraints.\n     */\n    async createCheckConstraints(\n        tableOrName: Table | string,\n        checkConstraints: TableCheck[],\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // clone original table and add check constraints in to cloned table\n        const changedTable = table.clone()\n        checkConstraints.forEach((checkConstraint) =>\n            changedTable.addCheckConstraint(checkConstraint),\n        )\n        await this.recreateTable(changedTable, table)\n    }\n\n    /**\n     * Drops check constraint.\n     */\n    async dropCheckConstraint(\n        tableOrName: Table | string,\n        checkOrName: TableCheck | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const checkConstraint = InstanceChecker.isTableCheck(checkOrName)\n            ? checkOrName\n            : table.checks.find((c) => c.name === checkOrName)\n        if (!checkConstraint)\n            throw new TypeORMError(\n                `Supplied check constraint was not found in table ${table.name}`,\n            )\n\n        await this.dropCheckConstraints(table, [checkConstraint])\n    }\n\n    /**\n     * Drops check constraints.\n     */\n    async dropCheckConstraints(\n        tableOrName: Table | string,\n        checkConstraints: TableCheck[],\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // clone original table and remove check constraints from cloned table\n        const changedTable = table.clone()\n        checkConstraints.forEach((checkConstraint) =>\n            changedTable.removeCheckConstraint(checkConstraint),\n        )\n\n        await this.recreateTable(changedTable, table)\n    }\n\n    /**\n     * Creates a new exclusion constraint.\n     */\n    async createExclusionConstraint(\n        tableOrName: Table | string,\n        exclusionConstraint: TableExclusion,\n    ): Promise<void> {\n        throw new TypeORMError(`Sqlite does not support exclusion constraints.`)\n    }\n\n    /**\n     * Creates a new exclusion constraints.\n     */\n    async createExclusionConstraints(\n        tableOrName: Table | string,\n        exclusionConstraints: TableExclusion[],\n    ): Promise<void> {\n        throw new TypeORMError(`Sqlite does not support exclusion constraints.`)\n    }\n\n    /**\n     * Drops exclusion constraint.\n     */\n    async dropExclusionConstraint(\n        tableOrName: Table | string,\n        exclusionOrName: TableExclusion | string,\n    ): Promise<void> {\n        throw new TypeORMError(`Sqlite does not support exclusion constraints.`)\n    }\n\n    /**\n     * Drops exclusion constraints.\n     */\n    async dropExclusionConstraints(\n        tableOrName: Table | string,\n        exclusionConstraints: TableExclusion[],\n    ): Promise<void> {\n        throw new TypeORMError(`Sqlite does not support exclusion constraints.`)\n    }\n\n    /**\n     * Creates a new foreign key.\n     */\n    async createForeignKey(\n        tableOrName: Table | string,\n        foreignKey: TableForeignKey,\n    ): Promise<void> {\n        await this.createForeignKeys(tableOrName, [foreignKey])\n    }\n\n    /**\n     * Creates a new foreign keys.\n     */\n    async createForeignKeys(\n        tableOrName: Table | string,\n        foreignKeys: TableForeignKey[],\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        // clone original table and add foreign keys in to cloned table\n        const changedTable = table.clone()\n        foreignKeys.forEach((foreignKey) =>\n            changedTable.addForeignKey(foreignKey),\n        )\n\n        await this.recreateTable(changedTable, table)\n    }\n\n    /**\n     * Drops a foreign key from the table.\n     */\n    async dropForeignKey(\n        tableOrName: Table | string,\n        foreignKeyOrName: TableForeignKey | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const foreignKey = InstanceChecker.isTableForeignKey(foreignKeyOrName)\n            ? foreignKeyOrName\n            : table.foreignKeys.find((fk) => fk.name === foreignKeyOrName)\n        if (!foreignKey)\n            throw new TypeORMError(\n                `Supplied foreign key was not found in table ${table.name}`,\n            )\n\n        await this.dropForeignKeys(tableOrName, [foreignKey])\n    }\n\n    /**\n     * Drops a foreign keys from the table.\n     */\n    async dropForeignKeys(\n        tableOrName: Table | string,\n        foreignKeys: TableForeignKey[],\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // clone original table and remove foreign keys from cloned table\n        const changedTable = table.clone()\n        foreignKeys.forEach((foreignKey) =>\n            changedTable.removeForeignKey(foreignKey),\n        )\n\n        await this.recreateTable(changedTable, table)\n    }\n\n    /**\n     * Creates a new index.\n     */\n    async createIndex(\n        tableOrName: Table | string,\n        index: TableIndex,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // new index may be passed without name. In this case we generate index name manually.\n        if (!index.name) index.name = this.generateIndexName(table, index)\n\n        const up = this.createIndexSql(table, index)\n        const down = this.dropIndexSql(index)\n        await this.executeQueries(up, down)\n        table.addIndex(index)\n    }\n\n    /**\n     * Creates a new indices\n     */\n    async createIndices(\n        tableOrName: Table | string,\n        indices: TableIndex[],\n    ): Promise<void> {\n        const promises = indices.map((index) =>\n            this.createIndex(tableOrName, index),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Drops an index from the table.\n     */\n    async dropIndex(\n        tableOrName: Table | string,\n        indexOrName: TableIndex | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const index = InstanceChecker.isTableIndex(indexOrName)\n            ? indexOrName\n            : table.indices.find((i) => i.name === indexOrName)\n        if (!index)\n            throw new TypeORMError(\n                `Supplied index ${indexOrName} was not found in table ${table.name}`,\n            )\n\n        // old index may be passed without name. In this case we generate index name manually.\n        if (!index.name) index.name = this.generateIndexName(table, index)\n\n        const up = this.dropIndexSql(index)\n        const down = this.createIndexSql(table, index)\n        await this.executeQueries(up, down)\n        table.removeIndex(index)\n    }\n\n    /**\n     * Drops an indices from the table.\n     */\n    async dropIndices(\n        tableOrName: Table | string,\n        indices: TableIndex[],\n    ): Promise<void> {\n        const promises = indices.map((index) =>\n            this.dropIndex(tableOrName, index),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Clears all table contents.\n     * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.\n     */\n    async clearTable(tableName: string): Promise<void> {\n        await this.query(`DELETE FROM ${this.escapePath(tableName)}`)\n    }\n\n    /**\n     * Removes all tables from the currently connected database.\n     */\n    async clearDatabase(database?: string): Promise<void> {\n        let dbPath: string | undefined = undefined\n        if (\n            database &&\n            this.driver.getAttachedDatabaseHandleByRelativePath(database)\n        ) {\n            dbPath =\n                this.driver.getAttachedDatabaseHandleByRelativePath(database)\n        }\n\n        await this.query(`PRAGMA foreign_keys = OFF`)\n\n        const isAnotherTransactionActive = this.isTransactionActive\n        if (!isAnotherTransactionActive) await this.startTransaction()\n        try {\n            const selectViewDropsQuery = dbPath\n                ? `SELECT 'DROP VIEW \"${dbPath}\".\"' || name || '\";' as query FROM \"${dbPath}\".\"sqlite_master\" WHERE \"type\" = 'view'`\n                : `SELECT 'DROP VIEW \"' || name || '\";' as query FROM \"sqlite_master\" WHERE \"type\" = 'view'`\n            const dropViewQueries: ObjectLiteral[] = await this.query(\n                selectViewDropsQuery,\n            )\n            await Promise.all(\n                dropViewQueries.map((q) => this.query(q[\"query\"])),\n            )\n\n            const selectTableDropsQuery = dbPath\n                ? `SELECT 'DROP TABLE \"${dbPath}\".\"' || name || '\";' as query FROM \"${dbPath}\".\"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" != 'sqlite_sequence'`\n                : `SELECT 'DROP TABLE \"' || name || '\";' as query FROM \"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" != 'sqlite_sequence'`\n            const dropTableQueries: ObjectLiteral[] = await this.query(\n                selectTableDropsQuery,\n            )\n            await Promise.all(\n                dropTableQueries.map((q) => this.query(q[\"query\"])),\n            )\n\n            if (!isAnotherTransactionActive) await this.commitTransaction()\n        } catch (error) {\n            try {\n                // we throw original error even if rollback thrown an error\n                if (!isAnotherTransactionActive)\n                    await this.rollbackTransaction()\n            } catch (rollbackError) {}\n            throw error\n        } finally {\n            await this.query(`PRAGMA foreign_keys = ON`)\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    protected async loadViews(viewNames?: string[]): Promise<View[]> {\n        const hasTable = await this.hasTable(this.getTypeormMetadataTableName())\n        if (!hasTable) {\n            return []\n        }\n\n        if (!viewNames) {\n            viewNames = []\n        }\n\n        const viewNamesString = viewNames\n            .map((name) => \"'\" + name + \"'\")\n            .join(\", \")\n        let query = `SELECT \"t\".* FROM \"${this.getTypeormMetadataTableName()}\" \"t\" INNER JOIN \"sqlite_master\" s ON \"s\".\"name\" = \"t\".\"name\" AND \"s\".\"type\" = 'view' WHERE \"t\".\"type\" = '${\n            MetadataTableType.VIEW\n        }'`\n        if (viewNamesString.length > 0)\n            query += ` AND \"t\".\"name\" IN (${viewNamesString})`\n        const dbViews = await this.query(query)\n        return dbViews.map((dbView: any) => {\n            const view = new View()\n            view.name = dbView[\"name\"]\n            view.expression = dbView[\"value\"]\n            return view\n        })\n    }\n\n    protected async loadTableRecords(\n        tablePath: string,\n        tableOrIndex: \"table\" | \"index\",\n    ) {\n        let database: string | undefined = undefined\n        const [schema, tableName] = this.splitTablePath(tablePath)\n        if (\n            schema &&\n            this.driver.getAttachedDatabasePathRelativeByHandle(schema)\n        ) {\n            database =\n                this.driver.getAttachedDatabasePathRelativeByHandle(schema)\n        }\n        return this.query(\n            `SELECT ${database ? `'${database}'` : null} as database, ${\n                schema ? `'${schema}'` : null\n            } as schema, * FROM ${\n                schema ? `\"${schema}\".` : \"\"\n            }${this.escapePath(\n                `sqlite_master`,\n            )} WHERE \"type\" = '${tableOrIndex}' AND \"${\n                tableOrIndex === \"table\" ? \"name\" : \"tbl_name\"\n            }\" IN ('${tableName}')`,\n        )\n    }\n\n    protected async loadPragmaRecords(tablePath: string, pragma: string) {\n        const [, tableName] = this.splitTablePath(tablePath)\n        return this.query(`PRAGMA ${pragma}(\"${tableName}\")`)\n    }\n\n    /**\n     * Loads all tables (with given names) from the database and creates a Table from them.\n     */\n    protected async loadTables(tableNames?: string[]): Promise<Table[]> {\n        // if no tables given then no need to proceed\n        if (tableNames && tableNames.length === 0) {\n            return []\n        }\n\n        let dbTables: { database?: string; name: string; sql: string }[] = []\n        let dbIndicesDef: ObjectLiteral[]\n\n        if (!tableNames) {\n            const tablesSql = `SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'table'`\n            dbTables.push(...(await this.query(tablesSql)))\n\n            const tableNamesString = dbTables\n                .map(({ name }) => `'${name}'`)\n                .join(\", \")\n            dbIndicesDef = await this.query(\n                `SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'index' AND \"tbl_name\" IN (${tableNamesString})`,\n            )\n        } else {\n            const tableNamesWithoutDot = tableNames\n                .filter((tableName) => {\n                    return tableName.split(\".\").length === 1\n                })\n                .map((tableName) => `'${tableName}'`)\n\n            const tableNamesWithDot = tableNames.filter((tableName) => {\n                return tableName.split(\".\").length > 1\n            })\n\n            const queryPromises = (type: \"table\" | \"index\") => {\n                const promises = [\n                    ...tableNamesWithDot.map((tableName) =>\n                        this.loadTableRecords(tableName, type),\n                    ),\n                ]\n\n                if (tableNamesWithoutDot.length) {\n                    promises.push(\n                        this.query(\n                            `SELECT * FROM \"sqlite_master\" WHERE \"type\" = '${type}' AND \"${\n                                type === \"table\" ? \"name\" : \"tbl_name\"\n                            }\" IN (${tableNamesWithoutDot})`,\n                        ),\n                    )\n                }\n\n                return promises\n            }\n            dbTables = (await Promise.all(queryPromises(\"table\")))\n                .reduce((acc, res) => [...acc, ...res], [])\n                .filter(Boolean)\n            dbIndicesDef = (await Promise.all(queryPromises(\"index\")))\n                .reduce((acc, res) => [...acc, ...res], [])\n                .filter(Boolean)\n        }\n\n        // if tables were not found in the db, no need to proceed\n        if (dbTables.length === 0) {\n            return []\n        }\n\n        // create table schemas for loaded tables\n        return Promise.all(\n            dbTables.map(async (dbTable) => {\n                const tablePath =\n                    dbTable[\"database\"] &&\n                    this.driver.getAttachedDatabaseHandleByRelativePath(\n                        dbTable[\"database\"],\n                    )\n                        ? `${this.driver.getAttachedDatabaseHandleByRelativePath(\n                              dbTable[\"database\"],\n                          )}.${dbTable[\"name\"]}`\n                        : dbTable[\"name\"]\n\n                const sql = dbTable[\"sql\"]\n\n                const withoutRowid = sql.includes(\"WITHOUT ROWID\")\n                const table = new Table({ name: tablePath, withoutRowid })\n\n                // load columns and indices\n                const [dbColumns, dbIndices, dbForeignKeys]: ObjectLiteral[][] =\n                    await Promise.all([\n                        this.loadPragmaRecords(tablePath, `table_xinfo`),\n                        this.loadPragmaRecords(tablePath, `index_list`),\n                        this.loadPragmaRecords(tablePath, `foreign_key_list`),\n                    ])\n\n                // find column name with auto increment\n                let autoIncrementColumnName: string | undefined = undefined\n                const tableSql: string = dbTable[\"sql\"]\n                let autoIncrementIndex = tableSql\n                    .toUpperCase()\n                    .indexOf(\"AUTOINCREMENT\")\n                if (autoIncrementIndex !== -1) {\n                    autoIncrementColumnName = tableSql.substr(\n                        0,\n                        autoIncrementIndex,\n                    )\n                    const comma = autoIncrementColumnName.lastIndexOf(\",\")\n                    const bracket = autoIncrementColumnName.lastIndexOf(\"(\")\n                    if (comma !== -1) {\n                        autoIncrementColumnName =\n                            autoIncrementColumnName.substr(comma)\n                        autoIncrementColumnName =\n                            autoIncrementColumnName.substr(\n                                0,\n                                autoIncrementColumnName.lastIndexOf('\"'),\n                            )\n                        autoIncrementColumnName =\n                            autoIncrementColumnName.substr(\n                                autoIncrementColumnName.indexOf('\"') + 1,\n                            )\n                    } else if (bracket !== -1) {\n                        autoIncrementColumnName =\n                            autoIncrementColumnName.substr(bracket)\n                        autoIncrementColumnName =\n                            autoIncrementColumnName.substr(\n                                0,\n                                autoIncrementColumnName.lastIndexOf('\"'),\n                            )\n                        autoIncrementColumnName =\n                            autoIncrementColumnName.substr(\n                                autoIncrementColumnName.indexOf('\"') + 1,\n                            )\n                    }\n                }\n\n                // create columns from the loaded columns\n                table.columns = await Promise.all(\n                    dbColumns.map(async (dbColumn) => {\n                        const tableColumn = new TableColumn()\n                        tableColumn.name = dbColumn[\"name\"]\n                        tableColumn.type = dbColumn[\"type\"].toLowerCase()\n                        tableColumn.default =\n                            dbColumn[\"dflt_value\"] !== null &&\n                            dbColumn[\"dflt_value\"] !== undefined\n                                ? dbColumn[\"dflt_value\"]\n                                : undefined\n                        tableColumn.isNullable = dbColumn[\"notnull\"] === 0\n                        // primary keys are numbered starting with 1, columns that aren't primary keys are marked with 0\n                        tableColumn.isPrimary = dbColumn[\"pk\"] > 0\n                        tableColumn.comment = \"\" // SQLite does not support column comments\n                        tableColumn.isGenerated =\n                            autoIncrementColumnName === dbColumn[\"name\"]\n                        if (tableColumn.isGenerated) {\n                            tableColumn.generationStrategy = \"increment\"\n                        }\n\n                        if (\n                            dbColumn[\"hidden\"] === 2 ||\n                            dbColumn[\"hidden\"] === 3\n                        ) {\n                            tableColumn.generatedType =\n                                dbColumn[\"hidden\"] === 2 ? \"VIRTUAL\" : \"STORED\"\n\n                            const asExpressionQuery =\n                                this.selectTypeormMetadataSql({\n                                    table: table.name,\n                                    type: MetadataTableType.GENERATED_COLUMN,\n                                    name: tableColumn.name,\n                                })\n\n                            const results = await this.query(\n                                asExpressionQuery.query,\n                                asExpressionQuery.parameters,\n                            )\n                            if (results[0] && results[0].value) {\n                                tableColumn.asExpression = results[0].value\n                            } else {\n                                tableColumn.asExpression = \"\"\n                            }\n                        }\n\n                        if (tableColumn.type === \"varchar\") {\n                            tableColumn.enum = OrmUtils.parseSqlCheckExpression(\n                                sql,\n                                tableColumn.name,\n                            )\n                        }\n\n                        // parse datatype and attempt to retrieve length, precision and scale\n                        let pos = tableColumn.type.indexOf(\"(\")\n                        if (pos !== -1) {\n                            const fullType = tableColumn.type\n                            let dataType = fullType.substr(0, pos)\n                            if (\n                                this.driver.withLengthColumnTypes.find(\n                                    (col) => col === dataType,\n                                )\n                            ) {\n                                let len = parseInt(\n                                    fullType.substring(\n                                        pos + 1,\n                                        fullType.length - 1,\n                                    ),\n                                )\n                                if (len) {\n                                    tableColumn.length = len.toString()\n                                    tableColumn.type = dataType // remove the length part from the datatype\n                                }\n                            }\n                            if (\n                                this.driver.withPrecisionColumnTypes.find(\n                                    (col) => col === dataType,\n                                )\n                            ) {\n                                const re = new RegExp(\n                                    `^${dataType}\\\\((\\\\d+),?\\\\s?(\\\\d+)?\\\\)`,\n                                )\n                                const matches = fullType.match(re)\n                                if (matches && matches[1]) {\n                                    tableColumn.precision = +matches[1]\n                                }\n                                if (\n                                    this.driver.withScaleColumnTypes.find(\n                                        (col) => col === dataType,\n                                    )\n                                ) {\n                                    if (matches && matches[2]) {\n                                        tableColumn.scale = +matches[2]\n                                    }\n                                }\n                                tableColumn.type = dataType // remove the precision/scale part from the datatype\n                            }\n                        }\n\n                        return tableColumn\n                    }),\n                )\n\n                // find foreign key constraints from CREATE TABLE sql\n                let fkResult\n                const fkMappings: {\n                    name: string\n                    columns: string[]\n                    referencedTableName: string\n                }[] = []\n                const fkRegex =\n                    /CONSTRAINT \"([^\"]*)\" FOREIGN KEY ?\\((.*?)\\) REFERENCES \"([^\"]*)\"/g\n                while ((fkResult = fkRegex.exec(sql)) !== null) {\n                    fkMappings.push({\n                        name: fkResult[1],\n                        columns: fkResult[2]\n                            .substr(1, fkResult[2].length - 2)\n                            .split(`\", \"`),\n                        referencedTableName: fkResult[3],\n                    })\n                }\n\n                // build foreign keys\n                const tableForeignKeyConstraints = OrmUtils.uniq(\n                    dbForeignKeys,\n                    (dbForeignKey) => dbForeignKey[\"id\"],\n                )\n\n                table.foreignKeys = tableForeignKeyConstraints.map(\n                    (foreignKey) => {\n                        const ownForeignKeys = dbForeignKeys.filter(\n                            (dbForeignKey) =>\n                                dbForeignKey[\"id\"] === foreignKey[\"id\"] &&\n                                dbForeignKey[\"table\"] === foreignKey[\"table\"],\n                        )\n                        const columnNames = ownForeignKeys.map(\n                            (dbForeignKey) => dbForeignKey[\"from\"],\n                        )\n                        const referencedColumnNames = ownForeignKeys.map(\n                            (dbForeignKey) => dbForeignKey[\"to\"],\n                        )\n\n                        // find related foreign key mapping\n                        const fkMapping = fkMappings.find(\n                            (it) =>\n                                it.referencedTableName ===\n                                    foreignKey[\"table\"] &&\n                                it.columns.every(\n                                    (column) =>\n                                        columnNames.indexOf(column) !== -1,\n                                ),\n                        )\n\n                        return new TableForeignKey({\n                            name: fkMapping?.name,\n                            columnNames: columnNames,\n                            referencedTableName: foreignKey[\"table\"],\n                            referencedColumnNames: referencedColumnNames,\n                            onDelete: foreignKey[\"on_delete\"],\n                            onUpdate: foreignKey[\"on_update\"],\n                        })\n                    },\n                )\n\n                // find unique constraints from CREATE TABLE sql\n                let uniqueRegexResult\n                const uniqueMappings: { name: string; columns: string[] }[] = []\n                const uniqueRegex = /CONSTRAINT \"([^\"]*)\" UNIQUE ?\\((.*?)\\)/g\n                while ((uniqueRegexResult = uniqueRegex.exec(sql)) !== null) {\n                    uniqueMappings.push({\n                        name: uniqueRegexResult[1],\n                        columns: uniqueRegexResult[2]\n                            .substr(1, uniqueRegexResult[2].length - 2)\n                            .split(`\", \"`),\n                    })\n                }\n\n                // build unique constraints\n                const tableUniquePromises = dbIndices\n                    .filter((dbIndex) => dbIndex[\"origin\"] === \"u\")\n                    .map((dbIndex) => dbIndex[\"name\"])\n                    .filter(\n                        (value, index, self) => self.indexOf(value) === index,\n                    )\n                    .map(async (dbIndexName) => {\n                        const dbIndex = dbIndices.find(\n                            (dbIndex) => dbIndex[\"name\"] === dbIndexName,\n                        )\n                        const indexInfos: ObjectLiteral[] = await this.query(\n                            `PRAGMA index_info(\"${dbIndex![\"name\"]}\")`,\n                        )\n                        const indexColumns = indexInfos\n                            .sort(\n                                (indexInfo1, indexInfo2) =>\n                                    parseInt(indexInfo1[\"seqno\"]) -\n                                    parseInt(indexInfo2[\"seqno\"]),\n                            )\n                            .map((indexInfo) => indexInfo[\"name\"])\n                        if (indexColumns.length === 1) {\n                            const column = table.columns.find((column) => {\n                                return !!indexColumns.find(\n                                    (indexColumn) =>\n                                        indexColumn === column.name,\n                                )\n                            })\n                            if (column) column.isUnique = true\n                        }\n\n                        // find existent mapping by a column names\n                        const foundMapping = uniqueMappings.find((mapping) => {\n                            return mapping!.columns.every(\n                                (column) => indexColumns.indexOf(column) !== -1,\n                            )\n                        })\n\n                        return new TableUnique({\n                            name: foundMapping\n                                ? foundMapping.name\n                                : this.connection.namingStrategy.uniqueConstraintName(\n                                      table,\n                                      indexColumns,\n                                  ),\n                            columnNames: indexColumns,\n                        })\n                    })\n                table.uniques = (await Promise.all(\n                    tableUniquePromises,\n                )) as TableUnique[]\n\n                // build checks\n                let result\n                const regexp =\n                    /CONSTRAINT \"([^\"]*)\" CHECK ?(\\(.*?\\))([,]|[)]$)/g\n                while ((result = regexp.exec(sql)) !== null) {\n                    table.checks.push(\n                        new TableCheck({\n                            name: result[1],\n                            expression: result[2],\n                        }),\n                    )\n                }\n\n                // build indices\n                const indicesPromises = dbIndices\n                    .filter((dbIndex) => dbIndex[\"origin\"] === \"c\")\n                    .map((dbIndex) => dbIndex[\"name\"])\n                    .filter(\n                        (value, index, self) => self.indexOf(value) === index,\n                    ) // unqiue\n                    .map(async (dbIndexName) => {\n                        const indexDef = dbIndicesDef.find(\n                            (dbIndexDef) => dbIndexDef[\"name\"] === dbIndexName,\n                        )\n                        const condition = /WHERE (.*)/.exec(indexDef![\"sql\"])\n                        const dbIndex = dbIndices.find(\n                            (dbIndex) => dbIndex[\"name\"] === dbIndexName,\n                        )\n                        const indexInfos: ObjectLiteral[] = await this.query(\n                            `PRAGMA index_info(\"${dbIndex![\"name\"]}\")`,\n                        )\n                        const indexColumns = indexInfos\n                            .sort(\n                                (indexInfo1, indexInfo2) =>\n                                    parseInt(indexInfo1[\"seqno\"]) -\n                                    parseInt(indexInfo2[\"seqno\"]),\n                            )\n                            .map((indexInfo) => indexInfo[\"name\"])\n                        const dbIndexPath = `${\n                            dbTable[\"database\"] ? `${dbTable[\"database\"]}.` : \"\"\n                        }${dbIndex![\"name\"]}`\n\n                        const isUnique =\n                            dbIndex![\"unique\"] === \"1\" ||\n                            dbIndex![\"unique\"] === 1\n                        return new TableIndex(<TableIndexOptions>{\n                            table: table,\n                            name: dbIndexPath,\n                            columnNames: indexColumns,\n                            isUnique: isUnique,\n                            where: condition ? condition[1] : undefined,\n                        })\n                    })\n                const indices = await Promise.all(indicesPromises)\n                table.indices = indices.filter(\n                    (index) => !!index,\n                ) as TableIndex[]\n\n                return table\n            }),\n        )\n    }\n\n    /**\n     * Builds create table sql.\n     */\n    protected createTableSql(\n        table: Table,\n        createForeignKeys?: boolean,\n        temporaryTable?: boolean,\n    ): Query {\n        const primaryColumns = table.columns.filter(\n            (column) => column.isPrimary,\n        )\n        const hasAutoIncrement = primaryColumns.find(\n            (column) =>\n                column.isGenerated && column.generationStrategy === \"increment\",\n        )\n        const skipPrimary = primaryColumns.length > 1\n        if (skipPrimary && hasAutoIncrement)\n            throw new TypeORMError(\n                `Sqlite does not support AUTOINCREMENT on composite primary key`,\n            )\n\n        const columnDefinitions = table.columns\n            .map((column) => this.buildCreateColumnSql(column, skipPrimary))\n            .join(\", \")\n        const [database] = this.splitTablePath(table.name)\n        let sql = `CREATE TABLE ${this.escapePath(\n            table.name,\n        )} (${columnDefinitions}`\n\n        let [databaseNew, tableName] = this.splitTablePath(table.name)\n        const newTableName = temporaryTable\n            ? `${databaseNew ? `${databaseNew}.` : \"\"}${tableName.replace(\n                  /^temporary_/,\n                  \"\",\n              )}`\n            : table.name\n\n        // need for `addColumn()` method, because it recreates table.\n        table.columns\n            .filter((column) => column.isUnique)\n            .forEach((column) => {\n                const isUniqueExist = table.uniques.some(\n                    (unique) =>\n                        unique.columnNames.length === 1 &&\n                        unique.columnNames[0] === column.name,\n                )\n                if (!isUniqueExist)\n                    table.uniques.push(\n                        new TableUnique({\n                            name: this.connection.namingStrategy.uniqueConstraintName(\n                                table,\n                                [column.name],\n                            ),\n                            columnNames: [column.name],\n                        }),\n                    )\n            })\n\n        if (table.uniques.length > 0) {\n            const uniquesSql = table.uniques\n                .map((unique) => {\n                    const uniqueName = unique.name\n                        ? unique.name\n                        : this.connection.namingStrategy.uniqueConstraintName(\n                              newTableName,\n                              unique.columnNames,\n                          )\n                    const columnNames = unique.columnNames\n                        .map((columnName) => `\"${columnName}\"`)\n                        .join(\", \")\n                    return `CONSTRAINT \"${uniqueName}\" UNIQUE (${columnNames})`\n                })\n                .join(\", \")\n\n            sql += `, ${uniquesSql}`\n        }\n\n        if (table.checks.length > 0) {\n            const checksSql = table.checks\n                .map((check) => {\n                    const checkName = check.name\n                        ? check.name\n                        : this.connection.namingStrategy.checkConstraintName(\n                              newTableName,\n                              check.expression!,\n                          )\n                    return `CONSTRAINT \"${checkName}\" CHECK (${check.expression})`\n                })\n                .join(\", \")\n\n            sql += `, ${checksSql}`\n        }\n\n        if (table.foreignKeys.length > 0 && createForeignKeys) {\n            const foreignKeysSql = table.foreignKeys\n                .filter((fk) => {\n                    const [referencedDatabase] = this.splitTablePath(\n                        fk.referencedTableName,\n                    )\n                    if (referencedDatabase !== database) {\n                        return false\n                    }\n                    return true\n                })\n                .map((fk) => {\n                    const [, referencedTable] = this.splitTablePath(\n                        fk.referencedTableName,\n                    )\n                    const columnNames = fk.columnNames\n                        .map((columnName) => `\"${columnName}\"`)\n                        .join(\", \")\n                    if (!fk.name)\n                        fk.name = this.connection.namingStrategy.foreignKeyName(\n                            newTableName,\n                            fk.columnNames,\n                            this.getTablePath(fk),\n                            fk.referencedColumnNames,\n                        )\n                    const referencedColumnNames = fk.referencedColumnNames\n                        .map((columnName) => `\"${columnName}\"`)\n                        .join(\", \")\n\n                    let constraint = `CONSTRAINT \"${fk.name}\" FOREIGN KEY (${columnNames}) REFERENCES \"${referencedTable}\" (${referencedColumnNames})`\n                    if (fk.onDelete) constraint += ` ON DELETE ${fk.onDelete}`\n                    if (fk.onUpdate) constraint += ` ON UPDATE ${fk.onUpdate}`\n                    if (fk.deferrable)\n                        constraint += ` DEFERRABLE ${fk.deferrable}`\n\n                    return constraint\n                })\n                .join(\", \")\n\n            sql += `, ${foreignKeysSql}`\n        }\n\n        if (primaryColumns.length > 1) {\n            const columnNames = primaryColumns\n                .map((column) => `\"${column.name}\"`)\n                .join(\", \")\n            sql += `, PRIMARY KEY (${columnNames})`\n        }\n\n        sql += `)`\n\n        if (table.withoutRowid) {\n            sql += \" WITHOUT ROWID\"\n        }\n\n        return new Query(sql)\n    }\n\n    /**\n     * Builds drop table sql.\n     */\n    protected dropTableSql(\n        tableOrName: Table | string,\n        ifExist?: boolean,\n    ): Query {\n        const tableName = InstanceChecker.isTable(tableOrName)\n            ? tableOrName.name\n            : tableOrName\n        const query = ifExist\n            ? `DROP TABLE IF EXISTS ${this.escapePath(tableName)}`\n            : `DROP TABLE ${this.escapePath(tableName)}`\n        return new Query(query)\n    }\n\n    protected createViewSql(view: View): Query {\n        if (typeof view.expression === \"string\") {\n            return new Query(`CREATE VIEW \"${view.name}\" AS ${view.expression}`)\n        } else {\n            return new Query(\n                `CREATE VIEW \"${view.name}\" AS ${view\n                    .expression(this.connection)\n                    .getQuery()}`,\n            )\n        }\n    }\n\n    protected insertViewDefinitionSql(view: View): Query {\n        const expression =\n            typeof view.expression === \"string\"\n                ? view.expression.trim()\n                : view.expression(this.connection).getQuery()\n        return this.insertTypeormMetadataSql({\n            type: MetadataTableType.VIEW,\n            name: view.name,\n            value: expression,\n        })\n    }\n\n    /**\n     * Builds drop view sql.\n     */\n    protected dropViewSql(viewOrPath: View | string): Query {\n        const viewName = InstanceChecker.isView(viewOrPath)\n            ? viewOrPath.name\n            : viewOrPath\n        return new Query(`DROP VIEW \"${viewName}\"`)\n    }\n\n    /**\n     * Builds remove view sql.\n     */\n    protected deleteViewDefinitionSql(viewOrPath: View | string): Query {\n        const viewName = InstanceChecker.isView(viewOrPath)\n            ? viewOrPath.name\n            : viewOrPath\n        return this.deleteTypeormMetadataSql({\n            type: MetadataTableType.VIEW,\n            name: viewName,\n        })\n    }\n\n    /**\n     * Builds create index sql.\n     */\n    protected createIndexSql(table: Table, index: TableIndex): Query {\n        const columns = index.columnNames\n            .map((columnName) => `\"${columnName}\"`)\n            .join(\", \")\n        const [database, tableName] = this.splitTablePath(table.name)\n        return new Query(\n            `CREATE ${index.isUnique ? \"UNIQUE \" : \"\"}INDEX ${\n                database ? `\"${database}\".` : \"\"\n            }${this.escapePath(index.name!)} ON \"${tableName}\" (${columns}) ${\n                index.where ? \"WHERE \" + index.where : \"\"\n            }`,\n        )\n    }\n\n    /**\n     * Builds drop index sql.\n     */\n    protected dropIndexSql(indexOrName: TableIndex | string): Query {\n        let indexName = InstanceChecker.isTableIndex(indexOrName)\n            ? indexOrName.name\n            : indexOrName\n        return new Query(`DROP INDEX ${this.escapePath(indexName!)}`)\n    }\n\n    /**\n     * Builds a query for create column.\n     */\n    protected buildCreateColumnSql(\n        column: TableColumn,\n        skipPrimary?: boolean,\n    ): string {\n        let c = '\"' + column.name + '\"'\n        if (InstanceChecker.isColumnMetadata(column)) {\n            c += \" \" + this.driver.normalizeType(column)\n        } else {\n            c += \" \" + this.connection.driver.createFullType(column)\n        }\n\n        if (column.enum)\n            c +=\n                ' CHECK( \"' +\n                column.name +\n                '\" IN (' +\n                column.enum.map((val) => \"'\" + val + \"'\").join(\",\") +\n                \") )\"\n        if (column.isPrimary && !skipPrimary) c += \" PRIMARY KEY\"\n        if (\n            column.isGenerated === true &&\n            column.generationStrategy === \"increment\"\n        )\n            // don't use skipPrimary here since updates can update already exist primary without auto inc.\n            c += \" AUTOINCREMENT\"\n        if (column.collation) c += \" COLLATE \" + column.collation\n        if (column.isNullable !== true) c += \" NOT NULL\"\n\n        if (column.asExpression) {\n            c += ` AS (${column.asExpression}) ${\n                column.generatedType ? column.generatedType : \"VIRTUAL\"\n            }`\n        } else {\n            if (column.default !== undefined && column.default !== null)\n                c += \" DEFAULT (\" + column.default + \")\"\n        }\n\n        return c\n    }\n\n    protected async recreateTable(\n        newTable: Table,\n        oldTable: Table,\n        migrateData = true,\n    ): Promise<void> {\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        // drop old table indices\n        oldTable.indices.forEach((index) => {\n            upQueries.push(this.dropIndexSql(index))\n            downQueries.push(this.createIndexSql(oldTable, index))\n        })\n\n        // change table name into 'temporary_table'\n        let [databaseNew, tableNameNew] = this.splitTablePath(newTable.name)\n        let [, tableNameOld] = this.splitTablePath(oldTable.name)\n        newTable.name = tableNameNew = `${\n            databaseNew ? `${databaseNew}.` : \"\"\n        }temporary_${tableNameNew}`\n\n        // create new table\n        upQueries.push(this.createTableSql(newTable, true, true))\n        downQueries.push(this.dropTableSql(newTable))\n\n        // migrate all data from the old table into new table\n        if (migrateData) {\n            let newColumnNames = newTable.columns\n                .filter((column) => !column.generatedType)\n                .map((column) => `\"${column.name}\"`)\n\n            let oldColumnNames = oldTable.columns\n                .filter((column) => !column.generatedType)\n                .map((column) => `\"${column.name}\"`)\n\n            if (oldColumnNames.length < newColumnNames.length) {\n                newColumnNames = newTable.columns\n                    .filter((column) => {\n                        const oldColumn = oldTable.columns.find(\n                            (c) => c.name === column.name,\n                        )\n                        if (oldColumn && oldColumn.generatedType) return false\n                        return !column.generatedType && oldColumn\n                    })\n                    .map((column) => `\"${column.name}\"`)\n            } else if (oldColumnNames.length > newColumnNames.length) {\n                oldColumnNames = oldTable.columns\n                    .filter((column) => {\n                        return (\n                            !column.generatedType &&\n                            newTable.columns.find((c) => c.name === column.name)\n                        )\n                    })\n                    .map((column) => `\"${column.name}\"`)\n            }\n\n            upQueries.push(\n                new Query(\n                    `INSERT INTO ${this.escapePath(\n                        newTable.name,\n                    )}(${newColumnNames.join(\n                        \", \",\n                    )}) SELECT ${oldColumnNames.join(\n                        \", \",\n                    )} FROM ${this.escapePath(oldTable.name)}`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `INSERT INTO ${this.escapePath(\n                        oldTable.name,\n                    )}(${oldColumnNames.join(\n                        \", \",\n                    )}) SELECT ${newColumnNames.join(\n                        \", \",\n                    )} FROM ${this.escapePath(newTable.name)}`,\n                ),\n            )\n        }\n\n        // drop old table\n        upQueries.push(this.dropTableSql(oldTable))\n        downQueries.push(this.createTableSql(oldTable, true))\n\n        // rename old table\n        upQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    newTable.name,\n                )} RENAME TO ${this.escapePath(tableNameOld)}`,\n            ),\n        )\n        downQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    oldTable.name,\n                )} RENAME TO ${this.escapePath(tableNameNew)}`,\n            ),\n        )\n\n        newTable.name = oldTable.name\n\n        // recreate table indices\n        newTable.indices.forEach((index) => {\n            // new index may be passed without name. In this case we generate index name manually.\n            if (!index.name)\n                index.name = this.connection.namingStrategy.indexName(\n                    newTable,\n                    index.columnNames,\n                    index.where,\n                )\n            upQueries.push(this.createIndexSql(newTable, index))\n            downQueries.push(this.dropIndexSql(index))\n        })\n\n        // update generated columns in \"typeorm_metadata\" table\n        // Step 1: clear data for removed generated columns\n        oldTable.columns\n            .filter((column) => {\n                const newTableColumn = newTable.columns.find(\n                    (c) => c.name === column.name,\n                )\n                // we should delete record from \"typeorm_metadata\" if generated column was removed\n                // or it was changed to non-generated\n                return (\n                    column.generatedType &&\n                    column.asExpression &&\n                    (!newTableColumn ||\n                        (!newTableColumn.generatedType &&\n                            !newTableColumn.asExpression))\n                )\n            })\n            .forEach((column) => {\n                const deleteQuery = this.deleteTypeormMetadataSql({\n                    table: oldTable.name,\n                    type: MetadataTableType.GENERATED_COLUMN,\n                    name: column.name,\n                })\n\n                const insertQuery = this.insertTypeormMetadataSql({\n                    table: oldTable.name,\n                    type: MetadataTableType.GENERATED_COLUMN,\n                    name: column.name,\n                    value: column.asExpression,\n                })\n\n                upQueries.push(deleteQuery)\n                downQueries.push(insertQuery)\n            })\n\n        // Step 2: add data for new generated columns\n        newTable.columns\n            .filter(\n                (column) =>\n                    column.generatedType &&\n                    column.asExpression &&\n                    !oldTable.columns.some((c) => c.name === column.name),\n            )\n            .forEach((column) => {\n                const insertQuery = this.insertTypeormMetadataSql({\n                    table: newTable.name,\n                    type: MetadataTableType.GENERATED_COLUMN,\n                    name: column.name,\n                    value: column.asExpression,\n                })\n\n                const deleteQuery = this.deleteTypeormMetadataSql({\n                    table: newTable.name,\n                    type: MetadataTableType.GENERATED_COLUMN,\n                    name: column.name,\n                })\n\n                upQueries.push(insertQuery)\n                downQueries.push(deleteQuery)\n            })\n\n        // Step 3: update changed expressions\n        newTable.columns\n            .filter((column) => column.generatedType && column.asExpression)\n            .forEach((column) => {\n                const oldColumn = oldTable.columns.find(\n                    (c) =>\n                        c.name === column.name &&\n                        c.generatedType &&\n                        column.generatedType &&\n                        c.asExpression !== column.asExpression,\n                )\n\n                if (!oldColumn) return\n\n                // update expression\n                const deleteQuery = this.deleteTypeormMetadataSql({\n                    table: oldTable.name,\n                    type: MetadataTableType.GENERATED_COLUMN,\n                    name: oldColumn.name,\n                })\n\n                const insertQuery = this.insertTypeormMetadataSql({\n                    table: newTable.name,\n                    type: MetadataTableType.GENERATED_COLUMN,\n                    name: column.name,\n                    value: column.asExpression,\n                })\n\n                upQueries.push(deleteQuery)\n                upQueries.push(insertQuery)\n\n                // revert update\n                const revertInsertQuery = this.insertTypeormMetadataSql({\n                    table: newTable.name,\n                    type: MetadataTableType.GENERATED_COLUMN,\n                    name: oldColumn.name,\n                    value: oldColumn.asExpression,\n                })\n\n                const revertDeleteQuery = this.deleteTypeormMetadataSql({\n                    table: oldTable.name,\n                    type: MetadataTableType.GENERATED_COLUMN,\n                    name: column.name,\n                })\n\n                downQueries.push(revertInsertQuery)\n                downQueries.push(revertDeleteQuery)\n            })\n\n        await this.executeQueries(upQueries, downQueries)\n        this.replaceCachedTable(oldTable, newTable)\n    }\n\n    /**\n     * tablePath e.g. \"myDB.myTable\", \"myTable\"\n     */\n    protected splitTablePath(tablePath: string): [string | undefined, string] {\n        return (\n            tablePath.indexOf(\".\") !== -1\n                ? tablePath.split(\".\")\n                : [undefined, tablePath]\n        ) as [string | undefined, string]\n    }\n\n    /**\n     * Escapes given table or view path. Tolerates leading/trailing dots\n     */\n    protected escapePath(\n        target: Table | View | string,\n        disableEscape?: boolean,\n    ): string {\n        const tableName =\n            InstanceChecker.isTable(target) || InstanceChecker.isView(target)\n                ? target.name\n                : target\n        return tableName\n            .replace(/^\\.+|\\.+$/g, \"\")\n            .split(\".\")\n            .map((i) => (disableEscape ? i : `\"${i}\"`))\n            .join(\".\")\n    }\n\n    /**\n     * Change table comment.\n     */\n    changeTableComment(\n        tableOrName: Table | string,\n        comment?: string,\n    ): Promise<void> {\n        throw new TypeORMError(`sqlit driver does not support change comment.`)\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}