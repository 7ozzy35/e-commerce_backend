{"ast":null,"code":"import { DateUtils } from \"../util/DateUtils\";\nimport { OrmUtils } from \"../util/OrmUtils\";\nimport { ApplyValueTransformers } from \"../util/ApplyValueTransformers\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\n/**\n * Finds what columns are changed in the subject entities.\n */\nexport class SubjectChangedColumnsComputer {\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Finds what columns are changed in the subject entities.\n   */\n  compute(subjects) {\n    subjects.forEach(subject => {\n      this.computeDiffColumns(subject);\n      this.computeDiffRelationalColumns(subjects, subject);\n    });\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Differentiate columns from the updated entity and entity stored in the database.\n   */\n  computeDiffColumns(subject) {\n    // if there is no persisted entity then nothing to compute changed in it\n    if (!subject.entity) return;\n    subject.metadata.columns.forEach(column => {\n      // ignore special columns\n      if (column.isVirtual || column.isDiscriminator // ||\n      // column.isUpdateDate ||\n      // column.isVersion ||\n      // column.isCreateDate\n      ) return;\n      const changeMap = subject.changeMaps.find(changeMap => changeMap.column === column);\n      if (changeMap) {\n        subject.changeMaps.splice(subject.changeMaps.indexOf(changeMap), 1);\n      }\n      // get user provided value - column value from the user provided persisted entity\n      const entityValue = column.getEntityValue(subject.entity);\n      // we don't perform operation over undefined properties (but we DO need null properties!)\n      if (entityValue === undefined) return;\n      // if there is no database entity then all columns are treated as new, e.g. changed\n      if (subject.databaseEntity) {\n        // skip transform database value for json / jsonb for comparison later on\n        const shouldTransformDatabaseEntity = column.type !== \"json\" && column.type !== \"jsonb\";\n        // get database value of the column\n        let databaseValue = column.getEntityValue(subject.databaseEntity, shouldTransformDatabaseEntity);\n        // filter out \"relational columns\" only in the case if there is a relation object in entity\n        if (column.relationMetadata) {\n          const value = column.relationMetadata.getEntityValue(subject.entity);\n          if (value !== null && value !== undefined) return;\n        }\n        let normalizedValue = entityValue;\n        // normalize special values to make proper comparision\n        if (entityValue !== null) {\n          switch (column.type) {\n            case \"date\":\n              normalizedValue = DateUtils.mixedDateToDateString(entityValue);\n              break;\n            case \"time\":\n            case \"time with time zone\":\n            case \"time without time zone\":\n            case \"timetz\":\n              normalizedValue = DateUtils.mixedDateToTimeString(entityValue);\n              break;\n            case \"datetime\":\n            case \"datetime2\":\n            case Date:\n            case \"timestamp\":\n            case \"timestamp without time zone\":\n            case \"timestamp with time zone\":\n            case \"timestamp with local time zone\":\n            case \"timestamptz\":\n              normalizedValue = DateUtils.mixedDateToUtcDatetimeString(entityValue);\n              databaseValue = DateUtils.mixedDateToUtcDatetimeString(databaseValue);\n              break;\n            case \"json\":\n            case \"jsonb\":\n              // JSON.stringify doesn't work because postgresql sorts jsonb before save.\n              // If you try to save json '[{\"messages\": \"\", \"attribute Key\": \"\", \"level\":\"\"}] ' as jsonb,\n              // then postgresql will save it as '[{\"level\": \"\", \"message\":\"\", \"attributeKey\": \"\"}]'\n              if (OrmUtils.deepCompare(entityValue, databaseValue)) return;\n              break;\n            case \"simple-array\":\n              normalizedValue = DateUtils.simpleArrayToString(entityValue);\n              databaseValue = DateUtils.simpleArrayToString(databaseValue);\n              break;\n            case \"simple-enum\":\n              normalizedValue = DateUtils.simpleEnumToString(entityValue);\n              databaseValue = DateUtils.simpleEnumToString(databaseValue);\n              break;\n            case \"simple-json\":\n              normalizedValue = DateUtils.simpleJsonToString(entityValue);\n              databaseValue = DateUtils.simpleJsonToString(databaseValue);\n              break;\n          }\n          if (column.transformer) {\n            normalizedValue = ApplyValueTransformers.transformTo(column.transformer, entityValue);\n          }\n        }\n        // if value is not changed - then do nothing\n        if (Buffer.isBuffer(normalizedValue) && Buffer.isBuffer(databaseValue)) {\n          if (normalizedValue.equals(databaseValue)) {\n            return;\n          }\n        } else {\n          if (normalizedValue === databaseValue) return;\n        }\n      }\n      if (!subject.diffColumns.includes(column)) subject.diffColumns.push(column);\n      subject.changeMaps.push({\n        column: column,\n        value: entityValue\n      });\n    });\n  }\n  /**\n   * Difference columns of the owning one-to-one and many-to-one columns.\n   */\n  computeDiffRelationalColumns(allSubjects, subject) {\n    // if there is no persisted entity then nothing to compute changed in it\n    if (!subject.entity) return;\n    subject.metadata.relationsWithJoinColumns.forEach(relation => {\n      // get the related entity from the persisted entity\n      let relatedEntity = relation.getEntityValue(subject.entity);\n      // we don't perform operation over undefined properties (but we DO need null properties!)\n      if (relatedEntity === undefined) return;\n      // if there is no database entity then all relational columns are treated as new, e.g. changed\n      if (subject.databaseEntity) {\n        // here we cover two scenarios:\n        // 1. related entity can be another entity which is natural way\n        // 2. related entity can be just an entity id\n        // if relation entity is just a relation id set (for example post.tag = 1)\n        // then we create an id map from it to make a proper comparision\n        let relatedEntityRelationIdMap = relatedEntity;\n        if (relatedEntityRelationIdMap !== null && ObjectUtils.isObject(relatedEntityRelationIdMap)) relatedEntityRelationIdMap = relation.getRelationIdMap(relatedEntityRelationIdMap);\n        // get database related entity. Since loadRelationIds are used on databaseEntity\n        // related entity will contain only its relation ids\n        const databaseRelatedEntityRelationIdMap = relation.getEntityValue(subject.databaseEntity);\n        // if relation ids are equal then we don't need to update anything\n        const areRelatedIdsEqual = OrmUtils.compareIds(relatedEntityRelationIdMap, databaseRelatedEntityRelationIdMap);\n        if (areRelatedIdsEqual) {\n          return;\n        } else {\n          subject.diffRelations.push(relation);\n        }\n      }\n      // if there is an inserted subject for the related entity of the persisted entity then use it as related entity\n      // this code is used for related entities without ids to be properly inserted (and then updated if needed)\n      const valueSubject = allSubjects.find(subject => subject.mustBeInserted && subject.entity === relatedEntity);\n      if (valueSubject) relatedEntity = valueSubject;\n      // find if there is already a relation to be changed\n      const changeMap = subject.changeMaps.find(changeMap => changeMap.relation === relation);\n      if (changeMap) {\n        // and update its value if it was found\n        changeMap.value = relatedEntity;\n      } else {\n        // if it wasn't found add a new relation for change\n        subject.changeMaps.push({\n          relation: relation,\n          value: relatedEntity\n        });\n      }\n    });\n  }\n}","map":{"version":3,"names":["DateUtils","OrmUtils","ApplyValueTransformers","ObjectUtils","SubjectChangedColumnsComputer","compute","subjects","forEach","subject","computeDiffColumns","computeDiffRelationalColumns","entity","metadata","columns","column","isVirtual","isDiscriminator","changeMap","changeMaps","find","splice","indexOf","entityValue","getEntityValue","undefined","databaseEntity","shouldTransformDatabaseEntity","type","databaseValue","relationMetadata","value","normalizedValue","mixedDateToDateString","mixedDateToTimeString","Date","mixedDateToUtcDatetimeString","deepCompare","simpleArrayToString","simpleEnumToString","simpleJsonToString","transformer","transformTo","Buffer","isBuffer","equals","diffColumns","includes","push","allSubjects","relationsWithJoinColumns","relation","relatedEntity","relatedEntityRelationIdMap","isObject","getRelationIdMap","databaseRelatedEntityRelationIdMap","areRelatedIdsEqual","compareIds","diffRelations","valueSubject","mustBeInserted"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\persistence\\SubjectChangedColumnsComputer.ts"],"sourcesContent":["import { Subject } from \"./Subject\"\nimport { DateUtils } from \"../util/DateUtils\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { OrmUtils } from \"../util/OrmUtils\"\nimport { ApplyValueTransformers } from \"../util/ApplyValueTransformers\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\n\n/**\n * Finds what columns are changed in the subject entities.\n */\nexport class SubjectChangedColumnsComputer {\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Finds what columns are changed in the subject entities.\n     */\n    compute(subjects: Subject[]) {\n        subjects.forEach((subject) => {\n            this.computeDiffColumns(subject)\n            this.computeDiffRelationalColumns(subjects, subject)\n        })\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Differentiate columns from the updated entity and entity stored in the database.\n     */\n    protected computeDiffColumns(subject: Subject): void {\n        // if there is no persisted entity then nothing to compute changed in it\n        if (!subject.entity) return\n\n        subject.metadata.columns.forEach((column) => {\n            // ignore special columns\n            if (\n                column.isVirtual ||\n                column.isDiscriminator // ||\n                // column.isUpdateDate ||\n                // column.isVersion ||\n                // column.isCreateDate\n            )\n                return\n\n            const changeMap = subject.changeMaps.find(\n                (changeMap) => changeMap.column === column,\n            )\n            if (changeMap) {\n                subject.changeMaps.splice(\n                    subject.changeMaps.indexOf(changeMap),\n                    1,\n                )\n            }\n\n            // get user provided value - column value from the user provided persisted entity\n            const entityValue = column.getEntityValue(subject.entity!)\n\n            // we don't perform operation over undefined properties (but we DO need null properties!)\n            if (entityValue === undefined) return\n\n            // if there is no database entity then all columns are treated as new, e.g. changed\n            if (subject.databaseEntity) {\n                // skip transform database value for json / jsonb for comparison later on\n                const shouldTransformDatabaseEntity =\n                    column.type !== \"json\" && column.type !== \"jsonb\"\n\n                // get database value of the column\n                let databaseValue = column.getEntityValue(\n                    subject.databaseEntity,\n                    shouldTransformDatabaseEntity,\n                )\n\n                // filter out \"relational columns\" only in the case if there is a relation object in entity\n                if (column.relationMetadata) {\n                    const value = column.relationMetadata.getEntityValue(\n                        subject.entity!,\n                    )\n                    if (value !== null && value !== undefined) return\n                }\n                let normalizedValue = entityValue\n                // normalize special values to make proper comparision\n                if (entityValue !== null) {\n                    switch (column.type) {\n                        case \"date\":\n                            normalizedValue =\n                                DateUtils.mixedDateToDateString(entityValue)\n                            break\n\n                        case \"time\":\n                        case \"time with time zone\":\n                        case \"time without time zone\":\n                        case \"timetz\":\n                            normalizedValue =\n                                DateUtils.mixedDateToTimeString(entityValue)\n                            break\n\n                        case \"datetime\":\n                        case \"datetime2\":\n                        case Date:\n                        case \"timestamp\":\n                        case \"timestamp without time zone\":\n                        case \"timestamp with time zone\":\n                        case \"timestamp with local time zone\":\n                        case \"timestamptz\":\n                            normalizedValue =\n                                DateUtils.mixedDateToUtcDatetimeString(\n                                    entityValue,\n                                )\n                            databaseValue =\n                                DateUtils.mixedDateToUtcDatetimeString(\n                                    databaseValue,\n                                )\n                            break\n\n                        case \"json\":\n                        case \"jsonb\":\n                            // JSON.stringify doesn't work because postgresql sorts jsonb before save.\n                            // If you try to save json '[{\"messages\": \"\", \"attribute Key\": \"\", \"level\":\"\"}] ' as jsonb,\n                            // then postgresql will save it as '[{\"level\": \"\", \"message\":\"\", \"attributeKey\": \"\"}]'\n                            if (\n                                OrmUtils.deepCompare(entityValue, databaseValue)\n                            )\n                                return\n                            break\n\n                        case \"simple-array\":\n                            normalizedValue =\n                                DateUtils.simpleArrayToString(entityValue)\n                            databaseValue =\n                                DateUtils.simpleArrayToString(databaseValue)\n                            break\n                        case \"simple-enum\":\n                            normalizedValue =\n                                DateUtils.simpleEnumToString(entityValue)\n                            databaseValue =\n                                DateUtils.simpleEnumToString(databaseValue)\n                            break\n                        case \"simple-json\":\n                            normalizedValue =\n                                DateUtils.simpleJsonToString(entityValue)\n                            databaseValue =\n                                DateUtils.simpleJsonToString(databaseValue)\n                            break\n                    }\n\n                    if (column.transformer) {\n                        normalizedValue = ApplyValueTransformers.transformTo(\n                            column.transformer,\n                            entityValue,\n                        )\n                    }\n                }\n\n                // if value is not changed - then do nothing\n                if (\n                    Buffer.isBuffer(normalizedValue) &&\n                    Buffer.isBuffer(databaseValue)\n                ) {\n                    if (normalizedValue.equals(databaseValue)) {\n                        return\n                    }\n                } else {\n                    if (normalizedValue === databaseValue) return\n                }\n            }\n\n            if (!subject.diffColumns.includes(column))\n                subject.diffColumns.push(column)\n\n            subject.changeMaps.push({\n                column: column,\n                value: entityValue,\n            })\n        })\n    }\n\n    /**\n     * Difference columns of the owning one-to-one and many-to-one columns.\n     */\n    protected computeDiffRelationalColumns(\n        allSubjects: Subject[],\n        subject: Subject,\n    ): void {\n        // if there is no persisted entity then nothing to compute changed in it\n        if (!subject.entity) return\n\n        subject.metadata.relationsWithJoinColumns.forEach((relation) => {\n            // get the related entity from the persisted entity\n            let relatedEntity = relation.getEntityValue(subject.entity!)\n\n            // we don't perform operation over undefined properties (but we DO need null properties!)\n            if (relatedEntity === undefined) return\n\n            // if there is no database entity then all relational columns are treated as new, e.g. changed\n            if (subject.databaseEntity) {\n                // here we cover two scenarios:\n                // 1. related entity can be another entity which is natural way\n                // 2. related entity can be just an entity id\n                // if relation entity is just a relation id set (for example post.tag = 1)\n                // then we create an id map from it to make a proper comparision\n                let relatedEntityRelationIdMap: ObjectLiteral = relatedEntity\n                if (\n                    relatedEntityRelationIdMap !== null &&\n                    ObjectUtils.isObject(relatedEntityRelationIdMap)\n                )\n                    relatedEntityRelationIdMap = relation.getRelationIdMap(\n                        relatedEntityRelationIdMap,\n                    )!\n\n                // get database related entity. Since loadRelationIds are used on databaseEntity\n                // related entity will contain only its relation ids\n                const databaseRelatedEntityRelationIdMap =\n                    relation.getEntityValue(subject.databaseEntity)\n\n                // if relation ids are equal then we don't need to update anything\n                const areRelatedIdsEqual = OrmUtils.compareIds(\n                    relatedEntityRelationIdMap,\n                    databaseRelatedEntityRelationIdMap,\n                )\n                if (areRelatedIdsEqual) {\n                    return\n                } else {\n                    subject.diffRelations.push(relation)\n                }\n            }\n\n            // if there is an inserted subject for the related entity of the persisted entity then use it as related entity\n            // this code is used for related entities without ids to be properly inserted (and then updated if needed)\n            const valueSubject = allSubjects.find(\n                (subject) =>\n                    subject.mustBeInserted && subject.entity === relatedEntity,\n            )\n            if (valueSubject) relatedEntity = valueSubject\n\n            // find if there is already a relation to be changed\n            const changeMap = subject.changeMaps.find(\n                (changeMap) => changeMap.relation === relation,\n            )\n            if (changeMap) {\n                // and update its value if it was found\n                changeMap.value = relatedEntity\n            } else {\n                // if it wasn't found add a new relation for change\n                subject.changeMaps.push({\n                    relation: relation,\n                    value: relatedEntity,\n                })\n            }\n        })\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}