{"ast":null,"code":"import { TypeORMError } from \"../error\";\n/**\n * Updates entity with returning results in the entity insert and update operations.\n */\nexport class ReturningResultsEntityUpdator {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(queryRunner, expressionMap) {\n    this.queryRunner = queryRunner;\n    this.expressionMap = expressionMap;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Updates entities with a special columns after updation query execution.\n   */\n  async update(updateResult, entities) {\n    const metadata = this.expressionMap.mainAlias.metadata;\n    await Promise.all(entities.map(async (entity, entityIndex) => {\n      // if database supports returning/output statement then we already should have updating values in the raw data returned by insert query\n      if (this.queryRunner.connection.driver.isReturningSqlSupported(\"update\")) {\n        if (this.queryRunner.connection.driver.options.type === \"oracle\" && Array.isArray(updateResult.raw) && this.expressionMap.extraReturningColumns.length > 0) {\n          updateResult.raw = updateResult.raw.reduce((newRaw, rawItem, rawItemIndex) => {\n            newRaw[this.expressionMap.extraReturningColumns[rawItemIndex].databaseName] = rawItem[0];\n            return newRaw;\n          }, {});\n        }\n        const result = Array.isArray(updateResult.raw) ? updateResult.raw[entityIndex] : updateResult.raw;\n        const returningColumns = this.queryRunner.connection.driver.createGeneratedMap(metadata, result);\n        if (returningColumns) {\n          this.queryRunner.manager.merge(metadata.target, entity, returningColumns);\n          updateResult.generatedMaps.push(returningColumns);\n        }\n      } else {\n        // for driver which do not support returning/output statement we need to perform separate query and load what we need\n        const updationColumns = this.expressionMap.extraReturningColumns;\n        if (updationColumns.length > 0) {\n          // get entity id by which we will get needed data\n          const entityId = this.expressionMap.mainAlias.metadata.getEntityIdMap(entity);\n          if (!entityId) throw new TypeORMError(`Cannot update entity because entity id is not set in the entity.`);\n          // execute query to get needed data\n          const loadedReturningColumns = await this.queryRunner.manager.createQueryBuilder().select(metadata.primaryColumns.map(column => metadata.targetName + \".\" + column.propertyPath)).addSelect(updationColumns.map(column => metadata.targetName + \".\" + column.propertyPath)).from(metadata.target, metadata.targetName).where(entityId).withDeleted().setOption(\"create-pojo\") // use POJO because created object can contain default values, e.g. property = null and those properties might be overridden by merge process\n          .getOne();\n          if (loadedReturningColumns) {\n            this.queryRunner.manager.merge(metadata.target, entity, loadedReturningColumns);\n            updateResult.generatedMaps.push(loadedReturningColumns);\n          }\n        }\n      }\n    }));\n  }\n  /**\n   * Updates entities with a special columns after insertion query execution.\n   */\n  async insert(insertResult, entities) {\n    const metadata = this.expressionMap.mainAlias.metadata;\n    let insertionColumns = metadata.getInsertionReturningColumns();\n    // to prevent extra select SQL execution for databases not supporting RETURNING\n    // in the case if we have generated column and it's value returned by underlying driver\n    // we remove this column from the insertionColumns list\n    const needToCheckGenerated = this.queryRunner.connection.driver.isReturningSqlSupported(\"insert\");\n    insertionColumns = insertionColumns.filter(column => {\n      if (!column.isGenerated) return true;\n      return needToCheckGenerated === true;\n    });\n    const generatedMaps = entities.map((entity, entityIndex) => {\n      if (this.queryRunner.connection.driver.options.type === \"oracle\" && Array.isArray(insertResult.raw) && this.expressionMap.extraReturningColumns.length > 0) {\n        insertResult.raw = insertResult.raw.reduce((newRaw, rawItem, rawItemIndex) => {\n          newRaw[this.expressionMap.extraReturningColumns[rawItemIndex].databaseName] = rawItem[0];\n          return newRaw;\n        }, {});\n      }\n      // get all values generated by a database for us\n      const result = Array.isArray(insertResult.raw) ? insertResult.raw[entityIndex] : insertResult.raw;\n      const generatedMap = this.queryRunner.connection.driver.createGeneratedMap(metadata, result, entityIndex, entities.length) || {};\n      if (entityIndex in this.expressionMap.locallyGenerated) {\n        this.queryRunner.manager.merge(metadata.target, generatedMap, this.expressionMap.locallyGenerated[entityIndex]);\n      }\n      this.queryRunner.manager.merge(metadata.target, entity, generatedMap);\n      return generatedMap;\n    });\n    // for postgres and mssql we use returning/output statement to get values of inserted default and generated values\n    // for other drivers we have to re-select this data from the database\n    if (insertionColumns.length > 0 && !this.queryRunner.connection.driver.isReturningSqlSupported(\"insert\")) {\n      const entityIds = entities.map(entity => {\n        const entityId = metadata.getEntityIdMap(entity);\n        // We have to check for an empty `entityId` - if we don't, the query against the database\n        // effectively drops the `where` clause entirely and the first record will be returned -\n        // not what we want at all.\n        if (!entityId) throw new TypeORMError(`Cannot update entity because entity id is not set in the entity.`);\n        return entityId;\n      });\n      // to select just inserted entities we need a criteria to select by.\n      // for newly inserted entities in drivers which do not support returning statement\n      // row identifier can only be an increment column\n      // (since its the only thing that can be generated by those databases)\n      // or (and) other primary key which is defined by a user and inserted value has it\n      const returningResult = await this.queryRunner.manager.createQueryBuilder().select(metadata.primaryColumns.map(column => metadata.targetName + \".\" + column.propertyPath)).addSelect(insertionColumns.map(column => metadata.targetName + \".\" + column.propertyPath)).from(metadata.target, metadata.targetName).where(entityIds).setOption(\"create-pojo\") // use POJO because created object can contain default values, e.g. property = null and those properties might be overridden by merge process\n      .getMany();\n      entities.forEach((entity, entityIndex) => {\n        this.queryRunner.manager.merge(metadata.target, generatedMaps[entityIndex], returningResult[entityIndex]);\n        this.queryRunner.manager.merge(metadata.target, entity, returningResult[entityIndex]);\n      });\n    }\n    entities.forEach((entity, entityIndex) => {\n      const entityId = metadata.getEntityIdMap(entity);\n      insertResult.identifiers.push(entityId);\n      insertResult.generatedMaps.push(generatedMaps[entityIndex]);\n    });\n  }\n  /**\n   * Columns we need to be returned from the database when we update entity.\n   */\n  getUpdationReturningColumns() {\n    return this.expressionMap.mainAlias.metadata.columns.filter(column => {\n      return column.asExpression !== undefined || column.isUpdateDate || column.isVersion;\n    });\n  }\n  /**\n   * Columns we need to be returned from the database when we soft delete and restore entity.\n   */\n  getSoftDeletionReturningColumns() {\n    return this.expressionMap.mainAlias.metadata.columns.filter(column => {\n      return column.asExpression !== undefined || column.isUpdateDate || column.isVersion || column.isDeleteDate;\n    });\n  }\n}","map":{"version":3,"names":["TypeORMError","ReturningResultsEntityUpdator","constructor","queryRunner","expressionMap","update","updateResult","entities","metadata","mainAlias","Promise","all","map","entity","entityIndex","connection","driver","isReturningSqlSupported","options","type","Array","isArray","raw","extraReturningColumns","length","reduce","newRaw","rawItem","rawItemIndex","databaseName","result","returningColumns","createGeneratedMap","manager","merge","target","generatedMaps","push","updationColumns","entityId","getEntityIdMap","loadedReturningColumns","createQueryBuilder","select","primaryColumns","column","targetName","propertyPath","addSelect","from","where","withDeleted","setOption","getOne","insert","insertResult","insertionColumns","getInsertionReturningColumns","needToCheckGenerated","filter","isGenerated","generatedMap","locallyGenerated","entityIds","returningResult","getMany","forEach","identifiers","getUpdationReturningColumns","columns","asExpression","undefined","isUpdateDate","isVersion","getSoftDeletionReturningColumns","isDeleteDate"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\query-builder\\ReturningResultsEntityUpdator.ts"],"sourcesContent":["import { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { QueryExpressionMap } from \"./QueryExpressionMap\"\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { UpdateResult } from \"./result/UpdateResult\"\nimport { InsertResult } from \"./result/InsertResult\"\nimport { TypeORMError } from \"../error\"\n\n/**\n * Updates entity with returning results in the entity insert and update operations.\n */\nexport class ReturningResultsEntityUpdator {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        protected queryRunner: QueryRunner,\n        protected expressionMap: QueryExpressionMap,\n    ) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Updates entities with a special columns after updation query execution.\n     */\n    async update(\n        updateResult: UpdateResult,\n        entities: ObjectLiteral[],\n    ): Promise<void> {\n        const metadata = this.expressionMap.mainAlias!.metadata\n\n        await Promise.all(\n            entities.map(async (entity, entityIndex) => {\n                // if database supports returning/output statement then we already should have updating values in the raw data returned by insert query\n                if (\n                    this.queryRunner.connection.driver.isReturningSqlSupported(\n                        \"update\",\n                    )\n                ) {\n                    if (\n                        this.queryRunner.connection.driver.options.type ===\n                            \"oracle\" &&\n                        Array.isArray(updateResult.raw) &&\n                        this.expressionMap.extraReturningColumns.length > 0\n                    ) {\n                        updateResult.raw = updateResult.raw.reduce(\n                            (newRaw, rawItem, rawItemIndex) => {\n                                newRaw[\n                                    this.expressionMap.extraReturningColumns[\n                                        rawItemIndex\n                                    ].databaseName\n                                ] = rawItem[0]\n                                return newRaw\n                            },\n                            {} as ObjectLiteral,\n                        )\n                    }\n                    const result = Array.isArray(updateResult.raw)\n                        ? updateResult.raw[entityIndex]\n                        : updateResult.raw\n                    const returningColumns =\n                        this.queryRunner.connection.driver.createGeneratedMap(\n                            metadata,\n                            result,\n                        )\n                    if (returningColumns) {\n                        this.queryRunner.manager.merge(\n                            metadata.target as any,\n                            entity,\n                            returningColumns,\n                        )\n                        updateResult.generatedMaps.push(returningColumns)\n                    }\n                } else {\n                    // for driver which do not support returning/output statement we need to perform separate query and load what we need\n                    const updationColumns =\n                        this.expressionMap.extraReturningColumns\n                    if (updationColumns.length > 0) {\n                        // get entity id by which we will get needed data\n                        const entityId =\n                            this.expressionMap.mainAlias!.metadata.getEntityIdMap(\n                                entity,\n                            )\n                        if (!entityId)\n                            throw new TypeORMError(\n                                `Cannot update entity because entity id is not set in the entity.`,\n                            )\n\n                        // execute query to get needed data\n                        const loadedReturningColumns =\n                            (await this.queryRunner.manager\n                                .createQueryBuilder()\n                                .select(\n                                    metadata.primaryColumns.map(\n                                        (column) =>\n                                            metadata.targetName +\n                                            \".\" +\n                                            column.propertyPath,\n                                    ),\n                                )\n                                .addSelect(\n                                    updationColumns.map(\n                                        (column) =>\n                                            metadata.targetName +\n                                            \".\" +\n                                            column.propertyPath,\n                                    ),\n                                )\n                                .from(metadata.target, metadata.targetName)\n                                .where(entityId)\n                                .withDeleted()\n                                .setOption(\"create-pojo\") // use POJO because created object can contain default values, e.g. property = null and those properties might be overridden by merge process\n                                .getOne()) as any\n\n                        if (loadedReturningColumns) {\n                            this.queryRunner.manager.merge(\n                                metadata.target as any,\n                                entity,\n                                loadedReturningColumns,\n                            )\n                            updateResult.generatedMaps.push(\n                                loadedReturningColumns,\n                            )\n                        }\n                    }\n                }\n            }),\n        )\n    }\n\n    /**\n     * Updates entities with a special columns after insertion query execution.\n     */\n    async insert(\n        insertResult: InsertResult,\n        entities: ObjectLiteral[],\n    ): Promise<void> {\n        const metadata = this.expressionMap.mainAlias!.metadata\n        let insertionColumns = metadata.getInsertionReturningColumns()\n\n        // to prevent extra select SQL execution for databases not supporting RETURNING\n        // in the case if we have generated column and it's value returned by underlying driver\n        // we remove this column from the insertionColumns list\n        const needToCheckGenerated =\n            this.queryRunner.connection.driver.isReturningSqlSupported(\"insert\")\n        insertionColumns = insertionColumns.filter((column) => {\n            if (!column.isGenerated) return true\n            return needToCheckGenerated === true\n        })\n\n        const generatedMaps = entities.map((entity, entityIndex) => {\n            if (\n                this.queryRunner.connection.driver.options.type === \"oracle\" &&\n                Array.isArray(insertResult.raw) &&\n                this.expressionMap.extraReturningColumns.length > 0\n            ) {\n                insertResult.raw = insertResult.raw.reduce(\n                    (newRaw, rawItem, rawItemIndex) => {\n                        newRaw[\n                            this.expressionMap.extraReturningColumns[\n                                rawItemIndex\n                            ].databaseName\n                        ] = rawItem[0]\n                        return newRaw\n                    },\n                    {} as ObjectLiteral,\n                )\n            }\n            // get all values generated by a database for us\n            const result = Array.isArray(insertResult.raw)\n                ? insertResult.raw[entityIndex]\n                : insertResult.raw\n\n            const generatedMap =\n                this.queryRunner.connection.driver.createGeneratedMap(\n                    metadata,\n                    result,\n                    entityIndex,\n                    entities.length,\n                ) || {}\n\n            if (entityIndex in this.expressionMap.locallyGenerated) {\n                this.queryRunner.manager.merge(\n                    metadata.target as any,\n                    generatedMap,\n                    this.expressionMap.locallyGenerated[entityIndex],\n                )\n            }\n\n            this.queryRunner.manager.merge(\n                metadata.target as any,\n                entity,\n                generatedMap,\n            )\n\n            return generatedMap\n        })\n\n        // for postgres and mssql we use returning/output statement to get values of inserted default and generated values\n        // for other drivers we have to re-select this data from the database\n        if (\n            insertionColumns.length > 0 &&\n            !this.queryRunner.connection.driver.isReturningSqlSupported(\n                \"insert\",\n            )\n        ) {\n            const entityIds = entities.map((entity) => {\n                const entityId = metadata.getEntityIdMap(entity)!\n\n                // We have to check for an empty `entityId` - if we don't, the query against the database\n                // effectively drops the `where` clause entirely and the first record will be returned -\n                // not what we want at all.\n                if (!entityId)\n                    throw new TypeORMError(\n                        `Cannot update entity because entity id is not set in the entity.`,\n                    )\n\n                return entityId\n            })\n\n            // to select just inserted entities we need a criteria to select by.\n            // for newly inserted entities in drivers which do not support returning statement\n            // row identifier can only be an increment column\n            // (since its the only thing that can be generated by those databases)\n            // or (and) other primary key which is defined by a user and inserted value has it\n\n            const returningResult: any = await this.queryRunner.manager\n                .createQueryBuilder()\n                .select(\n                    metadata.primaryColumns.map(\n                        (column) =>\n                            metadata.targetName + \".\" + column.propertyPath,\n                    ),\n                )\n                .addSelect(\n                    insertionColumns.map(\n                        (column) =>\n                            metadata.targetName + \".\" + column.propertyPath,\n                    ),\n                )\n                .from(metadata.target, metadata.targetName)\n                .where(entityIds)\n                .setOption(\"create-pojo\") // use POJO because created object can contain default values, e.g. property = null and those properties might be overridden by merge process\n                .getMany()\n\n            entities.forEach((entity, entityIndex) => {\n                this.queryRunner.manager.merge(\n                    metadata.target as any,\n                    generatedMaps[entityIndex],\n                    returningResult[entityIndex],\n                )\n\n                this.queryRunner.manager.merge(\n                    metadata.target as any,\n                    entity,\n                    returningResult[entityIndex],\n                )\n            })\n        }\n\n        entities.forEach((entity, entityIndex) => {\n            const entityId = metadata.getEntityIdMap(entity)!\n            insertResult.identifiers.push(entityId)\n            insertResult.generatedMaps.push(generatedMaps[entityIndex])\n        })\n    }\n\n    /**\n     * Columns we need to be returned from the database when we update entity.\n     */\n    getUpdationReturningColumns(): ColumnMetadata[] {\n        return this.expressionMap.mainAlias!.metadata.columns.filter(\n            (column) => {\n                return (\n                    column.asExpression !== undefined ||\n                    column.isUpdateDate ||\n                    column.isVersion\n                )\n            },\n        )\n    }\n\n    /**\n     * Columns we need to be returned from the database when we soft delete and restore entity.\n     */\n    getSoftDeletionReturningColumns(): ColumnMetadata[] {\n        return this.expressionMap.mainAlias!.metadata.columns.filter(\n            (column) => {\n                return (\n                    column.asExpression !== undefined ||\n                    column.isUpdateDate ||\n                    column.isVersion ||\n                    column.isDeleteDate\n                )\n            },\n        )\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}