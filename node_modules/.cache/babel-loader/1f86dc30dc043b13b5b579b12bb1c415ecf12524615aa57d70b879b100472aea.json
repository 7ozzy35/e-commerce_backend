{"ast":null,"code":"import { QueryBuilder } from \"./QueryBuilder\";\nimport { UpdateResult } from \"./result/UpdateResult\";\nimport { ReturningStatementNotSupportedError } from \"../error/ReturningStatementNotSupportedError\";\nimport { ReturningResultsEntityUpdator } from \"./ReturningResultsEntityUpdator\";\nimport { LimitOnUpdateNotSupportedError } from \"../error/LimitOnUpdateNotSupportedError\";\nimport { MissingDeleteDateColumnError } from \"../error/MissingDeleteDateColumnError\";\nimport { UpdateValuesMissingError } from \"../error/UpdateValuesMissingError\";\nimport { TypeORMError } from \"../error\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class SoftDeleteQueryBuilder extends QueryBuilder {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connectionOrQueryBuilder, queryRunner) {\n    super(connectionOrQueryBuilder, queryRunner);\n    this[\"@instanceof\"] = Symbol.for(\"SoftDeleteQueryBuilder\");\n    this.expressionMap.aliasNamePrefixingEnabled = false;\n  }\n  // -------------------------------------------------------------------------\n  // Public Implemented Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Gets generated SQL query without parameters being replaced.\n   */\n  getQuery() {\n    let sql = this.createUpdateExpression();\n    sql += this.createCteExpression();\n    sql += this.createOrderByExpression();\n    sql += this.createLimitExpression();\n    return this.replacePropertyNamesForTheWholeQuery(sql.trim());\n  }\n  /**\n   * Executes sql generated by query builder and returns raw database results.\n   */\n  async execute() {\n    const queryRunner = this.obtainQueryRunner();\n    let transactionStartedByUs = false;\n    try {\n      // start transaction if it was enabled\n      if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n        await queryRunner.startTransaction();\n        transactionStartedByUs = true;\n      }\n      // call before soft remove and recover methods in listeners and subscribers\n      if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {\n        if (this.expressionMap.queryType === \"soft-delete\") await queryRunner.broadcaster.broadcast(\"BeforeSoftRemove\", this.expressionMap.mainAlias.metadata);else if (this.expressionMap.queryType === \"restore\") await queryRunner.broadcaster.broadcast(\"BeforeRecover\", this.expressionMap.mainAlias.metadata);\n      }\n      // if update entity mode is enabled we may need extra columns for the returning statement\n      const returningResultsEntityUpdator = new ReturningResultsEntityUpdator(queryRunner, this.expressionMap);\n      if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata && this.expressionMap.whereEntities.length > 0) {\n        this.expressionMap.extraReturningColumns = returningResultsEntityUpdator.getSoftDeletionReturningColumns();\n      }\n      // execute update query\n      const [sql, parameters] = this.getQueryAndParameters();\n      const queryResult = await queryRunner.query(sql, parameters, true);\n      const updateResult = UpdateResult.from(queryResult);\n      // if we are updating entities and entity updation is enabled we must update some of entity columns (like version, update date, etc.)\n      if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata && this.expressionMap.whereEntities.length > 0) {\n        await returningResultsEntityUpdator.update(updateResult, this.expressionMap.whereEntities);\n      }\n      // call after soft remove and recover methods in listeners and subscribers\n      if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {\n        if (this.expressionMap.queryType === \"soft-delete\") await queryRunner.broadcaster.broadcast(\"AfterSoftRemove\", this.expressionMap.mainAlias.metadata);else if (this.expressionMap.queryType === \"restore\") await queryRunner.broadcaster.broadcast(\"AfterRecover\", this.expressionMap.mainAlias.metadata);\n      }\n      // close transaction if we started it\n      if (transactionStartedByUs) await queryRunner.commitTransaction();\n      return updateResult;\n    } catch (error) {\n      // rollback transaction if we started it\n      if (transactionStartedByUs) {\n        try {\n          await queryRunner.rollbackTransaction();\n        } catch (rollbackError) {}\n      }\n      throw error;\n    } finally {\n      if (queryRunner !== this.queryRunner) {\n        // means we created our own query runner\n        await queryRunner.release();\n      }\n    }\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Specifies FROM which entity's table select/update/delete/soft-delete will be executed.\n   * Also sets a main string alias of the selection data.\n   */\n  from(entityTarget, aliasName) {\n    entityTarget = InstanceChecker.isEntitySchema(entityTarget) ? entityTarget.options.name : entityTarget;\n    const mainAlias = this.createFromAlias(entityTarget, aliasName);\n    this.expressionMap.setMainAlias(mainAlias);\n    return this;\n  }\n  /**\n   * Sets WHERE condition in the query builder.\n   * If you had previously WHERE expression defined,\n   * calling this function will override previously set WHERE conditions.\n   * Additionally you can add parameters used in where expression.\n   */\n  where(where, parameters) {\n    this.expressionMap.wheres = []; // don't move this block below since computeWhereParameter can add where expressions\n    const condition = this.getWhereCondition(where);\n    if (condition) this.expressionMap.wheres = [{\n      type: \"simple\",\n      condition: condition\n    }];\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Adds new AND WHERE condition in the query builder.\n   * Additionally you can add parameters used in where expression.\n   */\n  andWhere(where, parameters) {\n    this.expressionMap.wheres.push({\n      type: \"and\",\n      condition: this.getWhereCondition(where)\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Adds new OR WHERE condition in the query builder.\n   * Additionally you can add parameters used in where expression.\n   */\n  orWhere(where, parameters) {\n    this.expressionMap.wheres.push({\n      type: \"or\",\n      condition: this.getWhereCondition(where)\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Adds new AND WHERE with conditions for the given ids.\n   */\n  whereInIds(ids) {\n    return this.where(this.getWhereInIdsCondition(ids));\n  }\n  /**\n   * Adds new AND WHERE with conditions for the given ids.\n   */\n  andWhereInIds(ids) {\n    return this.andWhere(this.getWhereInIdsCondition(ids));\n  }\n  /**\n   * Adds new OR WHERE with conditions for the given ids.\n   */\n  orWhereInIds(ids) {\n    return this.orWhere(this.getWhereInIdsCondition(ids));\n  }\n  /**\n   * Optional returning/output clause.\n   */\n  output(output) {\n    return this.returning(output);\n  }\n  /**\n   * Optional returning/output clause.\n   */\n  returning(returning) {\n    // not all databases support returning/output cause\n    if (!this.connection.driver.isReturningSqlSupported(\"update\")) {\n      throw new ReturningStatementNotSupportedError();\n    }\n    this.expressionMap.returning = returning;\n    return this;\n  }\n  /**\n   * Sets ORDER BY condition in the query builder.\n   * If you had previously ORDER BY expression defined,\n   * calling this function will override previously set ORDER BY conditions.\n   */\n  orderBy(sort, order = \"ASC\", nulls) {\n    if (sort) {\n      if (typeof sort === \"object\") {\n        this.expressionMap.orderBys = sort;\n      } else {\n        if (nulls) {\n          this.expressionMap.orderBys = {\n            [sort]: {\n              order,\n              nulls\n            }\n          };\n        } else {\n          this.expressionMap.orderBys = {\n            [sort]: order\n          };\n        }\n      }\n    } else {\n      this.expressionMap.orderBys = {};\n    }\n    return this;\n  }\n  /**\n   * Adds ORDER BY condition in the query builder.\n   */\n  addOrderBy(sort, order = \"ASC\", nulls) {\n    if (nulls) {\n      this.expressionMap.orderBys[sort] = {\n        order,\n        nulls\n      };\n    } else {\n      this.expressionMap.orderBys[sort] = order;\n    }\n    return this;\n  }\n  /**\n   * Sets LIMIT - maximum number of rows to be selected.\n   */\n  limit(limit) {\n    this.expressionMap.limit = limit;\n    return this;\n  }\n  /**\n   * Indicates if entity must be updated after update operation.\n   * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n   * Enabled by default.\n   */\n  whereEntity(entity) {\n    if (!this.expressionMap.mainAlias.hasMetadata) throw new TypeORMError(`.whereEntity method can only be used on queries which update real entity table.`);\n    this.expressionMap.wheres = [];\n    const entities = Array.isArray(entity) ? entity : [entity];\n    entities.forEach(entity => {\n      const entityIdMap = this.expressionMap.mainAlias.metadata.getEntityIdMap(entity);\n      if (!entityIdMap) throw new TypeORMError(`Provided entity does not have ids set, cannot perform operation.`);\n      this.orWhereInIds(entityIdMap);\n    });\n    this.expressionMap.whereEntities = entities;\n    return this;\n  }\n  /**\n   * Indicates if entity must be updated after update operation.\n   * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n   * Enabled by default.\n   */\n  updateEntity(enabled) {\n    this.expressionMap.updateEntity = enabled;\n    return this;\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates UPDATE express used to perform insert query.\n   */\n  createUpdateExpression() {\n    const metadata = this.expressionMap.mainAlias.hasMetadata ? this.expressionMap.mainAlias.metadata : undefined;\n    if (!metadata) throw new TypeORMError(`Cannot get entity metadata for the given alias \"${this.expressionMap.mainAlias}\"`);\n    if (!metadata.deleteDateColumn) {\n      throw new MissingDeleteDateColumnError(metadata);\n    }\n    // prepare columns and values to be updated\n    const updateColumnAndValues = [];\n    switch (this.expressionMap.queryType) {\n      case \"soft-delete\":\n        updateColumnAndValues.push(this.escape(metadata.deleteDateColumn.databaseName) + \" = CURRENT_TIMESTAMP\");\n        break;\n      case \"restore\":\n        updateColumnAndValues.push(this.escape(metadata.deleteDateColumn.databaseName) + \" = NULL\");\n        break;\n      default:\n        throw new TypeORMError(`The queryType must be \"soft-delete\" or \"restore\"`);\n    }\n    if (metadata.versionColumn) updateColumnAndValues.push(this.escape(metadata.versionColumn.databaseName) + \" = \" + this.escape(metadata.versionColumn.databaseName) + \" + 1\");\n    if (metadata.updateDateColumn) updateColumnAndValues.push(this.escape(metadata.updateDateColumn.databaseName) + \" = CURRENT_TIMESTAMP\"); // todo: fix issue with CURRENT_TIMESTAMP(6) being used, can \"DEFAULT\" be used?!\n    if (updateColumnAndValues.length <= 0) {\n      throw new UpdateValuesMissingError();\n    }\n    // get a table name and all column database names\n    const whereExpression = this.createWhereExpression();\n    const returningExpression = this.createReturningExpression(\"update\");\n    if (returningExpression === \"\") {\n      return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(\", \")}${whereExpression}`; // todo: how do we replace aliases in where to nothing?\n    }\n    if (this.connection.driver.options.type === \"mssql\") {\n      return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(\", \")} OUTPUT ${returningExpression}${whereExpression}`;\n    }\n    return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(\", \")}${whereExpression} RETURNING ${returningExpression}`;\n  }\n  /**\n   * Creates \"ORDER BY\" part of SQL query.\n   */\n  createOrderByExpression() {\n    const orderBys = this.expressionMap.orderBys;\n    if (Object.keys(orderBys).length > 0) return \" ORDER BY \" + Object.keys(orderBys).map(columnName => {\n      if (typeof orderBys[columnName] === \"string\") {\n        return this.replacePropertyNames(columnName) + \" \" + orderBys[columnName];\n      } else {\n        return this.replacePropertyNames(columnName) + \" \" + orderBys[columnName].order + \" \" + orderBys[columnName].nulls;\n      }\n    }).join(\", \");\n    return \"\";\n  }\n  /**\n   * Creates \"LIMIT\" parts of SQL query.\n   */\n  createLimitExpression() {\n    let limit = this.expressionMap.limit;\n    if (limit) {\n      if (DriverUtils.isMySQLFamily(this.connection.driver)) {\n        return \" LIMIT \" + limit;\n      } else {\n        throw new LimitOnUpdateNotSupportedError();\n      }\n    }\n    return \"\";\n  }\n}","map":{"version":3,"names":["QueryBuilder","UpdateResult","ReturningStatementNotSupportedError","ReturningResultsEntityUpdator","LimitOnUpdateNotSupportedError","MissingDeleteDateColumnError","UpdateValuesMissingError","TypeORMError","DriverUtils","InstanceChecker","SoftDeleteQueryBuilder","constructor","connectionOrQueryBuilder","queryRunner","Symbol","for","expressionMap","aliasNamePrefixingEnabled","getQuery","sql","createUpdateExpression","createCteExpression","createOrderByExpression","createLimitExpression","replacePropertyNamesForTheWholeQuery","trim","execute","obtainQueryRunner","transactionStartedByUs","useTransaction","isTransactionActive","startTransaction","callListeners","mainAlias","hasMetadata","queryType","broadcaster","broadcast","metadata","returningResultsEntityUpdator","updateEntity","whereEntities","length","extraReturningColumns","getSoftDeletionReturningColumns","parameters","getQueryAndParameters","queryResult","query","updateResult","from","update","commitTransaction","error","rollbackTransaction","rollbackError","release","entityTarget","aliasName","isEntitySchema","options","name","createFromAlias","setMainAlias","where","wheres","condition","getWhereCondition","type","setParameters","andWhere","push","orWhere","whereInIds","ids","getWhereInIdsCondition","andWhereInIds","orWhereInIds","output","returning","connection","driver","isReturningSqlSupported","orderBy","sort","order","nulls","orderBys","addOrderBy","limit","whereEntity","entity","entities","Array","isArray","forEach","entityIdMap","getEntityIdMap","enabled","undefined","deleteDateColumn","updateColumnAndValues","escape","databaseName","versionColumn","updateDateColumn","whereExpression","createWhereExpression","returningExpression","createReturningExpression","getTableName","getMainTableName","join","Object","keys","map","columnName","replacePropertyNames","isMySQLFamily"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\query-builder\\SoftDeleteQueryBuilder.ts"],"sourcesContent":["import { QueryBuilder } from \"./QueryBuilder\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { EntityTarget } from \"../common/EntityTarget\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { WhereExpressionBuilder } from \"./WhereExpressionBuilder\"\nimport { Brackets } from \"./Brackets\"\nimport { UpdateResult } from \"./result/UpdateResult\"\nimport { ReturningStatementNotSupportedError } from \"../error/ReturningStatementNotSupportedError\"\nimport { ReturningResultsEntityUpdator } from \"./ReturningResultsEntityUpdator\"\nimport { OrderByCondition } from \"../find-options/OrderByCondition\"\nimport { LimitOnUpdateNotSupportedError } from \"../error/LimitOnUpdateNotSupportedError\"\nimport { MissingDeleteDateColumnError } from \"../error/MissingDeleteDateColumnError\"\nimport { UpdateValuesMissingError } from \"../error/UpdateValuesMissingError\"\nimport { TypeORMError } from \"../error\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\n\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class SoftDeleteQueryBuilder<Entity extends ObjectLiteral>\n    extends QueryBuilder<Entity>\n    implements WhereExpressionBuilder\n{\n    readonly \"@instanceof\" = Symbol.for(\"SoftDeleteQueryBuilder\")\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        connectionOrQueryBuilder: DataSource | QueryBuilder<any>,\n        queryRunner?: QueryRunner,\n    ) {\n        super(connectionOrQueryBuilder as any, queryRunner)\n        this.expressionMap.aliasNamePrefixingEnabled = false\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets generated SQL query without parameters being replaced.\n     */\n    getQuery(): string {\n        let sql = this.createUpdateExpression()\n        sql += this.createCteExpression()\n        sql += this.createOrderByExpression()\n        sql += this.createLimitExpression()\n        return this.replacePropertyNamesForTheWholeQuery(sql.trim())\n    }\n\n    /**\n     * Executes sql generated by query builder and returns raw database results.\n     */\n    async execute(): Promise<UpdateResult> {\n        const queryRunner = this.obtainQueryRunner()\n        let transactionStartedByUs: boolean = false\n\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction()\n                transactionStartedByUs = true\n            }\n\n            // call before soft remove and recover methods in listeners and subscribers\n            if (\n                this.expressionMap.callListeners === true &&\n                this.expressionMap.mainAlias!.hasMetadata\n            ) {\n                if (this.expressionMap.queryType === \"soft-delete\")\n                    await queryRunner.broadcaster.broadcast(\n                        \"BeforeSoftRemove\",\n                        this.expressionMap.mainAlias!.metadata,\n                    )\n                else if (this.expressionMap.queryType === \"restore\")\n                    await queryRunner.broadcaster.broadcast(\n                        \"BeforeRecover\",\n                        this.expressionMap.mainAlias!.metadata,\n                    )\n            }\n\n            // if update entity mode is enabled we may need extra columns for the returning statement\n            const returningResultsEntityUpdator =\n                new ReturningResultsEntityUpdator(\n                    queryRunner,\n                    this.expressionMap,\n                )\n            if (\n                this.expressionMap.updateEntity === true &&\n                this.expressionMap.mainAlias!.hasMetadata &&\n                this.expressionMap.whereEntities.length > 0\n            ) {\n                this.expressionMap.extraReturningColumns =\n                    returningResultsEntityUpdator.getSoftDeletionReturningColumns()\n            }\n\n            // execute update query\n            const [sql, parameters] = this.getQueryAndParameters()\n\n            const queryResult = await queryRunner.query(sql, parameters, true)\n            const updateResult = UpdateResult.from(queryResult)\n\n            // if we are updating entities and entity updation is enabled we must update some of entity columns (like version, update date, etc.)\n            if (\n                this.expressionMap.updateEntity === true &&\n                this.expressionMap.mainAlias!.hasMetadata &&\n                this.expressionMap.whereEntities.length > 0\n            ) {\n                await returningResultsEntityUpdator.update(\n                    updateResult,\n                    this.expressionMap.whereEntities,\n                )\n            }\n\n            // call after soft remove and recover methods in listeners and subscribers\n            if (\n                this.expressionMap.callListeners === true &&\n                this.expressionMap.mainAlias!.hasMetadata\n            ) {\n                if (this.expressionMap.queryType === \"soft-delete\")\n                    await queryRunner.broadcaster.broadcast(\n                        \"AfterSoftRemove\",\n                        this.expressionMap.mainAlias!.metadata,\n                    )\n                else if (this.expressionMap.queryType === \"restore\")\n                    await queryRunner.broadcaster.broadcast(\n                        \"AfterRecover\",\n                        this.expressionMap.mainAlias!.metadata,\n                    )\n            }\n\n            // close transaction if we started it\n            if (transactionStartedByUs) await queryRunner.commitTransaction()\n\n            return updateResult\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n            throw error\n        } finally {\n            if (queryRunner !== this.queryRunner) {\n                // means we created our own query runner\n                await queryRunner.release()\n            }\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Specifies FROM which entity's table select/update/delete/soft-delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    from<T extends ObjectLiteral>(\n        entityTarget: EntityTarget<T>,\n        aliasName?: string,\n    ): SoftDeleteQueryBuilder<T> {\n        entityTarget = InstanceChecker.isEntitySchema(entityTarget)\n            ? entityTarget.options.name\n            : entityTarget\n        const mainAlias = this.createFromAlias(entityTarget, aliasName)\n        this.expressionMap.setMainAlias(mainAlias)\n        return this as any as SoftDeleteQueryBuilder<T>\n    }\n\n    /**\n     * Sets WHERE condition in the query builder.\n     * If you had previously WHERE expression defined,\n     * calling this function will override previously set WHERE conditions.\n     * Additionally you can add parameters used in where expression.\n     */\n    where(\n        where:\n            | string\n            | ((qb: this) => string)\n            | Brackets\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres = [] // don't move this block below since computeWhereParameter can add where expressions\n        const condition = this.getWhereCondition(where)\n        if (condition)\n            this.expressionMap.wheres = [\n                { type: \"simple\", condition: condition },\n            ]\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new AND WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    andWhere(\n        where:\n            | string\n            | ((qb: this) => string)\n            | Brackets\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres.push({\n            type: \"and\",\n            condition: this.getWhereCondition(where),\n        })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new OR WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    orWhere(\n        where:\n            | string\n            | ((qb: this) => string)\n            | Brackets\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres.push({\n            type: \"or\",\n            condition: this.getWhereCondition(where),\n        })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     */\n    whereInIds(ids: any | any[]): this {\n        return this.where(this.getWhereInIdsCondition(ids))\n    }\n\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     */\n    andWhereInIds(ids: any | any[]): this {\n        return this.andWhere(this.getWhereInIdsCondition(ids))\n    }\n\n    /**\n     * Adds new OR WHERE with conditions for the given ids.\n     */\n    orWhereInIds(ids: any | any[]): this {\n        return this.orWhere(this.getWhereInIdsCondition(ids))\n    }\n    /**\n     * Optional returning/output clause.\n     * This will return given column values.\n     */\n    output(columns: string[]): this\n\n    /**\n     * Optional returning/output clause.\n     * Returning is a SQL string containing returning statement.\n     */\n    output(output: string): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    output(output: string | string[]): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    output(output: string | string[]): this {\n        return this.returning(output)\n    }\n\n    /**\n     * Optional returning/output clause.\n     * This will return given column values.\n     */\n    returning(columns: string[]): this\n\n    /**\n     * Optional returning/output clause.\n     * Returning is a SQL string containing returning statement.\n     */\n    returning(returning: string): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    returning(returning: string | string[]): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    returning(returning: string | string[]): this {\n        // not all databases support returning/output cause\n        if (!this.connection.driver.isReturningSqlSupported(\"update\")) {\n            throw new ReturningStatementNotSupportedError()\n        }\n\n        this.expressionMap.returning = returning\n        return this\n    }\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     *\n     * Calling order by without order set will remove all previously set order bys.\n     */\n    orderBy(): this\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(\n        sort: string,\n        order?: \"ASC\" | \"DESC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\n    ): this\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(order: OrderByCondition): this\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(\n        sort?: string | OrderByCondition,\n        order: \"ASC\" | \"DESC\" = \"ASC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\n    ): this {\n        if (sort) {\n            if (typeof sort === \"object\") {\n                this.expressionMap.orderBys = sort as OrderByCondition\n            } else {\n                if (nulls) {\n                    this.expressionMap.orderBys = {\n                        [sort as string]: { order, nulls },\n                    }\n                } else {\n                    this.expressionMap.orderBys = { [sort as string]: order }\n                }\n            }\n        } else {\n            this.expressionMap.orderBys = {}\n        }\n        return this\n    }\n\n    /**\n     * Adds ORDER BY condition in the query builder.\n     */\n    addOrderBy(\n        sort: string,\n        order: \"ASC\" | \"DESC\" = \"ASC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\n    ): this {\n        if (nulls) {\n            this.expressionMap.orderBys[sort] = { order, nulls }\n        } else {\n            this.expressionMap.orderBys[sort] = order\n        }\n        return this\n    }\n\n    /**\n     * Sets LIMIT - maximum number of rows to be selected.\n     */\n    limit(limit?: number): this {\n        this.expressionMap.limit = limit\n        return this\n    }\n\n    /**\n     * Indicates if entity must be updated after update operation.\n     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n     * Enabled by default.\n     */\n    whereEntity(entity: Entity | Entity[]): this {\n        if (!this.expressionMap.mainAlias!.hasMetadata)\n            throw new TypeORMError(\n                `.whereEntity method can only be used on queries which update real entity table.`,\n            )\n\n        this.expressionMap.wheres = []\n        const entities: Entity[] = Array.isArray(entity) ? entity : [entity]\n        entities.forEach((entity) => {\n            const entityIdMap =\n                this.expressionMap.mainAlias!.metadata.getEntityIdMap(entity)\n            if (!entityIdMap)\n                throw new TypeORMError(\n                    `Provided entity does not have ids set, cannot perform operation.`,\n                )\n\n            this.orWhereInIds(entityIdMap)\n        })\n\n        this.expressionMap.whereEntities = entities\n        return this\n    }\n\n    /**\n     * Indicates if entity must be updated after update operation.\n     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n     * Enabled by default.\n     */\n    updateEntity(enabled: boolean): this {\n        this.expressionMap.updateEntity = enabled\n        return this\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates UPDATE express used to perform insert query.\n     */\n    protected createUpdateExpression() {\n        const metadata = this.expressionMap.mainAlias!.hasMetadata\n            ? this.expressionMap.mainAlias!.metadata\n            : undefined\n        if (!metadata)\n            throw new TypeORMError(\n                `Cannot get entity metadata for the given alias \"${this.expressionMap.mainAlias}\"`,\n            )\n        if (!metadata.deleteDateColumn) {\n            throw new MissingDeleteDateColumnError(metadata)\n        }\n\n        // prepare columns and values to be updated\n        const updateColumnAndValues: string[] = []\n\n        switch (this.expressionMap.queryType) {\n            case \"soft-delete\":\n                updateColumnAndValues.push(\n                    this.escape(metadata.deleteDateColumn.databaseName) +\n                        \" = CURRENT_TIMESTAMP\",\n                )\n                break\n            case \"restore\":\n                updateColumnAndValues.push(\n                    this.escape(metadata.deleteDateColumn.databaseName) +\n                        \" = NULL\",\n                )\n                break\n            default:\n                throw new TypeORMError(\n                    `The queryType must be \"soft-delete\" or \"restore\"`,\n                )\n        }\n        if (metadata.versionColumn)\n            updateColumnAndValues.push(\n                this.escape(metadata.versionColumn.databaseName) +\n                    \" = \" +\n                    this.escape(metadata.versionColumn.databaseName) +\n                    \" + 1\",\n            )\n        if (metadata.updateDateColumn)\n            updateColumnAndValues.push(\n                this.escape(metadata.updateDateColumn.databaseName) +\n                    \" = CURRENT_TIMESTAMP\",\n            ) // todo: fix issue with CURRENT_TIMESTAMP(6) being used, can \"DEFAULT\" be used?!\n\n        if (updateColumnAndValues.length <= 0) {\n            throw new UpdateValuesMissingError()\n        }\n\n        // get a table name and all column database names\n        const whereExpression = this.createWhereExpression()\n        const returningExpression = this.createReturningExpression(\"update\")\n\n        if (returningExpression === \"\") {\n            return `UPDATE ${this.getTableName(\n                this.getMainTableName(),\n            )} SET ${updateColumnAndValues.join(\", \")}${whereExpression}` // todo: how do we replace aliases in where to nothing?\n        }\n        if (this.connection.driver.options.type === \"mssql\") {\n            return `UPDATE ${this.getTableName(\n                this.getMainTableName(),\n            )} SET ${updateColumnAndValues.join(\n                \", \",\n            )} OUTPUT ${returningExpression}${whereExpression}`\n        }\n        return `UPDATE ${this.getTableName(\n            this.getMainTableName(),\n        )} SET ${updateColumnAndValues.join(\n            \", \",\n        )}${whereExpression} RETURNING ${returningExpression}`\n    }\n\n    /**\n     * Creates \"ORDER BY\" part of SQL query.\n     */\n    protected createOrderByExpression() {\n        const orderBys = this.expressionMap.orderBys\n        if (Object.keys(orderBys).length > 0)\n            return (\n                \" ORDER BY \" +\n                Object.keys(orderBys)\n                    .map((columnName) => {\n                        if (typeof orderBys[columnName] === \"string\") {\n                            return (\n                                this.replacePropertyNames(columnName) +\n                                \" \" +\n                                orderBys[columnName]\n                            )\n                        } else {\n                            return (\n                                this.replacePropertyNames(columnName) +\n                                \" \" +\n                                (orderBys[columnName] as any).order +\n                                \" \" +\n                                (orderBys[columnName] as any).nulls\n                            )\n                        }\n                    })\n                    .join(\", \")\n            )\n\n        return \"\"\n    }\n\n    /**\n     * Creates \"LIMIT\" parts of SQL query.\n     */\n    protected createLimitExpression(): string {\n        let limit: number | undefined = this.expressionMap.limit\n\n        if (limit) {\n            if (DriverUtils.isMySQLFamily(this.connection.driver)) {\n                return \" LIMIT \" + limit\n            } else {\n                throw new LimitOnUpdateNotSupportedError()\n            }\n        }\n\n        return \"\"\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}