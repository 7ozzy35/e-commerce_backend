{"ast":null,"code":"import { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\";\nimport { QueryFailedError } from \"../../error/QueryFailedError\";\nimport { AbstractSqliteQueryRunner } from \"../sqlite-abstract/AbstractSqliteQueryRunner\";\nimport { Broadcaster } from \"../../subscriber/Broadcaster\";\nimport { QueryResult } from \"../../query-runner/QueryResult\";\nimport { BroadcasterResult } from \"../../subscriber/BroadcasterResult\";\n/**\n * Runs queries on a single sqlite database connection.\n */\nexport class ReactNativeQueryRunner extends AbstractSqliteQueryRunner {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(driver) {\n    super();\n    this.driver = driver;\n    this.connection = driver.connection;\n    this.broadcaster = new Broadcaster(this);\n  }\n  /**\n   * Called before migrations are run.\n   */\n  async beforeMigration() {\n    await this.query(`PRAGMA foreign_keys = OFF`);\n  }\n  /**\n   * Called after migrations are run.\n   */\n  async afterMigration() {\n    await this.query(`PRAGMA foreign_keys = ON`);\n  }\n  /**\n   * Executes a given SQL query.\n   */\n  query(query, parameters, useStructuredResult = false) {\n    if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();\n    return new Promise(async (ok, fail) => {\n      const databaseConnection = await this.connect();\n      const broadcasterResult = new BroadcasterResult();\n      this.driver.connection.logger.logQuery(query, parameters, this);\n      this.broadcaster.broadcastBeforeQueryEvent(broadcasterResult, query, parameters);\n      const queryStartTime = +new Date();\n      databaseConnection.executeSql(query, parameters, async raw => {\n        // log slow queries if maxQueryExecution time is set\n        const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;\n        const queryEndTime = +new Date();\n        const queryExecutionTime = queryEndTime - queryStartTime;\n        this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, raw, undefined);\n        if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);\n        if (broadcasterResult.promises.length > 0) await Promise.all(broadcasterResult.promises);\n        const result = new QueryResult();\n        if (raw?.hasOwnProperty(\"rowsAffected\")) {\n          result.affected = raw.rowsAffected;\n        }\n        if (raw?.hasOwnProperty(\"rows\")) {\n          let records = [];\n          for (let i = 0; i < raw.rows.length; i++) {\n            records.push(raw.rows.item(i));\n          }\n          result.raw = records;\n          result.records = records;\n        }\n        // return id of inserted row, if query was insert statement.\n        if (query.substr(0, 11) === \"INSERT INTO\") {\n          result.raw = raw.insertId;\n        }\n        if (useStructuredResult) {\n          ok(result);\n        } else {\n          ok(result.raw);\n        }\n      }, async err => {\n        this.driver.connection.logger.logQueryError(err, query, parameters, this);\n        this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, undefined, undefined, err);\n        await broadcasterResult.wait();\n        fail(new QueryFailedError(query, parameters, err));\n      });\n    });\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Parametrizes given object of values. Used to create column=value queries.\n   */\n  parametrize(objectLiteral, startIndex = 0) {\n    return Object.keys(objectLiteral).map((key, index) => `\"${key}\"` + \"=?\");\n  }\n}","map":{"version":3,"names":["QueryRunnerAlreadyReleasedError","QueryFailedError","AbstractSqliteQueryRunner","Broadcaster","QueryResult","BroadcasterResult","ReactNativeQueryRunner","constructor","driver","connection","broadcaster","beforeMigration","query","afterMigration","parameters","useStructuredResult","isReleased","Promise","ok","fail","databaseConnection","connect","broadcasterResult","logger","logQuery","broadcastBeforeQueryEvent","queryStartTime","Date","executeSql","raw","maxQueryExecutionTime","options","queryEndTime","queryExecutionTime","broadcastAfterQueryEvent","undefined","logQuerySlow","promises","length","all","result","hasOwnProperty","affected","rowsAffected","records","i","rows","push","item","substr","insertId","err","logQueryError","wait","parametrize","objectLiteral","startIndex","Object","keys","map","key","index"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\driver\\react-native\\ReactNativeQueryRunner.ts"],"sourcesContent":["import { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\"\nimport { QueryFailedError } from \"../../error/QueryFailedError\"\nimport { AbstractSqliteQueryRunner } from \"../sqlite-abstract/AbstractSqliteQueryRunner\"\nimport { ReactNativeDriver } from \"./ReactNativeDriver\"\nimport { Broadcaster } from \"../../subscriber/Broadcaster\"\nimport { QueryResult } from \"../../query-runner/QueryResult\"\nimport { BroadcasterResult } from \"../../subscriber/BroadcasterResult\"\n\n/**\n * Runs queries on a single sqlite database connection.\n */\nexport class ReactNativeQueryRunner extends AbstractSqliteQueryRunner {\n    /**\n     * Database driver used by connection.\n     */\n    // @ts-ignore temporary, we need to fix the issue with the AbstractSqliteDriver and circular errors\n    driver: ReactNativeDriver\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(driver: ReactNativeDriver) {\n        super()\n        this.driver = driver\n        this.connection = driver.connection\n        this.broadcaster = new Broadcaster(this)\n    }\n\n    /**\n     * Called before migrations are run.\n     */\n    async beforeMigration(): Promise<void> {\n        await this.query(`PRAGMA foreign_keys = OFF`)\n    }\n\n    /**\n     * Called after migrations are run.\n     */\n    async afterMigration(): Promise<void> {\n        await this.query(`PRAGMA foreign_keys = ON`)\n    }\n\n    /**\n     * Executes a given SQL query.\n     */\n    query(\n        query: string,\n        parameters?: any[],\n        useStructuredResult = false,\n    ): Promise<any> {\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        return new Promise(async (ok, fail) => {\n            const databaseConnection = await this.connect()\n            const broadcasterResult = new BroadcasterResult()\n\n            this.driver.connection.logger.logQuery(query, parameters, this)\n            this.broadcaster.broadcastBeforeQueryEvent(\n                broadcasterResult,\n                query,\n                parameters,\n            )\n\n            const queryStartTime = +new Date()\n            databaseConnection.executeSql(\n                query,\n                parameters,\n                async (raw: any) => {\n                    // log slow queries if maxQueryExecution time is set\n                    const maxQueryExecutionTime =\n                        this.driver.options.maxQueryExecutionTime\n                    const queryEndTime = +new Date()\n                    const queryExecutionTime = queryEndTime - queryStartTime\n\n                    this.broadcaster.broadcastAfterQueryEvent(\n                        broadcasterResult,\n                        query,\n                        parameters,\n                        true,\n                        queryExecutionTime,\n                        raw,\n                        undefined,\n                    )\n\n                    if (\n                        maxQueryExecutionTime &&\n                        queryExecutionTime > maxQueryExecutionTime\n                    )\n                        this.driver.connection.logger.logQuerySlow(\n                            queryExecutionTime,\n                            query,\n                            parameters,\n                            this,\n                        )\n\n                    if (broadcasterResult.promises.length > 0)\n                        await Promise.all(broadcasterResult.promises)\n\n                    const result = new QueryResult()\n\n                    if (raw?.hasOwnProperty(\"rowsAffected\")) {\n                        result.affected = raw.rowsAffected\n                    }\n\n                    if (raw?.hasOwnProperty(\"rows\")) {\n                        let records = []\n                        for (let i = 0; i < raw.rows.length; i++) {\n                            records.push(raw.rows.item(i))\n                        }\n\n                        result.raw = records\n                        result.records = records\n                    }\n\n                    // return id of inserted row, if query was insert statement.\n                    if (query.substr(0, 11) === \"INSERT INTO\") {\n                        result.raw = raw.insertId\n                    }\n\n                    if (useStructuredResult) {\n                        ok(result)\n                    } else {\n                        ok(result.raw)\n                    }\n                },\n                async (err: any) => {\n                    this.driver.connection.logger.logQueryError(\n                        err,\n                        query,\n                        parameters,\n                        this,\n                    )\n                    this.broadcaster.broadcastAfterQueryEvent(\n                        broadcasterResult,\n                        query,\n                        parameters,\n                        false,\n                        undefined,\n                        undefined,\n                        err,\n                    )\n                    await broadcasterResult.wait()\n\n                    fail(new QueryFailedError(query, parameters, err))\n                },\n            )\n        })\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Parametrizes given object of values. Used to create column=value queries.\n     */\n    protected parametrize(\n        objectLiteral: ObjectLiteral,\n        startIndex: number = 0,\n    ): string[] {\n        return Object.keys(objectLiteral).map((key, index) => `\"${key}\"` + \"=?\")\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}