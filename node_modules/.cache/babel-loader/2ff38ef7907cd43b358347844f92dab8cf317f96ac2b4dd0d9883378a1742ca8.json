{"ast":null,"code":"import { MetadataArgsStorage } from \"../metadata-args/MetadataArgsStorage\";\nimport { EntitySchemaEmbeddedError } from \"./EntitySchemaEmbeddedError\";\n/**\n * Transforms entity schema into metadata args storage.\n * The result will be just like entities read from decorators.\n */\nexport class EntitySchemaTransformer {\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Transforms entity schema into new metadata args storage object.\n   */\n  transform(schemas) {\n    const metadataArgsStorage = new MetadataArgsStorage();\n    schemas.forEach(entitySchema => {\n      const options = entitySchema.options;\n      // add table metadata args from the schema\n      const tableMetadata = {\n        target: options.target || options.name,\n        name: options.tableName,\n        database: options.database,\n        schema: options.schema,\n        type: options.type || \"regular\",\n        orderBy: options.orderBy,\n        synchronize: options.synchronize,\n        withoutRowid: !!options.withoutRowid,\n        expression: options.expression\n      };\n      metadataArgsStorage.tables.push(tableMetadata);\n      const {\n        inheritance\n      } = options;\n      if (inheritance) {\n        metadataArgsStorage.inheritances.push({\n          target: options.target,\n          pattern: inheritance.pattern ?? \"STI\",\n          column: inheritance.column ? typeof inheritance.column === \"string\" ? {\n            name: inheritance.column\n          } : inheritance.column : undefined\n        });\n      }\n      const {\n        discriminatorValue\n      } = options;\n      if (discriminatorValue) {\n        metadataArgsStorage.discriminatorValues.push({\n          target: options.target || options.name,\n          value: discriminatorValue\n        });\n      }\n      this.transformColumnsRecursive(options, metadataArgsStorage);\n    });\n    return metadataArgsStorage;\n  }\n  transformColumnsRecursive(options, metadataArgsStorage) {\n    // add columns metadata args from the schema\n    Object.keys(options.columns).forEach(columnName => {\n      const column = options.columns[columnName];\n      const regularColumn = column;\n      let mode = \"regular\";\n      if (regularColumn.createDate) mode = \"createDate\";\n      if (regularColumn.updateDate) mode = \"updateDate\";\n      if (regularColumn.deleteDate) mode = \"deleteDate\";\n      if (regularColumn.version) mode = \"version\";\n      if (regularColumn.treeChildrenCount) mode = \"treeChildrenCount\";\n      if (regularColumn.treeLevel) mode = \"treeLevel\";\n      if (regularColumn.objectId) mode = \"objectId\";\n      const columnArgs = {\n        target: options.target || options.name,\n        mode: mode,\n        propertyName: columnName,\n        options: {\n          type: regularColumn.type,\n          name: regularColumn.objectId ? \"_id\" : regularColumn.name,\n          primaryKeyConstraintName: regularColumn.primaryKeyConstraintName,\n          length: regularColumn.length,\n          width: regularColumn.width,\n          nullable: regularColumn.nullable,\n          readonly: regularColumn.readonly,\n          update: regularColumn.update,\n          select: regularColumn.select,\n          insert: regularColumn.insert,\n          primary: regularColumn.primary,\n          unique: regularColumn.unique,\n          comment: regularColumn.comment,\n          default: regularColumn.default,\n          onUpdate: regularColumn.onUpdate,\n          precision: regularColumn.precision,\n          scale: regularColumn.scale,\n          zerofill: regularColumn.zerofill,\n          unsigned: regularColumn.unsigned,\n          charset: regularColumn.charset,\n          collation: regularColumn.collation,\n          enum: regularColumn.enum,\n          enumName: regularColumn.enumName,\n          asExpression: regularColumn.asExpression,\n          generatedType: regularColumn.generatedType,\n          hstoreType: regularColumn.hstoreType,\n          array: regularColumn.array,\n          transformer: regularColumn.transformer,\n          spatialFeatureType: regularColumn.spatialFeatureType,\n          srid: regularColumn.srid\n        }\n      };\n      metadataArgsStorage.columns.push(columnArgs);\n      if (regularColumn.generated) {\n        const generationArgs = {\n          target: options.target || options.name,\n          propertyName: columnName,\n          strategy: typeof regularColumn.generated === \"string\" ? regularColumn.generated : \"increment\"\n        };\n        metadataArgsStorage.generations.push(generationArgs);\n      }\n      if (regularColumn.unique) metadataArgsStorage.uniques.push({\n        target: options.target || options.name,\n        columns: [columnName]\n      });\n    });\n    // add relation metadata args from the schema\n    if (options.relations) {\n      Object.keys(options.relations).forEach(relationName => {\n        const relationSchema = options.relations[relationName];\n        const relation = {\n          target: options.target || options.name,\n          propertyName: relationName,\n          relationType: relationSchema.type,\n          isLazy: relationSchema.lazy || false,\n          type: relationSchema.target,\n          inverseSideProperty: relationSchema.inverseSide,\n          isTreeParent: relationSchema.treeParent,\n          isTreeChildren: relationSchema.treeChildren,\n          options: {\n            eager: relationSchema.eager || false,\n            cascade: relationSchema.cascade,\n            nullable: relationSchema.nullable,\n            onDelete: relationSchema.onDelete,\n            onUpdate: relationSchema.onUpdate,\n            deferrable: relationSchema.deferrable,\n            // primary: relationSchema.primary,\n            createForeignKeyConstraints: relationSchema.createForeignKeyConstraints,\n            persistence: relationSchema.persistence,\n            orphanedRowAction: relationSchema.orphanedRowAction\n          }\n        };\n        metadataArgsStorage.relations.push(relation);\n        // add join column\n        if (relationSchema.joinColumn) {\n          if (typeof relationSchema.joinColumn === \"boolean\") {\n            const joinColumn = {\n              target: options.target || options.name,\n              propertyName: relationName\n            };\n            metadataArgsStorage.joinColumns.push(joinColumn);\n          } else {\n            const joinColumnsOptions = Array.isArray(relationSchema.joinColumn) ? relationSchema.joinColumn : [relationSchema.joinColumn];\n            for (const joinColumnOption of joinColumnsOptions) {\n              const joinColumn = {\n                target: options.target || options.name,\n                propertyName: relationName,\n                name: joinColumnOption.name,\n                referencedColumnName: joinColumnOption.referencedColumnName,\n                foreignKeyConstraintName: joinColumnOption.foreignKeyConstraintName\n              };\n              metadataArgsStorage.joinColumns.push(joinColumn);\n            }\n          }\n        }\n        // add join table\n        if (relationSchema.joinTable) {\n          if (typeof relationSchema.joinTable === \"boolean\") {\n            const joinTable = {\n              target: options.target || options.name,\n              propertyName: relationName\n            };\n            metadataArgsStorage.joinTables.push(joinTable);\n          } else {\n            const joinTable = {\n              target: options.target || options.name,\n              propertyName: relationName,\n              name: relationSchema.joinTable.name,\n              database: relationSchema.joinTable.database,\n              schema: relationSchema.joinTable.schema,\n              joinColumns: relationSchema.joinTable.joinColumn ? [relationSchema.joinTable.joinColumn] : relationSchema.joinTable.joinColumns,\n              inverseJoinColumns: relationSchema.joinTable.inverseJoinColumn ? [relationSchema.joinTable.inverseJoinColumn] : relationSchema.joinTable.inverseJoinColumns\n            };\n            metadataArgsStorage.joinTables.push(joinTable);\n          }\n        }\n      });\n    }\n    // add relation id metadata args from the schema\n    if (options.relationIds) {\n      Object.keys(options.relationIds).forEach(relationIdName => {\n        const relationIdOptions = options.relationIds[relationIdName];\n        const relationId = {\n          propertyName: relationIdName,\n          relation: relationIdOptions.relationName,\n          target: options.target || options.name,\n          alias: relationIdOptions.alias,\n          queryBuilderFactory: relationIdOptions.queryBuilderFactory\n        };\n        metadataArgsStorage.relationIds.push(relationId);\n      });\n    }\n    // add index metadata args from the schema\n    if (options.indices) {\n      options.indices.forEach(index => {\n        const indexArgs = {\n          target: options.target || options.name,\n          name: index.name,\n          unique: index.unique === true ? true : false,\n          spatial: index.spatial === true ? true : false,\n          fulltext: index.fulltext === true ? true : false,\n          nullFiltered: index.nullFiltered === true ? true : false,\n          parser: index.parser,\n          synchronize: index.synchronize === false ? false : true,\n          where: index.where,\n          sparse: index.sparse,\n          columns: index.columns\n        };\n        metadataArgsStorage.indices.push(indexArgs);\n      });\n    }\n    // add unique metadata args from the schema\n    if (options.uniques) {\n      options.uniques.forEach(unique => {\n        const uniqueArgs = {\n          target: options.target || options.name,\n          name: unique.name,\n          columns: unique.columns,\n          deferrable: unique.deferrable\n        };\n        metadataArgsStorage.uniques.push(uniqueArgs);\n      });\n    }\n    // add check metadata args from the schema\n    if (options.checks) {\n      options.checks.forEach(check => {\n        const checkArgs = {\n          target: options.target || options.name,\n          name: check.name,\n          expression: check.expression\n        };\n        metadataArgsStorage.checks.push(checkArgs);\n      });\n    }\n    // add exclusion metadata args from the schema\n    if (options.exclusions) {\n      options.exclusions.forEach(exclusion => {\n        const exclusionArgs = {\n          target: options.target || options.name,\n          name: exclusion.name,\n          expression: exclusion.expression\n        };\n        metadataArgsStorage.exclusions.push(exclusionArgs);\n      });\n    }\n    if (options.embeddeds) {\n      Object.keys(options.embeddeds).forEach(columnName => {\n        const embeddedOptions = options.embeddeds[columnName];\n        if (!embeddedOptions.schema) throw EntitySchemaEmbeddedError.createEntitySchemaIsRequiredException(columnName);\n        const embeddedSchema = embeddedOptions.schema.options;\n        metadataArgsStorage.embeddeds.push({\n          target: options.target || options.name,\n          propertyName: columnName,\n          isArray: embeddedOptions.array === true,\n          prefix: embeddedOptions.prefix !== undefined ? embeddedOptions.prefix : undefined,\n          type: () => embeddedSchema?.target || embeddedSchema.name\n        });\n        this.transformColumnsRecursive(embeddedSchema, metadataArgsStorage);\n      });\n    }\n  }\n}","map":{"version":3,"names":["MetadataArgsStorage","EntitySchemaEmbeddedError","EntitySchemaTransformer","transform","schemas","metadataArgsStorage","forEach","entitySchema","options","tableMetadata","target","name","tableName","database","schema","type","orderBy","synchronize","withoutRowid","expression","tables","push","inheritance","inheritances","pattern","column","undefined","discriminatorValue","discriminatorValues","value","transformColumnsRecursive","Object","keys","columns","columnName","regularColumn","mode","createDate","updateDate","deleteDate","version","treeChildrenCount","treeLevel","objectId","columnArgs","propertyName","primaryKeyConstraintName","length","width","nullable","readonly","update","select","insert","primary","unique","comment","default","onUpdate","precision","scale","zerofill","unsigned","charset","collation","enum","enumName","asExpression","generatedType","hstoreType","array","transformer","spatialFeatureType","srid","generated","generationArgs","strategy","generations","uniques","relations","relationName","relationSchema","relation","relationType","isLazy","lazy","inverseSideProperty","inverseSide","isTreeParent","treeParent","isTreeChildren","treeChildren","eager","cascade","onDelete","deferrable","createForeignKeyConstraints","persistence","orphanedRowAction","joinColumn","joinColumns","joinColumnsOptions","Array","isArray","joinColumnOption","referencedColumnName","foreignKeyConstraintName","joinTable","joinTables","inverseJoinColumns","inverseJoinColumn","relationIds","relationIdName","relationIdOptions","relationId","alias","queryBuilderFactory","indices","index","indexArgs","spatial","fulltext","nullFiltered","parser","where","sparse","uniqueArgs","checks","check","checkArgs","exclusions","exclusion","exclusionArgs","embeddeds","embeddedOptions","createEntitySchemaIsRequiredException","embeddedSchema","prefix"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\entity-schema\\EntitySchemaTransformer.ts"],"sourcesContent":["import { EntitySchema } from \"./EntitySchema\"\nimport { MetadataArgsStorage } from \"../metadata-args/MetadataArgsStorage\"\nimport { TableMetadataArgs } from \"../metadata-args/TableMetadataArgs\"\nimport { ColumnMetadataArgs } from \"../metadata-args/ColumnMetadataArgs\"\nimport { IndexMetadataArgs } from \"../metadata-args/IndexMetadataArgs\"\nimport { RelationMetadataArgs } from \"../metadata-args/RelationMetadataArgs\"\nimport { JoinColumnMetadataArgs } from \"../metadata-args/JoinColumnMetadataArgs\"\nimport { JoinTableMetadataArgs } from \"../metadata-args/JoinTableMetadataArgs\"\nimport { JoinTableOptions } from \"../decorator/options/JoinTableOptions\"\nimport { JoinTableMultipleColumnsOptions } from \"../decorator/options/JoinTableMultipleColumnsOptions\"\nimport { ColumnMode } from \"../metadata-args/types/ColumnMode\"\nimport { GeneratedMetadataArgs } from \"../metadata-args/GeneratedMetadataArgs\"\nimport { UniqueMetadataArgs } from \"../metadata-args/UniqueMetadataArgs\"\nimport { CheckMetadataArgs } from \"../metadata-args/CheckMetadataArgs\"\nimport { ExclusionMetadataArgs } from \"../metadata-args/ExclusionMetadataArgs\"\nimport { EntitySchemaColumnOptions } from \"./EntitySchemaColumnOptions\"\nimport { EntitySchemaOptions } from \"./EntitySchemaOptions\"\nimport { EntitySchemaEmbeddedError } from \"./EntitySchemaEmbeddedError\"\nimport { InheritanceMetadataArgs } from \"../metadata-args/InheritanceMetadataArgs\"\nimport { RelationIdMetadataArgs } from \"../metadata-args/RelationIdMetadataArgs\"\n\n/**\n * Transforms entity schema into metadata args storage.\n * The result will be just like entities read from decorators.\n */\nexport class EntitySchemaTransformer {\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Transforms entity schema into new metadata args storage object.\n     */\n    transform(schemas: EntitySchema<any>[]): MetadataArgsStorage {\n        const metadataArgsStorage = new MetadataArgsStorage()\n\n        schemas.forEach((entitySchema) => {\n            const options = entitySchema.options\n\n            // add table metadata args from the schema\n            const tableMetadata: TableMetadataArgs = {\n                target: options.target || options.name,\n                name: options.tableName,\n                database: options.database,\n                schema: options.schema,\n                type: options.type || \"regular\",\n                orderBy: options.orderBy,\n                synchronize: options.synchronize,\n                withoutRowid: !!options.withoutRowid,\n                expression: options.expression,\n            }\n            metadataArgsStorage.tables.push(tableMetadata)\n\n            const { inheritance } = options\n\n            if (inheritance) {\n                metadataArgsStorage.inheritances.push({\n                    target: options.target,\n                    pattern: inheritance.pattern ?? \"STI\",\n                    column: inheritance.column\n                        ? typeof inheritance.column === \"string\"\n                            ? { name: inheritance.column }\n                            : inheritance.column\n                        : undefined,\n                } as InheritanceMetadataArgs)\n            }\n\n            const { discriminatorValue } = options\n\n            if (discriminatorValue) {\n                metadataArgsStorage.discriminatorValues.push({\n                    target: options.target || options.name,\n                    value: discriminatorValue,\n                })\n            }\n\n            this.transformColumnsRecursive(options, metadataArgsStorage)\n        })\n\n        return metadataArgsStorage\n    }\n\n    private transformColumnsRecursive(\n        options: EntitySchemaOptions<any>,\n        metadataArgsStorage: MetadataArgsStorage,\n    ): void {\n        // add columns metadata args from the schema\n        Object.keys(options.columns).forEach((columnName) => {\n            const column = options.columns[columnName]!\n\n            const regularColumn = column as EntitySchemaColumnOptions\n            let mode: ColumnMode = \"regular\"\n            if (regularColumn.createDate) mode = \"createDate\"\n            if (regularColumn.updateDate) mode = \"updateDate\"\n            if (regularColumn.deleteDate) mode = \"deleteDate\"\n            if (regularColumn.version) mode = \"version\"\n            if (regularColumn.treeChildrenCount) mode = \"treeChildrenCount\"\n            if (regularColumn.treeLevel) mode = \"treeLevel\"\n            if (regularColumn.objectId) mode = \"objectId\"\n\n            const columnArgs: ColumnMetadataArgs = {\n                target: options.target || options.name,\n                mode: mode,\n                propertyName: columnName,\n                options: {\n                    type: regularColumn.type,\n                    name: regularColumn.objectId ? \"_id\" : regularColumn.name,\n                    primaryKeyConstraintName:\n                        regularColumn.primaryKeyConstraintName,\n                    length: regularColumn.length,\n                    width: regularColumn.width,\n                    nullable: regularColumn.nullable,\n                    readonly: regularColumn.readonly,\n                    update: regularColumn.update,\n                    select: regularColumn.select,\n                    insert: regularColumn.insert,\n                    primary: regularColumn.primary,\n                    unique: regularColumn.unique,\n                    comment: regularColumn.comment,\n                    default: regularColumn.default,\n                    onUpdate: regularColumn.onUpdate,\n                    precision: regularColumn.precision,\n                    scale: regularColumn.scale,\n                    zerofill: regularColumn.zerofill,\n                    unsigned: regularColumn.unsigned,\n                    charset: regularColumn.charset,\n                    collation: regularColumn.collation,\n                    enum: regularColumn.enum,\n                    enumName: regularColumn.enumName,\n                    asExpression: regularColumn.asExpression,\n                    generatedType: regularColumn.generatedType,\n                    hstoreType: regularColumn.hstoreType,\n                    array: regularColumn.array,\n                    transformer: regularColumn.transformer,\n                    spatialFeatureType: regularColumn.spatialFeatureType,\n                    srid: regularColumn.srid,\n                },\n            }\n            metadataArgsStorage.columns.push(columnArgs)\n\n            if (regularColumn.generated) {\n                const generationArgs: GeneratedMetadataArgs = {\n                    target: options.target || options.name,\n                    propertyName: columnName,\n                    strategy:\n                        typeof regularColumn.generated === \"string\"\n                            ? regularColumn.generated\n                            : \"increment\",\n                }\n                metadataArgsStorage.generations.push(generationArgs)\n            }\n\n            if (regularColumn.unique)\n                metadataArgsStorage.uniques.push({\n                    target: options.target || options.name,\n                    columns: [columnName],\n                })\n        })\n\n        // add relation metadata args from the schema\n        if (options.relations) {\n            Object.keys(options.relations).forEach((relationName) => {\n                const relationSchema = options.relations![relationName]!\n                const relation: RelationMetadataArgs = {\n                    target: options.target || options.name,\n                    propertyName: relationName,\n                    relationType: relationSchema.type,\n                    isLazy: relationSchema.lazy || false,\n                    type: relationSchema.target,\n                    inverseSideProperty: relationSchema.inverseSide,\n                    isTreeParent: relationSchema.treeParent,\n                    isTreeChildren: relationSchema.treeChildren,\n                    options: {\n                        eager: relationSchema.eager || false,\n                        cascade: relationSchema.cascade,\n                        nullable: relationSchema.nullable,\n                        onDelete: relationSchema.onDelete,\n                        onUpdate: relationSchema.onUpdate,\n                        deferrable: relationSchema.deferrable,\n                        // primary: relationSchema.primary,\n                        createForeignKeyConstraints:\n                            relationSchema.createForeignKeyConstraints,\n                        persistence: relationSchema.persistence,\n                        orphanedRowAction: relationSchema.orphanedRowAction,\n                    },\n                }\n\n                metadataArgsStorage.relations.push(relation)\n\n                // add join column\n                if (relationSchema.joinColumn) {\n                    if (typeof relationSchema.joinColumn === \"boolean\") {\n                        const joinColumn: JoinColumnMetadataArgs = {\n                            target: options.target || options.name,\n                            propertyName: relationName,\n                        }\n                        metadataArgsStorage.joinColumns.push(joinColumn)\n                    } else {\n                        const joinColumnsOptions = Array.isArray(\n                            relationSchema.joinColumn,\n                        )\n                            ? relationSchema.joinColumn\n                            : [relationSchema.joinColumn]\n\n                        for (const joinColumnOption of joinColumnsOptions) {\n                            const joinColumn: JoinColumnMetadataArgs = {\n                                target: options.target || options.name,\n                                propertyName: relationName,\n                                name: joinColumnOption.name,\n                                referencedColumnName:\n                                    joinColumnOption.referencedColumnName,\n                                foreignKeyConstraintName:\n                                    joinColumnOption.foreignKeyConstraintName,\n                            }\n                            metadataArgsStorage.joinColumns.push(joinColumn)\n                        }\n                    }\n                }\n\n                // add join table\n                if (relationSchema.joinTable) {\n                    if (typeof relationSchema.joinTable === \"boolean\") {\n                        const joinTable: JoinTableMetadataArgs = {\n                            target: options.target || options.name,\n                            propertyName: relationName,\n                        }\n                        metadataArgsStorage.joinTables.push(joinTable)\n                    } else {\n                        const joinTable: JoinTableMetadataArgs = {\n                            target: options.target || options.name,\n                            propertyName: relationName,\n                            name: relationSchema.joinTable.name,\n                            database: relationSchema.joinTable.database,\n                            schema: relationSchema.joinTable.schema,\n                            joinColumns: ((\n                                relationSchema.joinTable as JoinTableOptions\n                            ).joinColumn\n                                ? [\n                                      (\n                                          relationSchema.joinTable as JoinTableOptions\n                                      ).joinColumn!,\n                                  ]\n                                : (\n                                      relationSchema.joinTable as JoinTableMultipleColumnsOptions\n                                  ).joinColumns) as any,\n                            inverseJoinColumns: ((\n                                relationSchema.joinTable as JoinTableOptions\n                            ).inverseJoinColumn\n                                ? [\n                                      (\n                                          relationSchema.joinTable as JoinTableOptions\n                                      ).inverseJoinColumn!,\n                                  ]\n                                : (\n                                      relationSchema.joinTable as JoinTableMultipleColumnsOptions\n                                  ).inverseJoinColumns) as any,\n                        }\n                        metadataArgsStorage.joinTables.push(joinTable)\n                    }\n                }\n            })\n        }\n\n        // add relation id metadata args from the schema\n        if (options.relationIds) {\n            Object.keys(options.relationIds).forEach((relationIdName) => {\n                const relationIdOptions = options.relationIds![relationIdName]!\n                const relationId: RelationIdMetadataArgs = {\n                    propertyName: relationIdName,\n                    relation: relationIdOptions.relationName,\n                    target: options.target || options.name,\n                    alias: relationIdOptions.alias,\n                    queryBuilderFactory: relationIdOptions.queryBuilderFactory,\n                }\n                metadataArgsStorage.relationIds.push(relationId)\n            })\n        }\n\n        // add index metadata args from the schema\n        if (options.indices) {\n            options.indices.forEach((index) => {\n                const indexArgs: IndexMetadataArgs = {\n                    target: options.target || options.name,\n                    name: index.name,\n                    unique: index.unique === true ? true : false,\n                    spatial: index.spatial === true ? true : false,\n                    fulltext: index.fulltext === true ? true : false,\n                    nullFiltered: index.nullFiltered === true ? true : false,\n                    parser: index.parser,\n                    synchronize: index.synchronize === false ? false : true,\n                    where: index.where,\n                    sparse: index.sparse,\n                    columns: index.columns,\n                }\n                metadataArgsStorage.indices.push(indexArgs)\n            })\n        }\n\n        // add unique metadata args from the schema\n        if (options.uniques) {\n            options.uniques.forEach((unique) => {\n                const uniqueArgs: UniqueMetadataArgs = {\n                    target: options.target || options.name,\n                    name: unique.name,\n                    columns: unique.columns,\n                    deferrable: unique.deferrable,\n                }\n                metadataArgsStorage.uniques.push(uniqueArgs)\n            })\n        }\n\n        // add check metadata args from the schema\n        if (options.checks) {\n            options.checks.forEach((check) => {\n                const checkArgs: CheckMetadataArgs = {\n                    target: options.target || options.name,\n                    name: check.name,\n                    expression: check.expression,\n                }\n                metadataArgsStorage.checks.push(checkArgs)\n            })\n        }\n\n        // add exclusion metadata args from the schema\n        if (options.exclusions) {\n            options.exclusions.forEach((exclusion) => {\n                const exclusionArgs: ExclusionMetadataArgs = {\n                    target: options.target || options.name,\n                    name: exclusion.name,\n                    expression: exclusion.expression,\n                }\n                metadataArgsStorage.exclusions.push(exclusionArgs)\n            })\n        }\n\n        if (options.embeddeds) {\n            Object.keys(options.embeddeds).forEach((columnName) => {\n                const embeddedOptions = options.embeddeds![columnName]\n\n                if (!embeddedOptions.schema)\n                    throw EntitySchemaEmbeddedError.createEntitySchemaIsRequiredException(\n                        columnName,\n                    )\n\n                const embeddedSchema = embeddedOptions.schema.options\n\n                metadataArgsStorage.embeddeds.push({\n                    target: options.target || options.name,\n                    propertyName: columnName,\n                    isArray: embeddedOptions.array === true,\n                    prefix:\n                        embeddedOptions.prefix !== undefined\n                            ? embeddedOptions.prefix\n                            : undefined,\n                    type: () => embeddedSchema?.target || embeddedSchema.name,\n                })\n\n                this.transformColumnsRecursive(\n                    embeddedSchema,\n                    metadataArgsStorage,\n                )\n            })\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}