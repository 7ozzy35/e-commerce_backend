{"ast":null,"code":"import { getMetadataArgsStorage } from \"../../globals\";\n/**\n * Marks a entity property as a parent of the tree.\n * \"Tree parent\" indicates who owns (is a parent) of this entity in tree structure.\n */\nexport function TreeParent(options) {\n  return function (object, propertyName) {\n    if (!options) options = {};\n    // now try to determine it its lazy relation\n    const reflectedType = Reflect && Reflect.getMetadata ? Reflect.getMetadata(\"design:type\", object, propertyName) : undefined;\n    const isLazy = reflectedType && typeof reflectedType.name === \"string\" && reflectedType.name.toLowerCase() === \"promise\" || false;\n    getMetadataArgsStorage().relations.push({\n      isTreeParent: true,\n      target: object.constructor,\n      propertyName: propertyName,\n      isLazy: isLazy,\n      relationType: \"many-to-one\",\n      type: () => object.constructor,\n      options: options\n    });\n  };\n}","map":{"version":3,"names":["getMetadataArgsStorage","TreeParent","options","object","propertyName","reflectedType","Reflect","getMetadata","undefined","isLazy","name","toLowerCase","relations","push","isTreeParent","target","constructor","relationType","type"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\decorator\\tree\\TreeParent.ts"],"sourcesContent":["import { getMetadataArgsStorage } from \"../../globals\"\nimport { RelationMetadataArgs } from \"../../metadata-args/RelationMetadataArgs\"\nimport { OnDeleteType } from \"../../metadata/types/OnDeleteType\"\nimport { RelationOptions } from \"../options/RelationOptions\"\n\n/**\n * Marks a entity property as a parent of the tree.\n * \"Tree parent\" indicates who owns (is a parent) of this entity in tree structure.\n */\nexport function TreeParent(options?: {\n    onDelete?: OnDeleteType\n}): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        if (!options) options = {} as RelationOptions\n\n        // now try to determine it its lazy relation\n        const reflectedType =\n            Reflect && (Reflect as any).getMetadata\n                ? Reflect.getMetadata(\"design:type\", object, propertyName)\n                : undefined\n        const isLazy =\n            (reflectedType &&\n                typeof reflectedType.name === \"string\" &&\n                reflectedType.name.toLowerCase() === \"promise\") ||\n            false\n\n        getMetadataArgsStorage().relations.push({\n            isTreeParent: true,\n            target: object.constructor,\n            propertyName: propertyName,\n            isLazy: isLazy,\n            relationType: \"many-to-one\",\n            type: () => object.constructor,\n            options: options,\n        } as RelationMetadataArgs)\n    }\n}\n"],"mappings":"AAAA,SAASA,sBAAsB,QAAQ,eAAe;AAKtD;;;;AAIA,OAAM,SAAUC,UAAUA,CAACC,OAE1B;EACG,OAAO,UAAUC,MAAc,EAAEC,YAAoB;IACjD,IAAI,CAACF,OAAO,EAAEA,OAAO,GAAG,EAAqB;IAE7C;IACA,MAAMG,aAAa,GACfC,OAAO,IAAKA,OAAe,CAACC,WAAW,GACjCD,OAAO,CAACC,WAAW,CAAC,aAAa,EAAEJ,MAAM,EAAEC,YAAY,CAAC,GACxDI,SAAS;IACnB,MAAMC,MAAM,GACPJ,aAAa,IACV,OAAOA,aAAa,CAACK,IAAI,KAAK,QAAQ,IACtCL,aAAa,CAACK,IAAI,CAACC,WAAW,EAAE,KAAK,SAAS,IAClD,KAAK;IAETX,sBAAsB,EAAE,CAACY,SAAS,CAACC,IAAI,CAAC;MACpCC,YAAY,EAAE,IAAI;MAClBC,MAAM,EAAEZ,MAAM,CAACa,WAAW;MAC1BZ,YAAY,EAAEA,YAAY;MAC1BK,MAAM,EAAEA,MAAM;MACdQ,YAAY,EAAE,aAAa;MAC3BC,IAAI,EAAEA,CAAA,KAAMf,MAAM,CAACa,WAAW;MAC9Bd,OAAO,EAAEA;KACY,CAAC;EAC9B,CAAC;AACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}