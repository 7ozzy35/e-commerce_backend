{"ast":null,"code":"export class RelationCountLoader {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection, queryRunner, relationCountAttributes) {\n    this.connection = connection;\n    this.queryRunner = queryRunner;\n    this.relationCountAttributes = relationCountAttributes;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  async load(rawEntities) {\n    const onlyUnique = (value, index, self) => {\n      return self.indexOf(value) === index;\n    };\n    const promises = this.relationCountAttributes.map(async relationCountAttr => {\n      if (relationCountAttr.relation.isOneToMany) {\n        // example: Post and Category\n        // loadRelationCountAndMap(\"post.categoryCount\", \"post.categories\")\n        // we expect it to load array of post ids\n        // todo(dima): fix issues wit multiple primary keys and remove joinColumns[0]\n        const relation = relationCountAttr.relation; // \"category.posts\"\n        const inverseRelation = relation.inverseRelation; // \"post.category\"\n        const referenceColumnName = inverseRelation.joinColumns[0].referencedColumn.propertyName; // post id\n        const inverseSideTable = relation.inverseEntityMetadata.target; // Post\n        const inverseSideTableName = relation.inverseEntityMetadata.tableName; // post\n        const inverseSideTableAlias = relationCountAttr.alias || inverseSideTableName; // if condition (custom query builder factory) is set then relationIdAttr.alias defined\n        const inverseSidePropertyName = inverseRelation.propertyName; // \"category\" from \"post.category\"\n        let referenceColumnValues = rawEntities.map(rawEntity => rawEntity[relationCountAttr.parentAlias + \"_\" + referenceColumnName]).filter(value => !!value);\n        referenceColumnValues = referenceColumnValues.filter(onlyUnique);\n        // ensure we won't perform redundant queries for joined data which was not found in selection\n        // example: if post.category was not found in db then no need to execute query for category.imageIds\n        if (referenceColumnValues.length === 0) return {\n          relationCountAttribute: relationCountAttr,\n          results: []\n        };\n        // generate query:\n        // SELECT category.post as parentId, COUNT(*) AS cnt FROM category category WHERE category.post IN (1, 2) GROUP BY category.post\n        const qb = this.connection.createQueryBuilder(this.queryRunner);\n        qb.select(inverseSideTableAlias + \".\" + inverseSidePropertyName, \"parentId\").addSelect(\"COUNT(*)\", \"cnt\").from(inverseSideTable, inverseSideTableAlias).where(inverseSideTableAlias + \".\" + inverseSidePropertyName + \" IN (:...ids)\").addGroupBy(inverseSideTableAlias + \".\" + inverseSidePropertyName).setParameter(\"ids\", referenceColumnValues);\n        // apply condition (custom query builder factory)\n        if (relationCountAttr.queryBuilderFactory) relationCountAttr.queryBuilderFactory(qb);\n        return {\n          relationCountAttribute: relationCountAttr,\n          results: await qb.getRawMany()\n        };\n      } else {\n        // example: Post and Category\n        // owner side: loadRelationIdAndMap(\"post.categoryIds\", \"post.categories\")\n        // inverse side: loadRelationIdAndMap(\"category.postIds\", \"category.posts\")\n        // we expect it to load array of post ids\n        let joinTableColumnName;\n        let inverseJoinColumnName;\n        let firstJunctionColumn;\n        let secondJunctionColumn;\n        if (relationCountAttr.relation.isOwning) {\n          // todo fix joinColumns[0] and inverseJoinColumns[0].\n          joinTableColumnName = relationCountAttr.relation.joinColumns[0].referencedColumn.databaseName;\n          inverseJoinColumnName = relationCountAttr.relation.inverseJoinColumns[0].referencedColumn.databaseName;\n          firstJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[0];\n          secondJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[1];\n        } else {\n          joinTableColumnName = relationCountAttr.relation.inverseRelation.inverseJoinColumns[0].referencedColumn.databaseName;\n          inverseJoinColumnName = relationCountAttr.relation.inverseRelation.joinColumns[0].referencedColumn.databaseName;\n          firstJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[1];\n          secondJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[0];\n        }\n        let referenceColumnValues = rawEntities.map(rawEntity => rawEntity[relationCountAttr.parentAlias + \"_\" + joinTableColumnName]).filter(value => !!value);\n        referenceColumnValues = referenceColumnValues.filter(onlyUnique);\n        // ensure we won't perform redundant queries for joined data which was not found in selection\n        // example: if post.category was not found in db then no need to execute query for category.imageIds\n        if (referenceColumnValues.length === 0) return {\n          relationCountAttribute: relationCountAttr,\n          results: []\n        };\n        const junctionAlias = relationCountAttr.junctionAlias;\n        const inverseSideTableName = relationCountAttr.joinInverseSideMetadata.tableName;\n        const inverseSideTableAlias = relationCountAttr.alias || inverseSideTableName;\n        const junctionTableName = relationCountAttr.relation.junctionEntityMetadata.tableName;\n        const condition = junctionAlias + \".\" + firstJunctionColumn.propertyName + \" IN (\" + referenceColumnValues.map(vals => isNaN(vals) ? \"'\" + vals + \"'\" : vals) + \")\" + \" AND \" + junctionAlias + \".\" + secondJunctionColumn.propertyName + \" = \" + inverseSideTableAlias + \".\" + inverseJoinColumnName;\n        const qb = this.connection.createQueryBuilder(this.queryRunner);\n        qb.select(junctionAlias + \".\" + firstJunctionColumn.propertyName, \"parentId\").addSelect(\"COUNT(\" + qb.escape(inverseSideTableAlias) + \".\" + qb.escape(inverseJoinColumnName) + \")\", \"cnt\").from(inverseSideTableName, inverseSideTableAlias).innerJoin(junctionTableName, junctionAlias, condition).addGroupBy(junctionAlias + \".\" + firstJunctionColumn.propertyName);\n        // apply condition (custom query builder factory)\n        if (relationCountAttr.queryBuilderFactory) relationCountAttr.queryBuilderFactory(qb);\n        return {\n          relationCountAttribute: relationCountAttr,\n          results: await qb.getRawMany()\n        };\n      }\n    });\n    return Promise.all(promises);\n  }\n}","map":{"version":3,"names":["RelationCountLoader","constructor","connection","queryRunner","relationCountAttributes","load","rawEntities","onlyUnique","value","index","self","indexOf","promises","map","relationCountAttr","relation","isOneToMany","inverseRelation","referenceColumnName","joinColumns","referencedColumn","propertyName","inverseSideTable","inverseEntityMetadata","target","inverseSideTableName","tableName","inverseSideTableAlias","alias","inverseSidePropertyName","referenceColumnValues","rawEntity","parentAlias","filter","length","relationCountAttribute","results","qb","createQueryBuilder","select","addSelect","from","where","addGroupBy","setParameter","queryBuilderFactory","getRawMany","joinTableColumnName","inverseJoinColumnName","firstJunctionColumn","secondJunctionColumn","isOwning","databaseName","inverseJoinColumns","junctionEntityMetadata","columns","junctionAlias","joinInverseSideMetadata","junctionTableName","condition","vals","isNaN","escape","innerJoin","Promise","all"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\query-builder\\relation-count\\RelationCountLoader.ts"],"sourcesContent":["import { ColumnMetadata } from \"../../metadata/ColumnMetadata\"\nimport { DataSource } from \"../../data-source/DataSource\"\nimport { RelationCountAttribute } from \"./RelationCountAttribute\"\nimport { RelationCountLoadResult } from \"./RelationCountLoadResult\"\nimport { QueryRunner } from \"../../query-runner/QueryRunner\"\n\nexport class RelationCountLoader {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        protected connection: DataSource,\n        protected queryRunner: QueryRunner | undefined,\n        protected relationCountAttributes: RelationCountAttribute[],\n    ) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    async load(rawEntities: any[]): Promise<RelationCountLoadResult[]> {\n        const onlyUnique = (value: any, index: number, self: any) => {\n            return self.indexOf(value) === index\n        }\n\n        const promises = this.relationCountAttributes.map(\n            async (relationCountAttr) => {\n                if (relationCountAttr.relation.isOneToMany) {\n                    // example: Post and Category\n                    // loadRelationCountAndMap(\"post.categoryCount\", \"post.categories\")\n                    // we expect it to load array of post ids\n\n                    // todo(dima): fix issues wit multiple primary keys and remove joinColumns[0]\n                    const relation = relationCountAttr.relation // \"category.posts\"\n                    const inverseRelation = relation.inverseRelation! // \"post.category\"\n                    const referenceColumnName =\n                        inverseRelation.joinColumns[0].referencedColumn!\n                            .propertyName // post id\n                    const inverseSideTable =\n                        relation.inverseEntityMetadata.target // Post\n                    const inverseSideTableName =\n                        relation.inverseEntityMetadata.tableName // post\n                    const inverseSideTableAlias =\n                        relationCountAttr.alias || inverseSideTableName // if condition (custom query builder factory) is set then relationIdAttr.alias defined\n                    const inverseSidePropertyName = inverseRelation.propertyName // \"category\" from \"post.category\"\n\n                    let referenceColumnValues = rawEntities\n                        .map(\n                            (rawEntity) =>\n                                rawEntity[\n                                    relationCountAttr.parentAlias +\n                                        \"_\" +\n                                        referenceColumnName\n                                ],\n                        )\n                        .filter((value) => !!value)\n                    referenceColumnValues =\n                        referenceColumnValues.filter(onlyUnique)\n\n                    // ensure we won't perform redundant queries for joined data which was not found in selection\n                    // example: if post.category was not found in db then no need to execute query for category.imageIds\n                    if (referenceColumnValues.length === 0)\n                        return {\n                            relationCountAttribute: relationCountAttr,\n                            results: [],\n                        }\n\n                    // generate query:\n                    // SELECT category.post as parentId, COUNT(*) AS cnt FROM category category WHERE category.post IN (1, 2) GROUP BY category.post\n                    const qb = this.connection.createQueryBuilder(\n                        this.queryRunner,\n                    )\n                    qb.select(\n                        inverseSideTableAlias + \".\" + inverseSidePropertyName,\n                        \"parentId\",\n                    )\n                        .addSelect(\"COUNT(*)\", \"cnt\")\n                        .from(inverseSideTable, inverseSideTableAlias)\n                        .where(\n                            inverseSideTableAlias +\n                                \".\" +\n                                inverseSidePropertyName +\n                                \" IN (:...ids)\",\n                        )\n                        .addGroupBy(\n                            inverseSideTableAlias +\n                                \".\" +\n                                inverseSidePropertyName,\n                        )\n                        .setParameter(\"ids\", referenceColumnValues)\n\n                    // apply condition (custom query builder factory)\n                    if (relationCountAttr.queryBuilderFactory)\n                        relationCountAttr.queryBuilderFactory(qb)\n\n                    return {\n                        relationCountAttribute: relationCountAttr,\n                        results: await qb.getRawMany(),\n                    }\n                } else {\n                    // example: Post and Category\n                    // owner side: loadRelationIdAndMap(\"post.categoryIds\", \"post.categories\")\n                    // inverse side: loadRelationIdAndMap(\"category.postIds\", \"category.posts\")\n                    // we expect it to load array of post ids\n\n                    let joinTableColumnName: string\n                    let inverseJoinColumnName: string\n                    let firstJunctionColumn: ColumnMetadata\n                    let secondJunctionColumn: ColumnMetadata\n\n                    if (relationCountAttr.relation.isOwning) {\n                        // todo fix joinColumns[0] and inverseJoinColumns[0].\n                        joinTableColumnName =\n                            relationCountAttr.relation.joinColumns[0]\n                                .referencedColumn!.databaseName\n                        inverseJoinColumnName =\n                            relationCountAttr.relation.inverseJoinColumns[0]\n                                .referencedColumn!.databaseName\n                        firstJunctionColumn =\n                            relationCountAttr.relation.junctionEntityMetadata!\n                                .columns[0]\n                        secondJunctionColumn =\n                            relationCountAttr.relation.junctionEntityMetadata!\n                                .columns[1]\n                    } else {\n                        joinTableColumnName =\n                            relationCountAttr.relation.inverseRelation!\n                                .inverseJoinColumns[0].referencedColumn!\n                                .databaseName\n                        inverseJoinColumnName =\n                            relationCountAttr.relation.inverseRelation!\n                                .joinColumns[0].referencedColumn!.databaseName\n                        firstJunctionColumn =\n                            relationCountAttr.relation.junctionEntityMetadata!\n                                .columns[1]\n                        secondJunctionColumn =\n                            relationCountAttr.relation.junctionEntityMetadata!\n                                .columns[0]\n                    }\n\n                    let referenceColumnValues = rawEntities\n                        .map(\n                            (rawEntity) =>\n                                rawEntity[\n                                    relationCountAttr.parentAlias +\n                                        \"_\" +\n                                        joinTableColumnName\n                                ],\n                        )\n                        .filter((value) => !!value)\n                    referenceColumnValues =\n                        referenceColumnValues.filter(onlyUnique)\n\n                    // ensure we won't perform redundant queries for joined data which was not found in selection\n                    // example: if post.category was not found in db then no need to execute query for category.imageIds\n                    if (referenceColumnValues.length === 0)\n                        return {\n                            relationCountAttribute: relationCountAttr,\n                            results: [],\n                        }\n\n                    const junctionAlias = relationCountAttr.junctionAlias\n                    const inverseSideTableName =\n                        relationCountAttr.joinInverseSideMetadata.tableName\n                    const inverseSideTableAlias =\n                        relationCountAttr.alias || inverseSideTableName\n                    const junctionTableName =\n                        relationCountAttr.relation.junctionEntityMetadata!\n                            .tableName\n\n                    const condition =\n                        junctionAlias +\n                        \".\" +\n                        firstJunctionColumn.propertyName +\n                        \" IN (\" +\n                        referenceColumnValues.map((vals) =>\n                            isNaN(vals) ? \"'\" + vals + \"'\" : vals,\n                        ) +\n                        \")\" +\n                        \" AND \" +\n                        junctionAlias +\n                        \".\" +\n                        secondJunctionColumn.propertyName +\n                        \" = \" +\n                        inverseSideTableAlias +\n                        \".\" +\n                        inverseJoinColumnName\n\n                    const qb = this.connection.createQueryBuilder(\n                        this.queryRunner,\n                    )\n                    qb.select(\n                        junctionAlias + \".\" + firstJunctionColumn.propertyName,\n                        \"parentId\",\n                    )\n                        .addSelect(\n                            \"COUNT(\" +\n                                qb.escape(inverseSideTableAlias) +\n                                \".\" +\n                                qb.escape(inverseJoinColumnName) +\n                                \")\",\n                            \"cnt\",\n                        )\n                        .from(inverseSideTableName, inverseSideTableAlias)\n                        .innerJoin(junctionTableName, junctionAlias, condition)\n                        .addGroupBy(\n                            junctionAlias +\n                                \".\" +\n                                firstJunctionColumn.propertyName,\n                        )\n\n                    // apply condition (custom query builder factory)\n                    if (relationCountAttr.queryBuilderFactory)\n                        relationCountAttr.queryBuilderFactory(qb)\n\n                    return {\n                        relationCountAttribute: relationCountAttr,\n                        results: await qb.getRawMany(),\n                    }\n                }\n            },\n        )\n\n        return Promise.all(promises)\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}