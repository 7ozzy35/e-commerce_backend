{"ast":null,"code":"import { MustBeEntityError } from \"../error/MustBeEntityError\";\nimport { SubjectExecutor } from \"./SubjectExecutor\";\nimport { CannotDetermineEntityError } from \"../error/CannotDetermineEntityError\";\nimport { Subject } from \"./Subject\";\nimport { OneToManySubjectBuilder } from \"./subject-builder/OneToManySubjectBuilder\";\nimport { OneToOneInverseSideSubjectBuilder } from \"./subject-builder/OneToOneInverseSideSubjectBuilder\";\nimport { ManyToManySubjectBuilder } from \"./subject-builder/ManyToManySubjectBuilder\";\nimport { SubjectDatabaseEntityLoader } from \"./SubjectDatabaseEntityLoader\";\nimport { CascadesSubjectBuilder } from \"./subject-builder/CascadesSubjectBuilder\";\nimport { OrmUtils } from \"../util/OrmUtils\";\n/**\n * Persists a single entity or multiple entities - saves or removes them.\n */\nexport class EntityPersistExecutor {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection, queryRunner, mode, target, entity, options) {\n    this.connection = connection;\n    this.queryRunner = queryRunner;\n    this.mode = mode;\n    this.target = target;\n    this.entity = entity;\n    this.options = options;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Executes persistence operation ob given entity or entities.\n   */\n  async execute() {\n    // check if entity we are going to save is valid and is an object\n    if (!this.entity || typeof this.entity !== \"object\") return Promise.reject(new MustBeEntityError(this.mode, this.entity));\n    // we MUST call \"fake\" resolve here to make sure all properties of lazily loaded relations are resolved\n    await Promise.resolve();\n    // if query runner is already defined in this class, it means this entity manager was already created for a single connection\n    // if its not defined we create a new query runner - single connection where we'll execute all our operations\n    const queryRunner = this.queryRunner || this.connection.createQueryRunner();\n    // save data in the query runner - this is useful functionality to share data from outside of the world\n    // with third classes - like subscribers and listener methods\n    let oldQueryRunnerData = queryRunner.data;\n    if (this.options && this.options.data) {\n      queryRunner.data = this.options.data;\n    }\n    try {\n      // collect all operate subjects\n      const entities = Array.isArray(this.entity) ? this.entity : [this.entity];\n      const entitiesInChunks = this.options && this.options.chunk && this.options.chunk > 0 ? OrmUtils.chunk(entities, this.options.chunk) : [entities];\n      // console.time(\"building subject executors...\");\n      const executors = await Promise.all(entitiesInChunks.map(async entities => {\n        const subjects = [];\n        // create subjects for all entities we received for the persistence\n        entities.forEach(entity => {\n          const entityTarget = this.target ? this.target : entity.constructor;\n          if (entityTarget === Object) throw new CannotDetermineEntityError(this.mode);\n          let metadata = this.connection.getMetadata(entityTarget).findInheritanceMetadata(entity);\n          subjects.push(new Subject({\n            metadata,\n            entity: entity,\n            canBeInserted: this.mode === \"save\",\n            canBeUpdated: this.mode === \"save\",\n            mustBeRemoved: this.mode === \"remove\",\n            canBeSoftRemoved: this.mode === \"soft-remove\",\n            canBeRecovered: this.mode === \"recover\"\n          }));\n        });\n        // console.time(\"building cascades...\");\n        // go through each entity with metadata and create subjects and subjects by cascades for them\n        const cascadesSubjectBuilder = new CascadesSubjectBuilder(subjects);\n        subjects.forEach(subject => {\n          // next step we build list of subjects we will operate with\n          // these subjects are subjects that we need to insert or update alongside with main persisted entity\n          cascadesSubjectBuilder.build(subject, this.mode);\n        });\n        // console.timeEnd(\"building cascades...\");\n        // load database entities for all subjects we have\n        // next step is to load database entities for all operate subjects\n        // console.time(\"loading...\");\n        await new SubjectDatabaseEntityLoader(queryRunner, subjects).load(this.mode);\n        // console.timeEnd(\"loading...\");\n        // console.time(\"other subjects...\");\n        // build all related subjects and change maps\n        if (this.mode === \"save\" || this.mode === \"soft-remove\" || this.mode === \"recover\") {\n          new OneToManySubjectBuilder(subjects).build();\n          new OneToOneInverseSideSubjectBuilder(subjects).build();\n          new ManyToManySubjectBuilder(subjects).build();\n        } else {\n          subjects.forEach(subject => {\n            if (subject.mustBeRemoved) {\n              new ManyToManySubjectBuilder(subjects).buildForAllRemoval(subject);\n            }\n          });\n        }\n        // console.timeEnd(\"other subjects...\");\n        // console.timeEnd(\"building subjects...\");\n        // console.log(\"subjects\", subjects);\n        // create a subject executor\n        return new SubjectExecutor(queryRunner, subjects, this.options);\n      }));\n      // console.timeEnd(\"building subject executors...\");\n      // make sure we have at least one executable operation before we create a transaction and proceed\n      // if we don't have operations it means we don't really need to update or remove something\n      const executorsWithExecutableOperations = executors.filter(executor => executor.hasExecutableOperations);\n      if (executorsWithExecutableOperations.length === 0) return;\n      // start execute queries in a transaction\n      // if transaction is already opened in this query runner then we don't touch it\n      // if its not opened yet then we open it here, and once we finish - we close it\n      let isTransactionStartedByUs = false;\n      try {\n        // open transaction if its not opened yet\n        if (!queryRunner.isTransactionActive) {\n          if (this.connection.driver.transactionSupport !== \"none\" && (!this.options || this.options.transaction !== false)) {\n            // start transaction until it was not explicitly disabled\n            isTransactionStartedByUs = true;\n            await queryRunner.startTransaction();\n          }\n        }\n        // execute all persistence operations for all entities we have\n        // console.time(\"executing subject executors...\");\n        for (const executor of executorsWithExecutableOperations) {\n          await executor.execute();\n        }\n        // console.timeEnd(\"executing subject executors...\");\n        // commit transaction if it was started by us\n        // console.time(\"commit\");\n        if (isTransactionStartedByUs === true) await queryRunner.commitTransaction();\n        // console.timeEnd(\"commit\");\n      } catch (error) {\n        // rollback transaction if it was started by us\n        if (isTransactionStartedByUs) {\n          try {\n            await queryRunner.rollbackTransaction();\n          } catch (rollbackError) {}\n        }\n        throw error;\n      }\n    } finally {\n      queryRunner.data = oldQueryRunnerData;\n      // release query runner only if its created by us\n      if (!this.queryRunner) await queryRunner.release();\n    }\n  }\n}","map":{"version":3,"names":["MustBeEntityError","SubjectExecutor","CannotDetermineEntityError","Subject","OneToManySubjectBuilder","OneToOneInverseSideSubjectBuilder","ManyToManySubjectBuilder","SubjectDatabaseEntityLoader","CascadesSubjectBuilder","OrmUtils","EntityPersistExecutor","constructor","connection","queryRunner","mode","target","entity","options","execute","Promise","reject","resolve","createQueryRunner","oldQueryRunnerData","data","entities","Array","isArray","entitiesInChunks","chunk","executors","all","map","subjects","forEach","entityTarget","Object","metadata","getMetadata","findInheritanceMetadata","push","canBeInserted","canBeUpdated","mustBeRemoved","canBeSoftRemoved","canBeRecovered","cascadesSubjectBuilder","subject","build","load","buildForAllRemoval","executorsWithExecutableOperations","filter","executor","hasExecutableOperations","length","isTransactionStartedByUs","isTransactionActive","driver","transactionSupport","transaction","startTransaction","commitTransaction","error","rollbackTransaction","rollbackError","release"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\persistence\\EntityPersistExecutor.ts"],"sourcesContent":["import { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { SaveOptions } from \"../repository/SaveOptions\"\nimport { RemoveOptions } from \"../repository/RemoveOptions\"\nimport { MustBeEntityError } from \"../error/MustBeEntityError\"\nimport { SubjectExecutor } from \"./SubjectExecutor\"\nimport { CannotDetermineEntityError } from \"../error/CannotDetermineEntityError\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { Subject } from \"./Subject\"\nimport { OneToManySubjectBuilder } from \"./subject-builder/OneToManySubjectBuilder\"\nimport { OneToOneInverseSideSubjectBuilder } from \"./subject-builder/OneToOneInverseSideSubjectBuilder\"\nimport { ManyToManySubjectBuilder } from \"./subject-builder/ManyToManySubjectBuilder\"\nimport { SubjectDatabaseEntityLoader } from \"./SubjectDatabaseEntityLoader\"\nimport { CascadesSubjectBuilder } from \"./subject-builder/CascadesSubjectBuilder\"\nimport { OrmUtils } from \"../util/OrmUtils\"\n\n/**\n * Persists a single entity or multiple entities - saves or removes them.\n */\nexport class EntityPersistExecutor {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        protected connection: DataSource,\n        protected queryRunner: QueryRunner | undefined,\n        protected mode: \"save\" | \"remove\" | \"soft-remove\" | \"recover\",\n        protected target: Function | string | undefined,\n        protected entity: ObjectLiteral | ObjectLiteral[],\n        protected options?: SaveOptions & RemoveOptions,\n    ) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes persistence operation ob given entity or entities.\n     */\n    async execute(): Promise<void> {\n        // check if entity we are going to save is valid and is an object\n        if (!this.entity || typeof this.entity !== \"object\")\n            return Promise.reject(new MustBeEntityError(this.mode, this.entity))\n\n        // we MUST call \"fake\" resolve here to make sure all properties of lazily loaded relations are resolved\n        await Promise.resolve()\n\n        // if query runner is already defined in this class, it means this entity manager was already created for a single connection\n        // if its not defined we create a new query runner - single connection where we'll execute all our operations\n        const queryRunner =\n            this.queryRunner || this.connection.createQueryRunner()\n\n        // save data in the query runner - this is useful functionality to share data from outside of the world\n        // with third classes - like subscribers and listener methods\n        let oldQueryRunnerData = queryRunner.data\n        if (this.options && this.options.data) {\n            queryRunner.data = this.options.data\n        }\n\n        try {\n            // collect all operate subjects\n            const entities: ObjectLiteral[] = Array.isArray(this.entity)\n                ? this.entity\n                : [this.entity]\n            const entitiesInChunks =\n                this.options && this.options.chunk && this.options.chunk > 0\n                    ? OrmUtils.chunk(entities, this.options.chunk)\n                    : [entities]\n\n            // console.time(\"building subject executors...\");\n            const executors = await Promise.all(\n                entitiesInChunks.map(async (entities) => {\n                    const subjects: Subject[] = []\n\n                    // create subjects for all entities we received for the persistence\n                    entities.forEach((entity) => {\n                        const entityTarget = this.target\n                            ? this.target\n                            : entity.constructor\n                        if (entityTarget === Object)\n                            throw new CannotDetermineEntityError(this.mode)\n\n                        let metadata = this.connection\n                            .getMetadata(entityTarget)\n                            .findInheritanceMetadata(entity)\n\n                        subjects.push(\n                            new Subject({\n                                metadata,\n                                entity: entity,\n                                canBeInserted: this.mode === \"save\",\n                                canBeUpdated: this.mode === \"save\",\n                                mustBeRemoved: this.mode === \"remove\",\n                                canBeSoftRemoved: this.mode === \"soft-remove\",\n                                canBeRecovered: this.mode === \"recover\",\n                            }),\n                        )\n                    })\n\n                    // console.time(\"building cascades...\");\n                    // go through each entity with metadata and create subjects and subjects by cascades for them\n                    const cascadesSubjectBuilder = new CascadesSubjectBuilder(\n                        subjects,\n                    )\n                    subjects.forEach((subject) => {\n                        // next step we build list of subjects we will operate with\n                        // these subjects are subjects that we need to insert or update alongside with main persisted entity\n                        cascadesSubjectBuilder.build(subject, this.mode)\n                    })\n                    // console.timeEnd(\"building cascades...\");\n\n                    // load database entities for all subjects we have\n                    // next step is to load database entities for all operate subjects\n                    // console.time(\"loading...\");\n                    await new SubjectDatabaseEntityLoader(\n                        queryRunner,\n                        subjects,\n                    ).load(this.mode)\n                    // console.timeEnd(\"loading...\");\n\n                    // console.time(\"other subjects...\");\n                    // build all related subjects and change maps\n                    if (\n                        this.mode === \"save\" ||\n                        this.mode === \"soft-remove\" ||\n                        this.mode === \"recover\"\n                    ) {\n                        new OneToManySubjectBuilder(subjects).build()\n                        new OneToOneInverseSideSubjectBuilder(subjects).build()\n                        new ManyToManySubjectBuilder(subjects).build()\n                    } else {\n                        subjects.forEach((subject) => {\n                            if (subject.mustBeRemoved) {\n                                new ManyToManySubjectBuilder(\n                                    subjects,\n                                ).buildForAllRemoval(subject)\n                            }\n                        })\n                    }\n                    // console.timeEnd(\"other subjects...\");\n                    // console.timeEnd(\"building subjects...\");\n                    // console.log(\"subjects\", subjects);\n\n                    // create a subject executor\n                    return new SubjectExecutor(\n                        queryRunner,\n                        subjects,\n                        this.options,\n                    )\n                }),\n            )\n            // console.timeEnd(\"building subject executors...\");\n\n            // make sure we have at least one executable operation before we create a transaction and proceed\n            // if we don't have operations it means we don't really need to update or remove something\n            const executorsWithExecutableOperations = executors.filter(\n                (executor) => executor.hasExecutableOperations,\n            )\n            if (executorsWithExecutableOperations.length === 0) return\n\n            // start execute queries in a transaction\n            // if transaction is already opened in this query runner then we don't touch it\n            // if its not opened yet then we open it here, and once we finish - we close it\n            let isTransactionStartedByUs = false\n            try {\n                // open transaction if its not opened yet\n                if (!queryRunner.isTransactionActive) {\n                    if (\n                        this.connection.driver.transactionSupport !== \"none\" &&\n                        (!this.options || this.options.transaction !== false)\n                    ) {\n                        // start transaction until it was not explicitly disabled\n                        isTransactionStartedByUs = true\n                        await queryRunner.startTransaction()\n                    }\n                }\n\n                // execute all persistence operations for all entities we have\n                // console.time(\"executing subject executors...\");\n                for (const executor of executorsWithExecutableOperations) {\n                    await executor.execute()\n                }\n                // console.timeEnd(\"executing subject executors...\");\n\n                // commit transaction if it was started by us\n                // console.time(\"commit\");\n                if (isTransactionStartedByUs === true)\n                    await queryRunner.commitTransaction()\n                // console.timeEnd(\"commit\");\n            } catch (error) {\n                // rollback transaction if it was started by us\n                if (isTransactionStartedByUs) {\n                    try {\n                        await queryRunner.rollbackTransaction()\n                    } catch (rollbackError) {}\n                }\n                throw error\n            }\n        } finally {\n            queryRunner.data = oldQueryRunnerData\n\n            // release query runner only if its created by us\n            if (!this.queryRunner) await queryRunner.release()\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}