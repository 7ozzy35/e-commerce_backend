{"ast":null,"code":"import { RawSqlResultsToEntityTransformer } from \"./transformer/RawSqlResultsToEntityTransformer\";\nimport { PessimisticLockTransactionRequiredError } from \"../error/PessimisticLockTransactionRequiredError\";\nimport { NoVersionOrUpdateDateColumnError } from \"../error/NoVersionOrUpdateDateColumnError\";\nimport { OptimisticLockVersionMismatchError } from \"../error/OptimisticLockVersionMismatchError\";\nimport { OptimisticLockCanNotBeUsedError } from \"../error/OptimisticLockCanNotBeUsedError\";\nimport { JoinAttribute } from \"./JoinAttribute\";\nimport { RelationIdAttribute } from \"./relation-id/RelationIdAttribute\";\nimport { RelationCountAttribute } from \"./relation-count/RelationCountAttribute\";\nimport { RelationIdLoader } from \"./relation-id/RelationIdLoader\";\nimport { RelationIdLoader as QueryStrategyRelationIdLoader } from \"./RelationIdLoader\";\nimport { RelationIdMetadataToAttributeTransformer } from \"./relation-id/RelationIdMetadataToAttributeTransformer\";\nimport { RelationCountLoader } from \"./relation-count/RelationCountLoader\";\nimport { RelationCountMetadataToAttributeTransformer } from \"./relation-count/RelationCountMetadataToAttributeTransformer\";\nimport { QueryBuilder } from \"./QueryBuilder\";\nimport { LockNotSupportedOnGivenDriverError } from \"../error/LockNotSupportedOnGivenDriverError\";\nimport { OffsetWithoutLimitNotSupportedError } from \"../error/OffsetWithoutLimitNotSupportedError\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\nimport { EntityNotFoundError } from \"../error/EntityNotFoundError\";\nimport { TypeORMError } from \"../error\";\nimport { FindOptionsUtils } from \"../find-options/FindOptionsUtils\";\nimport { OrmUtils } from \"../util/OrmUtils\";\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\nimport { FindOperator } from \"../find-options/FindOperator\";\nimport { ApplyValueTransformers } from \"../util/ApplyValueTransformers\";\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class SelectQueryBuilder extends QueryBuilder {\n  constructor() {\n    super(...arguments);\n    this[\"@instanceof\"] = Symbol.for(\"SelectQueryBuilder\");\n    this.findOptions = {};\n    this.selects = [];\n    this.joins = [];\n    this.conditions = \"\";\n    this.orderBys = [];\n    this.relationMetadatas = [];\n  }\n  // -------------------------------------------------------------------------\n  // Public Implemented Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Gets generated SQL query without parameters being replaced.\n   */\n  getQuery() {\n    let sql = this.createComment();\n    sql += this.createCteExpression();\n    sql += this.createSelectExpression();\n    sql += this.createJoinExpression();\n    sql += this.createWhereExpression();\n    sql += this.createGroupByExpression();\n    sql += this.createHavingExpression();\n    sql += this.createOrderByExpression();\n    sql += this.createLimitOffsetExpression();\n    sql += this.createLockExpression();\n    sql = sql.trim();\n    if (this.expressionMap.subQuery) sql = \"(\" + sql + \")\";\n    return this.replacePropertyNamesForTheWholeQuery(sql);\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  setFindOptions(findOptions) {\n    this.findOptions = findOptions;\n    this.applyFindOptions();\n    return this;\n  }\n  /**\n   * Creates a subquery - query that can be used inside other queries.\n   */\n  subQuery() {\n    const qb = this.createQueryBuilder();\n    qb.expressionMap.subQuery = true;\n    qb.parentQueryBuilder = this;\n    return qb;\n  }\n  /**\n   * Creates SELECT query and selects given data.\n   * Replaces all previous selections if they exist.\n   */\n  select(selection, selectionAliasName) {\n    this.expressionMap.queryType = \"select\";\n    if (Array.isArray(selection)) {\n      this.expressionMap.selects = selection.map(selection => ({\n        selection: selection\n      }));\n    } else if (typeof selection === \"function\") {\n      const subQueryBuilder = selection(this.subQuery());\n      this.setParameters(subQueryBuilder.getParameters());\n      this.expressionMap.selects.push({\n        selection: subQueryBuilder.getQuery(),\n        aliasName: selectionAliasName\n      });\n    } else if (selection) {\n      this.expressionMap.selects = [{\n        selection: selection,\n        aliasName: selectionAliasName\n      }];\n    }\n    return this;\n  }\n  /**\n   * Adds new selection to the SELECT query.\n   */\n  addSelect(selection, selectionAliasName) {\n    if (!selection) return this;\n    if (Array.isArray(selection)) {\n      this.expressionMap.selects = this.expressionMap.selects.concat(selection.map(selection => ({\n        selection: selection\n      })));\n    } else if (typeof selection === \"function\") {\n      const subQueryBuilder = selection(this.subQuery());\n      this.setParameters(subQueryBuilder.getParameters());\n      this.expressionMap.selects.push({\n        selection: subQueryBuilder.getQuery(),\n        aliasName: selectionAliasName\n      });\n    } else if (selection) {\n      this.expressionMap.selects.push({\n        selection: selection,\n        aliasName: selectionAliasName\n      });\n    }\n    return this;\n  }\n  /**\n   * Set max execution time.\n   * @param milliseconds\n   */\n  maxExecutionTime(milliseconds) {\n    this.expressionMap.maxExecutionTime = milliseconds;\n    return this;\n  }\n  /**\n   * Sets whether the selection is DISTINCT.\n   */\n  distinct(distinct = true) {\n    this.expressionMap.selectDistinct = distinct;\n    return this;\n  }\n  /**\n   * Sets the distinct on clause for Postgres.\n   */\n  distinctOn(distinctOn) {\n    this.expressionMap.selectDistinctOn = distinctOn;\n    return this;\n  }\n  fromDummy() {\n    return this.from(this.connection.driver.dummyTableName ?? \"(SELECT 1 AS dummy_column)\", \"dummy_table\");\n  }\n  /**\n   * Specifies FROM which entity's table select/update/delete will be executed.\n   * Also sets a main string alias of the selection data.\n   * Removes all previously set from-s.\n   */\n  from(entityTarget, aliasName) {\n    const mainAlias = this.createFromAlias(entityTarget, aliasName);\n    this.expressionMap.setMainAlias(mainAlias);\n    return this;\n  }\n  /**\n   * Specifies FROM which entity's table select/update/delete will be executed.\n   * Also sets a main string alias of the selection data.\n   */\n  addFrom(entityTarget, aliasName) {\n    const alias = this.createFromAlias(entityTarget, aliasName);\n    if (!this.expressionMap.mainAlias) this.expressionMap.setMainAlias(alias);\n    return this;\n  }\n  /**\n   * INNER JOINs (without selection).\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n  innerJoin(entityOrProperty, alias, condition, parameters) {\n    this.join(\"INNER\", entityOrProperty, alias, condition, parameters);\n    return this;\n  }\n  /**\n   * LEFT JOINs (without selection).\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n  leftJoin(entityOrProperty, alias, condition, parameters) {\n    this.join(\"LEFT\", entityOrProperty, alias, condition, parameters);\n    return this;\n  }\n  /**\n   * INNER JOINs and adds all selection properties to SELECT.\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n  innerJoinAndSelect(entityOrProperty, alias, condition, parameters) {\n    this.addSelect(alias);\n    this.innerJoin(entityOrProperty, alias, condition, parameters);\n    return this;\n  }\n  /**\n   * LEFT JOINs and adds all selection properties to SELECT.\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n  leftJoinAndSelect(entityOrProperty, alias, condition, parameters) {\n    this.addSelect(alias);\n    this.leftJoin(entityOrProperty, alias, condition, parameters);\n    return this;\n  }\n  /**\n   * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n   * This is extremely useful when you want to select some data and map it to some virtual property.\n   * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n  innerJoinAndMapMany(mapToProperty, entityOrProperty, alias, condition, parameters) {\n    this.addSelect(alias);\n    this.join(\"INNER\", entityOrProperty, alias, condition, parameters, mapToProperty, true);\n    return this;\n  }\n  /**\n   * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n   * This is extremely useful when you want to select some data and map it to some virtual property.\n   * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n  innerJoinAndMapOne(mapToProperty, entityOrProperty, alias, condition, parameters, mapAsEntity) {\n    this.addSelect(alias);\n    this.join(\"INNER\", entityOrProperty, alias, condition, parameters, mapToProperty, false, mapAsEntity);\n    return this;\n  }\n  /**\n   * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n   * This is extremely useful when you want to select some data and map it to some virtual property.\n   * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n  leftJoinAndMapMany(mapToProperty, entityOrProperty, alias, condition, parameters) {\n    this.addSelect(alias);\n    this.join(\"LEFT\", entityOrProperty, alias, condition, parameters, mapToProperty, true);\n    return this;\n  }\n  /**\n   * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n   * This is extremely useful when you want to select some data and map it to some virtual property.\n   * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n  leftJoinAndMapOne(mapToProperty, entityOrProperty, alias, condition, parameters, mapAsEntity) {\n    this.addSelect(alias);\n    this.join(\"LEFT\", entityOrProperty, alias, condition, parameters, mapToProperty, false, mapAsEntity);\n    return this;\n  }\n  /**\n   * LEFT JOINs relation id and maps it into some entity's property.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n  loadRelationIdAndMap(mapToProperty, relationName, aliasNameOrOptions, queryBuilderFactory) {\n    const relationIdAttribute = new RelationIdAttribute(this.expressionMap);\n    relationIdAttribute.mapToProperty = mapToProperty;\n    relationIdAttribute.relationName = relationName;\n    if (typeof aliasNameOrOptions === \"string\") relationIdAttribute.alias = aliasNameOrOptions;\n    if (typeof aliasNameOrOptions === \"object\" && aliasNameOrOptions.disableMixedMap) relationIdAttribute.disableMixedMap = true;\n    relationIdAttribute.queryBuilderFactory = queryBuilderFactory;\n    this.expressionMap.relationIdAttributes.push(relationIdAttribute);\n    if (relationIdAttribute.relation.junctionEntityMetadata) {\n      this.expressionMap.createAlias({\n        type: \"other\",\n        name: relationIdAttribute.junctionAlias,\n        metadata: relationIdAttribute.relation.junctionEntityMetadata\n      });\n    }\n    return this;\n  }\n  /**\n   * Counts number of entities of entity's relation and maps the value into some entity's property.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n  loadRelationCountAndMap(mapToProperty, relationName, aliasName, queryBuilderFactory) {\n    const relationCountAttribute = new RelationCountAttribute(this.expressionMap);\n    relationCountAttribute.mapToProperty = mapToProperty;\n    relationCountAttribute.relationName = relationName;\n    relationCountAttribute.alias = aliasName;\n    relationCountAttribute.queryBuilderFactory = queryBuilderFactory;\n    this.expressionMap.relationCountAttributes.push(relationCountAttribute);\n    this.expressionMap.createAlias({\n      type: \"other\",\n      name: relationCountAttribute.junctionAlias\n    });\n    if (relationCountAttribute.relation.junctionEntityMetadata) {\n      this.expressionMap.createAlias({\n        type: \"other\",\n        name: relationCountAttribute.junctionAlias,\n        metadata: relationCountAttribute.relation.junctionEntityMetadata\n      });\n    }\n    return this;\n  }\n  /**\n   * Loads all relation ids for all relations of the selected entity.\n   * All relation ids will be mapped to relation property themself.\n   * If array of strings is given then loads only relation ids of the given properties.\n   */\n  loadAllRelationIds(options) {\n    // todo: add skip relations\n    this.expressionMap.mainAlias.metadata.relations.forEach(relation => {\n      if (options !== undefined && options.relations !== undefined && options.relations.indexOf(relation.propertyPath) === -1) return;\n      this.loadRelationIdAndMap(this.expressionMap.mainAlias.name + \".\" + relation.propertyPath, this.expressionMap.mainAlias.name + \".\" + relation.propertyPath, options);\n    });\n    return this;\n  }\n  /**\n   * Sets WHERE condition in the query builder.\n   * If you had previously WHERE expression defined,\n   * calling this function will override previously set WHERE conditions.\n   * Additionally you can add parameters used in where expression.\n   */\n  where(where, parameters) {\n    this.expressionMap.wheres = []; // don't move this block below since computeWhereParameter can add where expressions\n    const condition = this.getWhereCondition(where);\n    if (condition) {\n      this.expressionMap.wheres = [{\n        type: \"simple\",\n        condition: condition\n      }];\n    }\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Adds new AND WHERE condition in the query builder.\n   * Additionally you can add parameters used in where expression.\n   */\n  andWhere(where, parameters) {\n    this.expressionMap.wheres.push({\n      type: \"and\",\n      condition: this.getWhereCondition(where)\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Adds new OR WHERE condition in the query builder.\n   * Additionally you can add parameters used in where expression.\n   */\n  orWhere(where, parameters) {\n    this.expressionMap.wheres.push({\n      type: \"or\",\n      condition: this.getWhereCondition(where)\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Sets a new where EXISTS clause\n   */\n  whereExists(subQuery) {\n    return this.where(...this.getExistsCondition(subQuery));\n  }\n  /**\n   * Adds a new AND where EXISTS clause\n   */\n  andWhereExists(subQuery) {\n    return this.andWhere(...this.getExistsCondition(subQuery));\n  }\n  /**\n   * Adds a new OR where EXISTS clause\n   */\n  orWhereExists(subQuery) {\n    return this.orWhere(...this.getExistsCondition(subQuery));\n  }\n  /**\n   * Adds new AND WHERE with conditions for the given ids.\n   *\n   * Ids are mixed.\n   * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n   * If you have multiple primary keys you need to pass object with property names and values specified,\n   * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n   */\n  whereInIds(ids) {\n    return this.where(this.getWhereInIdsCondition(ids));\n  }\n  /**\n   * Adds new AND WHERE with conditions for the given ids.\n   *\n   * Ids are mixed.\n   * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n   * If you have multiple primary keys you need to pass object with property names and values specified,\n   * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n   */\n  andWhereInIds(ids) {\n    return this.andWhere(this.getWhereInIdsCondition(ids));\n  }\n  /**\n   * Adds new OR WHERE with conditions for the given ids.\n   *\n   * Ids are mixed.\n   * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n   * If you have multiple primary keys you need to pass object with property names and values specified,\n   * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n   */\n  orWhereInIds(ids) {\n    return this.orWhere(this.getWhereInIdsCondition(ids));\n  }\n  /**\n   * Sets HAVING condition in the query builder.\n   * If you had previously HAVING expression defined,\n   * calling this function will override previously set HAVING conditions.\n   * Additionally you can add parameters used in where expression.\n   */\n  having(having, parameters) {\n    this.expressionMap.havings.push({\n      type: \"simple\",\n      condition: having\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Adds new AND HAVING condition in the query builder.\n   * Additionally you can add parameters used in where expression.\n   */\n  andHaving(having, parameters) {\n    this.expressionMap.havings.push({\n      type: \"and\",\n      condition: having\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Adds new OR HAVING condition in the query builder.\n   * Additionally you can add parameters used in where expression.\n   */\n  orHaving(having, parameters) {\n    this.expressionMap.havings.push({\n      type: \"or\",\n      condition: having\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Sets GROUP BY condition in the query builder.\n   * If you had previously GROUP BY expression defined,\n   * calling this function will override previously set GROUP BY conditions.\n   */\n  groupBy(groupBy) {\n    if (groupBy) {\n      this.expressionMap.groupBys = [groupBy];\n    } else {\n      this.expressionMap.groupBys = [];\n    }\n    return this;\n  }\n  /**\n   * Adds GROUP BY condition in the query builder.\n   */\n  addGroupBy(groupBy) {\n    this.expressionMap.groupBys.push(groupBy);\n    return this;\n  }\n  /**\n   * Enables time travelling for the current query (only supported by cockroach currently)\n   */\n  timeTravelQuery(timeTravelFn) {\n    if (this.connection.driver.options.type === \"cockroachdb\") {\n      if (timeTravelFn === undefined) {\n        this.expressionMap.timeTravel = \"follower_read_timestamp()\";\n      } else {\n        this.expressionMap.timeTravel = timeTravelFn;\n      }\n    }\n    return this;\n  }\n  /**\n   * Sets ORDER BY condition in the query builder.\n   * If you had previously ORDER BY expression defined,\n   * calling this function will override previously set ORDER BY conditions.\n   */\n  orderBy(sort, order = \"ASC\", nulls) {\n    if (order !== undefined && order !== \"ASC\" && order !== \"DESC\") throw new TypeORMError(`SelectQueryBuilder.addOrderBy \"order\" can accept only \"ASC\" and \"DESC\" values.`);\n    if (nulls !== undefined && nulls !== \"NULLS FIRST\" && nulls !== \"NULLS LAST\") throw new TypeORMError(`SelectQueryBuilder.addOrderBy \"nulls\" can accept only \"NULLS FIRST\" and \"NULLS LAST\" values.`);\n    if (sort) {\n      if (typeof sort === \"object\") {\n        this.expressionMap.orderBys = sort;\n      } else {\n        if (nulls) {\n          this.expressionMap.orderBys = {\n            [sort]: {\n              order,\n              nulls\n            }\n          };\n        } else {\n          this.expressionMap.orderBys = {\n            [sort]: order\n          };\n        }\n      }\n    } else {\n      this.expressionMap.orderBys = {};\n    }\n    return this;\n  }\n  /**\n   * Adds ORDER BY condition in the query builder.\n   */\n  addOrderBy(sort, order = \"ASC\", nulls) {\n    if (order !== undefined && order !== \"ASC\" && order !== \"DESC\") throw new TypeORMError(`SelectQueryBuilder.addOrderBy \"order\" can accept only \"ASC\" and \"DESC\" values.`);\n    if (nulls !== undefined && nulls !== \"NULLS FIRST\" && nulls !== \"NULLS LAST\") throw new TypeORMError(`SelectQueryBuilder.addOrderBy \"nulls\" can accept only \"NULLS FIRST\" and \"NULLS LAST\" values.`);\n    if (nulls) {\n      this.expressionMap.orderBys[sort] = {\n        order,\n        nulls\n      };\n    } else {\n      this.expressionMap.orderBys[sort] = order;\n    }\n    return this;\n  }\n  /**\n   * Sets LIMIT - maximum number of rows to be selected.\n   * NOTE that it may not work as you expect if you are using joins.\n   * If you want to implement pagination, and you are having join in your query,\n   * then use the take method instead.\n   */\n  limit(limit) {\n    this.expressionMap.limit = this.normalizeNumber(limit);\n    if (this.expressionMap.limit !== undefined && isNaN(this.expressionMap.limit)) throw new TypeORMError(`Provided \"limit\" value is not a number. Please provide a numeric value.`);\n    return this;\n  }\n  /**\n   * Sets OFFSET - selection offset.\n   * NOTE that it may not work as you expect if you are using joins.\n   * If you want to implement pagination, and you are having join in your query,\n   * then use the skip method instead.\n   */\n  offset(offset) {\n    this.expressionMap.offset = this.normalizeNumber(offset);\n    if (this.expressionMap.offset !== undefined && isNaN(this.expressionMap.offset)) throw new TypeORMError(`Provided \"offset\" value is not a number. Please provide a numeric value.`);\n    return this;\n  }\n  /**\n   * Sets maximal number of entities to take.\n   */\n  take(take) {\n    this.expressionMap.take = this.normalizeNumber(take);\n    if (this.expressionMap.take !== undefined && isNaN(this.expressionMap.take)) throw new TypeORMError(`Provided \"take\" value is not a number. Please provide a numeric value.`);\n    return this;\n  }\n  /**\n   * Sets number of entities to skip.\n   */\n  skip(skip) {\n    this.expressionMap.skip = this.normalizeNumber(skip);\n    if (this.expressionMap.skip !== undefined && isNaN(this.expressionMap.skip)) throw new TypeORMError(`Provided \"skip\" value is not a number. Please provide a numeric value.`);\n    return this;\n  }\n  /**\n   * Set certain index to be used by the query.\n   *\n   * @param index Name of index to be used.\n   */\n  useIndex(index) {\n    this.expressionMap.useIndex = index;\n    return this;\n  }\n  /**\n   * Sets locking mode.\n   */\n  setLock(lockMode, lockVersion, lockTables) {\n    this.expressionMap.lockMode = lockMode;\n    this.expressionMap.lockVersion = lockVersion;\n    this.expressionMap.lockTables = lockTables;\n    return this;\n  }\n  /**\n   * Sets lock handling by adding NO WAIT or SKIP LOCKED.\n   */\n  setOnLocked(onLocked) {\n    this.expressionMap.onLocked = onLocked;\n    return this;\n  }\n  /**\n   * Disables the global condition of \"non-deleted\" for the entity with delete date columns.\n   */\n  withDeleted() {\n    this.expressionMap.withDeleted = true;\n    return this;\n  }\n  /**\n   * Gets first raw result returned by execution of generated query builder sql.\n   */\n  async getRawOne() {\n    return (await this.getRawMany())[0];\n  }\n  /**\n   * Gets all raw results returned by execution of generated query builder sql.\n   */\n  async getRawMany() {\n    if (this.expressionMap.lockMode === \"optimistic\") throw new OptimisticLockCanNotBeUsedError();\n    this.expressionMap.queryEntity = false;\n    const queryRunner = this.obtainQueryRunner();\n    let transactionStartedByUs = false;\n    try {\n      // start transaction if it was enabled\n      if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n        await queryRunner.startTransaction();\n        transactionStartedByUs = true;\n      }\n      const results = await this.loadRawResults(queryRunner);\n      // close transaction if we started it\n      if (transactionStartedByUs) {\n        await queryRunner.commitTransaction();\n      }\n      return results;\n    } catch (error) {\n      // rollback transaction if we started it\n      if (transactionStartedByUs) {\n        try {\n          await queryRunner.rollbackTransaction();\n        } catch (rollbackError) {}\n      }\n      throw error;\n    } finally {\n      if (queryRunner !== this.queryRunner) {\n        // means we created our own query runner\n        await queryRunner.release();\n      }\n    }\n  }\n  /**\n   * Executes sql generated by query builder and returns object with raw results and entities created from them.\n   */\n  async getRawAndEntities() {\n    const queryRunner = this.obtainQueryRunner();\n    let transactionStartedByUs = false;\n    try {\n      // start transaction if it was enabled\n      if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n        await queryRunner.startTransaction();\n        transactionStartedByUs = true;\n      }\n      this.expressionMap.queryEntity = true;\n      const results = await this.executeEntitiesAndRawResults(queryRunner);\n      // close transaction if we started it\n      if (transactionStartedByUs) {\n        await queryRunner.commitTransaction();\n      }\n      return results;\n    } catch (error) {\n      // rollback transaction if we started it\n      if (transactionStartedByUs) {\n        try {\n          await queryRunner.rollbackTransaction();\n        } catch (rollbackError) {}\n      }\n      throw error;\n    } finally {\n      if (queryRunner !== this.queryRunner)\n        // means we created our own query runner\n        await queryRunner.release();\n    }\n  }\n  /**\n   * Gets single entity returned by execution of generated query builder sql.\n   */\n  async getOne() {\n    const results = await this.getRawAndEntities();\n    const result = results.entities[0];\n    if (result && this.expressionMap.lockMode === \"optimistic\" && this.expressionMap.lockVersion) {\n      const metadata = this.expressionMap.mainAlias.metadata;\n      if (this.expressionMap.lockVersion instanceof Date) {\n        const actualVersion = metadata.updateDateColumn.getEntityValue(result); // what if columns arent set?\n        if (actualVersion.getTime() !== this.expressionMap.lockVersion.getTime()) throw new OptimisticLockVersionMismatchError(metadata.name, this.expressionMap.lockVersion, actualVersion);\n      } else {\n        const actualVersion = metadata.versionColumn.getEntityValue(result); // what if columns arent set?\n        if (actualVersion !== this.expressionMap.lockVersion) throw new OptimisticLockVersionMismatchError(metadata.name, this.expressionMap.lockVersion, actualVersion);\n      }\n    }\n    if (result === undefined) {\n      return null;\n    }\n    return result;\n  }\n  /**\n   * Gets the first entity returned by execution of generated query builder sql or rejects the returned promise on error.\n   */\n  async getOneOrFail() {\n    const entity = await this.getOne();\n    if (!entity) {\n      throw new EntityNotFoundError(this.expressionMap.mainAlias.target, this.expressionMap.parameters);\n    }\n    return entity;\n  }\n  /**\n   * Gets entities returned by execution of generated query builder sql.\n   */\n  async getMany() {\n    if (this.expressionMap.lockMode === \"optimistic\") throw new OptimisticLockCanNotBeUsedError();\n    const results = await this.getRawAndEntities();\n    return results.entities;\n  }\n  /**\n   * Gets count - number of entities selected by sql generated by this query builder.\n   * Count excludes all limitations set by offset, limit, skip, and take.\n   */\n  async getCount() {\n    if (this.expressionMap.lockMode === \"optimistic\") throw new OptimisticLockCanNotBeUsedError();\n    const queryRunner = this.obtainQueryRunner();\n    let transactionStartedByUs = false;\n    try {\n      // start transaction if it was enabled\n      if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n        await queryRunner.startTransaction();\n        transactionStartedByUs = true;\n      }\n      this.expressionMap.queryEntity = false;\n      const results = await this.executeCountQuery(queryRunner);\n      // close transaction if we started it\n      if (transactionStartedByUs) {\n        await queryRunner.commitTransaction();\n      }\n      return results;\n    } catch (error) {\n      // rollback transaction if we started it\n      if (transactionStartedByUs) {\n        try {\n          await queryRunner.rollbackTransaction();\n        } catch (rollbackError) {}\n      }\n      throw error;\n    } finally {\n      if (queryRunner !== this.queryRunner)\n        // means we created our own query runner\n        await queryRunner.release();\n    }\n  }\n  /**\n   * Gets exists\n   * Returns whether any rows exists matching current query.\n   */\n  async getExists() {\n    if (this.expressionMap.lockMode === \"optimistic\") throw new OptimisticLockCanNotBeUsedError();\n    const queryRunner = this.obtainQueryRunner();\n    let transactionStartedByUs = false;\n    try {\n      // start transaction if it was enabled\n      if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n        await queryRunner.startTransaction();\n        transactionStartedByUs = true;\n      }\n      this.expressionMap.queryEntity = false;\n      const results = await this.executeExistsQuery(queryRunner);\n      // close transaction if we started it\n      if (transactionStartedByUs) {\n        await queryRunner.commitTransaction();\n      }\n      return results;\n    } catch (error) {\n      // rollback transaction if we started it\n      if (transactionStartedByUs) {\n        try {\n          await queryRunner.rollbackTransaction();\n        } catch (rollbackError) {}\n      }\n      throw error;\n    } finally {\n      if (queryRunner !== this.queryRunner)\n        // means we created our own query runner\n        await queryRunner.release();\n    }\n  }\n  /**\n   * Executes built SQL query and returns entities and overall entities count (without limitation).\n   * This method is useful to build pagination.\n   */\n  async getManyAndCount() {\n    if (this.expressionMap.lockMode === \"optimistic\") throw new OptimisticLockCanNotBeUsedError();\n    const queryRunner = this.obtainQueryRunner();\n    let transactionStartedByUs = false;\n    try {\n      // start transaction if it was enabled\n      if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n        await queryRunner.startTransaction();\n        transactionStartedByUs = true;\n      }\n      this.expressionMap.queryEntity = true;\n      const entitiesAndRaw = await this.executeEntitiesAndRawResults(queryRunner);\n      this.expressionMap.queryEntity = false;\n      const cacheId = this.expressionMap.cacheId;\n      // Creates a new cacheId for the count query, or it will retreive the above query results\n      // and count will return 0.\n      this.expressionMap.cacheId = cacheId ? `${cacheId}-count` : cacheId;\n      const count = await this.executeCountQuery(queryRunner);\n      const results = [entitiesAndRaw.entities, count];\n      // close transaction if we started it\n      if (transactionStartedByUs) {\n        await queryRunner.commitTransaction();\n      }\n      return results;\n    } catch (error) {\n      // rollback transaction if we started it\n      if (transactionStartedByUs) {\n        try {\n          await queryRunner.rollbackTransaction();\n        } catch (rollbackError) {}\n      }\n      throw error;\n    } finally {\n      if (queryRunner !== this.queryRunner)\n        // means we created our own query runner\n        await queryRunner.release();\n    }\n  }\n  /**\n   * Executes built SQL query and returns raw data stream.\n   */\n  async stream() {\n    this.expressionMap.queryEntity = false;\n    const [sql, parameters] = this.getQueryAndParameters();\n    const queryRunner = this.obtainQueryRunner();\n    let transactionStartedByUs = false;\n    try {\n      // start transaction if it was enabled\n      if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n        await queryRunner.startTransaction();\n        transactionStartedByUs = true;\n      }\n      const releaseFn = () => {\n        if (queryRunner !== this.queryRunner)\n          // means we created our own query runner\n          return queryRunner.release();\n        return;\n      };\n      const results = queryRunner.stream(sql, parameters, releaseFn, releaseFn);\n      // close transaction if we started it\n      if (transactionStartedByUs) {\n        await queryRunner.commitTransaction();\n      }\n      return results;\n    } catch (error) {\n      // rollback transaction if we started it\n      if (transactionStartedByUs) {\n        try {\n          await queryRunner.rollbackTransaction();\n        } catch (rollbackError) {}\n      }\n      throw error;\n    }\n  }\n  /**\n   * Enables or disables query result caching.\n   */\n  cache(enabledOrMillisecondsOrId, maybeMilliseconds) {\n    if (typeof enabledOrMillisecondsOrId === \"boolean\") {\n      this.expressionMap.cache = enabledOrMillisecondsOrId;\n    } else if (typeof enabledOrMillisecondsOrId === \"number\") {\n      this.expressionMap.cache = true;\n      this.expressionMap.cacheDuration = enabledOrMillisecondsOrId;\n    } else if (typeof enabledOrMillisecondsOrId === \"string\" || typeof enabledOrMillisecondsOrId === \"number\") {\n      this.expressionMap.cache = true;\n      this.expressionMap.cacheId = enabledOrMillisecondsOrId;\n    }\n    if (maybeMilliseconds) {\n      this.expressionMap.cacheDuration = maybeMilliseconds;\n    }\n    return this;\n  }\n  /**\n   * Sets extra options that can be used to configure how query builder works.\n   */\n  setOption(option) {\n    this.expressionMap.options.push(option);\n    return this;\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  join(direction, entityOrProperty, aliasName, condition, parameters, mapToProperty, isMappingMany, mapAsEntity) {\n    if (parameters) {\n      this.setParameters(parameters);\n    }\n    const joinAttribute = new JoinAttribute(this.connection, this.expressionMap);\n    joinAttribute.direction = direction;\n    joinAttribute.mapAsEntity = mapAsEntity;\n    joinAttribute.mapToProperty = mapToProperty;\n    joinAttribute.isMappingMany = isMappingMany;\n    joinAttribute.entityOrProperty = entityOrProperty; // relationName\n    joinAttribute.condition = condition; // joinInverseSideCondition\n    // joinAttribute.junctionAlias = joinAttribute.relation.isOwning ? parentAlias + \"_\" + destinationTableAlias : destinationTableAlias + \"_\" + parentAlias;\n    this.expressionMap.joinAttributes.push(joinAttribute);\n    const joinAttributeMetadata = joinAttribute.metadata;\n    if (joinAttributeMetadata) {\n      if (joinAttributeMetadata.deleteDateColumn && !this.expressionMap.withDeleted) {\n        const conditionDeleteColumn = `${aliasName}.${joinAttributeMetadata.deleteDateColumn.propertyName} IS NULL`;\n        joinAttribute.condition = joinAttribute.condition ? ` ${joinAttribute.condition} AND ${conditionDeleteColumn}` : `${conditionDeleteColumn}`;\n      }\n      // todo: find and set metadata right there?\n      joinAttribute.alias = this.expressionMap.createAlias({\n        type: \"join\",\n        name: aliasName,\n        metadata: joinAttributeMetadata\n      });\n      if (joinAttribute.relation && joinAttribute.relation.junctionEntityMetadata) {\n        this.expressionMap.createAlias({\n          type: \"join\",\n          name: joinAttribute.junctionAlias,\n          metadata: joinAttribute.relation.junctionEntityMetadata\n        });\n      }\n    } else {\n      let subQuery = \"\";\n      if (typeof entityOrProperty === \"function\") {\n        const subQueryBuilder = entityOrProperty(this.subQuery());\n        this.setParameters(subQueryBuilder.getParameters());\n        subQuery = subQueryBuilder.getQuery();\n      } else {\n        subQuery = entityOrProperty;\n      }\n      const isSubQuery = typeof entityOrProperty === \"function\" || entityOrProperty.substr(0, 1) === \"(\" && entityOrProperty.substr(-1) === \")\";\n      joinAttribute.alias = this.expressionMap.createAlias({\n        type: \"join\",\n        name: aliasName,\n        tablePath: isSubQuery === false ? entityOrProperty : undefined,\n        subQuery: isSubQuery === true ? subQuery : undefined\n      });\n    }\n  }\n  /**\n   * Creates \"SELECT FROM\" part of SQL query.\n   */\n  createSelectExpression() {\n    if (!this.expressionMap.mainAlias) throw new TypeORMError(\"Cannot build query because main alias is not set (call qb#from method)\");\n    // todo throw exception if selects or from is missing\n    const allSelects = [];\n    const excludedSelects = [];\n    if (this.expressionMap.mainAlias.hasMetadata) {\n      const metadata = this.expressionMap.mainAlias.metadata;\n      allSelects.push(...this.buildEscapedEntityColumnSelects(this.expressionMap.mainAlias.name, metadata));\n      excludedSelects.push(...this.findEntityColumnSelects(this.expressionMap.mainAlias.name, metadata));\n    }\n    // add selects from joins\n    this.expressionMap.joinAttributes.forEach(join => {\n      if (join.metadata) {\n        allSelects.push(...this.buildEscapedEntityColumnSelects(join.alias.name, join.metadata));\n        excludedSelects.push(...this.findEntityColumnSelects(join.alias.name, join.metadata));\n      } else {\n        const hasMainAlias = this.expressionMap.selects.some(select => select.selection === join.alias.name);\n        if (hasMainAlias) {\n          allSelects.push({\n            selection: this.escape(join.alias.name) + \".*\"\n          });\n          const excludedSelect = this.expressionMap.selects.find(select => select.selection === join.alias.name);\n          excludedSelects.push(excludedSelect);\n        }\n      }\n    });\n    // add all other selects\n    this.expressionMap.selects.filter(select => excludedSelects.indexOf(select) === -1).forEach(select => allSelects.push({\n      selection: this.replacePropertyNames(select.selection),\n      aliasName: select.aliasName\n    }));\n    // if still selection is empty, then simply set it to all (*)\n    if (allSelects.length === 0) allSelects.push({\n      selection: \"*\"\n    });\n    // Use certain index\n    let useIndex = \"\";\n    if (this.expressionMap.useIndex) {\n      if (DriverUtils.isMySQLFamily(this.connection.driver)) {\n        useIndex = ` USE INDEX (${this.expressionMap.useIndex})`;\n      }\n    }\n    // create a selection query\n    const froms = this.expressionMap.aliases.filter(alias => alias.type === \"from\" && (alias.tablePath || alias.subQuery)).map(alias => {\n      if (alias.subQuery) return alias.subQuery + \" \" + this.escape(alias.name);\n      return this.getTableName(alias.tablePath) + \" \" + this.escape(alias.name);\n    });\n    const select = this.createSelectDistinctExpression();\n    const selection = allSelects.map(select => select.selection + (select.aliasName ? \" AS \" + this.escape(select.aliasName) : \"\")).join(\", \");\n    return select + selection + \" FROM \" + froms.join(\", \") + this.createTableLockExpression() + useIndex;\n  }\n  /**\n   * Creates select | select distinct part of SQL query.\n   */\n  createSelectDistinctExpression() {\n    const {\n      selectDistinct,\n      selectDistinctOn,\n      maxExecutionTime\n    } = this.expressionMap;\n    const {\n      driver\n    } = this.connection;\n    let select = \"SELECT \";\n    if (maxExecutionTime > 0) {\n      if (DriverUtils.isMySQLFamily(driver)) {\n        select += `/*+ MAX_EXECUTION_TIME(${this.expressionMap.maxExecutionTime}) */ `;\n      }\n    }\n    if (DriverUtils.isPostgresFamily(driver) && selectDistinctOn.length > 0) {\n      const selectDistinctOnMap = selectDistinctOn.map(on => this.replacePropertyNames(on)).join(\", \");\n      select = `SELECT DISTINCT ON (${selectDistinctOnMap}) `;\n    } else if (selectDistinct) {\n      select = \"SELECT DISTINCT \";\n    }\n    return select;\n  }\n  /**\n   * Creates \"JOIN\" part of SQL query.\n   */\n  createJoinExpression() {\n    // examples:\n    // select from owning side\n    // qb.select(\"post\")\n    //     .leftJoinAndSelect(\"post.category\", \"category\");\n    // select from non-owning side\n    // qb.select(\"category\")\n    //     .leftJoinAndSelect(\"category.post\", \"post\");\n    const joins = this.expressionMap.joinAttributes.map(joinAttr => {\n      const relation = joinAttr.relation;\n      const destinationTableName = joinAttr.tablePath;\n      const destinationTableAlias = joinAttr.alias.name;\n      let appendedCondition = joinAttr.condition ? \" AND (\" + joinAttr.condition + \")\" : \"\";\n      const parentAlias = joinAttr.parentAlias;\n      // if join was build without relation (e.g. without \"post.category\") then it means that we have direct\n      // table to join, without junction table involved. This means we simply join direct table.\n      if (!parentAlias || !relation) {\n        const destinationJoin = joinAttr.alias.subQuery ? joinAttr.alias.subQuery : this.getTableName(destinationTableName);\n        return \" \" + joinAttr.direction + \" JOIN \" + destinationJoin + \" \" + this.escape(destinationTableAlias) + this.createTableLockExpression() + (joinAttr.condition ? \" ON \" + this.replacePropertyNames(joinAttr.condition) : \"\");\n      }\n      // if real entity relation is involved\n      if (relation.isManyToOne || relation.isOneToOneOwner) {\n        // JOIN `category` `category` ON `category`.`id` = `post`.`categoryId`\n        const condition = relation.joinColumns.map(joinColumn => {\n          return destinationTableAlias + \".\" + joinColumn.referencedColumn.propertyPath + \"=\" + parentAlias + \".\" + relation.propertyPath + \".\" + joinColumn.referencedColumn.propertyPath;\n        }).join(\" AND \");\n        return \" \" + joinAttr.direction + \" JOIN \" + this.getTableName(destinationTableName) + \" \" + this.escape(destinationTableAlias) + this.createTableLockExpression() + \" ON \" + this.replacePropertyNames(condition + appendedCondition);\n      } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n        // JOIN `post` `post` ON `post`.`categoryId` = `category`.`id`\n        const condition = relation.inverseRelation.joinColumns.map(joinColumn => {\n          if (relation.inverseEntityMetadata.tableType === \"entity-child\" && relation.inverseEntityMetadata.discriminatorColumn) {\n            appendedCondition += \" AND \" + destinationTableAlias + \".\" + relation.inverseEntityMetadata.discriminatorColumn.databaseName + \"='\" + relation.inverseEntityMetadata.discriminatorValue + \"'\";\n          }\n          return destinationTableAlias + \".\" + relation.inverseRelation.propertyPath + \".\" + joinColumn.referencedColumn.propertyPath + \"=\" + parentAlias + \".\" + joinColumn.referencedColumn.propertyPath;\n        }).join(\" AND \");\n        if (!condition) throw new TypeORMError(`Relation ${relation.entityMetadata.name}.${relation.propertyName} does not have join columns.`);\n        return \" \" + joinAttr.direction + \" JOIN \" + this.getTableName(destinationTableName) + \" \" + this.escape(destinationTableAlias) + this.createTableLockExpression() + \" ON \" + this.replacePropertyNames(condition + appendedCondition);\n      } else {\n        // means many-to-many\n        const junctionTableName = relation.junctionEntityMetadata.tablePath;\n        const junctionAlias = joinAttr.junctionAlias;\n        let junctionCondition = \"\",\n          destinationCondition = \"\";\n        if (relation.isOwning) {\n          junctionCondition = relation.joinColumns.map(joinColumn => {\n            // `post_category`.`postId` = `post`.`id`\n            return junctionAlias + \".\" + joinColumn.propertyPath + \"=\" + parentAlias + \".\" + joinColumn.referencedColumn.propertyPath;\n          }).join(\" AND \");\n          destinationCondition = relation.inverseJoinColumns.map(joinColumn => {\n            // `category`.`id` = `post_category`.`categoryId`\n            return destinationTableAlias + \".\" + joinColumn.referencedColumn.propertyPath + \"=\" + junctionAlias + \".\" + joinColumn.propertyPath;\n          }).join(\" AND \");\n        } else {\n          junctionCondition = relation.inverseRelation.inverseJoinColumns.map(joinColumn => {\n            // `post_category`.`categoryId` = `category`.`id`\n            return junctionAlias + \".\" + joinColumn.propertyPath + \"=\" + parentAlias + \".\" + joinColumn.referencedColumn.propertyPath;\n          }).join(\" AND \");\n          destinationCondition = relation.inverseRelation.joinColumns.map(joinColumn => {\n            // `post`.`id` = `post_category`.`postId`\n            return destinationTableAlias + \".\" + joinColumn.referencedColumn.propertyPath + \"=\" + junctionAlias + \".\" + joinColumn.propertyPath;\n          }).join(\" AND \");\n        }\n        return \" \" + joinAttr.direction + \" JOIN \" + this.getTableName(junctionTableName) + \" \" + this.escape(junctionAlias) + this.createTableLockExpression() + \" ON \" + this.replacePropertyNames(junctionCondition) + \" \" + joinAttr.direction + \" JOIN \" + this.getTableName(destinationTableName) + \" \" + this.escape(destinationTableAlias) + this.createTableLockExpression() + \" ON \" + this.replacePropertyNames(destinationCondition + appendedCondition);\n      }\n    });\n    return joins.join(\" \");\n  }\n  /**\n   * Creates \"GROUP BY\" part of SQL query.\n   */\n  createGroupByExpression() {\n    if (!this.expressionMap.groupBys || !this.expressionMap.groupBys.length) return \"\";\n    return \" GROUP BY \" + this.replacePropertyNames(this.expressionMap.groupBys.join(\", \"));\n  }\n  /**\n   * Creates \"ORDER BY\" part of SQL query.\n   */\n  createOrderByExpression() {\n    const orderBys = this.expressionMap.allOrderBys;\n    if (Object.keys(orderBys).length === 0) return \"\";\n    return \" ORDER BY \" + Object.keys(orderBys).map(columnName => {\n      const orderValue = typeof orderBys[columnName] === \"string\" ? orderBys[columnName] : orderBys[columnName].order + \" \" + orderBys[columnName].nulls;\n      const selection = this.expressionMap.selects.find(s => s.selection === columnName);\n      if (selection && !selection.aliasName && columnName.indexOf(\".\") !== -1) {\n        const criteriaParts = columnName.split(\".\");\n        const aliasName = criteriaParts[0];\n        const propertyPath = criteriaParts.slice(1).join(\".\");\n        const alias = this.expressionMap.aliases.find(alias => alias.name === aliasName);\n        if (alias) {\n          const column = alias.metadata.findColumnWithPropertyPath(propertyPath);\n          if (column) {\n            const orderAlias = DriverUtils.buildAlias(this.connection.driver, undefined, aliasName, column.databaseName);\n            return this.escape(orderAlias) + \" \" + orderValue;\n          }\n        }\n      }\n      return this.replacePropertyNames(columnName) + \" \" + orderValue;\n    }).join(\", \");\n  }\n  /**\n   * Creates \"LIMIT\" and \"OFFSET\" parts of SQL query.\n   */\n  createLimitOffsetExpression() {\n    // in the case if nothing is joined in the query builder we don't need to make two requests to get paginated results\n    // we can use regular limit / offset, that's why we add offset and limit construction here based on skip and take values\n    let offset = this.expressionMap.offset,\n      limit = this.expressionMap.limit;\n    if (!offset && !limit && this.expressionMap.joinAttributes.length === 0) {\n      offset = this.expressionMap.skip;\n      limit = this.expressionMap.take;\n    }\n    if (this.connection.driver.options.type === \"mssql\") {\n      // Due to a limitation in SQL Server's parser implementation it does not support using\n      // OFFSET or FETCH NEXT without an ORDER BY clause being provided. In cases where the\n      // user does not request one we insert a dummy ORDER BY that does nothing and should\n      // have no effect on the query planner or on the order of the results returned.\n      // https://dba.stackexchange.com/a/193799\n      let prefix = \"\";\n      if ((limit || offset) && Object.keys(this.expressionMap.allOrderBys).length <= 0) {\n        prefix = \" ORDER BY (SELECT NULL)\";\n      }\n      if (limit && offset) return prefix + \" OFFSET \" + offset + \" ROWS FETCH NEXT \" + limit + \" ROWS ONLY\";\n      if (limit) return prefix + \" OFFSET 0 ROWS FETCH NEXT \" + limit + \" ROWS ONLY\";\n      if (offset) return prefix + \" OFFSET \" + offset + \" ROWS\";\n    } else if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\" || this.connection.driver.options.type === \"sap\" || this.connection.driver.options.type === \"spanner\") {\n      if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset;\n      if (limit) return \" LIMIT \" + limit;\n      if (offset) throw new OffsetWithoutLimitNotSupportedError();\n    } else if (DriverUtils.isSQLiteFamily(this.connection.driver)) {\n      if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset;\n      if (limit) return \" LIMIT \" + limit;\n      if (offset) return \" LIMIT -1 OFFSET \" + offset;\n    } else if (this.connection.driver.options.type === \"oracle\") {\n      if (limit && offset) return \" OFFSET \" + offset + \" ROWS FETCH NEXT \" + limit + \" ROWS ONLY\";\n      if (limit) return \" FETCH NEXT \" + limit + \" ROWS ONLY\";\n      if (offset) return \" OFFSET \" + offset + \" ROWS\";\n    } else {\n      if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset;\n      if (limit) return \" LIMIT \" + limit;\n      if (offset) return \" OFFSET \" + offset;\n    }\n    return \"\";\n  }\n  /**\n   * Creates \"LOCK\" part of SELECT Query after table Clause\n   * ex.\n   *  SELECT 1\n   *  FROM USER U WITH (NOLOCK)\n   *  JOIN ORDER O WITH (NOLOCK)\n   *      ON U.ID=O.OrderID\n   */\n  createTableLockExpression() {\n    if (this.connection.driver.options.type === \"mssql\") {\n      switch (this.expressionMap.lockMode) {\n        case \"pessimistic_read\":\n          return \" WITH (HOLDLOCK, ROWLOCK)\";\n        case \"pessimistic_write\":\n          return \" WITH (UPDLOCK, ROWLOCK)\";\n        case \"dirty_read\":\n          return \" WITH (NOLOCK)\";\n      }\n    }\n    return \"\";\n  }\n  /**\n   * Creates \"LOCK\" part of SQL query.\n   */\n  createLockExpression() {\n    const driver = this.connection.driver;\n    let lockTablesClause = \"\";\n    if (this.expressionMap.lockTables) {\n      if (!(DriverUtils.isPostgresFamily(driver) || driver.options.type === \"cockroachdb\")) {\n        throw new TypeORMError(\"Lock tables not supported in selected driver\");\n      }\n      if (this.expressionMap.lockTables.length < 1) {\n        throw new TypeORMError(\"lockTables cannot be an empty array\");\n      }\n      lockTablesClause = \" OF \" + this.expressionMap.lockTables.join(\", \");\n    }\n    let onLockExpression = \"\";\n    if (this.expressionMap.onLocked === \"nowait\") {\n      onLockExpression = \" NOWAIT\";\n    } else if (this.expressionMap.onLocked === \"skip_locked\") {\n      onLockExpression = \" SKIP LOCKED\";\n    }\n    switch (this.expressionMap.lockMode) {\n      case \"pessimistic_read\":\n        if (driver.options.type === \"mysql\" || driver.options.type === \"aurora-mysql\") {\n          if (DriverUtils.isReleaseVersionOrGreater(driver, \"8.0.0\")) {\n            return \" FOR SHARE\" + lockTablesClause + onLockExpression;\n          } else {\n            return \" LOCK IN SHARE MODE\";\n          }\n        } else if (driver.options.type === \"mariadb\") {\n          return \" LOCK IN SHARE MODE\";\n        } else if (DriverUtils.isPostgresFamily(driver)) {\n          return \" FOR SHARE\" + lockTablesClause + onLockExpression;\n        } else if (driver.options.type === \"oracle\") {\n          return \" FOR UPDATE\";\n        } else if (driver.options.type === \"mssql\") {\n          return \"\";\n        } else {\n          throw new LockNotSupportedOnGivenDriverError();\n        }\n      case \"pessimistic_write\":\n        if (DriverUtils.isMySQLFamily(driver) || driver.options.type === \"aurora-mysql\" || driver.options.type === \"oracle\") {\n          return \" FOR UPDATE\" + onLockExpression;\n        } else if (DriverUtils.isPostgresFamily(driver) || driver.options.type === \"cockroachdb\") {\n          return \" FOR UPDATE\" + lockTablesClause + onLockExpression;\n        } else if (driver.options.type === \"mssql\") {\n          return \"\";\n        } else {\n          throw new LockNotSupportedOnGivenDriverError();\n        }\n      case \"pessimistic_partial_write\":\n        if (DriverUtils.isPostgresFamily(driver)) {\n          return \" FOR UPDATE\" + lockTablesClause + \" SKIP LOCKED\";\n        } else if (DriverUtils.isMySQLFamily(driver)) {\n          return \" FOR UPDATE SKIP LOCKED\";\n        } else {\n          throw new LockNotSupportedOnGivenDriverError();\n        }\n      case \"pessimistic_write_or_fail\":\n        if (DriverUtils.isPostgresFamily(driver) || driver.options.type === \"cockroachdb\") {\n          return \" FOR UPDATE\" + lockTablesClause + \" NOWAIT\";\n        } else if (DriverUtils.isMySQLFamily(driver)) {\n          return \" FOR UPDATE NOWAIT\";\n        } else {\n          throw new LockNotSupportedOnGivenDriverError();\n        }\n      case \"for_no_key_update\":\n        if (DriverUtils.isPostgresFamily(driver) || driver.options.type === \"cockroachdb\") {\n          return \" FOR NO KEY UPDATE\" + lockTablesClause + onLockExpression;\n        } else {\n          throw new LockNotSupportedOnGivenDriverError();\n        }\n      case \"for_key_share\":\n        if (DriverUtils.isPostgresFamily(driver)) {\n          return \" FOR KEY SHARE\" + lockTablesClause + onLockExpression;\n        } else {\n          throw new LockNotSupportedOnGivenDriverError();\n        }\n      default:\n        return \"\";\n    }\n  }\n  /**\n   * Creates \"HAVING\" part of SQL query.\n   */\n  createHavingExpression() {\n    if (!this.expressionMap.havings || !this.expressionMap.havings.length) return \"\";\n    const conditions = this.expressionMap.havings.map((having, index) => {\n      switch (having.type) {\n        case \"and\":\n          return (index > 0 ? \"AND \" : \"\") + this.replacePropertyNames(having.condition);\n        case \"or\":\n          return (index > 0 ? \"OR \" : \"\") + this.replacePropertyNames(having.condition);\n        default:\n          return this.replacePropertyNames(having.condition);\n      }\n    }).join(\" \");\n    if (!conditions.length) return \"\";\n    return \" HAVING \" + conditions;\n  }\n  buildEscapedEntityColumnSelects(aliasName, metadata) {\n    const hasMainAlias = this.expressionMap.selects.some(select => select.selection === aliasName);\n    const columns = [];\n    if (hasMainAlias) {\n      columns.push(...metadata.columns.filter(column => column.isSelect === true));\n    }\n    columns.push(...metadata.columns.filter(column => {\n      return this.expressionMap.selects.some(select => select.selection === aliasName + \".\" + column.propertyPath);\n    }));\n    // if user used partial selection and did not select some primary columns which are required to be selected\n    // we select those primary columns and mark them as \"virtual\". Later virtual column values will be removed from final entity\n    // to make entity contain exactly what user selected\n    if (columns.length === 0)\n      // however not in the case when nothing (even partial) was selected from this target (for example joins without selection)\n      return [];\n    const nonSelectedPrimaryColumns = this.expressionMap.queryEntity ? metadata.primaryColumns.filter(primaryColumn => columns.indexOf(primaryColumn) === -1) : [];\n    const allColumns = [...columns, ...nonSelectedPrimaryColumns];\n    const finalSelects = [];\n    const escapedAliasName = this.escape(aliasName);\n    allColumns.forEach(column => {\n      let selectionPath = escapedAliasName + \".\" + this.escape(column.databaseName);\n      if (column.isVirtualProperty && column.query) {\n        selectionPath = `(${column.query(escapedAliasName)})`;\n      }\n      if (this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n        if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\") {\n          const useLegacy = this.connection.driver.options.legacySpatialSupport;\n          const asText = useLegacy ? \"AsText\" : \"ST_AsText\";\n          selectionPath = `${asText}(${selectionPath})`;\n        }\n        if (DriverUtils.isPostgresFamily(this.connection.driver)) if (column.precision) {\n          // cast to JSON to trigger parsing in the driver\n          selectionPath = `ST_AsGeoJSON(${selectionPath}, ${column.precision})::json`;\n        } else {\n          selectionPath = `ST_AsGeoJSON(${selectionPath})::json`;\n        }\n        if (this.connection.driver.options.type === \"mssql\") selectionPath = `${selectionPath}.ToString()`;\n      }\n      const selections = this.expressionMap.selects.filter(select => select.selection === aliasName + \".\" + column.propertyPath);\n      if (selections.length) {\n        selections.forEach(selection => {\n          finalSelects.push({\n            selection: selectionPath,\n            aliasName: selection.aliasName ? selection.aliasName : DriverUtils.buildAlias(this.connection.driver, undefined, aliasName, column.databaseName),\n            // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!\n            virtual: selection.virtual\n          });\n        });\n      } else {\n        if (column.isVirtualProperty) {\n          // Do not add unselected virtual properties to final select\n          return;\n        }\n        finalSelects.push({\n          selection: selectionPath,\n          aliasName: DriverUtils.buildAlias(this.connection.driver, undefined, aliasName, column.databaseName),\n          // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!\n          virtual: hasMainAlias\n        });\n      }\n    });\n    return finalSelects;\n  }\n  findEntityColumnSelects(aliasName, metadata) {\n    const mainSelect = this.expressionMap.selects.find(select => select.selection === aliasName);\n    if (mainSelect) return [mainSelect];\n    return this.expressionMap.selects.filter(select => {\n      return metadata.columns.some(column => select.selection === aliasName + \".\" + column.propertyPath);\n    });\n  }\n  computeCountExpression() {\n    const mainAlias = this.expressionMap.mainAlias.name; // todo: will this work with \"fromTableName\"?\n    const metadata = this.expressionMap.mainAlias.metadata;\n    const primaryColumns = metadata.primaryColumns;\n    const distinctAlias = this.escape(mainAlias);\n    // If we aren't doing anything that will create a join, we can use a simpler `COUNT` instead\n    // so we prevent poor query patterns in the most likely cases\n    if (this.expressionMap.joinAttributes.length === 0 && this.expressionMap.relationIdAttributes.length === 0 && this.expressionMap.relationCountAttributes.length === 0) {\n      return \"COUNT(1)\";\n    }\n    // For everything else, we'll need to do some hackery to get the correct count values.\n    if (this.connection.driver.options.type === \"cockroachdb\" || DriverUtils.isPostgresFamily(this.connection.driver)) {\n      // Postgres and CockroachDB can pass multiple parameters to the `DISTINCT` function\n      // https://www.postgresql.org/docs/9.5/sql-select.html#SQL-DISTINCT\n      return \"COUNT(DISTINCT(\" + primaryColumns.map(c => `${distinctAlias}.${this.escape(c.databaseName)}`).join(\", \") + \"))\";\n    }\n    if (DriverUtils.isMySQLFamily(this.connection.driver)) {\n      // MySQL & MariaDB can pass multiple parameters to the `DISTINCT` language construct\n      // https://mariadb.com/kb/en/count-distinct/\n      return \"COUNT(DISTINCT \" + primaryColumns.map(c => `${distinctAlias}.${this.escape(c.databaseName)}`).join(\", \") + \")\";\n    }\n    if (this.connection.driver.options.type === \"mssql\") {\n      // SQL Server has gotta be different from everyone else.  They don't support\n      // distinct counting multiple columns & they don't have the same operator\n      // characteristic for concatenating, so we gotta use the `CONCAT` function.\n      // However, If it's exactly 1 column we can omit the `CONCAT` for better performance.\n      const columnsExpression = primaryColumns.map(primaryColumn => `${distinctAlias}.${this.escape(primaryColumn.databaseName)}`).join(\", '|;|', \");\n      if (primaryColumns.length === 1) {\n        return `COUNT(DISTINCT(${columnsExpression}))`;\n      }\n      return `COUNT(DISTINCT(CONCAT(${columnsExpression})))`;\n    }\n    if (this.connection.driver.options.type === \"spanner\") {\n      // spanner also has gotta be different from everyone else.\n      // they do not support concatenation of different column types without casting them to string\n      if (primaryColumns.length === 1) {\n        return `COUNT(DISTINCT(${distinctAlias}.${this.escape(primaryColumns[0].databaseName)}))`;\n      }\n      const columnsExpression = primaryColumns.map(primaryColumn => `CAST(${distinctAlias}.${this.escape(primaryColumn.databaseName)} AS STRING)`).join(\", '|;|', \");\n      return `COUNT(DISTINCT(CONCAT(${columnsExpression})))`;\n    }\n    // If all else fails, fall back to a `COUNT` and `DISTINCT` across all the primary columns concatenated.\n    // Per the SQL spec, this is the canonical string concatenation mechanism which is most\n    // likely to work across servers implementing the SQL standard.\n    // Please note, if there is only one primary column that the concatenation does not occur in this\n    // query and the query is a standard `COUNT DISTINCT` in that case.\n    return `COUNT(DISTINCT(` + primaryColumns.map(c => `${distinctAlias}.${this.escape(c.databaseName)}`).join(\" || '|;|' || \") + \"))\";\n  }\n  async executeCountQuery(queryRunner) {\n    const countSql = this.computeCountExpression();\n    const results = await this.clone().orderBy().groupBy().offset(undefined).limit(undefined).skip(undefined).take(undefined).select(countSql, \"cnt\").setOption(\"disable-global-order\").loadRawResults(queryRunner);\n    if (!results || !results[0] || !results[0][\"cnt\"]) return 0;\n    return parseInt(results[0][\"cnt\"]);\n  }\n  async executeExistsQuery(queryRunner) {\n    const results = await this.connection.createQueryBuilder().fromDummy().select(\"1\", \"row_exists\").whereExists(this).limit(1).loadRawResults(queryRunner);\n    return results.length > 0;\n  }\n  applyFindOptions() {\n    // todo: convert relations: string[] to object map to simplify code\n    // todo: same with selects\n    if (this.expressionMap.mainAlias.metadata) {\n      if (this.findOptions.relationLoadStrategy) {\n        this.expressionMap.relationLoadStrategy = this.findOptions.relationLoadStrategy;\n      }\n      if (this.findOptions.comment) {\n        this.comment(this.findOptions.comment);\n      }\n      if (this.findOptions.withDeleted) {\n        this.withDeleted();\n      }\n      if (this.findOptions.select) {\n        const select = Array.isArray(this.findOptions.select) ? OrmUtils.propertyPathsToTruthyObject(this.findOptions.select) : this.findOptions.select;\n        this.buildSelect(select, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);\n      }\n      if (this.selects.length) {\n        this.select(this.selects);\n      }\n      this.selects = [];\n      if (this.findOptions.relations) {\n        const relations = Array.isArray(this.findOptions.relations) ? OrmUtils.propertyPathsToTruthyObject(this.findOptions.relations) : this.findOptions.relations;\n        this.buildRelations(relations, typeof this.findOptions.select === \"object\" ? this.findOptions.select : undefined, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);\n        if (this.findOptions.loadEagerRelations !== false && this.expressionMap.relationLoadStrategy === \"join\") {\n          this.buildEagerRelations(relations, typeof this.findOptions.select === \"object\" ? this.findOptions.select : undefined, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);\n        }\n      }\n      if (this.selects.length) {\n        this.addSelect(this.selects);\n      }\n      if (this.findOptions.where) {\n        this.conditions = this.buildWhere(this.findOptions.where, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);\n        if (this.conditions.length) this.andWhere(this.conditions.substr(0, 1) !== \"(\" ? \"(\" + this.conditions + \")\" : this.conditions); // temporary and where and braces\n      }\n      if (this.findOptions.order) {\n        this.buildOrder(this.findOptions.order, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);\n      }\n      // apply joins\n      if (this.joins.length) {\n        this.joins.forEach(join => {\n          if (join.select && !join.selection) {\n            // if (join.selection) {\n            //\n            // } else {\n            if (join.type === \"inner\") {\n              this.innerJoinAndSelect(`${join.parentAlias}.${join.relationMetadata.propertyPath}`, join.alias);\n            } else {\n              this.leftJoinAndSelect(`${join.parentAlias}.${join.relationMetadata.propertyPath}`, join.alias);\n            }\n            // }\n          } else {\n            if (join.type === \"inner\") {\n              this.innerJoin(`${join.parentAlias}.${join.relationMetadata.propertyPath}`, join.alias);\n            } else {\n              this.leftJoin(`${join.parentAlias}.${join.relationMetadata.propertyPath}`, join.alias);\n            }\n          }\n          // if (join.select) {\n          //     if (this.findOptions.loadEagerRelations !== false) {\n          //         FindOptionsUtils.joinEagerRelations(\n          //             this,\n          //             join.alias,\n          //             join.relationMetadata.inverseEntityMetadata\n          //         );\n          //     }\n          // }\n        });\n      }\n      // if (this.conditions.length) {\n      //     this.where(this.conditions.join(\" AND \"));\n      // }\n      // apply offset\n      if (this.findOptions.skip !== undefined) {\n        // if (this.findOptions.options && this.findOptions.options.pagination === false) {\n        //     this.offset(this.findOptions.skip);\n        // } else {\n        this.skip(this.findOptions.skip);\n        // }\n      }\n      // apply limit\n      if (this.findOptions.take !== undefined) {\n        // if (this.findOptions.options && this.findOptions.options.pagination === false) {\n        //     this.limit(this.findOptions.take);\n        // } else {\n        this.take(this.findOptions.take);\n        // }\n      }\n      // apply caching options\n      if (typeof this.findOptions.cache === \"number\") {\n        this.cache(this.findOptions.cache);\n      } else if (typeof this.findOptions.cache === \"boolean\") {\n        this.cache(this.findOptions.cache);\n      } else if (typeof this.findOptions.cache === \"object\") {\n        this.cache(this.findOptions.cache.id, this.findOptions.cache.milliseconds);\n      }\n      if (this.findOptions.join) {\n        if (this.findOptions.join.leftJoin) Object.keys(this.findOptions.join.leftJoin).forEach(key => {\n          this.leftJoin(this.findOptions.join.leftJoin[key], key);\n        });\n        if (this.findOptions.join.innerJoin) Object.keys(this.findOptions.join.innerJoin).forEach(key => {\n          this.innerJoin(this.findOptions.join.innerJoin[key], key);\n        });\n        if (this.findOptions.join.leftJoinAndSelect) Object.keys(this.findOptions.join.leftJoinAndSelect).forEach(key => {\n          this.leftJoinAndSelect(this.findOptions.join.leftJoinAndSelect[key], key);\n        });\n        if (this.findOptions.join.innerJoinAndSelect) Object.keys(this.findOptions.join.innerJoinAndSelect).forEach(key => {\n          this.innerJoinAndSelect(this.findOptions.join.innerJoinAndSelect[key], key);\n        });\n      }\n      if (this.findOptions.lock) {\n        if (this.findOptions.lock.mode === \"optimistic\") {\n          this.setLock(this.findOptions.lock.mode, this.findOptions.lock.version);\n        } else if (this.findOptions.lock.mode === \"pessimistic_read\" || this.findOptions.lock.mode === \"pessimistic_write\" || this.findOptions.lock.mode === \"dirty_read\" || this.findOptions.lock.mode === \"pessimistic_partial_write\" || this.findOptions.lock.mode === \"pessimistic_write_or_fail\" || this.findOptions.lock.mode === \"for_no_key_update\" || this.findOptions.lock.mode === \"for_key_share\") {\n          const tableNames = this.findOptions.lock.tables ? this.findOptions.lock.tables.map(table => {\n            const tableAlias = this.expressionMap.aliases.find(alias => {\n              return alias.metadata.tableNameWithoutPrefix === table;\n            });\n            if (!tableAlias) {\n              throw new TypeORMError(`\"${table}\" is not part of this query`);\n            }\n            return this.escape(tableAlias.name);\n          }) : undefined;\n          this.setLock(this.findOptions.lock.mode, undefined, tableNames);\n          if (this.findOptions.lock.onLocked) {\n            this.setOnLocked(this.findOptions.lock.onLocked);\n          }\n        }\n      }\n      if (this.findOptions.loadRelationIds === true) {\n        this.loadAllRelationIds();\n      } else if (typeof this.findOptions.loadRelationIds === \"object\") {\n        this.loadAllRelationIds(this.findOptions.loadRelationIds);\n      }\n      if (this.findOptions.loadEagerRelations !== false) {\n        FindOptionsUtils.joinEagerRelations(this, this.expressionMap.mainAlias.name, this.expressionMap.mainAlias.metadata);\n      }\n      if (this.findOptions.transaction === true) {\n        this.expressionMap.useTransaction = true;\n      }\n      // if (this.orderBys.length) {\n      //     this.orderBys.forEach(orderBy => {\n      //         this.addOrderBy(orderBy.alias, orderBy.direction, orderBy.nulls);\n      //     });\n      // }\n      // todo\n      // if (this.options.options && this.options.options.eagerRelations) {\n      //     this.queryBuilder\n      // }\n      // todo\n      // if (this.findOptions.options && this.findOptions.listeners === false) {\n      //     this.callListeners(false);\n      // }\n    }\n  }\n  concatRelationMetadata(relationMetadata) {\n    this.relationMetadatas.push(relationMetadata);\n  }\n  /**\n   * Executes sql generated by query builder and returns object with raw results and entities created from them.\n   */\n  async executeEntitiesAndRawResults(queryRunner) {\n    if (!this.expressionMap.mainAlias) throw new TypeORMError(`Alias is not set. Use \"from\" method to set an alias.`);\n    if ((this.expressionMap.lockMode === \"pessimistic_read\" || this.expressionMap.lockMode === \"pessimistic_write\" || this.expressionMap.lockMode === \"pessimistic_partial_write\" || this.expressionMap.lockMode === \"pessimistic_write_or_fail\" || this.expressionMap.lockMode === \"for_no_key_update\" || this.expressionMap.lockMode === \"for_key_share\") && !queryRunner.isTransactionActive) throw new PessimisticLockTransactionRequiredError();\n    if (this.expressionMap.lockMode === \"optimistic\") {\n      const metadata = this.expressionMap.mainAlias.metadata;\n      if (!metadata.versionColumn && !metadata.updateDateColumn) throw new NoVersionOrUpdateDateColumnError(metadata.name);\n    }\n    const relationIdLoader = new RelationIdLoader(this.connection, queryRunner, this.expressionMap.relationIdAttributes);\n    const relationCountLoader = new RelationCountLoader(this.connection, queryRunner, this.expressionMap.relationCountAttributes);\n    const relationIdMetadataTransformer = new RelationIdMetadataToAttributeTransformer(this.expressionMap);\n    relationIdMetadataTransformer.transform();\n    const relationCountMetadataTransformer = new RelationCountMetadataToAttributeTransformer(this.expressionMap);\n    relationCountMetadataTransformer.transform();\n    let rawResults = [],\n      entities = [];\n    // for pagination enabled (e.g. skip and take) its much more complicated - its a special process\n    // where we make two queries to find the data we need\n    // first query find ids in skip and take range\n    // and second query loads the actual data in given ids range\n    if ((this.expressionMap.skip || this.expressionMap.take) && this.expressionMap.joinAttributes.length > 0) {\n      // we are skipping order by here because its not working in subqueries anyway\n      // to make order by working we need to apply it on a distinct query\n      const [selects, orderBys] = this.createOrderByCombinedWithSelectExpression(\"distinctAlias\");\n      const metadata = this.expressionMap.mainAlias.metadata;\n      const mainAliasName = this.expressionMap.mainAlias.name;\n      const querySelects = metadata.primaryColumns.map(primaryColumn => {\n        const distinctAlias = this.escape(\"distinctAlias\");\n        const columnAlias = this.escape(DriverUtils.buildAlias(this.connection.driver, undefined, mainAliasName, primaryColumn.databaseName));\n        if (!orderBys[columnAlias])\n          // make sure we aren't overriding user-defined order in inverse direction\n          orderBys[columnAlias] = \"ASC\";\n        const alias = DriverUtils.buildAlias(this.connection.driver, undefined, \"ids_\" + mainAliasName, primaryColumn.databaseName);\n        return `${distinctAlias}.${columnAlias} AS ${this.escape(alias)}`;\n      });\n      const originalQuery = this.clone();\n      // preserve original timeTravel value since we set it to \"false\" in subquery\n      const originalQueryTimeTravel = originalQuery.expressionMap.timeTravel;\n      rawResults = await new SelectQueryBuilder(this.connection, queryRunner).select(`DISTINCT ${querySelects.join(\", \")}`).addSelect(selects).from(`(${originalQuery.orderBy().timeTravelQuery(false) // set it to \"false\" since time travel clause must appear at the very end and applies to the entire SELECT clause.\n      .getQuery()})`, \"distinctAlias\").timeTravelQuery(originalQueryTimeTravel).offset(this.expressionMap.skip).limit(this.expressionMap.take).orderBy(orderBys).cache(this.expressionMap.cache && this.expressionMap.cacheId ? `${this.expressionMap.cacheId}-pagination` : this.expressionMap.cache, this.expressionMap.cacheDuration).setParameters(this.getParameters()).setNativeParameters(this.expressionMap.nativeParameters).getRawMany();\n      if (rawResults.length > 0) {\n        let condition = \"\";\n        const parameters = {};\n        if (metadata.hasMultiplePrimaryKeys) {\n          condition = rawResults.map((result, index) => {\n            return metadata.primaryColumns.map(primaryColumn => {\n              const paramKey = `orm_distinct_ids_${index}_${primaryColumn.databaseName}`;\n              const paramKeyResult = DriverUtils.buildAlias(this.connection.driver, undefined, \"ids_\" + mainAliasName, primaryColumn.databaseName);\n              parameters[paramKey] = result[paramKeyResult];\n              return `${mainAliasName}.${primaryColumn.propertyPath}=:${paramKey}`;\n            }).join(\" AND \");\n          }).join(\" OR \");\n        } else {\n          const alias = DriverUtils.buildAlias(this.connection.driver, undefined, \"ids_\" + mainAliasName, metadata.primaryColumns[0].databaseName);\n          const ids = rawResults.map(result => result[alias]);\n          const areAllNumbers = ids.every(id => typeof id === \"number\");\n          if (areAllNumbers) {\n            // fixes #190. if all numbers then its safe to perform query without parameter\n            condition = `${mainAliasName}.${metadata.primaryColumns[0].propertyPath} IN (${ids.join(\", \")})`;\n          } else {\n            parameters[\"orm_distinct_ids\"] = ids;\n            condition = mainAliasName + \".\" + metadata.primaryColumns[0].propertyPath + \" IN (:...orm_distinct_ids)\";\n          }\n        }\n        rawResults = await this.clone().mergeExpressionMap({\n          extraAppendedAndWhereCondition: condition\n        }).setParameters(parameters).loadRawResults(queryRunner);\n      }\n    } else {\n      rawResults = await this.loadRawResults(queryRunner);\n    }\n    if (rawResults.length > 0) {\n      // transform raw results into entities\n      const rawRelationIdResults = await relationIdLoader.load(rawResults);\n      const rawRelationCountResults = await relationCountLoader.load(rawResults);\n      const transformer = new RawSqlResultsToEntityTransformer(this.expressionMap, this.connection.driver, rawRelationIdResults, rawRelationCountResults, this.queryRunner);\n      entities = transformer.transform(rawResults, this.expressionMap.mainAlias);\n      // broadcast all \"after load\" events\n      if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {\n        await queryRunner.broadcaster.broadcast(\"Load\", this.expressionMap.mainAlias.metadata, entities);\n      }\n    }\n    if (this.expressionMap.relationLoadStrategy === \"query\") {\n      const queryStrategyRelationIdLoader = new QueryStrategyRelationIdLoader(this.connection, queryRunner);\n      await Promise.all(this.relationMetadatas.map(async relation => {\n        const relationTarget = relation.inverseEntityMetadata.target;\n        const relationAlias = relation.inverseEntityMetadata.targetName;\n        const select = Array.isArray(this.findOptions.select) ? OrmUtils.propertyPathsToTruthyObject(this.findOptions.select) : this.findOptions.select;\n        const relations = Array.isArray(this.findOptions.relations) ? OrmUtils.propertyPathsToTruthyObject(this.findOptions.relations) : this.findOptions.relations;\n        const queryBuilder = this.createQueryBuilder(queryRunner).select(relationAlias).from(relationTarget, relationAlias).setFindOptions({\n          select: select ? OrmUtils.deepValue(select, relation.propertyPath) : undefined,\n          order: this.findOptions.order ? OrmUtils.deepValue(this.findOptions.order, relation.propertyPath) : undefined,\n          relations: relations ? OrmUtils.deepValue(relations, relation.propertyPath) : undefined,\n          withDeleted: this.findOptions.withDeleted,\n          relationLoadStrategy: this.findOptions.relationLoadStrategy\n        });\n        if (entities.length > 0) {\n          const relatedEntityGroups = await queryStrategyRelationIdLoader.loadManyToManyRelationIdsAndGroup(relation, entities, undefined, queryBuilder);\n          entities.forEach(entity => {\n            const relatedEntityGroup = relatedEntityGroups.find(group => group.entity === entity);\n            if (relatedEntityGroup) {\n              const value = relatedEntityGroup.related === undefined ? null : relatedEntityGroup.related;\n              relation.setEntityValue(entity, value);\n            }\n          });\n        }\n      }));\n    }\n    return {\n      raw: rawResults,\n      entities: entities\n    };\n  }\n  createOrderByCombinedWithSelectExpression(parentAlias) {\n    // if table has a default order then apply it\n    const orderBys = this.expressionMap.allOrderBys;\n    const selectString = Object.keys(orderBys).map(orderCriteria => {\n      if (orderCriteria.indexOf(\".\") !== -1) {\n        const criteriaParts = orderCriteria.split(\".\");\n        const aliasName = criteriaParts[0];\n        const propertyPath = criteriaParts.slice(1).join(\".\");\n        const alias = this.expressionMap.findAliasByName(aliasName);\n        const column = alias.metadata.findColumnWithPropertyPath(propertyPath);\n        return this.escape(parentAlias) + \".\" + this.escape(DriverUtils.buildAlias(this.connection.driver, undefined, aliasName, column.databaseName));\n      } else {\n        if (this.expressionMap.selects.find(select => select.selection === orderCriteria || select.aliasName === orderCriteria)) return this.escape(parentAlias) + \".\" + this.escape(orderCriteria);\n        return \"\";\n      }\n    }).join(\", \");\n    const orderByObject = {};\n    Object.keys(orderBys).forEach(orderCriteria => {\n      if (orderCriteria.indexOf(\".\") !== -1) {\n        const criteriaParts = orderCriteria.split(\".\");\n        const aliasName = criteriaParts[0];\n        const propertyPath = criteriaParts.slice(1).join(\".\");\n        const alias = this.expressionMap.findAliasByName(aliasName);\n        const column = alias.metadata.findColumnWithPropertyPath(propertyPath);\n        orderByObject[this.escape(parentAlias) + \".\" + this.escape(DriverUtils.buildAlias(this.connection.driver, undefined, aliasName, column.databaseName))] = orderBys[orderCriteria];\n      } else {\n        if (this.expressionMap.selects.find(select => select.selection === orderCriteria || select.aliasName === orderCriteria)) {\n          orderByObject[this.escape(parentAlias) + \".\" + this.escape(orderCriteria)] = orderBys[orderCriteria];\n        } else {\n          orderByObject[orderCriteria] = orderBys[orderCriteria];\n        }\n      }\n    });\n    return [selectString, orderByObject];\n  }\n  /**\n   * Loads raw results from the database.\n   */\n  async loadRawResults(queryRunner) {\n    const [sql, parameters] = this.getQueryAndParameters();\n    const queryId = sql + \" -- PARAMETERS: \" + JSON.stringify(parameters, (_, value) => typeof value === \"bigint\" ? value.toString() : value);\n    const cacheOptions = typeof this.connection.options.cache === \"object\" ? this.connection.options.cache : {};\n    let savedQueryResultCacheOptions = undefined;\n    const isCachingEnabled =\n    // Caching is enabled globally and isn't disabled locally.\n    cacheOptions.alwaysEnabled && this.expressionMap.cache !== false ||\n    // ...or it's enabled locally explicitly.\n    this.expressionMap.cache === true;\n    let cacheError = false;\n    if (this.connection.queryResultCache && isCachingEnabled) {\n      try {\n        savedQueryResultCacheOptions = await this.connection.queryResultCache.getFromCache({\n          identifier: this.expressionMap.cacheId,\n          query: queryId,\n          duration: this.expressionMap.cacheDuration || cacheOptions.duration || 1000\n        }, queryRunner);\n        if (savedQueryResultCacheOptions && !this.connection.queryResultCache.isExpired(savedQueryResultCacheOptions)) {\n          return JSON.parse(savedQueryResultCacheOptions.result);\n        }\n      } catch (error) {\n        if (!cacheOptions.ignoreErrors) {\n          throw error;\n        }\n        cacheError = true;\n      }\n    }\n    const results = await queryRunner.query(sql, parameters, true);\n    if (!cacheError && this.connection.queryResultCache && isCachingEnabled) {\n      try {\n        await this.connection.queryResultCache.storeInCache({\n          identifier: this.expressionMap.cacheId,\n          query: queryId,\n          time: new Date().getTime(),\n          duration: this.expressionMap.cacheDuration || cacheOptions.duration || 1000,\n          result: JSON.stringify(results.records)\n        }, savedQueryResultCacheOptions, queryRunner);\n      } catch (error) {\n        if (!cacheOptions.ignoreErrors) {\n          throw error;\n        }\n      }\n    }\n    return results.records;\n  }\n  /**\n   * Merges into expression map given expression map properties.\n   */\n  mergeExpressionMap(expressionMap) {\n    ObjectUtils.assign(this.expressionMap, expressionMap);\n    return this;\n  }\n  /**\n   * Normalizes a give number - converts to int if possible.\n   */\n  normalizeNumber(num) {\n    if (typeof num === \"number\" || num === undefined || num === null) return num;\n    return Number(num);\n  }\n  /**\n   * Creates a query builder used to execute sql queries inside this query builder.\n   */\n  obtainQueryRunner() {\n    return this.queryRunner || this.connection.createQueryRunner(this.connection.defaultReplicationModeForReads());\n  }\n  buildSelect(select, metadata, alias, embedPrefix) {\n    for (let key in select) {\n      if (select[key] === undefined || select[key] === false) continue;\n      const propertyPath = embedPrefix ? embedPrefix + \".\" + key : key;\n      const column = metadata.findColumnWithPropertyPathStrict(propertyPath);\n      const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);\n      const relation = metadata.findRelationWithPropertyPath(propertyPath);\n      if (!embed && !column && !relation) throw new EntityPropertyNotFoundError(propertyPath, metadata);\n      if (column) {\n        this.selects.push(alias + \".\" + propertyPath);\n        // this.addSelect(alias + \".\" + propertyPath);\n      } else if (embed) {\n        this.buildSelect(select[key], metadata, alias, propertyPath);\n        // } else if (relation) {\n        //     const joinAlias = alias + \"_\" + relation.propertyName;\n        //     const existJoin = this.joins.find(join => join.alias === joinAlias);\n        //     if (!existJoin) {\n        //         this.joins.push({\n        //             type: \"left\",\n        //             select: false,\n        //             alias: joinAlias,\n        //             parentAlias: alias,\n        //             relationMetadata: relation\n        //         });\n        //     }\n        //     this.buildOrder(select[key] as FindOptionsOrder<any>, relation.inverseEntityMetadata, joinAlias);\n      }\n    }\n  }\n  buildRelations(relations, selection, metadata, alias, embedPrefix) {\n    if (!relations) return;\n    Object.keys(relations).forEach(relationName => {\n      const relationValue = relations[relationName];\n      const propertyPath = embedPrefix ? embedPrefix + \".\" + relationName : relationName;\n      const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);\n      const relation = metadata.findRelationWithPropertyPath(propertyPath);\n      if (!embed && !relation) throw new EntityPropertyNotFoundError(propertyPath, metadata);\n      if (embed) {\n        this.buildRelations(relationValue, typeof selection === \"object\" ? OrmUtils.deepValue(selection, embed.propertyPath) : undefined, metadata, alias, propertyPath);\n      } else if (relation) {\n        let joinAlias = alias + \"_\" + propertyPath.replace(\".\", \"_\");\n        joinAlias = DriverUtils.buildAlias(this.connection.driver, {\n          joiner: \"__\"\n        }, alias, joinAlias);\n        if (relationValue === true || typeof relationValue === \"object\") {\n          if (this.expressionMap.relationLoadStrategy === \"query\") {\n            this.concatRelationMetadata(relation);\n          } else {\n            // join\n            this.joins.push({\n              type: \"left\",\n              select: true,\n              selection: selection && typeof selection[relationName] === \"object\" ? selection[relationName] : undefined,\n              alias: joinAlias,\n              parentAlias: alias,\n              relationMetadata: relation\n            });\n            if (selection && typeof selection[relationName] === \"object\") {\n              this.buildSelect(selection[relationName], relation.inverseEntityMetadata, joinAlias);\n            }\n          }\n        }\n        if (typeof relationValue === \"object\" && this.expressionMap.relationLoadStrategy === \"join\") {\n          this.buildRelations(relationValue, typeof selection === \"object\" ? OrmUtils.deepValue(selection, relation.propertyPath) : undefined, relation.inverseEntityMetadata, joinAlias, undefined);\n        }\n      }\n    });\n  }\n  buildEagerRelations(relations, selection, metadata, alias, embedPrefix) {\n    if (!relations) return;\n    Object.keys(relations).forEach(relationName => {\n      const relationValue = relations[relationName];\n      const propertyPath = embedPrefix ? embedPrefix + \".\" + relationName : relationName;\n      const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);\n      const relation = metadata.findRelationWithPropertyPath(propertyPath);\n      if (!embed && !relation) throw new EntityPropertyNotFoundError(propertyPath, metadata);\n      if (embed) {\n        this.buildEagerRelations(relationValue, typeof selection === \"object\" ? OrmUtils.deepValue(selection, embed.propertyPath) : undefined, metadata, alias, propertyPath);\n      } else if (relation) {\n        let joinAlias = alias + \"_\" + propertyPath.replace(\".\", \"_\");\n        joinAlias = DriverUtils.buildAlias(this.connection.driver, {\n          joiner: \"__\"\n        }, alias, joinAlias);\n        if (relationValue === true || typeof relationValue === \"object\") {\n          relation.inverseEntityMetadata.eagerRelations.forEach(eagerRelation => {\n            let eagerRelationJoinAlias = joinAlias + \"_\" + eagerRelation.propertyPath.replace(\".\", \"_\");\n            eagerRelationJoinAlias = DriverUtils.buildAlias(this.connection.driver, {\n              joiner: \"__\"\n            }, joinAlias, eagerRelationJoinAlias);\n            const existJoin = this.joins.find(join => join.alias === eagerRelationJoinAlias);\n            if (!existJoin) {\n              this.joins.push({\n                type: \"left\",\n                select: true,\n                alias: eagerRelationJoinAlias,\n                parentAlias: joinAlias,\n                selection: undefined,\n                relationMetadata: eagerRelation\n              });\n            }\n            if (selection && typeof selection[relationName] === \"object\") {\n              this.buildSelect(selection[relationName], relation.inverseEntityMetadata, joinAlias);\n            }\n          });\n        }\n        if (typeof relationValue === \"object\") {\n          this.buildEagerRelations(relationValue, typeof selection === \"object\" ? OrmUtils.deepValue(selection, relation.propertyPath) : undefined, relation.inverseEntityMetadata, joinAlias, undefined);\n        }\n      }\n    });\n  }\n  buildOrder(order, metadata, alias, embedPrefix) {\n    for (let key in order) {\n      if (order[key] === undefined) continue;\n      const propertyPath = embedPrefix ? embedPrefix + \".\" + key : key;\n      const column = metadata.findColumnWithPropertyPathStrict(propertyPath);\n      const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);\n      const relation = metadata.findRelationWithPropertyPath(propertyPath);\n      if (!embed && !column && !relation) throw new EntityPropertyNotFoundError(propertyPath, metadata);\n      if (column) {\n        let direction = typeof order[key] === \"object\" ? order[key].direction : order[key];\n        direction = direction === \"DESC\" || direction === \"desc\" || direction === -1 ? \"DESC\" : \"ASC\";\n        let nulls = typeof order[key] === \"object\" ? order[key].nulls : undefined;\n        nulls = nulls?.toLowerCase() === \"first\" ? \"NULLS FIRST\" : nulls?.toLowerCase() === \"last\" ? \"NULLS LAST\" : undefined;\n        let aliasPath = `${alias}.${propertyPath}`;\n        // const selection = this.expressionMap.selects.find(\n        //     (s) => s.selection === aliasPath,\n        // )\n        // if (selection) {\n        //     // this is not building correctly now???\n        //     aliasPath = this.escape(\n        //         DriverUtils.buildAlias(\n        //             this.connection.driver,\n        //             undefined,\n        //             alias,\n        //             column.databaseName,\n        //         ),\n        //     )\n        //     // selection.aliasName = aliasPath\n        // } else {\n        //     if (column.isVirtualProperty && column.query) {\n        //         aliasPath = `(${column.query(alias)})`\n        //     }\n        // }\n        // console.log(\"add sort\", selection, aliasPath, direction, nulls)\n        this.addOrderBy(aliasPath, direction, nulls);\n        // this.orderBys.push({ alias: alias + \".\" + propertyPath, direction, nulls });\n      } else if (embed) {\n        this.buildOrder(order[key], metadata, alias, propertyPath);\n      } else if (relation) {\n        let joinAlias = alias + \"_\" + propertyPath.replace(\".\", \"_\");\n        joinAlias = DriverUtils.buildAlias(this.connection.driver, {\n          joiner: \"__\"\n        }, alias, joinAlias);\n        // console.log(\"joinAlias\", joinAlias, joinAlias.length, this.connection.driver.maxAliasLength)\n        // todo: use expressionMap.joinAttributes, and create a new one using\n        //  const joinAttribute = new JoinAttribute(this.connection, this.expressionMap);\n        const existJoin = this.joins.find(join => join.alias === joinAlias);\n        if (!existJoin) {\n          this.joins.push({\n            type: \"left\",\n            select: false,\n            alias: joinAlias,\n            parentAlias: alias,\n            selection: undefined,\n            relationMetadata: relation\n          });\n        }\n        this.buildOrder(order[key], relation.inverseEntityMetadata, joinAlias);\n      }\n    }\n  }\n  buildWhere(where, metadata, alias, embedPrefix) {\n    let condition = \"\";\n    // let parameterIndex = Object.keys(this.expressionMap.nativeParameters).length;\n    if (Array.isArray(where)) {\n      if (where.length) {\n        condition = where.map(whereItem => {\n          return this.buildWhere(whereItem, metadata, alias, embedPrefix);\n        }).filter(condition => !!condition).map(condition => \"(\" + condition + \")\").join(\" OR \");\n      }\n    } else {\n      let andConditions = [];\n      for (let key in where) {\n        if (where[key] === undefined || where[key] === null) continue;\n        const propertyPath = embedPrefix ? embedPrefix + \".\" + key : key;\n        const column = metadata.findColumnWithPropertyPathStrict(propertyPath);\n        const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);\n        const relation = metadata.findRelationWithPropertyPath(propertyPath);\n        if (!embed && !column && !relation) throw new EntityPropertyNotFoundError(propertyPath, metadata);\n        if (column) {\n          let aliasPath = `${alias}.${propertyPath}`;\n          if (column.isVirtualProperty && column.query) {\n            aliasPath = `(${column.query(alias)})`;\n          }\n          // const parameterName = alias + \"_\" + propertyPath.split(\".\").join(\"_\") + \"_\" + parameterIndex;\n          // todo: we need to handle other operators as well?\n          let parameterValue = where[key];\n          if (InstanceChecker.isEqualOperator(where[key])) {\n            parameterValue = where[key].value;\n          }\n          if (column.transformer) {\n            parameterValue instanceof FindOperator ? parameterValue.transformValue(column.transformer) : parameterValue = ApplyValueTransformers.transformTo(column.transformer, parameterValue);\n          }\n          // if (parameterValue === null) {\n          //     andConditions.push(`${aliasPath} IS NULL`);\n          //\n          // } else if (parameterValue instanceof FindOperator) {\n          //     // let parameters: any[] = [];\n          //     // if (parameterValue.useParameter) {\n          //     //     const realParameterValues: any[] = parameterValue.multipleParameters ? parameterValue.value : [parameterValue.value];\n          //     //     realParameterValues.forEach((realParameterValue, realParameterValueIndex) => {\n          //     //\n          //     //         // don't create parameters for number to prevent max number of variables issues as much as possible\n          //     //         if (typeof realParameterValue === \"number\") {\n          //     //             parameters.push(realParameterValue);\n          //     //\n          //     //         } else {\n          //     //             this.expressionMap.nativeParameters[parameterName + realParameterValueIndex] = realParameterValue;\n          //     //             parameterIndex++;\n          //     //             parameters.push(this.connection.driver.createParameter(parameterName + realParameterValueIndex, parameterIndex - 1));\n          //     //         }\n          //     //     });\n          //     // }\n          //     andConditions.push(\n          //         this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, parameterValue))\n          //         // parameterValue.toSql(this.connection, aliasPath, parameters));\n          //     )\n          //\n          // } else {\n          //     this.expressionMap.nativeParameters[parameterName] = parameterValue;\n          //     parameterIndex++;\n          //     const parameter = this.connection.driver.createParameter(parameterName, parameterIndex - 1);\n          //     andConditions.push(`${aliasPath} = ${parameter}`);\n          // }\n          andConditions.push(this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, parameterValue)));\n          // this.conditions.push(`${alias}.${propertyPath} = :${paramName}`);\n          // this.expressionMap.parameters[paramName] = where[key]; // todo: handle functions and other edge cases\n        } else if (embed) {\n          const condition = this.buildWhere(where[key], metadata, alias, propertyPath);\n          if (condition) andConditions.push(condition);\n        } else if (relation) {\n          // if all properties of where are undefined we don't need to join anything\n          // this can happen when user defines map with conditional queries inside\n          if (typeof where[key] === \"object\") {\n            const allAllUndefined = Object.keys(where[key]).every(k => where[key][k] === undefined);\n            if (allAllUndefined) {\n              continue;\n            }\n          }\n          if (InstanceChecker.isFindOperator(where[key])) {\n            if (where[key].type === \"moreThan\" || where[key].type === \"lessThan\" || where[key].type === \"moreThanOrEqual\" || where[key].type === \"lessThanOrEqual\") {\n              let sqlOperator = \"\";\n              if (where[key].type === \"moreThan\") {\n                sqlOperator = \">\";\n              } else if (where[key].type === \"lessThan\") {\n                sqlOperator = \"<\";\n              } else if (where[key].type === \"moreThanOrEqual\") {\n                sqlOperator = \">=\";\n              } else if (where[key].type === \"lessThanOrEqual\") {\n                sqlOperator = \"<=\";\n              }\n              // basically relation count functionality\n              const qb = this.subQuery();\n              if (relation.isManyToManyOwner) {\n                qb.select(\"COUNT(*)\").from(relation.joinTableName, relation.joinTableName).where(relation.joinColumns.map(column => {\n                  return `${relation.joinTableName}.${column.propertyName} = ${alias}.${column.referencedColumn.propertyName}`;\n                }).join(\" AND \"));\n              } else if (relation.isManyToManyNotOwner) {\n                qb.select(\"COUNT(*)\").from(relation.inverseRelation.joinTableName, relation.inverseRelation.joinTableName).where(relation.inverseRelation.inverseJoinColumns.map(column => {\n                  return `${relation.inverseRelation.joinTableName}.${column.propertyName} = ${alias}.${column.referencedColumn.propertyName}`;\n                }).join(\" AND \"));\n              } else if (relation.isOneToMany) {\n                qb.select(\"COUNT(*)\").from(relation.inverseEntityMetadata.target, relation.inverseEntityMetadata.tableName).where(relation.inverseRelation.joinColumns.map(column => {\n                  return `${relation.inverseEntityMetadata.tableName}.${column.propertyName} = ${alias}.${column.referencedColumn.propertyName}`;\n                }).join(\" AND \"));\n              } else {\n                throw new Error(`This relation isn't supported by given find operator`);\n              }\n              // this\n              //     .addSelect(qb.getSql(), relation.propertyAliasName + \"_cnt\")\n              //     .andWhere(this.escape(relation.propertyAliasName + \"_cnt\") + \" \" + sqlOperator + \" \" + parseInt(where[key].value));\n              this.andWhere(qb.getSql() + \" \" + sqlOperator + \" \" + parseInt(where[key].value));\n            } else {\n              if (relation.isManyToOne || relation.isOneToOne && relation.isOneToOneOwner) {\n                const aliasPath = `${alias}.${propertyPath}`;\n                andConditions.push(this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, where[key])));\n              } else {\n                throw new Error(`This relation isn't supported by given find operator`);\n              }\n            }\n          } else {\n            // const joinAlias = alias + \"_\" + relation.propertyName;\n            let joinAlias = alias + \"_\" + relation.propertyPath.replace(\".\", \"_\");\n            joinAlias = DriverUtils.buildAlias(this.connection.driver, {\n              joiner: \"__\"\n            }, alias, joinAlias);\n            const existJoin = this.joins.find(join => join.alias === joinAlias);\n            if (!existJoin) {\n              this.joins.push({\n                type: \"left\",\n                select: false,\n                selection: undefined,\n                alias: joinAlias,\n                parentAlias: alias,\n                relationMetadata: relation\n              });\n            }\n            const condition = this.buildWhere(where[key], relation.inverseEntityMetadata, joinAlias);\n            if (condition) {\n              andConditions.push(condition);\n              // parameterIndex = Object.keys(this.expressionMap.nativeParameters).length;\n            }\n          }\n        }\n      }\n      condition = andConditions.length ? \"(\" + andConditions.join(\") AND (\") + \")\" : andConditions.join(\" AND \");\n    }\n    return condition.length ? \"(\" + condition + \")\" : condition;\n  }\n}","map":{"version":3,"names":["RawSqlResultsToEntityTransformer","PessimisticLockTransactionRequiredError","NoVersionOrUpdateDateColumnError","OptimisticLockVersionMismatchError","OptimisticLockCanNotBeUsedError","JoinAttribute","RelationIdAttribute","RelationCountAttribute","RelationIdLoader","QueryStrategyRelationIdLoader","RelationIdMetadataToAttributeTransformer","RelationCountLoader","RelationCountMetadataToAttributeTransformer","QueryBuilder","LockNotSupportedOnGivenDriverError","OffsetWithoutLimitNotSupportedError","ObjectUtils","DriverUtils","EntityNotFoundError","TypeORMError","FindOptionsUtils","OrmUtils","EntityPropertyNotFoundError","InstanceChecker","FindOperator","ApplyValueTransformers","SelectQueryBuilder","constructor","Symbol","for","findOptions","selects","joins","conditions","orderBys","relationMetadatas","getQuery","sql","createComment","createCteExpression","createSelectExpression","createJoinExpression","createWhereExpression","createGroupByExpression","createHavingExpression","createOrderByExpression","createLimitOffsetExpression","createLockExpression","trim","expressionMap","subQuery","replacePropertyNamesForTheWholeQuery","setFindOptions","applyFindOptions","qb","createQueryBuilder","parentQueryBuilder","select","selection","selectionAliasName","queryType","Array","isArray","map","subQueryBuilder","setParameters","getParameters","push","aliasName","addSelect","concat","maxExecutionTime","milliseconds","distinct","selectDistinct","distinctOn","selectDistinctOn","fromDummy","from","connection","driver","dummyTableName","entityTarget","mainAlias","createFromAlias","setMainAlias","addFrom","alias","innerJoin","entityOrProperty","condition","parameters","join","leftJoin","innerJoinAndSelect","leftJoinAndSelect","innerJoinAndMapMany","mapToProperty","innerJoinAndMapOne","mapAsEntity","leftJoinAndMapMany","leftJoinAndMapOne","loadRelationIdAndMap","relationName","aliasNameOrOptions","queryBuilderFactory","relationIdAttribute","disableMixedMap","relationIdAttributes","relation","junctionEntityMetadata","createAlias","type","name","junctionAlias","metadata","loadRelationCountAndMap","relationCountAttribute","relationCountAttributes","loadAllRelationIds","options","relations","forEach","undefined","indexOf","propertyPath","where","wheres","getWhereCondition","andWhere","orWhere","whereExists","getExistsCondition","andWhereExists","orWhereExists","whereInIds","ids","getWhereInIdsCondition","andWhereInIds","orWhereInIds","having","havings","andHaving","orHaving","groupBy","groupBys","addGroupBy","timeTravelQuery","timeTravelFn","timeTravel","orderBy","sort","order","nulls","addOrderBy","limit","normalizeNumber","isNaN","offset","take","skip","useIndex","index","setLock","lockMode","lockVersion","lockTables","setOnLocked","onLocked","withDeleted","getRawOne","getRawMany","queryEntity","queryRunner","obtainQueryRunner","transactionStartedByUs","useTransaction","isTransactionActive","startTransaction","results","loadRawResults","commitTransaction","error","rollbackTransaction","rollbackError","release","getRawAndEntities","executeEntitiesAndRawResults","getOne","result","entities","Date","actualVersion","updateDateColumn","getEntityValue","getTime","versionColumn","getOneOrFail","entity","target","getMany","getCount","executeCountQuery","getExists","executeExistsQuery","getManyAndCount","entitiesAndRaw","cacheId","count","stream","getQueryAndParameters","releaseFn","cache","enabledOrMillisecondsOrId","maybeMilliseconds","cacheDuration","setOption","option","direction","isMappingMany","joinAttribute","joinAttributes","joinAttributeMetadata","deleteDateColumn","conditionDeleteColumn","propertyName","isSubQuery","substr","tablePath","allSelects","excludedSelects","hasMetadata","buildEscapedEntityColumnSelects","findEntityColumnSelects","hasMainAlias","some","escape","excludedSelect","find","filter","replacePropertyNames","length","isMySQLFamily","froms","aliases","getTableName","createSelectDistinctExpression","createTableLockExpression","isPostgresFamily","selectDistinctOnMap","on","joinAttr","destinationTableName","destinationTableAlias","appendedCondition","parentAlias","destinationJoin","isManyToOne","isOneToOneOwner","joinColumns","joinColumn","referencedColumn","isOneToMany","isOneToOneNotOwner","inverseRelation","inverseEntityMetadata","tableType","discriminatorColumn","databaseName","discriminatorValue","entityMetadata","junctionTableName","junctionCondition","destinationCondition","isOwning","inverseJoinColumns","allOrderBys","Object","keys","columnName","orderValue","s","criteriaParts","split","slice","column","findColumnWithPropertyPath","orderAlias","buildAlias","prefix","isSQLiteFamily","lockTablesClause","onLockExpression","isReleaseVersionOrGreater","columns","isSelect","nonSelectedPrimaryColumns","primaryColumns","primaryColumn","allColumns","finalSelects","escapedAliasName","selectionPath","isVirtualProperty","query","spatialTypes","useLegacy","legacySpatialSupport","asText","precision","selections","virtual","mainSelect","computeCountExpression","distinctAlias","c","columnsExpression","countSql","clone","parseInt","relationLoadStrategy","comment","propertyPathsToTruthyObject","buildSelect","buildRelations","loadEagerRelations","buildEagerRelations","buildWhere","buildOrder","relationMetadata","id","key","lock","mode","version","tableNames","tables","table","tableAlias","tableNameWithoutPrefix","loadRelationIds","joinEagerRelations","transaction","concatRelationMetadata","relationIdLoader","relationCountLoader","relationIdMetadataTransformer","transform","relationCountMetadataTransformer","rawResults","createOrderByCombinedWithSelectExpression","mainAliasName","querySelects","columnAlias","originalQuery","originalQueryTimeTravel","setNativeParameters","nativeParameters","hasMultiplePrimaryKeys","paramKey","paramKeyResult","areAllNumbers","every","mergeExpressionMap","extraAppendedAndWhereCondition","rawRelationIdResults","load","rawRelationCountResults","transformer","callListeners","broadcaster","broadcast","queryStrategyRelationIdLoader","Promise","all","relationTarget","relationAlias","targetName","queryBuilder","deepValue","relatedEntityGroups","loadManyToManyRelationIdsAndGroup","relatedEntityGroup","group","value","related","setEntityValue","raw","selectString","orderCriteria","findAliasByName","orderByObject","queryId","JSON","stringify","_","toString","cacheOptions","savedQueryResultCacheOptions","isCachingEnabled","alwaysEnabled","cacheError","queryResultCache","getFromCache","identifier","duration","isExpired","parse","ignoreErrors","storeInCache","time","records","assign","num","Number","createQueryRunner","defaultReplicationModeForReads","embedPrefix","findColumnWithPropertyPathStrict","embed","findEmbeddedWithPropertyPath","findRelationWithPropertyPath","relationValue","joinAlias","replace","joiner","eagerRelations","eagerRelation","eagerRelationJoinAlias","existJoin","toLowerCase","aliasPath","whereItem","andConditions","parameterValue","isEqualOperator","transformValue","transformTo","createWhereConditionExpression","getWherePredicateCondition","allAllUndefined","k","isFindOperator","sqlOperator","isManyToManyOwner","joinTableName","isManyToManyNotOwner","tableName","Error","getSql","isOneToOne"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\query-builder\\SelectQueryBuilder.ts"],"sourcesContent":["import { RawSqlResultsToEntityTransformer } from \"./transformer/RawSqlResultsToEntityTransformer\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { PessimisticLockTransactionRequiredError } from \"../error/PessimisticLockTransactionRequiredError\"\nimport { NoVersionOrUpdateDateColumnError } from \"../error/NoVersionOrUpdateDateColumnError\"\nimport { OptimisticLockVersionMismatchError } from \"../error/OptimisticLockVersionMismatchError\"\nimport { OptimisticLockCanNotBeUsedError } from \"../error/OptimisticLockCanNotBeUsedError\"\nimport { JoinAttribute } from \"./JoinAttribute\"\nimport { RelationIdAttribute } from \"./relation-id/RelationIdAttribute\"\nimport { RelationCountAttribute } from \"./relation-count/RelationCountAttribute\"\nimport { RelationIdLoader } from \"./relation-id/RelationIdLoader\"\nimport { RelationIdLoader as QueryStrategyRelationIdLoader } from \"./RelationIdLoader\"\nimport { RelationIdMetadataToAttributeTransformer } from \"./relation-id/RelationIdMetadataToAttributeTransformer\"\nimport { RelationCountLoader } from \"./relation-count/RelationCountLoader\"\nimport { RelationCountMetadataToAttributeTransformer } from \"./relation-count/RelationCountMetadataToAttributeTransformer\"\nimport { QueryBuilder } from \"./QueryBuilder\"\nimport { ReadStream } from \"../platform/PlatformTools\"\nimport { LockNotSupportedOnGivenDriverError } from \"../error/LockNotSupportedOnGivenDriverError\"\nimport { MysqlDriver } from \"../driver/mysql/MysqlDriver\"\nimport { SelectQuery } from \"./SelectQuery\"\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { OrderByCondition } from \"../find-options/OrderByCondition\"\nimport { QueryExpressionMap } from \"./QueryExpressionMap\"\nimport { EntityTarget } from \"../common/EntityTarget\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { WhereExpressionBuilder } from \"./WhereExpressionBuilder\"\nimport { Brackets } from \"./Brackets\"\nimport { QueryResultCacheOptions } from \"../cache/QueryResultCacheOptions\"\nimport { OffsetWithoutLimitNotSupportedError } from \"../error/OffsetWithoutLimitNotSupportedError\"\nimport { SelectQueryBuilderOption } from \"./SelectQueryBuilderOption\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\nimport { EntityNotFoundError } from \"../error/EntityNotFoundError\"\nimport { TypeORMError } from \"../error\"\nimport { FindManyOptions } from \"../find-options/FindManyOptions\"\nimport { FindOptionsSelect } from \"../find-options/FindOptionsSelect\"\nimport { RelationMetadata } from \"../metadata/RelationMetadata\"\nimport { FindOptionsOrder } from \"../find-options/FindOptionsOrder\"\nimport { FindOptionsWhere } from \"../find-options/FindOptionsWhere\"\nimport { FindOptionsUtils } from \"../find-options/FindOptionsUtils\"\nimport { FindOptionsRelations } from \"../find-options/FindOptionsRelations\"\nimport { OrmUtils } from \"../util/OrmUtils\"\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\"\nimport { AuroraMysqlDriver } from \"../driver/aurora-mysql/AuroraMysqlDriver\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\nimport { FindOperator } from \"../find-options/FindOperator\"\nimport { ApplyValueTransformers } from \"../util/ApplyValueTransformers\"\n\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class SelectQueryBuilder<Entity extends ObjectLiteral>\n    extends QueryBuilder<Entity>\n    implements WhereExpressionBuilder\n{\n    readonly \"@instanceof\" = Symbol.for(\"SelectQueryBuilder\")\n\n    protected findOptions: FindManyOptions = {}\n    protected selects: string[] = []\n    protected joins: {\n        type: \"inner\" | \"left\"\n        alias: string\n        parentAlias: string\n        relationMetadata: RelationMetadata\n        select: boolean\n        selection: FindOptionsSelect<any> | undefined\n    }[] = []\n    protected conditions: string = \"\"\n    protected orderBys: {\n        alias: string\n        direction: \"ASC\" | \"DESC\"\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\"\n    }[] = []\n    protected relationMetadatas: RelationMetadata[] = []\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets generated SQL query without parameters being replaced.\n     */\n    getQuery(): string {\n        let sql = this.createComment()\n        sql += this.createCteExpression()\n        sql += this.createSelectExpression()\n        sql += this.createJoinExpression()\n        sql += this.createWhereExpression()\n        sql += this.createGroupByExpression()\n        sql += this.createHavingExpression()\n        sql += this.createOrderByExpression()\n        sql += this.createLimitOffsetExpression()\n        sql += this.createLockExpression()\n        sql = sql.trim()\n        if (this.expressionMap.subQuery) sql = \"(\" + sql + \")\"\n        return this.replacePropertyNamesForTheWholeQuery(sql)\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    setFindOptions(findOptions: FindManyOptions<Entity>) {\n        this.findOptions = findOptions\n        this.applyFindOptions()\n        return this\n    }\n\n    /**\n     * Creates a subquery - query that can be used inside other queries.\n     */\n    subQuery(): SelectQueryBuilder<any> {\n        const qb = this.createQueryBuilder()\n        qb.expressionMap.subQuery = true\n        qb.parentQueryBuilder = this\n        return qb\n    }\n\n    /**\n     * Creates SELECT query.\n     * Replaces all previous selections if they exist.\n     */\n    select(): this\n\n    /**\n     * Creates SELECT query.\n     * Replaces all previous selections if they exist.\n     */\n    select(\n        selection: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>,\n        selectionAliasName?: string,\n    ): this\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(selection: string, selectionAliasName?: string): this\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(selection: string[]): this\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(\n        selection?:\n            | string\n            | string[]\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        selectionAliasName?: string,\n    ): SelectQueryBuilder<Entity> {\n        this.expressionMap.queryType = \"select\"\n        if (Array.isArray(selection)) {\n            this.expressionMap.selects = selection.map((selection) => ({\n                selection: selection,\n            }))\n        } else if (typeof selection === \"function\") {\n            const subQueryBuilder = selection(this.subQuery())\n            this.setParameters(subQueryBuilder.getParameters())\n            this.expressionMap.selects.push({\n                selection: subQueryBuilder.getQuery(),\n                aliasName: selectionAliasName,\n            })\n        } else if (selection) {\n            this.expressionMap.selects = [\n                { selection: selection, aliasName: selectionAliasName },\n            ]\n        }\n\n        return this\n    }\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(\n        selection: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>,\n        selectionAliasName?: string,\n    ): this\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(selection: string, selectionAliasName?: string): this\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(selection: string[]): this\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(\n        selection:\n            | string\n            | string[]\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        selectionAliasName?: string,\n    ): this {\n        if (!selection) return this\n\n        if (Array.isArray(selection)) {\n            this.expressionMap.selects = this.expressionMap.selects.concat(\n                selection.map((selection) => ({ selection: selection })),\n            )\n        } else if (typeof selection === \"function\") {\n            const subQueryBuilder = selection(this.subQuery())\n            this.setParameters(subQueryBuilder.getParameters())\n            this.expressionMap.selects.push({\n                selection: subQueryBuilder.getQuery(),\n                aliasName: selectionAliasName,\n            })\n        } else if (selection) {\n            this.expressionMap.selects.push({\n                selection: selection,\n                aliasName: selectionAliasName,\n            })\n        }\n\n        return this\n    }\n\n    /**\n     * Set max execution time.\n     * @param milliseconds\n     */\n    maxExecutionTime(milliseconds: number): this {\n        this.expressionMap.maxExecutionTime = milliseconds\n        return this\n    }\n\n    /**\n     * Sets whether the selection is DISTINCT.\n     */\n    distinct(distinct: boolean = true): this {\n        this.expressionMap.selectDistinct = distinct\n        return this\n    }\n\n    /**\n     * Sets the distinct on clause for Postgres.\n     */\n    distinctOn(distinctOn: string[]): this {\n        this.expressionMap.selectDistinctOn = distinctOn\n        return this\n    }\n\n    fromDummy(): SelectQueryBuilder<any> {\n        return this.from(\n            this.connection.driver.dummyTableName ??\n                \"(SELECT 1 AS dummy_column)\",\n            \"dummy_table\",\n        )\n    }\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     * Removes all previously set from-s.\n     */\n    from<T extends ObjectLiteral>(\n        entityTarget: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>,\n        aliasName: string,\n    ): SelectQueryBuilder<T>\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     * Removes all previously set from-s.\n     */\n    from<T extends ObjectLiteral>(\n        entityTarget: EntityTarget<T>,\n        aliasName: string,\n    ): SelectQueryBuilder<T>\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     * Removes all previously set from-s.\n     */\n    from<T extends ObjectLiteral>(\n        entityTarget:\n            | EntityTarget<T>\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        aliasName: string,\n    ): SelectQueryBuilder<T> {\n        const mainAlias = this.createFromAlias(entityTarget, aliasName)\n        this.expressionMap.setMainAlias(mainAlias)\n        return this as any as SelectQueryBuilder<T>\n    }\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    addFrom<T extends ObjectLiteral>(\n        entityTarget: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>,\n        aliasName: string,\n    ): SelectQueryBuilder<T>\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    addFrom<T extends ObjectLiteral>(\n        entityTarget: EntityTarget<T>,\n        aliasName: string,\n    ): SelectQueryBuilder<T>\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    addFrom<T extends ObjectLiteral>(\n        entityTarget:\n            | EntityTarget<T>\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        aliasName: string,\n    ): SelectQueryBuilder<T> {\n        const alias = this.createFromAlias(entityTarget, aliasName)\n        if (!this.expressionMap.mainAlias)\n            this.expressionMap.setMainAlias(alias)\n\n        return this as any as SelectQueryBuilder<T>\n    }\n\n    /**\n     * INNER JOINs (without selection) given subquery.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs (without selection) entity's property.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs (without selection) given entity's table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs (without selection) given table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs (without selection).\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this {\n        this.join(\"INNER\", entityOrProperty, alias, condition, parameters)\n        return this\n    }\n\n    /**\n     * LEFT JOINs (without selection) given subquery.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs (without selection) entity's property.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs (without selection) entity's table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs (without selection) given table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs (without selection).\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this {\n        this.join(\"LEFT\", entityOrProperty, alias, condition, parameters)\n        return this\n    }\n\n    /**\n     * INNER JOINs given subquery and adds all selection properties to SELECT..\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs entity's property and adds all selection properties to SELECT.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs entity and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs table and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this {\n        this.addSelect(alias)\n        this.innerJoin(entityOrProperty, alias, condition, parameters)\n        return this\n    }\n\n    /**\n     * LEFT JOINs given subquery and adds all selection properties to SELECT..\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs entity's property and adds all selection properties to SELECT.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs entity and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs table and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this {\n        this.addSelect(alias)\n        this.leftJoin(entityOrProperty, alias, condition, parameters)\n        return this\n    }\n\n    /**\n     * INNER JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(\n        mapToProperty: string,\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(\n        mapToProperty: string,\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(\n        mapToProperty: string,\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(\n        mapToProperty: string,\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(\n        mapToProperty: string,\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this {\n        this.addSelect(alias)\n        this.join(\n            \"INNER\",\n            entityOrProperty,\n            alias,\n            condition,\n            parameters,\n            mapToProperty,\n            true,\n        )\n        return this\n    }\n\n    /**\n     * INNER JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(\n        mapToProperty: string,\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n        mapAsEntity?: Function | string,\n    ): this\n\n    /**\n     * INNER JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(\n        mapToProperty: string,\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(\n        mapToProperty: string,\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(\n        mapToProperty: string,\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(\n        mapToProperty: string,\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n        mapAsEntity?: Function | string,\n    ): this {\n        this.addSelect(alias)\n        this.join(\n            \"INNER\",\n            entityOrProperty,\n            alias,\n            condition,\n            parameters,\n            mapToProperty,\n            false,\n            mapAsEntity,\n        )\n        return this\n    }\n\n    /**\n     * LEFT JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(\n        mapToProperty: string,\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(\n        mapToProperty: string,\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(\n        mapToProperty: string,\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(\n        mapToProperty: string,\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(\n        mapToProperty: string,\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this {\n        this.addSelect(alias)\n        this.join(\n            \"LEFT\",\n            entityOrProperty,\n            alias,\n            condition,\n            parameters,\n            mapToProperty,\n            true,\n        )\n        return this\n    }\n\n    /**\n     * LEFT JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(\n        mapToProperty: string,\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n        mapAsEntity?: Function | string,\n    ): this\n\n    /**\n     * LEFT JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(\n        mapToProperty: string,\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(\n        mapToProperty: string,\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(\n        mapToProperty: string,\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(\n        mapToProperty: string,\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n        mapAsEntity?: Function | string,\n    ): this {\n        this.addSelect(alias)\n        this.join(\n            \"LEFT\",\n            entityOrProperty,\n            alias,\n            condition,\n            parameters,\n            mapToProperty,\n            false,\n            mapAsEntity,\n        )\n        return this\n    }\n\n    /**\n     */\n    // selectAndMap(mapToProperty: string, property: string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this;\n\n    /**\n     */\n    // selectAndMap(mapToProperty: string, entity: Function|string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this;\n\n    /**\n     */\n    // selectAndMap(mapToProperty: string, tableName: string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this;\n\n    /**\n     */\n    // selectAndMap(mapToProperty: string, entityOrProperty: Function|string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this {\n    //     const select = new SelectAttribute(this.expressionMap);\n    //     select.mapToProperty = mapToProperty;\n    //     select.entityOrProperty = entityOrProperty;\n    //     select.aliasName = aliasName;\n    //     select.qbFactory = qbFactory;\n    //     return this;\n    // }\n\n    /**\n     * LEFT JOINs relation id and maps it into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationIdAndMap(\n        mapToProperty: string,\n        relationName: string,\n        options?: { disableMixedMap?: boolean },\n    ): this\n\n    /**\n     * LEFT JOINs relation id and maps it into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationIdAndMap(\n        mapToProperty: string,\n        relationName: string,\n        alias: string,\n        queryBuilderFactory: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n    ): this\n\n    /**\n     * LEFT JOINs relation id and maps it into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationIdAndMap(\n        mapToProperty: string,\n        relationName: string,\n        aliasNameOrOptions?: string | { disableMixedMap?: boolean },\n        queryBuilderFactory?: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n    ): this {\n        const relationIdAttribute = new RelationIdAttribute(this.expressionMap)\n        relationIdAttribute.mapToProperty = mapToProperty\n        relationIdAttribute.relationName = relationName\n        if (typeof aliasNameOrOptions === \"string\")\n            relationIdAttribute.alias = aliasNameOrOptions\n        if (\n            typeof aliasNameOrOptions === \"object\" &&\n            (aliasNameOrOptions as any).disableMixedMap\n        )\n            relationIdAttribute.disableMixedMap = true\n\n        relationIdAttribute.queryBuilderFactory = queryBuilderFactory\n        this.expressionMap.relationIdAttributes.push(relationIdAttribute)\n\n        if (relationIdAttribute.relation.junctionEntityMetadata) {\n            this.expressionMap.createAlias({\n                type: \"other\",\n                name: relationIdAttribute.junctionAlias,\n                metadata: relationIdAttribute.relation.junctionEntityMetadata,\n            })\n        }\n        return this\n    }\n\n    /**\n     * Counts number of entities of entity's relation and maps the value into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationCountAndMap(\n        mapToProperty: string,\n        relationName: string,\n        aliasName?: string,\n        queryBuilderFactory?: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n    ): this {\n        const relationCountAttribute = new RelationCountAttribute(\n            this.expressionMap,\n        )\n        relationCountAttribute.mapToProperty = mapToProperty\n        relationCountAttribute.relationName = relationName\n        relationCountAttribute.alias = aliasName\n        relationCountAttribute.queryBuilderFactory = queryBuilderFactory\n        this.expressionMap.relationCountAttributes.push(relationCountAttribute)\n\n        this.expressionMap.createAlias({\n            type: \"other\",\n            name: relationCountAttribute.junctionAlias,\n        })\n        if (relationCountAttribute.relation.junctionEntityMetadata) {\n            this.expressionMap.createAlias({\n                type: \"other\",\n                name: relationCountAttribute.junctionAlias,\n                metadata:\n                    relationCountAttribute.relation.junctionEntityMetadata,\n            })\n        }\n        return this\n    }\n\n    /**\n     * Loads all relation ids for all relations of the selected entity.\n     * All relation ids will be mapped to relation property themself.\n     * If array of strings is given then loads only relation ids of the given properties.\n     */\n    loadAllRelationIds(options?: {\n        relations?: string[]\n        disableMixedMap?: boolean\n    }): this {\n        // todo: add skip relations\n        this.expressionMap.mainAlias!.metadata.relations.forEach((relation) => {\n            if (\n                options !== undefined &&\n                options.relations !== undefined &&\n                options.relations.indexOf(relation.propertyPath) === -1\n            )\n                return\n\n            this.loadRelationIdAndMap(\n                this.expressionMap.mainAlias!.name +\n                    \".\" +\n                    relation.propertyPath,\n                this.expressionMap.mainAlias!.name +\n                    \".\" +\n                    relation.propertyPath,\n                options,\n            )\n        })\n        return this\n    }\n\n    /**\n     * Sets WHERE condition in the query builder.\n     * If you had previously WHERE expression defined,\n     * calling this function will override previously set WHERE conditions.\n     * Additionally you can add parameters used in where expression.\n     */\n    where(\n        where:\n            | Brackets\n            | string\n            | ((qb: this) => string)\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres = [] // don't move this block below since computeWhereParameter can add where expressions\n        const condition = this.getWhereCondition(where)\n        if (condition) {\n            this.expressionMap.wheres = [\n                { type: \"simple\", condition: condition },\n            ]\n        }\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new AND WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    andWhere(\n        where:\n            | string\n            | Brackets\n            | ((qb: this) => string)\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres.push({\n            type: \"and\",\n            condition: this.getWhereCondition(where),\n        })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new OR WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    orWhere(\n        where:\n            | Brackets\n            | string\n            | ((qb: this) => string)\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres.push({\n            type: \"or\",\n            condition: this.getWhereCondition(where),\n        })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Sets a new where EXISTS clause\n     */\n    whereExists(subQuery: SelectQueryBuilder<any>): this {\n        return this.where(...this.getExistsCondition(subQuery))\n    }\n\n    /**\n     * Adds a new AND where EXISTS clause\n     */\n    andWhereExists(subQuery: SelectQueryBuilder<any>): this {\n        return this.andWhere(...this.getExistsCondition(subQuery))\n    }\n\n    /**\n     * Adds a new OR where EXISTS clause\n     */\n    orWhereExists(subQuery: SelectQueryBuilder<any>): this {\n        return this.orWhere(...this.getExistsCondition(subQuery))\n    }\n\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     *\n     * Ids are mixed.\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n     * If you have multiple primary keys you need to pass object with property names and values specified,\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n     */\n    whereInIds(ids: any | any[]): this {\n        return this.where(this.getWhereInIdsCondition(ids))\n    }\n\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     *\n     * Ids are mixed.\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n     * If you have multiple primary keys you need to pass object with property names and values specified,\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n     */\n    andWhereInIds(ids: any | any[]): this {\n        return this.andWhere(this.getWhereInIdsCondition(ids))\n    }\n\n    /**\n     * Adds new OR WHERE with conditions for the given ids.\n     *\n     * Ids are mixed.\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n     * If you have multiple primary keys you need to pass object with property names and values specified,\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n     */\n    orWhereInIds(ids: any | any[]): this {\n        return this.orWhere(this.getWhereInIdsCondition(ids))\n    }\n\n    /**\n     * Sets HAVING condition in the query builder.\n     * If you had previously HAVING expression defined,\n     * calling this function will override previously set HAVING conditions.\n     * Additionally you can add parameters used in where expression.\n     */\n    having(having: string, parameters?: ObjectLiteral): this {\n        this.expressionMap.havings.push({ type: \"simple\", condition: having })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new AND HAVING condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    andHaving(having: string, parameters?: ObjectLiteral): this {\n        this.expressionMap.havings.push({ type: \"and\", condition: having })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new OR HAVING condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    orHaving(having: string, parameters?: ObjectLiteral): this {\n        this.expressionMap.havings.push({ type: \"or\", condition: having })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Sets GROUP BY condition in the query builder.\n     * If you had previously GROUP BY expression defined,\n     * calling this function will override previously set GROUP BY conditions.\n     */\n    groupBy(): this\n\n    /**\n     * Sets GROUP BY condition in the query builder.\n     * If you had previously GROUP BY expression defined,\n     * calling this function will override previously set GROUP BY conditions.\n     */\n    groupBy(groupBy: string): this\n\n    /**\n     * Sets GROUP BY condition in the query builder.\n     * If you had previously GROUP BY expression defined,\n     * calling this function will override previously set GROUP BY conditions.\n     */\n    groupBy(groupBy?: string): this {\n        if (groupBy) {\n            this.expressionMap.groupBys = [groupBy]\n        } else {\n            this.expressionMap.groupBys = []\n        }\n        return this\n    }\n\n    /**\n     * Adds GROUP BY condition in the query builder.\n     */\n    addGroupBy(groupBy: string): this {\n        this.expressionMap.groupBys.push(groupBy)\n        return this\n    }\n\n    /**\n     * Enables time travelling for the current query (only supported by cockroach currently)\n     */\n    timeTravelQuery(timeTravelFn?: string | boolean): this {\n        if (this.connection.driver.options.type === \"cockroachdb\") {\n            if (timeTravelFn === undefined) {\n                this.expressionMap.timeTravel = \"follower_read_timestamp()\"\n            } else {\n                this.expressionMap.timeTravel = timeTravelFn\n            }\n        }\n\n        return this\n    }\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     *\n     * Calling order by without order set will remove all previously set order bys.\n     */\n    orderBy(): this\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(\n        sort: string,\n        order?: \"ASC\" | \"DESC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\n    ): this\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(order: OrderByCondition): this\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(\n        sort?: string | OrderByCondition,\n        order: \"ASC\" | \"DESC\" = \"ASC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\n    ): this {\n        if (order !== undefined && order !== \"ASC\" && order !== \"DESC\")\n            throw new TypeORMError(\n                `SelectQueryBuilder.addOrderBy \"order\" can accept only \"ASC\" and \"DESC\" values.`,\n            )\n        if (\n            nulls !== undefined &&\n            nulls !== \"NULLS FIRST\" &&\n            nulls !== \"NULLS LAST\"\n        )\n            throw new TypeORMError(\n                `SelectQueryBuilder.addOrderBy \"nulls\" can accept only \"NULLS FIRST\" and \"NULLS LAST\" values.`,\n            )\n\n        if (sort) {\n            if (typeof sort === \"object\") {\n                this.expressionMap.orderBys = sort as OrderByCondition\n            } else {\n                if (nulls) {\n                    this.expressionMap.orderBys = {\n                        [sort as string]: { order, nulls },\n                    }\n                } else {\n                    this.expressionMap.orderBys = { [sort as string]: order }\n                }\n            }\n        } else {\n            this.expressionMap.orderBys = {}\n        }\n        return this\n    }\n\n    /**\n     * Adds ORDER BY condition in the query builder.\n     */\n    addOrderBy(\n        sort: string,\n        order: \"ASC\" | \"DESC\" = \"ASC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\n    ): this {\n        if (order !== undefined && order !== \"ASC\" && order !== \"DESC\")\n            throw new TypeORMError(\n                `SelectQueryBuilder.addOrderBy \"order\" can accept only \"ASC\" and \"DESC\" values.`,\n            )\n        if (\n            nulls !== undefined &&\n            nulls !== \"NULLS FIRST\" &&\n            nulls !== \"NULLS LAST\"\n        )\n            throw new TypeORMError(\n                `SelectQueryBuilder.addOrderBy \"nulls\" can accept only \"NULLS FIRST\" and \"NULLS LAST\" values.`,\n            )\n\n        if (nulls) {\n            this.expressionMap.orderBys[sort] = { order, nulls }\n        } else {\n            this.expressionMap.orderBys[sort] = order\n        }\n        return this\n    }\n\n    /**\n     * Sets LIMIT - maximum number of rows to be selected.\n     * NOTE that it may not work as you expect if you are using joins.\n     * If you want to implement pagination, and you are having join in your query,\n     * then use the take method instead.\n     */\n    limit(limit?: number): this {\n        this.expressionMap.limit = this.normalizeNumber(limit)\n        if (\n            this.expressionMap.limit !== undefined &&\n            isNaN(this.expressionMap.limit)\n        )\n            throw new TypeORMError(\n                `Provided \"limit\" value is not a number. Please provide a numeric value.`,\n            )\n\n        return this\n    }\n\n    /**\n     * Sets OFFSET - selection offset.\n     * NOTE that it may not work as you expect if you are using joins.\n     * If you want to implement pagination, and you are having join in your query,\n     * then use the skip method instead.\n     */\n    offset(offset?: number): this {\n        this.expressionMap.offset = this.normalizeNumber(offset)\n        if (\n            this.expressionMap.offset !== undefined &&\n            isNaN(this.expressionMap.offset)\n        )\n            throw new TypeORMError(\n                `Provided \"offset\" value is not a number. Please provide a numeric value.`,\n            )\n\n        return this\n    }\n\n    /**\n     * Sets maximal number of entities to take.\n     */\n    take(take?: number): this {\n        this.expressionMap.take = this.normalizeNumber(take)\n        if (\n            this.expressionMap.take !== undefined &&\n            isNaN(this.expressionMap.take)\n        )\n            throw new TypeORMError(\n                `Provided \"take\" value is not a number. Please provide a numeric value.`,\n            )\n\n        return this\n    }\n\n    /**\n     * Sets number of entities to skip.\n     */\n    skip(skip?: number): this {\n        this.expressionMap.skip = this.normalizeNumber(skip)\n        if (\n            this.expressionMap.skip !== undefined &&\n            isNaN(this.expressionMap.skip)\n        )\n            throw new TypeORMError(\n                `Provided \"skip\" value is not a number. Please provide a numeric value.`,\n            )\n\n        return this\n    }\n\n    /**\n     * Set certain index to be used by the query.\n     *\n     * @param index Name of index to be used.\n     */\n    useIndex(index: string): this {\n        this.expressionMap.useIndex = index\n\n        return this\n    }\n\n    /**\n     * Sets locking mode.\n     */\n    setLock(lockMode: \"optimistic\", lockVersion: number | Date): this\n\n    /**\n     * Sets locking mode.\n     */\n    setLock(\n        lockMode:\n            | \"pessimistic_read\"\n            | \"pessimistic_write\"\n            | \"dirty_read\"\n            /*\n                \"pessimistic_partial_write\" and \"pessimistic_write_or_fail\" are deprecated and\n                will be removed in a future version.\n\n                Use setOnLocked instead.\n             */\n            | \"pessimistic_partial_write\"\n            | \"pessimistic_write_or_fail\"\n            | \"for_no_key_update\"\n            | \"for_key_share\",\n        lockVersion?: undefined,\n        lockTables?: string[],\n    ): this\n\n    /**\n     * Sets locking mode.\n     */\n    setLock(\n        lockMode:\n            | \"optimistic\"\n            | \"pessimistic_read\"\n            | \"pessimistic_write\"\n            | \"dirty_read\"\n            /*\n                \"pessimistic_partial_write\" and \"pessimistic_write_or_fail\" are deprecated and\n                will be removed in a future version.\n\n                Use setOnLocked instead.\n             */\n            | \"pessimistic_partial_write\"\n            | \"pessimistic_write_or_fail\"\n            | \"for_no_key_update\"\n            | \"for_key_share\",\n        lockVersion?: number | Date,\n        lockTables?: string[],\n    ): this {\n        this.expressionMap.lockMode = lockMode\n        this.expressionMap.lockVersion = lockVersion\n        this.expressionMap.lockTables = lockTables\n        return this\n    }\n\n    /**\n     * Sets lock handling by adding NO WAIT or SKIP LOCKED.\n     */\n    setOnLocked(onLocked: \"nowait\" | \"skip_locked\"): this {\n        this.expressionMap.onLocked = onLocked\n        return this\n    }\n\n    /**\n     * Disables the global condition of \"non-deleted\" for the entity with delete date columns.\n     */\n    withDeleted(): this {\n        this.expressionMap.withDeleted = true\n        return this\n    }\n\n    /**\n     * Gets first raw result returned by execution of generated query builder sql.\n     */\n    async getRawOne<T = any>(): Promise<T | undefined> {\n        return (await this.getRawMany())[0]\n    }\n\n    /**\n     * Gets all raw results returned by execution of generated query builder sql.\n     */\n    async getRawMany<T = any>(): Promise<T[]> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError()\n\n        this.expressionMap.queryEntity = false\n        const queryRunner = this.obtainQueryRunner()\n        let transactionStartedByUs: boolean = false\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction()\n                transactionStartedByUs = true\n            }\n\n            const results = await this.loadRawResults(queryRunner)\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction()\n            }\n\n            return results\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n            throw error\n        } finally {\n            if (queryRunner !== this.queryRunner) {\n                // means we created our own query runner\n                await queryRunner.release()\n            }\n        }\n    }\n\n    /**\n     * Executes sql generated by query builder and returns object with raw results and entities created from them.\n     */\n    async getRawAndEntities<T = any>(): Promise<{\n        entities: Entity[]\n        raw: T[]\n    }> {\n        const queryRunner = this.obtainQueryRunner()\n        let transactionStartedByUs: boolean = false\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction()\n                transactionStartedByUs = true\n            }\n\n            this.expressionMap.queryEntity = true\n            const results = await this.executeEntitiesAndRawResults(queryRunner)\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction()\n            }\n\n            return results\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n            throw error\n        } finally {\n            if (queryRunner !== this.queryRunner)\n                // means we created our own query runner\n                await queryRunner.release()\n        }\n    }\n\n    /**\n     * Gets single entity returned by execution of generated query builder sql.\n     */\n    async getOne(): Promise<Entity | null> {\n        const results = await this.getRawAndEntities()\n        const result = results.entities[0] as any\n\n        if (\n            result &&\n            this.expressionMap.lockMode === \"optimistic\" &&\n            this.expressionMap.lockVersion\n        ) {\n            const metadata = this.expressionMap.mainAlias!.metadata\n\n            if (this.expressionMap.lockVersion instanceof Date) {\n                const actualVersion =\n                    metadata.updateDateColumn!.getEntityValue(result) // what if columns arent set?\n                if (\n                    actualVersion.getTime() !==\n                    this.expressionMap.lockVersion.getTime()\n                )\n                    throw new OptimisticLockVersionMismatchError(\n                        metadata.name,\n                        this.expressionMap.lockVersion,\n                        actualVersion,\n                    )\n            } else {\n                const actualVersion =\n                    metadata.versionColumn!.getEntityValue(result) // what if columns arent set?\n                if (actualVersion !== this.expressionMap.lockVersion)\n                    throw new OptimisticLockVersionMismatchError(\n                        metadata.name,\n                        this.expressionMap.lockVersion,\n                        actualVersion,\n                    )\n            }\n        }\n\n        if (result === undefined) {\n            return null\n        }\n        return result\n    }\n\n    /**\n     * Gets the first entity returned by execution of generated query builder sql or rejects the returned promise on error.\n     */\n    async getOneOrFail(): Promise<Entity> {\n        const entity = await this.getOne()\n\n        if (!entity) {\n            throw new EntityNotFoundError(\n                this.expressionMap.mainAlias!.target,\n                this.expressionMap.parameters,\n            )\n        }\n\n        return entity\n    }\n\n    /**\n     * Gets entities returned by execution of generated query builder sql.\n     */\n    async getMany(): Promise<Entity[]> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError()\n\n        const results = await this.getRawAndEntities()\n        return results.entities\n    }\n\n    /**\n     * Gets count - number of entities selected by sql generated by this query builder.\n     * Count excludes all limitations set by offset, limit, skip, and take.\n     */\n    async getCount(): Promise<number> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError()\n\n        const queryRunner = this.obtainQueryRunner()\n        let transactionStartedByUs: boolean = false\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction()\n                transactionStartedByUs = true\n            }\n\n            this.expressionMap.queryEntity = false\n            const results = await this.executeCountQuery(queryRunner)\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction()\n            }\n\n            return results\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n            throw error\n        } finally {\n            if (queryRunner !== this.queryRunner)\n                // means we created our own query runner\n                await queryRunner.release()\n        }\n    }\n\n    /**\n     * Gets exists\n     * Returns whether any rows exists matching current query.\n     */\n    async getExists(): Promise<boolean> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError()\n\n        const queryRunner = this.obtainQueryRunner()\n        let transactionStartedByUs: boolean = false\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction()\n                transactionStartedByUs = true\n            }\n\n            this.expressionMap.queryEntity = false\n            const results = await this.executeExistsQuery(queryRunner)\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction()\n            }\n\n            return results\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n            throw error\n        } finally {\n            if (queryRunner !== this.queryRunner)\n                // means we created our own query runner\n                await queryRunner.release()\n        }\n    }\n\n    /**\n     * Executes built SQL query and returns entities and overall entities count (without limitation).\n     * This method is useful to build pagination.\n     */\n    async getManyAndCount(): Promise<[Entity[], number]> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError()\n\n        const queryRunner = this.obtainQueryRunner()\n        let transactionStartedByUs: boolean = false\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction()\n                transactionStartedByUs = true\n            }\n\n            this.expressionMap.queryEntity = true\n            const entitiesAndRaw = await this.executeEntitiesAndRawResults(\n                queryRunner,\n            )\n            this.expressionMap.queryEntity = false\n            const cacheId = this.expressionMap.cacheId\n            // Creates a new cacheId for the count query, or it will retreive the above query results\n            // and count will return 0.\n            this.expressionMap.cacheId = cacheId ? `${cacheId}-count` : cacheId\n            const count = await this.executeCountQuery(queryRunner)\n            const results: [Entity[], number] = [entitiesAndRaw.entities, count]\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction()\n            }\n\n            return results\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n            throw error\n        } finally {\n            if (queryRunner !== this.queryRunner)\n                // means we created our own query runner\n                await queryRunner.release()\n        }\n    }\n\n    /**\n     * Executes built SQL query and returns raw data stream.\n     */\n    async stream(): Promise<ReadStream> {\n        this.expressionMap.queryEntity = false\n        const [sql, parameters] = this.getQueryAndParameters()\n        const queryRunner = this.obtainQueryRunner()\n        let transactionStartedByUs: boolean = false\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction()\n                transactionStartedByUs = true\n            }\n\n            const releaseFn = () => {\n                if (queryRunner !== this.queryRunner)\n                    // means we created our own query runner\n                    return queryRunner.release()\n                return\n            }\n            const results = queryRunner.stream(\n                sql,\n                parameters,\n                releaseFn,\n                releaseFn,\n            )\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction()\n            }\n\n            return results\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n            throw error\n        }\n    }\n\n    /**\n     * Enables or disables query result caching.\n     */\n    cache(enabled: boolean): this\n\n    /**\n     * Enables query result caching and sets in milliseconds in which cache will expire.\n     * If not set then global caching time will be used.\n     */\n    cache(milliseconds: number): this\n\n    /**\n     * Enables query result caching and sets cache id and milliseconds in which cache will expire.\n     */\n    cache(id: any, milliseconds?: number): this\n\n    /**\n     * Enables or disables query result caching.\n     */\n    cache(\n        enabledOrMillisecondsOrId: boolean | number | string,\n        maybeMilliseconds?: number,\n    ): this {\n        if (typeof enabledOrMillisecondsOrId === \"boolean\") {\n            this.expressionMap.cache = enabledOrMillisecondsOrId\n        } else if (typeof enabledOrMillisecondsOrId === \"number\") {\n            this.expressionMap.cache = true\n            this.expressionMap.cacheDuration = enabledOrMillisecondsOrId\n        } else if (\n            typeof enabledOrMillisecondsOrId === \"string\" ||\n            typeof enabledOrMillisecondsOrId === \"number\"\n        ) {\n            this.expressionMap.cache = true\n            this.expressionMap.cacheId = enabledOrMillisecondsOrId\n        }\n\n        if (maybeMilliseconds) {\n            this.expressionMap.cacheDuration = maybeMilliseconds\n        }\n\n        return this\n    }\n\n    /**\n     * Sets extra options that can be used to configure how query builder works.\n     */\n    setOption(option: SelectQueryBuilderOption): this {\n        this.expressionMap.options.push(option)\n        return this\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    protected join(\n        direction: \"INNER\" | \"LEFT\",\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        aliasName: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n        mapToProperty?: string,\n        isMappingMany?: boolean,\n        mapAsEntity?: Function | string,\n    ): void {\n        if (parameters) {\n            this.setParameters(parameters)\n        }\n\n        const joinAttribute = new JoinAttribute(\n            this.connection,\n            this.expressionMap,\n        )\n        joinAttribute.direction = direction\n        joinAttribute.mapAsEntity = mapAsEntity\n        joinAttribute.mapToProperty = mapToProperty\n        joinAttribute.isMappingMany = isMappingMany\n        joinAttribute.entityOrProperty = entityOrProperty // relationName\n        joinAttribute.condition = condition // joinInverseSideCondition\n        // joinAttribute.junctionAlias = joinAttribute.relation.isOwning ? parentAlias + \"_\" + destinationTableAlias : destinationTableAlias + \"_\" + parentAlias;\n        this.expressionMap.joinAttributes.push(joinAttribute)\n\n        const joinAttributeMetadata = joinAttribute.metadata\n        if (joinAttributeMetadata) {\n            if (\n                joinAttributeMetadata.deleteDateColumn &&\n                !this.expressionMap.withDeleted\n            ) {\n                const conditionDeleteColumn = `${aliasName}.${joinAttributeMetadata.deleteDateColumn.propertyName} IS NULL`\n                joinAttribute.condition = joinAttribute.condition\n                    ? ` ${joinAttribute.condition} AND ${conditionDeleteColumn}`\n                    : `${conditionDeleteColumn}`\n            }\n            // todo: find and set metadata right there?\n            joinAttribute.alias = this.expressionMap.createAlias({\n                type: \"join\",\n                name: aliasName,\n                metadata: joinAttributeMetadata,\n            })\n            if (\n                joinAttribute.relation &&\n                joinAttribute.relation.junctionEntityMetadata\n            ) {\n                this.expressionMap.createAlias({\n                    type: \"join\",\n                    name: joinAttribute.junctionAlias,\n                    metadata: joinAttribute.relation.junctionEntityMetadata,\n                })\n            }\n        } else {\n            let subQuery: string = \"\"\n            if (typeof entityOrProperty === \"function\") {\n                const subQueryBuilder: SelectQueryBuilder<any> = (\n                    entityOrProperty as any\n                )((this as any as SelectQueryBuilder<any>).subQuery())\n                this.setParameters(subQueryBuilder.getParameters())\n                subQuery = subQueryBuilder.getQuery()\n            } else {\n                subQuery = entityOrProperty\n            }\n            const isSubQuery =\n                typeof entityOrProperty === \"function\" ||\n                (entityOrProperty.substr(0, 1) === \"(\" &&\n                    entityOrProperty.substr(-1) === \")\")\n            joinAttribute.alias = this.expressionMap.createAlias({\n                type: \"join\",\n                name: aliasName,\n                tablePath:\n                    isSubQuery === false\n                        ? (entityOrProperty as string)\n                        : undefined,\n                subQuery: isSubQuery === true ? subQuery : undefined,\n            })\n        }\n    }\n\n    /**\n     * Creates \"SELECT FROM\" part of SQL query.\n     */\n    protected createSelectExpression() {\n        if (!this.expressionMap.mainAlias)\n            throw new TypeORMError(\n                \"Cannot build query because main alias is not set (call qb#from method)\",\n            )\n\n        // todo throw exception if selects or from is missing\n\n        const allSelects: SelectQuery[] = []\n        const excludedSelects: SelectQuery[] = []\n\n        if (this.expressionMap.mainAlias.hasMetadata) {\n            const metadata = this.expressionMap.mainAlias.metadata\n            allSelects.push(\n                ...this.buildEscapedEntityColumnSelects(\n                    this.expressionMap.mainAlias.name,\n                    metadata,\n                ),\n            )\n            excludedSelects.push(\n                ...this.findEntityColumnSelects(\n                    this.expressionMap.mainAlias.name,\n                    metadata,\n                ),\n            )\n        }\n\n        // add selects from joins\n        this.expressionMap.joinAttributes.forEach((join) => {\n            if (join.metadata) {\n                allSelects.push(\n                    ...this.buildEscapedEntityColumnSelects(\n                        join.alias.name!,\n                        join.metadata,\n                    ),\n                )\n                excludedSelects.push(\n                    ...this.findEntityColumnSelects(\n                        join.alias.name!,\n                        join.metadata,\n                    ),\n                )\n            } else {\n                const hasMainAlias = this.expressionMap.selects.some(\n                    (select) => select.selection === join.alias.name,\n                )\n                if (hasMainAlias) {\n                    allSelects.push({\n                        selection: this.escape(join.alias.name!) + \".*\",\n                    })\n                    const excludedSelect = this.expressionMap.selects.find(\n                        (select) => select.selection === join.alias.name,\n                    )\n                    excludedSelects.push(excludedSelect!)\n                }\n            }\n        })\n\n        // add all other selects\n        this.expressionMap.selects\n            .filter((select) => excludedSelects.indexOf(select) === -1)\n            .forEach((select) =>\n                allSelects.push({\n                    selection: this.replacePropertyNames(select.selection),\n                    aliasName: select.aliasName,\n                }),\n            )\n\n        // if still selection is empty, then simply set it to all (*)\n        if (allSelects.length === 0) allSelects.push({ selection: \"*\" })\n\n        // Use certain index\n        let useIndex: string = \"\"\n        if (this.expressionMap.useIndex) {\n            if (DriverUtils.isMySQLFamily(this.connection.driver)) {\n                useIndex = ` USE INDEX (${this.expressionMap.useIndex})`\n            }\n        }\n\n        // create a selection query\n        const froms = this.expressionMap.aliases\n            .filter(\n                (alias) =>\n                    alias.type === \"from\" &&\n                    (alias.tablePath || alias.subQuery),\n            )\n            .map((alias) => {\n                if (alias.subQuery)\n                    return alias.subQuery + \" \" + this.escape(alias.name)\n\n                return (\n                    this.getTableName(alias.tablePath!) +\n                    \" \" +\n                    this.escape(alias.name)\n                )\n            })\n\n        const select = this.createSelectDistinctExpression()\n        const selection = allSelects\n            .map(\n                (select) =>\n                    select.selection +\n                    (select.aliasName\n                        ? \" AS \" + this.escape(select.aliasName)\n                        : \"\"),\n            )\n            .join(\", \")\n\n        return (\n            select +\n            selection +\n            \" FROM \" +\n            froms.join(\", \") +\n            this.createTableLockExpression() +\n            useIndex\n        )\n    }\n\n    /**\n     * Creates select | select distinct part of SQL query.\n     */\n    protected createSelectDistinctExpression(): string {\n        const { selectDistinct, selectDistinctOn, maxExecutionTime } =\n            this.expressionMap\n        const { driver } = this.connection\n\n        let select = \"SELECT \"\n\n        if (maxExecutionTime > 0) {\n            if (DriverUtils.isMySQLFamily(driver)) {\n                select += `/*+ MAX_EXECUTION_TIME(${this.expressionMap.maxExecutionTime}) */ `\n            }\n        }\n\n        if (\n            DriverUtils.isPostgresFamily(driver) &&\n            selectDistinctOn.length > 0\n        ) {\n            const selectDistinctOnMap = selectDistinctOn\n                .map((on) => this.replacePropertyNames(on))\n                .join(\", \")\n\n            select = `SELECT DISTINCT ON (${selectDistinctOnMap}) `\n        } else if (selectDistinct) {\n            select = \"SELECT DISTINCT \"\n        }\n\n        return select\n    }\n\n    /**\n     * Creates \"JOIN\" part of SQL query.\n     */\n    protected createJoinExpression(): string {\n        // examples:\n        // select from owning side\n        // qb.select(\"post\")\n        //     .leftJoinAndSelect(\"post.category\", \"category\");\n        // select from non-owning side\n        // qb.select(\"category\")\n        //     .leftJoinAndSelect(\"category.post\", \"post\");\n\n        const joins = this.expressionMap.joinAttributes.map((joinAttr) => {\n            const relation = joinAttr.relation\n            const destinationTableName = joinAttr.tablePath\n            const destinationTableAlias = joinAttr.alias.name\n            let appendedCondition = joinAttr.condition\n                ? \" AND (\" + joinAttr.condition + \")\"\n                : \"\"\n            const parentAlias = joinAttr.parentAlias\n\n            // if join was build without relation (e.g. without \"post.category\") then it means that we have direct\n            // table to join, without junction table involved. This means we simply join direct table.\n            if (!parentAlias || !relation) {\n                const destinationJoin = joinAttr.alias.subQuery\n                    ? joinAttr.alias.subQuery\n                    : this.getTableName(destinationTableName)\n                return (\n                    \" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    destinationJoin +\n                    \" \" +\n                    this.escape(destinationTableAlias) +\n                    this.createTableLockExpression() +\n                    (joinAttr.condition\n                        ? \" ON \" + this.replacePropertyNames(joinAttr.condition)\n                        : \"\")\n                )\n            }\n\n            // if real entity relation is involved\n            if (relation.isManyToOne || relation.isOneToOneOwner) {\n                // JOIN `category` `category` ON `category`.`id` = `post`.`categoryId`\n                const condition = relation.joinColumns\n                    .map((joinColumn) => {\n                        return (\n                            destinationTableAlias +\n                            \".\" +\n                            joinColumn.referencedColumn!.propertyPath +\n                            \"=\" +\n                            parentAlias +\n                            \".\" +\n                            relation.propertyPath +\n                            \".\" +\n                            joinColumn.referencedColumn!.propertyPath\n                        )\n                    })\n                    .join(\" AND \")\n\n                return (\n                    \" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    this.getTableName(destinationTableName) +\n                    \" \" +\n                    this.escape(destinationTableAlias) +\n                    this.createTableLockExpression() +\n                    \" ON \" +\n                    this.replacePropertyNames(condition + appendedCondition)\n                )\n            } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n                // JOIN `post` `post` ON `post`.`categoryId` = `category`.`id`\n                const condition = relation\n                    .inverseRelation!.joinColumns.map((joinColumn) => {\n                        if (\n                            relation.inverseEntityMetadata.tableType ===\n                                \"entity-child\" &&\n                            relation.inverseEntityMetadata.discriminatorColumn\n                        ) {\n                            appendedCondition +=\n                                \" AND \" +\n                                destinationTableAlias +\n                                \".\" +\n                                relation.inverseEntityMetadata\n                                    .discriminatorColumn.databaseName +\n                                \"='\" +\n                                relation.inverseEntityMetadata\n                                    .discriminatorValue +\n                                \"'\"\n                        }\n\n                        return (\n                            destinationTableAlias +\n                            \".\" +\n                            relation.inverseRelation!.propertyPath +\n                            \".\" +\n                            joinColumn.referencedColumn!.propertyPath +\n                            \"=\" +\n                            parentAlias +\n                            \".\" +\n                            joinColumn.referencedColumn!.propertyPath\n                        )\n                    })\n                    .join(\" AND \")\n\n                if (!condition)\n                    throw new TypeORMError(\n                        `Relation ${relation.entityMetadata.name}.${relation.propertyName} does not have join columns.`,\n                    )\n\n                return (\n                    \" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    this.getTableName(destinationTableName) +\n                    \" \" +\n                    this.escape(destinationTableAlias) +\n                    this.createTableLockExpression() +\n                    \" ON \" +\n                    this.replacePropertyNames(condition + appendedCondition)\n                )\n            } else {\n                // means many-to-many\n                const junctionTableName =\n                    relation.junctionEntityMetadata!.tablePath\n\n                const junctionAlias = joinAttr.junctionAlias\n                let junctionCondition = \"\",\n                    destinationCondition = \"\"\n\n                if (relation.isOwning) {\n                    junctionCondition = relation.joinColumns\n                        .map((joinColumn) => {\n                            // `post_category`.`postId` = `post`.`id`\n                            return (\n                                junctionAlias +\n                                \".\" +\n                                joinColumn.propertyPath +\n                                \"=\" +\n                                parentAlias +\n                                \".\" +\n                                joinColumn.referencedColumn!.propertyPath\n                            )\n                        })\n                        .join(\" AND \")\n\n                    destinationCondition = relation.inverseJoinColumns\n                        .map((joinColumn) => {\n                            // `category`.`id` = `post_category`.`categoryId`\n                            return (\n                                destinationTableAlias +\n                                \".\" +\n                                joinColumn.referencedColumn!.propertyPath +\n                                \"=\" +\n                                junctionAlias +\n                                \".\" +\n                                joinColumn.propertyPath\n                            )\n                        })\n                        .join(\" AND \")\n                } else {\n                    junctionCondition = relation\n                        .inverseRelation!.inverseJoinColumns.map(\n                            (joinColumn) => {\n                                // `post_category`.`categoryId` = `category`.`id`\n                                return (\n                                    junctionAlias +\n                                    \".\" +\n                                    joinColumn.propertyPath +\n                                    \"=\" +\n                                    parentAlias +\n                                    \".\" +\n                                    joinColumn.referencedColumn!.propertyPath\n                                )\n                            },\n                        )\n                        .join(\" AND \")\n\n                    destinationCondition = relation\n                        .inverseRelation!.joinColumns.map((joinColumn) => {\n                            // `post`.`id` = `post_category`.`postId`\n                            return (\n                                destinationTableAlias +\n                                \".\" +\n                                joinColumn.referencedColumn!.propertyPath +\n                                \"=\" +\n                                junctionAlias +\n                                \".\" +\n                                joinColumn.propertyPath\n                            )\n                        })\n                        .join(\" AND \")\n                }\n\n                return (\n                    \" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    this.getTableName(junctionTableName) +\n                    \" \" +\n                    this.escape(junctionAlias) +\n                    this.createTableLockExpression() +\n                    \" ON \" +\n                    this.replacePropertyNames(junctionCondition) +\n                    \" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    this.getTableName(destinationTableName) +\n                    \" \" +\n                    this.escape(destinationTableAlias) +\n                    this.createTableLockExpression() +\n                    \" ON \" +\n                    this.replacePropertyNames(\n                        destinationCondition + appendedCondition,\n                    )\n                )\n            }\n        })\n\n        return joins.join(\" \")\n    }\n\n    /**\n     * Creates \"GROUP BY\" part of SQL query.\n     */\n    protected createGroupByExpression() {\n        if (!this.expressionMap.groupBys || !this.expressionMap.groupBys.length)\n            return \"\"\n        return (\n            \" GROUP BY \" +\n            this.replacePropertyNames(this.expressionMap.groupBys.join(\", \"))\n        )\n    }\n\n    /**\n     * Creates \"ORDER BY\" part of SQL query.\n     */\n    protected createOrderByExpression() {\n        const orderBys = this.expressionMap.allOrderBys\n        if (Object.keys(orderBys).length === 0) return \"\"\n\n        return (\n            \" ORDER BY \" +\n            Object.keys(orderBys)\n                .map((columnName) => {\n                    const orderValue =\n                        typeof orderBys[columnName] === \"string\"\n                            ? orderBys[columnName]\n                            : (orderBys[columnName] as any).order +\n                              \" \" +\n                              (orderBys[columnName] as any).nulls\n                    const selection = this.expressionMap.selects.find(\n                        (s) => s.selection === columnName,\n                    )\n                    if (\n                        selection &&\n                        !selection.aliasName &&\n                        columnName.indexOf(\".\") !== -1\n                    ) {\n                        const criteriaParts = columnName.split(\".\")\n                        const aliasName = criteriaParts[0]\n                        const propertyPath = criteriaParts.slice(1).join(\".\")\n                        const alias = this.expressionMap.aliases.find(\n                            (alias) => alias.name === aliasName,\n                        )\n                        if (alias) {\n                            const column =\n                                alias.metadata.findColumnWithPropertyPath(\n                                    propertyPath,\n                                )\n                            if (column) {\n                                const orderAlias = DriverUtils.buildAlias(\n                                    this.connection.driver,\n                                    undefined,\n                                    aliasName,\n                                    column.databaseName,\n                                )\n                                return (\n                                    this.escape(orderAlias) + \" \" + orderValue\n                                )\n                            }\n                        }\n                    }\n\n                    return (\n                        this.replacePropertyNames(columnName) + \" \" + orderValue\n                    )\n                })\n                .join(\", \")\n        )\n    }\n\n    /**\n     * Creates \"LIMIT\" and \"OFFSET\" parts of SQL query.\n     */\n    protected createLimitOffsetExpression(): string {\n        // in the case if nothing is joined in the query builder we don't need to make two requests to get paginated results\n        // we can use regular limit / offset, that's why we add offset and limit construction here based on skip and take values\n        let offset: number | undefined = this.expressionMap.offset,\n            limit: number | undefined = this.expressionMap.limit\n        if (\n            !offset &&\n            !limit &&\n            this.expressionMap.joinAttributes.length === 0\n        ) {\n            offset = this.expressionMap.skip\n            limit = this.expressionMap.take\n        }\n\n        if (this.connection.driver.options.type === \"mssql\") {\n            // Due to a limitation in SQL Server's parser implementation it does not support using\n            // OFFSET or FETCH NEXT without an ORDER BY clause being provided. In cases where the\n            // user does not request one we insert a dummy ORDER BY that does nothing and should\n            // have no effect on the query planner or on the order of the results returned.\n            // https://dba.stackexchange.com/a/193799\n            let prefix = \"\"\n            if (\n                (limit || offset) &&\n                Object.keys(this.expressionMap.allOrderBys).length <= 0\n            ) {\n                prefix = \" ORDER BY (SELECT NULL)\"\n            }\n\n            if (limit && offset)\n                return (\n                    prefix +\n                    \" OFFSET \" +\n                    offset +\n                    \" ROWS FETCH NEXT \" +\n                    limit +\n                    \" ROWS ONLY\"\n                )\n            if (limit)\n                return (\n                    prefix + \" OFFSET 0 ROWS FETCH NEXT \" + limit + \" ROWS ONLY\"\n                )\n            if (offset) return prefix + \" OFFSET \" + offset + \" ROWS\"\n        } else if (\n            DriverUtils.isMySQLFamily(this.connection.driver) ||\n            this.connection.driver.options.type === \"aurora-mysql\" ||\n            this.connection.driver.options.type === \"sap\" ||\n            this.connection.driver.options.type === \"spanner\"\n        ) {\n            if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset\n            if (limit) return \" LIMIT \" + limit\n            if (offset) throw new OffsetWithoutLimitNotSupportedError()\n        } else if (DriverUtils.isSQLiteFamily(this.connection.driver)) {\n            if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset\n            if (limit) return \" LIMIT \" + limit\n            if (offset) return \" LIMIT -1 OFFSET \" + offset\n        } else if (this.connection.driver.options.type === \"oracle\") {\n            if (limit && offset)\n                return (\n                    \" OFFSET \" +\n                    offset +\n                    \" ROWS FETCH NEXT \" +\n                    limit +\n                    \" ROWS ONLY\"\n                )\n            if (limit) return \" FETCH NEXT \" + limit + \" ROWS ONLY\"\n            if (offset) return \" OFFSET \" + offset + \" ROWS\"\n        } else {\n            if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset\n            if (limit) return \" LIMIT \" + limit\n            if (offset) return \" OFFSET \" + offset\n        }\n\n        return \"\"\n    }\n\n    /**\n     * Creates \"LOCK\" part of SELECT Query after table Clause\n     * ex.\n     *  SELECT 1\n     *  FROM USER U WITH (NOLOCK)\n     *  JOIN ORDER O WITH (NOLOCK)\n     *      ON U.ID=O.OrderID\n     */\n    private createTableLockExpression(): string {\n        if (this.connection.driver.options.type === \"mssql\") {\n            switch (this.expressionMap.lockMode) {\n                case \"pessimistic_read\":\n                    return \" WITH (HOLDLOCK, ROWLOCK)\"\n                case \"pessimistic_write\":\n                    return \" WITH (UPDLOCK, ROWLOCK)\"\n                case \"dirty_read\":\n                    return \" WITH (NOLOCK)\"\n            }\n        }\n\n        return \"\"\n    }\n\n    /**\n     * Creates \"LOCK\" part of SQL query.\n     */\n    protected createLockExpression(): string {\n        const driver = this.connection.driver\n\n        let lockTablesClause = \"\"\n\n        if (this.expressionMap.lockTables) {\n            if (\n                !(\n                    DriverUtils.isPostgresFamily(driver) ||\n                    driver.options.type === \"cockroachdb\"\n                )\n            ) {\n                throw new TypeORMError(\n                    \"Lock tables not supported in selected driver\",\n                )\n            }\n            if (this.expressionMap.lockTables.length < 1) {\n                throw new TypeORMError(\"lockTables cannot be an empty array\")\n            }\n            lockTablesClause = \" OF \" + this.expressionMap.lockTables.join(\", \")\n        }\n\n        let onLockExpression = \"\"\n        if (this.expressionMap.onLocked === \"nowait\") {\n            onLockExpression = \" NOWAIT\"\n        } else if (this.expressionMap.onLocked === \"skip_locked\") {\n            onLockExpression = \" SKIP LOCKED\"\n        }\n        switch (this.expressionMap.lockMode) {\n            case \"pessimistic_read\":\n                if (\n                    driver.options.type === \"mysql\" ||\n                    driver.options.type === \"aurora-mysql\"\n                ) {\n                    if (\n                        DriverUtils.isReleaseVersionOrGreater(driver, \"8.0.0\")\n                    ) {\n                        return (\n                            \" FOR SHARE\" + lockTablesClause + onLockExpression\n                        )\n                    } else {\n                        return \" LOCK IN SHARE MODE\"\n                    }\n                } else if (driver.options.type === \"mariadb\") {\n                    return \" LOCK IN SHARE MODE\"\n                } else if (DriverUtils.isPostgresFamily(driver)) {\n                    return \" FOR SHARE\" + lockTablesClause + onLockExpression\n                } else if (driver.options.type === \"oracle\") {\n                    return \" FOR UPDATE\"\n                } else if (driver.options.type === \"mssql\") {\n                    return \"\"\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError()\n                }\n            case \"pessimistic_write\":\n                if (\n                    DriverUtils.isMySQLFamily(driver) ||\n                    driver.options.type === \"aurora-mysql\" ||\n                    driver.options.type === \"oracle\"\n                ) {\n                    return \" FOR UPDATE\" + onLockExpression\n                } else if (\n                    DriverUtils.isPostgresFamily(driver) ||\n                    driver.options.type === \"cockroachdb\"\n                ) {\n                    return \" FOR UPDATE\" + lockTablesClause + onLockExpression\n                } else if (driver.options.type === \"mssql\") {\n                    return \"\"\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError()\n                }\n            case \"pessimistic_partial_write\":\n                if (DriverUtils.isPostgresFamily(driver)) {\n                    return \" FOR UPDATE\" + lockTablesClause + \" SKIP LOCKED\"\n                } else if (DriverUtils.isMySQLFamily(driver)) {\n                    return \" FOR UPDATE SKIP LOCKED\"\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError()\n                }\n            case \"pessimistic_write_or_fail\":\n                if (\n                    DriverUtils.isPostgresFamily(driver) ||\n                    driver.options.type === \"cockroachdb\"\n                ) {\n                    return \" FOR UPDATE\" + lockTablesClause + \" NOWAIT\"\n                } else if (DriverUtils.isMySQLFamily(driver)) {\n                    return \" FOR UPDATE NOWAIT\"\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError()\n                }\n            case \"for_no_key_update\":\n                if (\n                    DriverUtils.isPostgresFamily(driver) ||\n                    driver.options.type === \"cockroachdb\"\n                ) {\n                    return (\n                        \" FOR NO KEY UPDATE\" +\n                        lockTablesClause +\n                        onLockExpression\n                    )\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError()\n                }\n            case \"for_key_share\":\n                if (DriverUtils.isPostgresFamily(driver)) {\n                    return (\n                        \" FOR KEY SHARE\" + lockTablesClause + onLockExpression\n                    )\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError()\n                }\n            default:\n                return \"\"\n        }\n    }\n\n    /**\n     * Creates \"HAVING\" part of SQL query.\n     */\n    protected createHavingExpression() {\n        if (!this.expressionMap.havings || !this.expressionMap.havings.length)\n            return \"\"\n        const conditions = this.expressionMap.havings\n            .map((having, index) => {\n                switch (having.type) {\n                    case \"and\":\n                        return (\n                            (index > 0 ? \"AND \" : \"\") +\n                            this.replacePropertyNames(having.condition)\n                        )\n                    case \"or\":\n                        return (\n                            (index > 0 ? \"OR \" : \"\") +\n                            this.replacePropertyNames(having.condition)\n                        )\n                    default:\n                        return this.replacePropertyNames(having.condition)\n                }\n            })\n            .join(\" \")\n\n        if (!conditions.length) return \"\"\n        return \" HAVING \" + conditions\n    }\n\n    protected buildEscapedEntityColumnSelects(\n        aliasName: string,\n        metadata: EntityMetadata,\n    ): SelectQuery[] {\n        const hasMainAlias = this.expressionMap.selects.some(\n            (select) => select.selection === aliasName,\n        )\n\n        const columns: ColumnMetadata[] = []\n        if (hasMainAlias) {\n            columns.push(\n                ...metadata.columns.filter(\n                    (column) => column.isSelect === true,\n                ),\n            )\n        }\n        columns.push(\n            ...metadata.columns.filter((column) => {\n                return this.expressionMap.selects.some(\n                    (select) =>\n                        select.selection ===\n                        aliasName + \".\" + column.propertyPath,\n                )\n            }),\n        )\n\n        // if user used partial selection and did not select some primary columns which are required to be selected\n        // we select those primary columns and mark them as \"virtual\". Later virtual column values will be removed from final entity\n        // to make entity contain exactly what user selected\n        if (columns.length === 0)\n            // however not in the case when nothing (even partial) was selected from this target (for example joins without selection)\n            return []\n\n        const nonSelectedPrimaryColumns = this.expressionMap.queryEntity\n            ? metadata.primaryColumns.filter(\n                  (primaryColumn) => columns.indexOf(primaryColumn) === -1,\n              )\n            : []\n        const allColumns = [...columns, ...nonSelectedPrimaryColumns]\n        const finalSelects: SelectQuery[] = []\n\n        const escapedAliasName = this.escape(aliasName)\n        allColumns.forEach((column) => {\n            let selectionPath =\n                escapedAliasName + \".\" + this.escape(column.databaseName)\n\n            if (column.isVirtualProperty && column.query) {\n                selectionPath = `(${column.query(escapedAliasName)})`\n            }\n\n            if (\n                this.connection.driver.spatialTypes.indexOf(column.type) !== -1\n            ) {\n                if (\n                    DriverUtils.isMySQLFamily(this.connection.driver) ||\n                    this.connection.driver.options.type === \"aurora-mysql\"\n                ) {\n                    const useLegacy = (\n                        this.connection.driver as\n                            | MysqlDriver\n                            | AuroraMysqlDriver\n                    ).options.legacySpatialSupport\n                    const asText = useLegacy ? \"AsText\" : \"ST_AsText\"\n                    selectionPath = `${asText}(${selectionPath})`\n                }\n\n                if (DriverUtils.isPostgresFamily(this.connection.driver))\n                    if (column.precision) {\n                        // cast to JSON to trigger parsing in the driver\n                        selectionPath = `ST_AsGeoJSON(${selectionPath}, ${column.precision})::json`\n                    } else {\n                        selectionPath = `ST_AsGeoJSON(${selectionPath})::json`\n                    }\n                if (this.connection.driver.options.type === \"mssql\")\n                    selectionPath = `${selectionPath}.ToString()`\n            }\n\n            const selections = this.expressionMap.selects.filter(\n                (select) =>\n                    select.selection === aliasName + \".\" + column.propertyPath,\n            )\n            if (selections.length) {\n                selections.forEach((selection) => {\n                    finalSelects.push({\n                        selection: selectionPath,\n                        aliasName: selection.aliasName\n                            ? selection.aliasName\n                            : DriverUtils.buildAlias(\n                                  this.connection.driver,\n                                  undefined,\n                                  aliasName,\n                                  column.databaseName,\n                              ),\n                        // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!\n                        virtual: selection.virtual,\n                    })\n                })\n            } else {\n                if (column.isVirtualProperty) {\n                    // Do not add unselected virtual properties to final select\n                    return\n                }\n\n                finalSelects.push({\n                    selection: selectionPath,\n                    aliasName: DriverUtils.buildAlias(\n                        this.connection.driver,\n                        undefined,\n                        aliasName,\n                        column.databaseName,\n                    ),\n                    // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!\n                    virtual: hasMainAlias,\n                })\n            }\n        })\n        return finalSelects\n    }\n\n    protected findEntityColumnSelects(\n        aliasName: string,\n        metadata: EntityMetadata,\n    ): SelectQuery[] {\n        const mainSelect = this.expressionMap.selects.find(\n            (select) => select.selection === aliasName,\n        )\n        if (mainSelect) return [mainSelect]\n\n        return this.expressionMap.selects.filter((select) => {\n            return metadata.columns.some(\n                (column) =>\n                    select.selection === aliasName + \".\" + column.propertyPath,\n            )\n        })\n    }\n\n    private computeCountExpression() {\n        const mainAlias = this.expressionMap.mainAlias!.name // todo: will this work with \"fromTableName\"?\n        const metadata = this.expressionMap.mainAlias!.metadata\n\n        const primaryColumns = metadata.primaryColumns\n        const distinctAlias = this.escape(mainAlias)\n\n        // If we aren't doing anything that will create a join, we can use a simpler `COUNT` instead\n        // so we prevent poor query patterns in the most likely cases\n        if (\n            this.expressionMap.joinAttributes.length === 0 &&\n            this.expressionMap.relationIdAttributes.length === 0 &&\n            this.expressionMap.relationCountAttributes.length === 0\n        ) {\n            return \"COUNT(1)\"\n        }\n\n        // For everything else, we'll need to do some hackery to get the correct count values.\n\n        if (\n            this.connection.driver.options.type === \"cockroachdb\" ||\n            DriverUtils.isPostgresFamily(this.connection.driver)\n        ) {\n            // Postgres and CockroachDB can pass multiple parameters to the `DISTINCT` function\n            // https://www.postgresql.org/docs/9.5/sql-select.html#SQL-DISTINCT\n            return (\n                \"COUNT(DISTINCT(\" +\n                primaryColumns\n                    .map(\n                        (c) =>\n                            `${distinctAlias}.${this.escape(c.databaseName)}`,\n                    )\n                    .join(\", \") +\n                \"))\"\n            )\n        }\n\n        if (DriverUtils.isMySQLFamily(this.connection.driver)) {\n            // MySQL & MariaDB can pass multiple parameters to the `DISTINCT` language construct\n            // https://mariadb.com/kb/en/count-distinct/\n            return (\n                \"COUNT(DISTINCT \" +\n                primaryColumns\n                    .map(\n                        (c) =>\n                            `${distinctAlias}.${this.escape(c.databaseName)}`,\n                    )\n                    .join(\", \") +\n                \")\"\n            )\n        }\n\n        if (this.connection.driver.options.type === \"mssql\") {\n            // SQL Server has gotta be different from everyone else.  They don't support\n            // distinct counting multiple columns & they don't have the same operator\n            // characteristic for concatenating, so we gotta use the `CONCAT` function.\n            // However, If it's exactly 1 column we can omit the `CONCAT` for better performance.\n\n            const columnsExpression = primaryColumns\n                .map(\n                    (primaryColumn) =>\n                        `${distinctAlias}.${this.escape(\n                            primaryColumn.databaseName,\n                        )}`,\n                )\n                .join(\", '|;|', \")\n\n            if (primaryColumns.length === 1) {\n                return `COUNT(DISTINCT(${columnsExpression}))`\n            }\n\n            return `COUNT(DISTINCT(CONCAT(${columnsExpression})))`\n        }\n\n        if (this.connection.driver.options.type === \"spanner\") {\n            // spanner also has gotta be different from everyone else.\n            // they do not support concatenation of different column types without casting them to string\n\n            if (primaryColumns.length === 1) {\n                return `COUNT(DISTINCT(${distinctAlias}.${this.escape(\n                    primaryColumns[0].databaseName,\n                )}))`\n            }\n\n            const columnsExpression = primaryColumns\n                .map(\n                    (primaryColumn) =>\n                        `CAST(${distinctAlias}.${this.escape(\n                            primaryColumn.databaseName,\n                        )} AS STRING)`,\n                )\n                .join(\", '|;|', \")\n            return `COUNT(DISTINCT(CONCAT(${columnsExpression})))`\n        }\n\n        // If all else fails, fall back to a `COUNT` and `DISTINCT` across all the primary columns concatenated.\n        // Per the SQL spec, this is the canonical string concatenation mechanism which is most\n        // likely to work across servers implementing the SQL standard.\n\n        // Please note, if there is only one primary column that the concatenation does not occur in this\n        // query and the query is a standard `COUNT DISTINCT` in that case.\n\n        return (\n            `COUNT(DISTINCT(` +\n            primaryColumns\n                .map((c) => `${distinctAlias}.${this.escape(c.databaseName)}`)\n                .join(\" || '|;|' || \") +\n            \"))\"\n        )\n    }\n\n    protected async executeCountQuery(\n        queryRunner: QueryRunner,\n    ): Promise<number> {\n        const countSql = this.computeCountExpression()\n\n        const results = await this.clone()\n            .orderBy()\n            .groupBy()\n            .offset(undefined)\n            .limit(undefined)\n            .skip(undefined)\n            .take(undefined)\n            .select(countSql, \"cnt\")\n            .setOption(\"disable-global-order\")\n            .loadRawResults(queryRunner)\n\n        if (!results || !results[0] || !results[0][\"cnt\"]) return 0\n\n        return parseInt(results[0][\"cnt\"])\n    }\n\n    protected async executeExistsQuery(\n        queryRunner: QueryRunner,\n    ): Promise<boolean> {\n        const results = await this.connection\n            .createQueryBuilder()\n            .fromDummy()\n            .select(\"1\", \"row_exists\")\n            .whereExists(this)\n            .limit(1)\n            .loadRawResults(queryRunner)\n\n        return results.length > 0\n    }\n\n    protected applyFindOptions() {\n        // todo: convert relations: string[] to object map to simplify code\n        // todo: same with selects\n\n        if (this.expressionMap.mainAlias!.metadata) {\n            if (this.findOptions.relationLoadStrategy) {\n                this.expressionMap.relationLoadStrategy =\n                    this.findOptions.relationLoadStrategy\n            }\n\n            if (this.findOptions.comment) {\n                this.comment(this.findOptions.comment)\n            }\n\n            if (this.findOptions.withDeleted) {\n                this.withDeleted()\n            }\n\n            if (this.findOptions.select) {\n                const select = Array.isArray(this.findOptions.select)\n                    ? OrmUtils.propertyPathsToTruthyObject(\n                          this.findOptions.select as string[],\n                      )\n                    : this.findOptions.select\n\n                this.buildSelect(\n                    select,\n                    this.expressionMap.mainAlias!.metadata,\n                    this.expressionMap.mainAlias!.name,\n                )\n            }\n\n            if (this.selects.length) {\n                this.select(this.selects)\n            }\n\n            this.selects = []\n            if (this.findOptions.relations) {\n                const relations = Array.isArray(this.findOptions.relations)\n                    ? OrmUtils.propertyPathsToTruthyObject(\n                          this.findOptions.relations,\n                      )\n                    : this.findOptions.relations\n\n                this.buildRelations(\n                    relations,\n                    typeof this.findOptions.select === \"object\"\n                        ? (this.findOptions.select as FindOptionsSelect<any>)\n                        : undefined,\n                    this.expressionMap.mainAlias!.metadata,\n                    this.expressionMap.mainAlias!.name,\n                )\n                if (\n                    this.findOptions.loadEagerRelations !== false &&\n                    this.expressionMap.relationLoadStrategy === \"join\"\n                ) {\n                    this.buildEagerRelations(\n                        relations,\n                        typeof this.findOptions.select === \"object\"\n                            ? (this.findOptions\n                                  .select as FindOptionsSelect<any>)\n                            : undefined,\n                        this.expressionMap.mainAlias!.metadata,\n                        this.expressionMap.mainAlias!.name,\n                    )\n                }\n            }\n            if (this.selects.length) {\n                this.addSelect(this.selects)\n            }\n\n            if (this.findOptions.where) {\n                this.conditions = this.buildWhere(\n                    this.findOptions.where,\n                    this.expressionMap.mainAlias!.metadata,\n                    this.expressionMap.mainAlias!.name,\n                )\n\n                if (this.conditions.length)\n                    this.andWhere(\n                        this.conditions.substr(0, 1) !== \"(\"\n                            ? \"(\" + this.conditions + \")\"\n                            : this.conditions,\n                    ) // temporary and where and braces\n            }\n\n            if (this.findOptions.order) {\n                this.buildOrder(\n                    this.findOptions.order,\n                    this.expressionMap.mainAlias!.metadata,\n                    this.expressionMap.mainAlias!.name,\n                )\n            }\n\n            // apply joins\n            if (this.joins.length) {\n                this.joins.forEach((join) => {\n                    if (join.select && !join.selection) {\n                        // if (join.selection) {\n                        //\n                        // } else {\n                        if (join.type === \"inner\") {\n                            this.innerJoinAndSelect(\n                                `${join.parentAlias}.${join.relationMetadata.propertyPath}`,\n                                join.alias,\n                            )\n                        } else {\n                            this.leftJoinAndSelect(\n                                `${join.parentAlias}.${join.relationMetadata.propertyPath}`,\n                                join.alias,\n                            )\n                        }\n                        // }\n                    } else {\n                        if (join.type === \"inner\") {\n                            this.innerJoin(\n                                `${join.parentAlias}.${join.relationMetadata.propertyPath}`,\n                                join.alias,\n                            )\n                        } else {\n                            this.leftJoin(\n                                `${join.parentAlias}.${join.relationMetadata.propertyPath}`,\n                                join.alias,\n                            )\n                        }\n                    }\n\n                    // if (join.select) {\n                    //     if (this.findOptions.loadEagerRelations !== false) {\n                    //         FindOptionsUtils.joinEagerRelations(\n                    //             this,\n                    //             join.alias,\n                    //             join.relationMetadata.inverseEntityMetadata\n                    //         );\n                    //     }\n                    // }\n                })\n            }\n\n            // if (this.conditions.length) {\n            //     this.where(this.conditions.join(\" AND \"));\n            // }\n\n            // apply offset\n            if (this.findOptions.skip !== undefined) {\n                // if (this.findOptions.options && this.findOptions.options.pagination === false) {\n                //     this.offset(this.findOptions.skip);\n                // } else {\n                this.skip(this.findOptions.skip)\n                // }\n            }\n\n            // apply limit\n            if (this.findOptions.take !== undefined) {\n                // if (this.findOptions.options && this.findOptions.options.pagination === false) {\n                //     this.limit(this.findOptions.take);\n                // } else {\n                this.take(this.findOptions.take)\n                // }\n            }\n\n            // apply caching options\n            if (typeof this.findOptions.cache === \"number\") {\n                this.cache(this.findOptions.cache)\n            } else if (typeof this.findOptions.cache === \"boolean\") {\n                this.cache(this.findOptions.cache)\n            } else if (typeof this.findOptions.cache === \"object\") {\n                this.cache(\n                    this.findOptions.cache.id,\n                    this.findOptions.cache.milliseconds,\n                )\n            }\n\n            if (this.findOptions.join) {\n                if (this.findOptions.join.leftJoin)\n                    Object.keys(this.findOptions.join.leftJoin).forEach(\n                        (key) => {\n                            this.leftJoin(\n                                this.findOptions.join!.leftJoin![key],\n                                key,\n                            )\n                        },\n                    )\n\n                if (this.findOptions.join.innerJoin)\n                    Object.keys(this.findOptions.join.innerJoin).forEach(\n                        (key) => {\n                            this.innerJoin(\n                                this.findOptions.join!.innerJoin![key],\n                                key,\n                            )\n                        },\n                    )\n\n                if (this.findOptions.join.leftJoinAndSelect)\n                    Object.keys(\n                        this.findOptions.join.leftJoinAndSelect,\n                    ).forEach((key) => {\n                        this.leftJoinAndSelect(\n                            this.findOptions.join!.leftJoinAndSelect![key],\n                            key,\n                        )\n                    })\n\n                if (this.findOptions.join.innerJoinAndSelect)\n                    Object.keys(\n                        this.findOptions.join.innerJoinAndSelect,\n                    ).forEach((key) => {\n                        this.innerJoinAndSelect(\n                            this.findOptions.join!.innerJoinAndSelect![key],\n                            key,\n                        )\n                    })\n            }\n\n            if (this.findOptions.lock) {\n                if (this.findOptions.lock.mode === \"optimistic\") {\n                    this.setLock(\n                        this.findOptions.lock.mode,\n                        this.findOptions.lock.version,\n                    )\n                } else if (\n                    this.findOptions.lock.mode === \"pessimistic_read\" ||\n                    this.findOptions.lock.mode === \"pessimistic_write\" ||\n                    this.findOptions.lock.mode === \"dirty_read\" ||\n                    this.findOptions.lock.mode ===\n                        \"pessimistic_partial_write\" ||\n                    this.findOptions.lock.mode ===\n                        \"pessimistic_write_or_fail\" ||\n                    this.findOptions.lock.mode === \"for_no_key_update\" ||\n                    this.findOptions.lock.mode === \"for_key_share\"\n                ) {\n                    const tableNames = this.findOptions.lock.tables\n                        ? this.findOptions.lock.tables.map((table) => {\n                              const tableAlias =\n                                  this.expressionMap.aliases.find((alias) => {\n                                      return (\n                                          alias.metadata\n                                              .tableNameWithoutPrefix === table\n                                      )\n                                  })\n                              if (!tableAlias) {\n                                  throw new TypeORMError(\n                                      `\"${table}\" is not part of this query`,\n                                  )\n                              }\n                              return this.escape(tableAlias.name)\n                          })\n                        : undefined\n                    this.setLock(\n                        this.findOptions.lock.mode,\n                        undefined,\n                        tableNames,\n                    )\n\n                    if (this.findOptions.lock.onLocked) {\n                        this.setOnLocked(this.findOptions.lock.onLocked)\n                    }\n                }\n            }\n\n            if (this.findOptions.loadRelationIds === true) {\n                this.loadAllRelationIds()\n            } else if (typeof this.findOptions.loadRelationIds === \"object\") {\n                this.loadAllRelationIds(this.findOptions.loadRelationIds as any)\n            }\n\n            if (this.findOptions.loadEagerRelations !== false) {\n                FindOptionsUtils.joinEagerRelations(\n                    this,\n                    this.expressionMap.mainAlias!.name,\n                    this.expressionMap.mainAlias!.metadata,\n                )\n            }\n\n            if (this.findOptions.transaction === true) {\n                this.expressionMap.useTransaction = true\n            }\n\n            // if (this.orderBys.length) {\n            //     this.orderBys.forEach(orderBy => {\n            //         this.addOrderBy(orderBy.alias, orderBy.direction, orderBy.nulls);\n            //     });\n            // }\n\n            // todo\n            // if (this.options.options && this.options.options.eagerRelations) {\n            //     this.queryBuilder\n            // }\n\n            // todo\n            // if (this.findOptions.options && this.findOptions.listeners === false) {\n            //     this.callListeners(false);\n            // }\n        }\n    }\n\n    public concatRelationMetadata(relationMetadata: RelationMetadata) {\n        this.relationMetadatas.push(relationMetadata)\n    }\n\n    /**\n     * Executes sql generated by query builder and returns object with raw results and entities created from them.\n     */\n    protected async executeEntitiesAndRawResults(\n        queryRunner: QueryRunner,\n    ): Promise<{ entities: Entity[]; raw: any[] }> {\n        if (!this.expressionMap.mainAlias)\n            throw new TypeORMError(\n                `Alias is not set. Use \"from\" method to set an alias.`,\n            )\n\n        if (\n            (this.expressionMap.lockMode === \"pessimistic_read\" ||\n                this.expressionMap.lockMode === \"pessimistic_write\" ||\n                this.expressionMap.lockMode === \"pessimistic_partial_write\" ||\n                this.expressionMap.lockMode === \"pessimistic_write_or_fail\" ||\n                this.expressionMap.lockMode === \"for_no_key_update\" ||\n                this.expressionMap.lockMode === \"for_key_share\") &&\n            !queryRunner.isTransactionActive\n        )\n            throw new PessimisticLockTransactionRequiredError()\n\n        if (this.expressionMap.lockMode === \"optimistic\") {\n            const metadata = this.expressionMap.mainAlias.metadata\n            if (!metadata.versionColumn && !metadata.updateDateColumn)\n                throw new NoVersionOrUpdateDateColumnError(metadata.name)\n        }\n\n        const relationIdLoader = new RelationIdLoader(\n            this.connection,\n            queryRunner,\n            this.expressionMap.relationIdAttributes,\n        )\n        const relationCountLoader = new RelationCountLoader(\n            this.connection,\n            queryRunner,\n            this.expressionMap.relationCountAttributes,\n        )\n        const relationIdMetadataTransformer =\n            new RelationIdMetadataToAttributeTransformer(this.expressionMap)\n        relationIdMetadataTransformer.transform()\n        const relationCountMetadataTransformer =\n            new RelationCountMetadataToAttributeTransformer(this.expressionMap)\n        relationCountMetadataTransformer.transform()\n\n        let rawResults: any[] = [],\n            entities: any[] = []\n\n        // for pagination enabled (e.g. skip and take) its much more complicated - its a special process\n        // where we make two queries to find the data we need\n        // first query find ids in skip and take range\n        // and second query loads the actual data in given ids range\n        if (\n            (this.expressionMap.skip || this.expressionMap.take) &&\n            this.expressionMap.joinAttributes.length > 0\n        ) {\n            // we are skipping order by here because its not working in subqueries anyway\n            // to make order by working we need to apply it on a distinct query\n            const [selects, orderBys] =\n                this.createOrderByCombinedWithSelectExpression(\"distinctAlias\")\n            const metadata = this.expressionMap.mainAlias.metadata\n            const mainAliasName = this.expressionMap.mainAlias.name\n\n            const querySelects = metadata.primaryColumns.map(\n                (primaryColumn) => {\n                    const distinctAlias = this.escape(\"distinctAlias\")\n                    const columnAlias = this.escape(\n                        DriverUtils.buildAlias(\n                            this.connection.driver,\n                            undefined,\n                            mainAliasName,\n                            primaryColumn.databaseName,\n                        ),\n                    )\n                    if (!orderBys[columnAlias])\n                        // make sure we aren't overriding user-defined order in inverse direction\n                        orderBys[columnAlias] = \"ASC\"\n\n                    const alias = DriverUtils.buildAlias(\n                        this.connection.driver,\n                        undefined,\n                        \"ids_\" + mainAliasName,\n                        primaryColumn.databaseName,\n                    )\n\n                    return `${distinctAlias}.${columnAlias} AS ${this.escape(\n                        alias,\n                    )}`\n                },\n            )\n\n            const originalQuery = this.clone()\n\n            // preserve original timeTravel value since we set it to \"false\" in subquery\n            const originalQueryTimeTravel =\n                originalQuery.expressionMap.timeTravel\n\n            rawResults = await new SelectQueryBuilder(\n                this.connection,\n                queryRunner,\n            )\n                .select(`DISTINCT ${querySelects.join(\", \")}`)\n                .addSelect(selects)\n                .from(\n                    `(${originalQuery\n                        .orderBy()\n                        .timeTravelQuery(false) // set it to \"false\" since time travel clause must appear at the very end and applies to the entire SELECT clause.\n                        .getQuery()})`,\n                    \"distinctAlias\",\n                )\n                .timeTravelQuery(originalQueryTimeTravel)\n                .offset(this.expressionMap.skip)\n                .limit(this.expressionMap.take)\n                .orderBy(orderBys)\n                .cache(\n                    this.expressionMap.cache && this.expressionMap.cacheId\n                        ? `${this.expressionMap.cacheId}-pagination`\n                        : this.expressionMap.cache,\n                    this.expressionMap.cacheDuration,\n                )\n                .setParameters(this.getParameters())\n                .setNativeParameters(this.expressionMap.nativeParameters)\n                .getRawMany()\n\n            if (rawResults.length > 0) {\n                let condition = \"\"\n                const parameters: ObjectLiteral = {}\n                if (metadata.hasMultiplePrimaryKeys) {\n                    condition = rawResults\n                        .map((result, index) => {\n                            return metadata.primaryColumns\n                                .map((primaryColumn) => {\n                                    const paramKey = `orm_distinct_ids_${index}_${primaryColumn.databaseName}`\n                                    const paramKeyResult =\n                                        DriverUtils.buildAlias(\n                                            this.connection.driver,\n                                            undefined,\n                                            \"ids_\" + mainAliasName,\n                                            primaryColumn.databaseName,\n                                        )\n                                    parameters[paramKey] =\n                                        result[paramKeyResult]\n                                    return `${mainAliasName}.${primaryColumn.propertyPath}=:${paramKey}`\n                                })\n                                .join(\" AND \")\n                        })\n                        .join(\" OR \")\n                } else {\n                    const alias = DriverUtils.buildAlias(\n                        this.connection.driver,\n                        undefined,\n                        \"ids_\" + mainAliasName,\n                        metadata.primaryColumns[0].databaseName,\n                    )\n\n                    const ids = rawResults.map((result) => result[alias])\n                    const areAllNumbers = ids.every(\n                        (id: any) => typeof id === \"number\",\n                    )\n                    if (areAllNumbers) {\n                        // fixes #190. if all numbers then its safe to perform query without parameter\n                        condition = `${mainAliasName}.${\n                            metadata.primaryColumns[0].propertyPath\n                        } IN (${ids.join(\", \")})`\n                    } else {\n                        parameters[\"orm_distinct_ids\"] = ids\n                        condition =\n                            mainAliasName +\n                            \".\" +\n                            metadata.primaryColumns[0].propertyPath +\n                            \" IN (:...orm_distinct_ids)\"\n                    }\n                }\n                rawResults = await this.clone()\n                    .mergeExpressionMap({\n                        extraAppendedAndWhereCondition: condition,\n                    })\n                    .setParameters(parameters)\n                    .loadRawResults(queryRunner)\n            }\n        } else {\n            rawResults = await this.loadRawResults(queryRunner)\n        }\n\n        if (rawResults.length > 0) {\n            // transform raw results into entities\n            const rawRelationIdResults = await relationIdLoader.load(rawResults)\n            const rawRelationCountResults = await relationCountLoader.load(\n                rawResults,\n            )\n            const transformer = new RawSqlResultsToEntityTransformer(\n                this.expressionMap,\n                this.connection.driver,\n                rawRelationIdResults,\n                rawRelationCountResults,\n                this.queryRunner,\n            )\n            entities = transformer.transform(\n                rawResults,\n                this.expressionMap.mainAlias!,\n            )\n\n            // broadcast all \"after load\" events\n            if (\n                this.expressionMap.callListeners === true &&\n                this.expressionMap.mainAlias.hasMetadata\n            ) {\n                await queryRunner.broadcaster.broadcast(\n                    \"Load\",\n                    this.expressionMap.mainAlias.metadata,\n                    entities,\n                )\n            }\n        }\n\n        if (this.expressionMap.relationLoadStrategy === \"query\") {\n            const queryStrategyRelationIdLoader =\n                new QueryStrategyRelationIdLoader(this.connection, queryRunner)\n\n            await Promise.all(\n                this.relationMetadatas.map(async (relation) => {\n                    const relationTarget = relation.inverseEntityMetadata.target\n                    const relationAlias =\n                        relation.inverseEntityMetadata.targetName\n\n                    const select = Array.isArray(this.findOptions.select)\n                        ? OrmUtils.propertyPathsToTruthyObject(\n                              this.findOptions.select as string[],\n                          )\n                        : this.findOptions.select\n                    const relations = Array.isArray(this.findOptions.relations)\n                        ? OrmUtils.propertyPathsToTruthyObject(\n                              this.findOptions.relations,\n                          )\n                        : this.findOptions.relations\n\n                    const queryBuilder = this.createQueryBuilder(queryRunner)\n                        .select(relationAlias)\n                        .from(relationTarget, relationAlias)\n                        .setFindOptions({\n                            select: select\n                                ? OrmUtils.deepValue(\n                                      select,\n                                      relation.propertyPath,\n                                  )\n                                : undefined,\n                            order: this.findOptions.order\n                                ? OrmUtils.deepValue(\n                                      this.findOptions.order,\n                                      relation.propertyPath,\n                                  )\n                                : undefined,\n                            relations: relations\n                                ? OrmUtils.deepValue(\n                                      relations,\n                                      relation.propertyPath,\n                                  )\n                                : undefined,\n                            withDeleted: this.findOptions.withDeleted,\n                            relationLoadStrategy:\n                                this.findOptions.relationLoadStrategy,\n                        })\n                    if (entities.length > 0) {\n                        const relatedEntityGroups: any[] =\n                            await queryStrategyRelationIdLoader.loadManyToManyRelationIdsAndGroup(\n                                relation,\n                                entities,\n                                undefined,\n                                queryBuilder,\n                            )\n                        entities.forEach((entity) => {\n                            const relatedEntityGroup = relatedEntityGroups.find(\n                                (group) => group.entity === entity,\n                            )\n                            if (relatedEntityGroup) {\n                                const value =\n                                    relatedEntityGroup.related === undefined\n                                        ? null\n                                        : relatedEntityGroup.related\n                                relation.setEntityValue(entity, value)\n                            }\n                        })\n                    }\n                }),\n            )\n        }\n\n        return {\n            raw: rawResults,\n            entities: entities,\n        }\n    }\n\n    protected createOrderByCombinedWithSelectExpression(\n        parentAlias: string,\n    ): [string, OrderByCondition] {\n        // if table has a default order then apply it\n        const orderBys = this.expressionMap.allOrderBys\n        const selectString = Object.keys(orderBys)\n            .map((orderCriteria) => {\n                if (orderCriteria.indexOf(\".\") !== -1) {\n                    const criteriaParts = orderCriteria.split(\".\")\n                    const aliasName = criteriaParts[0]\n                    const propertyPath = criteriaParts.slice(1).join(\".\")\n                    const alias = this.expressionMap.findAliasByName(aliasName)\n                    const column =\n                        alias.metadata.findColumnWithPropertyPath(propertyPath)\n                    return (\n                        this.escape(parentAlias) +\n                        \".\" +\n                        this.escape(\n                            DriverUtils.buildAlias(\n                                this.connection.driver,\n                                undefined,\n                                aliasName,\n                                column!.databaseName,\n                            ),\n                        )\n                    )\n                } else {\n                    if (\n                        this.expressionMap.selects.find(\n                            (select) =>\n                                select.selection === orderCriteria ||\n                                select.aliasName === orderCriteria,\n                        )\n                    )\n                        return (\n                            this.escape(parentAlias) +\n                            \".\" +\n                            this.escape(orderCriteria)\n                        )\n\n                    return \"\"\n                }\n            })\n            .join(\", \")\n\n        const orderByObject: OrderByCondition = {}\n        Object.keys(orderBys).forEach((orderCriteria) => {\n            if (orderCriteria.indexOf(\".\") !== -1) {\n                const criteriaParts = orderCriteria.split(\".\")\n                const aliasName = criteriaParts[0]\n                const propertyPath = criteriaParts.slice(1).join(\".\")\n                const alias = this.expressionMap.findAliasByName(aliasName)\n                const column =\n                    alias.metadata.findColumnWithPropertyPath(propertyPath)\n                orderByObject[\n                    this.escape(parentAlias) +\n                        \".\" +\n                        this.escape(\n                            DriverUtils.buildAlias(\n                                this.connection.driver,\n                                undefined,\n                                aliasName,\n                                column!.databaseName,\n                            ),\n                        )\n                ] = orderBys[orderCriteria]\n            } else {\n                if (\n                    this.expressionMap.selects.find(\n                        (select) =>\n                            select.selection === orderCriteria ||\n                            select.aliasName === orderCriteria,\n                    )\n                ) {\n                    orderByObject[\n                        this.escape(parentAlias) +\n                            \".\" +\n                            this.escape(orderCriteria)\n                    ] = orderBys[orderCriteria]\n                } else {\n                    orderByObject[orderCriteria] = orderBys[orderCriteria]\n                }\n            }\n        })\n\n        return [selectString, orderByObject]\n    }\n\n    /**\n     * Loads raw results from the database.\n     */\n    protected async loadRawResults(queryRunner: QueryRunner) {\n        const [sql, parameters] = this.getQueryAndParameters()\n        const queryId =\n            sql +\n            \" -- PARAMETERS: \" +\n            JSON.stringify(parameters, (_, value) =>\n                typeof value === \"bigint\" ? value.toString() : value,\n            )\n        const cacheOptions =\n            typeof this.connection.options.cache === \"object\"\n                ? this.connection.options.cache\n                : {}\n        let savedQueryResultCacheOptions: QueryResultCacheOptions | undefined =\n            undefined\n        const isCachingEnabled =\n            // Caching is enabled globally and isn't disabled locally.\n            (cacheOptions.alwaysEnabled &&\n                this.expressionMap.cache !== false) ||\n            // ...or it's enabled locally explicitly.\n            this.expressionMap.cache === true\n        let cacheError = false\n        if (this.connection.queryResultCache && isCachingEnabled) {\n            try {\n                savedQueryResultCacheOptions =\n                    await this.connection.queryResultCache.getFromCache(\n                        {\n                            identifier: this.expressionMap.cacheId,\n                            query: queryId,\n                            duration:\n                                this.expressionMap.cacheDuration ||\n                                cacheOptions.duration ||\n                                1000,\n                        },\n                        queryRunner,\n                    )\n                if (\n                    savedQueryResultCacheOptions &&\n                    !this.connection.queryResultCache.isExpired(\n                        savedQueryResultCacheOptions,\n                    )\n                ) {\n                    return JSON.parse(savedQueryResultCacheOptions.result)\n                }\n            } catch (error) {\n                if (!cacheOptions.ignoreErrors) {\n                    throw error\n                }\n                cacheError = true\n            }\n        }\n\n        const results = await queryRunner.query(sql, parameters, true)\n\n        if (\n            !cacheError &&\n            this.connection.queryResultCache &&\n            isCachingEnabled\n        ) {\n            try {\n                await this.connection.queryResultCache.storeInCache(\n                    {\n                        identifier: this.expressionMap.cacheId,\n                        query: queryId,\n                        time: new Date().getTime(),\n                        duration:\n                            this.expressionMap.cacheDuration ||\n                            cacheOptions.duration ||\n                            1000,\n                        result: JSON.stringify(results.records),\n                    },\n                    savedQueryResultCacheOptions,\n                    queryRunner,\n                )\n            } catch (error) {\n                if (!cacheOptions.ignoreErrors) {\n                    throw error\n                }\n            }\n        }\n\n        return results.records\n    }\n\n    /**\n     * Merges into expression map given expression map properties.\n     */\n    protected mergeExpressionMap(\n        expressionMap: Partial<QueryExpressionMap>,\n    ): this {\n        ObjectUtils.assign(this.expressionMap, expressionMap)\n        return this\n    }\n\n    /**\n     * Normalizes a give number - converts to int if possible.\n     */\n    protected normalizeNumber(num: any) {\n        if (typeof num === \"number\" || num === undefined || num === null)\n            return num\n\n        return Number(num)\n    }\n\n    /**\n     * Creates a query builder used to execute sql queries inside this query builder.\n     */\n    protected obtainQueryRunner() {\n        return (\n            this.queryRunner ||\n            this.connection.createQueryRunner(\n                this.connection.defaultReplicationModeForReads(),\n            )\n        )\n    }\n\n    protected buildSelect(\n        select: FindOptionsSelect<any>,\n        metadata: EntityMetadata,\n        alias: string,\n        embedPrefix?: string,\n    ) {\n        for (let key in select) {\n            if (select[key] === undefined || select[key] === false) continue\n\n            const propertyPath = embedPrefix ? embedPrefix + \".\" + key : key\n            const column =\n                metadata.findColumnWithPropertyPathStrict(propertyPath)\n            const embed = metadata.findEmbeddedWithPropertyPath(propertyPath)\n            const relation = metadata.findRelationWithPropertyPath(propertyPath)\n\n            if (!embed && !column && !relation)\n                throw new EntityPropertyNotFoundError(propertyPath, metadata)\n\n            if (column) {\n                this.selects.push(alias + \".\" + propertyPath)\n                // this.addSelect(alias + \".\" + propertyPath);\n            } else if (embed) {\n                this.buildSelect(\n                    select[key] as FindOptionsSelect<any>,\n                    metadata,\n                    alias,\n                    propertyPath,\n                )\n\n                // } else if (relation) {\n                //     const joinAlias = alias + \"_\" + relation.propertyName;\n                //     const existJoin = this.joins.find(join => join.alias === joinAlias);\n                //     if (!existJoin) {\n                //         this.joins.push({\n                //             type: \"left\",\n                //             select: false,\n                //             alias: joinAlias,\n                //             parentAlias: alias,\n                //             relationMetadata: relation\n                //         });\n                //     }\n                //     this.buildOrder(select[key] as FindOptionsOrder<any>, relation.inverseEntityMetadata, joinAlias);\n            }\n        }\n    }\n\n    protected buildRelations(\n        relations: FindOptionsRelations<any>,\n        selection: FindOptionsSelect<any> | undefined,\n        metadata: EntityMetadata,\n        alias: string,\n        embedPrefix?: string,\n    ) {\n        if (!relations) return\n\n        Object.keys(relations).forEach((relationName) => {\n            const relationValue = (relations as any)[relationName]\n            const propertyPath = embedPrefix\n                ? embedPrefix + \".\" + relationName\n                : relationName\n            const embed = metadata.findEmbeddedWithPropertyPath(propertyPath)\n            const relation = metadata.findRelationWithPropertyPath(propertyPath)\n            if (!embed && !relation)\n                throw new EntityPropertyNotFoundError(propertyPath, metadata)\n\n            if (embed) {\n                this.buildRelations(\n                    relationValue,\n                    typeof selection === \"object\"\n                        ? OrmUtils.deepValue(selection, embed.propertyPath)\n                        : undefined,\n                    metadata,\n                    alias,\n                    propertyPath,\n                )\n            } else if (relation) {\n                let joinAlias = alias + \"_\" + propertyPath.replace(\".\", \"_\")\n                joinAlias = DriverUtils.buildAlias(\n                    this.connection.driver,\n                    { joiner: \"__\" },\n                    alias,\n                    joinAlias,\n                )\n                if (\n                    relationValue === true ||\n                    typeof relationValue === \"object\"\n                ) {\n                    if (this.expressionMap.relationLoadStrategy === \"query\") {\n                        this.concatRelationMetadata(relation)\n                    } else {\n                        // join\n                        this.joins.push({\n                            type: \"left\",\n                            select: true,\n                            selection:\n                                selection &&\n                                typeof selection[relationName] === \"object\"\n                                    ? (selection[\n                                          relationName\n                                      ] as FindOptionsSelect<any>)\n                                    : undefined,\n                            alias: joinAlias,\n                            parentAlias: alias,\n                            relationMetadata: relation,\n                        })\n\n                        if (\n                            selection &&\n                            typeof selection[relationName] === \"object\"\n                        ) {\n                            this.buildSelect(\n                                selection[\n                                    relationName\n                                ] as FindOptionsSelect<any>,\n                                relation.inverseEntityMetadata,\n                                joinAlias,\n                            )\n                        }\n                    }\n                }\n\n                if (\n                    typeof relationValue === \"object\" &&\n                    this.expressionMap.relationLoadStrategy === \"join\"\n                ) {\n                    this.buildRelations(\n                        relationValue,\n                        typeof selection === \"object\"\n                            ? OrmUtils.deepValue(\n                                  selection,\n                                  relation.propertyPath,\n                              )\n                            : undefined,\n                        relation.inverseEntityMetadata,\n                        joinAlias,\n                        undefined,\n                    )\n                }\n            }\n        })\n    }\n\n    protected buildEagerRelations(\n        relations: FindOptionsRelations<any>,\n        selection: FindOptionsSelect<any> | undefined,\n        metadata: EntityMetadata,\n        alias: string,\n        embedPrefix?: string,\n    ) {\n        if (!relations) return\n\n        Object.keys(relations).forEach((relationName) => {\n            const relationValue = (relations as any)[relationName]\n            const propertyPath = embedPrefix\n                ? embedPrefix + \".\" + relationName\n                : relationName\n            const embed = metadata.findEmbeddedWithPropertyPath(propertyPath)\n            const relation = metadata.findRelationWithPropertyPath(propertyPath)\n            if (!embed && !relation)\n                throw new EntityPropertyNotFoundError(propertyPath, metadata)\n\n            if (embed) {\n                this.buildEagerRelations(\n                    relationValue,\n                    typeof selection === \"object\"\n                        ? OrmUtils.deepValue(selection, embed.propertyPath)\n                        : undefined,\n                    metadata,\n                    alias,\n                    propertyPath,\n                )\n            } else if (relation) {\n                let joinAlias = alias + \"_\" + propertyPath.replace(\".\", \"_\")\n                joinAlias = DriverUtils.buildAlias(\n                    this.connection.driver,\n                    { joiner: \"__\" },\n                    alias,\n                    joinAlias,\n                )\n\n                if (\n                    relationValue === true ||\n                    typeof relationValue === \"object\"\n                ) {\n                    relation.inverseEntityMetadata.eagerRelations.forEach(\n                        (eagerRelation) => {\n                            let eagerRelationJoinAlias =\n                                joinAlias +\n                                \"_\" +\n                                eagerRelation.propertyPath.replace(\".\", \"_\")\n                            eagerRelationJoinAlias = DriverUtils.buildAlias(\n                                this.connection.driver,\n                                { joiner: \"__\" },\n                                joinAlias,\n                                eagerRelationJoinAlias,\n                            )\n\n                            const existJoin = this.joins.find(\n                                (join) => join.alias === eagerRelationJoinAlias,\n                            )\n                            if (!existJoin) {\n                                this.joins.push({\n                                    type: \"left\",\n                                    select: true,\n                                    alias: eagerRelationJoinAlias,\n                                    parentAlias: joinAlias,\n                                    selection: undefined,\n                                    relationMetadata: eagerRelation,\n                                })\n                            }\n\n                            if (\n                                selection &&\n                                typeof selection[relationName] === \"object\"\n                            ) {\n                                this.buildSelect(\n                                    selection[\n                                        relationName\n                                    ] as FindOptionsSelect<any>,\n                                    relation.inverseEntityMetadata,\n                                    joinAlias,\n                                )\n                            }\n                        },\n                    )\n                }\n\n                if (typeof relationValue === \"object\") {\n                    this.buildEagerRelations(\n                        relationValue,\n                        typeof selection === \"object\"\n                            ? OrmUtils.deepValue(\n                                  selection,\n                                  relation.propertyPath,\n                              )\n                            : undefined,\n                        relation.inverseEntityMetadata,\n                        joinAlias,\n                        undefined,\n                    )\n                }\n            }\n        })\n    }\n\n    protected buildOrder(\n        order: FindOptionsOrder<any>,\n        metadata: EntityMetadata,\n        alias: string,\n        embedPrefix?: string,\n    ) {\n        for (let key in order) {\n            if (order[key] === undefined) continue\n\n            const propertyPath = embedPrefix ? embedPrefix + \".\" + key : key\n            const column =\n                metadata.findColumnWithPropertyPathStrict(propertyPath)\n            const embed = metadata.findEmbeddedWithPropertyPath(propertyPath)\n            const relation = metadata.findRelationWithPropertyPath(propertyPath)\n\n            if (!embed && !column && !relation)\n                throw new EntityPropertyNotFoundError(propertyPath, metadata)\n\n            if (column) {\n                let direction =\n                    typeof order[key] === \"object\"\n                        ? (order[key] as any).direction\n                        : order[key]\n                direction =\n                    direction === \"DESC\" ||\n                    direction === \"desc\" ||\n                    direction === -1\n                        ? \"DESC\"\n                        : \"ASC\"\n                let nulls =\n                    typeof order[key] === \"object\"\n                        ? (order[key] as any).nulls\n                        : undefined\n                nulls =\n                    nulls?.toLowerCase() === \"first\"\n                        ? \"NULLS FIRST\"\n                        : nulls?.toLowerCase() === \"last\"\n                        ? \"NULLS LAST\"\n                        : undefined\n\n                let aliasPath = `${alias}.${propertyPath}`\n                // const selection = this.expressionMap.selects.find(\n                //     (s) => s.selection === aliasPath,\n                // )\n                // if (selection) {\n                //     // this is not building correctly now???\n                //     aliasPath = this.escape(\n                //         DriverUtils.buildAlias(\n                //             this.connection.driver,\n                //             undefined,\n                //             alias,\n                //             column.databaseName,\n                //         ),\n                //     )\n                //     // selection.aliasName = aliasPath\n                // } else {\n                //     if (column.isVirtualProperty && column.query) {\n                //         aliasPath = `(${column.query(alias)})`\n                //     }\n                // }\n\n                // console.log(\"add sort\", selection, aliasPath, direction, nulls)\n                this.addOrderBy(aliasPath, direction, nulls)\n                // this.orderBys.push({ alias: alias + \".\" + propertyPath, direction, nulls });\n            } else if (embed) {\n                this.buildOrder(\n                    order[key] as FindOptionsOrder<any>,\n                    metadata,\n                    alias,\n                    propertyPath,\n                )\n            } else if (relation) {\n                let joinAlias = alias + \"_\" + propertyPath.replace(\".\", \"_\")\n                joinAlias = DriverUtils.buildAlias(\n                    this.connection.driver,\n                    { joiner: \"__\" },\n                    alias,\n                    joinAlias,\n                )\n                // console.log(\"joinAlias\", joinAlias, joinAlias.length, this.connection.driver.maxAliasLength)\n                // todo: use expressionMap.joinAttributes, and create a new one using\n                //  const joinAttribute = new JoinAttribute(this.connection, this.expressionMap);\n\n                const existJoin = this.joins.find(\n                    (join) => join.alias === joinAlias,\n                )\n                if (!existJoin) {\n                    this.joins.push({\n                        type: \"left\",\n                        select: false,\n                        alias: joinAlias,\n                        parentAlias: alias,\n                        selection: undefined,\n                        relationMetadata: relation,\n                    })\n                }\n                this.buildOrder(\n                    order[key] as FindOptionsOrder<any>,\n                    relation.inverseEntityMetadata,\n                    joinAlias,\n                )\n            }\n        }\n    }\n\n    protected buildWhere(\n        where: FindOptionsWhere<any>[] | FindOptionsWhere<any>,\n        metadata: EntityMetadata,\n        alias: string,\n        embedPrefix?: string,\n    ) {\n        let condition: string = \"\"\n        // let parameterIndex = Object.keys(this.expressionMap.nativeParameters).length;\n        if (Array.isArray(where)) {\n            if (where.length) {\n                condition = where\n                    .map((whereItem) => {\n                        return this.buildWhere(\n                            whereItem,\n                            metadata,\n                            alias,\n                            embedPrefix,\n                        )\n                    })\n                    .filter((condition) => !!condition)\n                    .map((condition) => \"(\" + condition + \")\")\n                    .join(\" OR \")\n            }\n        } else {\n            let andConditions: string[] = []\n            for (let key in where) {\n                if (where[key] === undefined || where[key] === null) continue\n\n                const propertyPath = embedPrefix ? embedPrefix + \".\" + key : key\n                const column =\n                    metadata.findColumnWithPropertyPathStrict(propertyPath)\n                const embed =\n                    metadata.findEmbeddedWithPropertyPath(propertyPath)\n                const relation =\n                    metadata.findRelationWithPropertyPath(propertyPath)\n\n                if (!embed && !column && !relation)\n                    throw new EntityPropertyNotFoundError(\n                        propertyPath,\n                        metadata,\n                    )\n\n                if (column) {\n                    let aliasPath = `${alias}.${propertyPath}`\n                    if (column.isVirtualProperty && column.query) {\n                        aliasPath = `(${column.query(alias)})`\n                    }\n                    // const parameterName = alias + \"_\" + propertyPath.split(\".\").join(\"_\") + \"_\" + parameterIndex;\n\n                    // todo: we need to handle other operators as well?\n                    let parameterValue = where[key]\n                    if (InstanceChecker.isEqualOperator(where[key])) {\n                        parameterValue = where[key].value\n                    }\n                    if (column.transformer) {\n                        parameterValue instanceof FindOperator\n                            ? parameterValue.transformValue(column.transformer)\n                            : (parameterValue =\n                                  ApplyValueTransformers.transformTo(\n                                      column.transformer,\n                                      parameterValue,\n                                  ))\n                    }\n\n                    // if (parameterValue === null) {\n                    //     andConditions.push(`${aliasPath} IS NULL`);\n                    //\n                    // } else if (parameterValue instanceof FindOperator) {\n                    //     // let parameters: any[] = [];\n                    //     // if (parameterValue.useParameter) {\n                    //     //     const realParameterValues: any[] = parameterValue.multipleParameters ? parameterValue.value : [parameterValue.value];\n                    //     //     realParameterValues.forEach((realParameterValue, realParameterValueIndex) => {\n                    //     //\n                    //     //         // don't create parameters for number to prevent max number of variables issues as much as possible\n                    //     //         if (typeof realParameterValue === \"number\") {\n                    //     //             parameters.push(realParameterValue);\n                    //     //\n                    //     //         } else {\n                    //     //             this.expressionMap.nativeParameters[parameterName + realParameterValueIndex] = realParameterValue;\n                    //     //             parameterIndex++;\n                    //     //             parameters.push(this.connection.driver.createParameter(parameterName + realParameterValueIndex, parameterIndex - 1));\n                    //     //         }\n                    //     //     });\n                    //     // }\n                    //     andConditions.push(\n                    //         this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, parameterValue))\n                    //         // parameterValue.toSql(this.connection, aliasPath, parameters));\n                    //     )\n                    //\n                    // } else {\n                    //     this.expressionMap.nativeParameters[parameterName] = parameterValue;\n                    //     parameterIndex++;\n                    //     const parameter = this.connection.driver.createParameter(parameterName, parameterIndex - 1);\n                    //     andConditions.push(`${aliasPath} = ${parameter}`);\n                    // }\n\n                    andConditions.push(\n                        this.createWhereConditionExpression(\n                            this.getWherePredicateCondition(\n                                aliasPath,\n                                parameterValue,\n                            ),\n                        ),\n                        // parameterValue.toSql(this.connection, aliasPath, parameters));\n                    )\n\n                    // this.conditions.push(`${alias}.${propertyPath} = :${paramName}`);\n                    // this.expressionMap.parameters[paramName] = where[key]; // todo: handle functions and other edge cases\n                } else if (embed) {\n                    const condition = this.buildWhere(\n                        where[key],\n                        metadata,\n                        alias,\n                        propertyPath,\n                    )\n                    if (condition) andConditions.push(condition)\n                } else if (relation) {\n                    // if all properties of where are undefined we don't need to join anything\n                    // this can happen when user defines map with conditional queries inside\n                    if (typeof where[key] === \"object\") {\n                        const allAllUndefined = Object.keys(where[key]).every(\n                            (k) => where[key][k] === undefined,\n                        )\n                        if (allAllUndefined) {\n                            continue\n                        }\n                    }\n\n                    if (InstanceChecker.isFindOperator(where[key])) {\n                        if (\n                            where[key].type === \"moreThan\" ||\n                            where[key].type === \"lessThan\" ||\n                            where[key].type === \"moreThanOrEqual\" ||\n                            where[key].type === \"lessThanOrEqual\"\n                        ) {\n                            let sqlOperator = \"\"\n                            if (where[key].type === \"moreThan\") {\n                                sqlOperator = \">\"\n                            } else if (where[key].type === \"lessThan\") {\n                                sqlOperator = \"<\"\n                            } else if (where[key].type === \"moreThanOrEqual\") {\n                                sqlOperator = \">=\"\n                            } else if (where[key].type === \"lessThanOrEqual\") {\n                                sqlOperator = \"<=\"\n                            }\n                            // basically relation count functionality\n                            const qb: QueryBuilder<any> = this.subQuery()\n                            if (relation.isManyToManyOwner) {\n                                qb.select(\"COUNT(*)\")\n                                    .from(\n                                        relation.joinTableName,\n                                        relation.joinTableName,\n                                    )\n                                    .where(\n                                        relation.joinColumns\n                                            .map((column) => {\n                                                return `${\n                                                    relation.joinTableName\n                                                }.${\n                                                    column.propertyName\n                                                } = ${alias}.${\n                                                    column.referencedColumn!\n                                                        .propertyName\n                                                }`\n                                            })\n                                            .join(\" AND \"),\n                                    )\n                            } else if (relation.isManyToManyNotOwner) {\n                                qb.select(\"COUNT(*)\")\n                                    .from(\n                                        relation.inverseRelation!.joinTableName,\n                                        relation.inverseRelation!.joinTableName,\n                                    )\n                                    .where(\n                                        relation\n                                            .inverseRelation!.inverseJoinColumns.map(\n                                                (column) => {\n                                                    return `${\n                                                        relation.inverseRelation!\n                                                            .joinTableName\n                                                    }.${\n                                                        column.propertyName\n                                                    } = ${alias}.${\n                                                        column.referencedColumn!\n                                                            .propertyName\n                                                    }`\n                                                },\n                                            )\n                                            .join(\" AND \"),\n                                    )\n                            } else if (relation.isOneToMany) {\n                                qb.select(\"COUNT(*)\")\n                                    .from(\n                                        relation.inverseEntityMetadata.target,\n                                        relation.inverseEntityMetadata\n                                            .tableName,\n                                    )\n                                    .where(\n                                        relation\n                                            .inverseRelation!.joinColumns.map(\n                                                (column) => {\n                                                    return `${\n                                                        relation\n                                                            .inverseEntityMetadata\n                                                            .tableName\n                                                    }.${\n                                                        column.propertyName\n                                                    } = ${alias}.${\n                                                        column.referencedColumn!\n                                                            .propertyName\n                                                    }`\n                                                },\n                                            )\n                                            .join(\" AND \"),\n                                    )\n                            } else {\n                                throw new Error(\n                                    `This relation isn't supported by given find operator`,\n                                )\n                            }\n                            // this\n                            //     .addSelect(qb.getSql(), relation.propertyAliasName + \"_cnt\")\n                            //     .andWhere(this.escape(relation.propertyAliasName + \"_cnt\") + \" \" + sqlOperator + \" \" + parseInt(where[key].value));\n                            this.andWhere(\n                                qb.getSql() +\n                                    \" \" +\n                                    sqlOperator +\n                                    \" \" +\n                                    parseInt(where[key].value),\n                            )\n                        } else {\n                            if (\n                                relation.isManyToOne ||\n                                (relation.isOneToOne &&\n                                    relation.isOneToOneOwner)\n                            ) {\n                                const aliasPath = `${alias}.${propertyPath}`\n\n                                andConditions.push(\n                                    this.createWhereConditionExpression(\n                                        this.getWherePredicateCondition(\n                                            aliasPath,\n                                            where[key],\n                                        ),\n                                    ),\n                                )\n                            } else {\n                                throw new Error(\n                                    `This relation isn't supported by given find operator`,\n                                )\n                            }\n                        }\n                    } else {\n                        // const joinAlias = alias + \"_\" + relation.propertyName;\n                        let joinAlias =\n                            alias +\n                            \"_\" +\n                            relation.propertyPath.replace(\".\", \"_\")\n                        joinAlias = DriverUtils.buildAlias(\n                            this.connection.driver,\n                            { joiner: \"__\" },\n                            alias,\n                            joinAlias,\n                        )\n\n                        const existJoin = this.joins.find(\n                            (join) => join.alias === joinAlias,\n                        )\n                        if (!existJoin) {\n                            this.joins.push({\n                                type: \"left\",\n                                select: false,\n                                selection: undefined,\n                                alias: joinAlias,\n                                parentAlias: alias,\n                                relationMetadata: relation,\n                            })\n                        }\n\n                        const condition = this.buildWhere(\n                            where[key],\n                            relation.inverseEntityMetadata,\n                            joinAlias,\n                        )\n                        if (condition) {\n                            andConditions.push(condition)\n                            // parameterIndex = Object.keys(this.expressionMap.nativeParameters).length;\n                        }\n                    }\n                }\n            }\n            condition = andConditions.length\n                ? \"(\" + andConditions.join(\") AND (\") + \")\"\n                : andConditions.join(\" AND \")\n        }\n        return condition.length ? \"(\" + condition + \")\" : condition\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}