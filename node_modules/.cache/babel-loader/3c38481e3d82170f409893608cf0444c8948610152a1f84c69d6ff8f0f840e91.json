{"ast":null,"code":"import { ColumnTypeUndefinedError } from \"../../error\";\nimport { getMetadataArgsStorage } from \"../../globals\";\n/**\n * VirtualColumn decorator is used to mark a specific class property as a Virtual column.\n */\nexport function VirtualColumn(typeOrOptions, options) {\n  return function (object, propertyName) {\n    // normalize parameters\n    let type;\n    if (typeof typeOrOptions === \"string\") {\n      type = typeOrOptions;\n    } else {\n      options = typeOrOptions;\n      type = options.type;\n    }\n    if (!options?.query) {\n      throw new Error(\"Column options must be defined for calculated columns.\");\n    }\n    // if type is not given explicitly then try to guess it\n    const reflectMetadataType = Reflect && Reflect.getMetadata ? Reflect.getMetadata(\"design:type\", object, propertyName) : undefined;\n    if (!type && reflectMetadataType)\n      // if type is not given explicitly then try to guess it\n      type = reflectMetadataType;\n    // check if there is no type in column options then set type from first function argument, or guessed one\n    if (type) options.type = type;\n    // specify HSTORE type if column is HSTORE\n    if (options.type === \"hstore\" && !options.hstoreType) options.hstoreType = reflectMetadataType === Object ? \"object\" : \"string\";\n    // if we still don't have a type then we need to give error to user that type is required\n    if (!options.type) throw new ColumnTypeUndefinedError(object, propertyName);\n    getMetadataArgsStorage().columns.push({\n      target: object.constructor,\n      propertyName: propertyName,\n      mode: \"virtual-property\",\n      options: options || {}\n    });\n  };\n}","map":{"version":3,"names":["ColumnTypeUndefinedError","getMetadataArgsStorage","VirtualColumn","typeOrOptions","options","object","propertyName","type","query","Error","reflectMetadataType","Reflect","getMetadata","undefined","hstoreType","Object","columns","push","target","constructor","mode"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\decorator\\columns\\VirtualColumn.ts"],"sourcesContent":["import { ColumnType } from \"../../driver/types/ColumnTypes\"\nimport { ColumnTypeUndefinedError } from \"../../error\"\nimport { getMetadataArgsStorage } from \"../../globals\"\nimport { ColumnMetadataArgs } from \"../../metadata-args/ColumnMetadataArgs\"\nimport { VirtualColumnOptions } from \"../options/VirtualColumnOptions\"\n/**\n * VirtualColumn decorator is used to mark a specific class property as a Virtual column.\n */\nexport function VirtualColumn(options: VirtualColumnOptions): PropertyDecorator\n\n/**\n * VirtualColumn decorator is used to mark a specific class property as a Virtual column.\n */\nexport function VirtualColumn(\n    typeOrOptions: ColumnType,\n    options: VirtualColumnOptions,\n): PropertyDecorator\n\n/**\n * VirtualColumn decorator is used to mark a specific class property as a Virtual column.\n */\nexport function VirtualColumn(\n    typeOrOptions?: ColumnType | VirtualColumnOptions,\n    options?: VirtualColumnOptions,\n): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        // normalize parameters\n        let type: ColumnType | undefined\n        if (typeof typeOrOptions === \"string\") {\n            type = <ColumnType>typeOrOptions\n        } else {\n            options = <VirtualColumnOptions>typeOrOptions\n            type = options.type\n        }\n\n        if (!options?.query) {\n            throw new Error(\n                \"Column options must be defined for calculated columns.\",\n            )\n        }\n\n        // if type is not given explicitly then try to guess it\n        const reflectMetadataType =\n            Reflect && (Reflect as any).getMetadata\n                ? (Reflect as any).getMetadata(\n                      \"design:type\",\n                      object,\n                      propertyName,\n                  )\n                : undefined\n        if (!type && reflectMetadataType)\n            // if type is not given explicitly then try to guess it\n            type = reflectMetadataType\n\n        // check if there is no type in column options then set type from first function argument, or guessed one\n        if (type) options.type = type\n\n        // specify HSTORE type if column is HSTORE\n        if (options.type === \"hstore\" && !options.hstoreType)\n            options.hstoreType =\n                reflectMetadataType === Object ? \"object\" : \"string\"\n\n        // if we still don't have a type then we need to give error to user that type is required\n        if (!options.type)\n            throw new ColumnTypeUndefinedError(object, propertyName)\n\n        getMetadataArgsStorage().columns.push({\n            target: object.constructor,\n            propertyName: propertyName,\n            mode: \"virtual-property\",\n            options: options || {},\n        } as ColumnMetadataArgs)\n    }\n}\n"],"mappings":"AACA,SAASA,wBAAwB,QAAQ,aAAa;AACtD,SAASC,sBAAsB,QAAQ,eAAe;AAgBtD;;;AAGA,OAAM,SAAUC,aAAaA,CACzBC,aAAiD,EACjDC,OAA8B;EAE9B,OAAO,UAAUC,MAAc,EAAEC,YAAoB;IACjD;IACA,IAAIC,IAA4B;IAChC,IAAI,OAAOJ,aAAa,KAAK,QAAQ,EAAE;MACnCI,IAAI,GAAeJ,aAAa;IACpC,CAAC,MAAM;MACHC,OAAO,GAAyBD,aAAa;MAC7CI,IAAI,GAAGH,OAAO,CAACG,IAAI;IACvB;IAEA,IAAI,CAACH,OAAO,EAAEI,KAAK,EAAE;MACjB,MAAM,IAAIC,KAAK,CACX,wDAAwD,CAC3D;IACL;IAEA;IACA,MAAMC,mBAAmB,GACrBC,OAAO,IAAKA,OAAe,CAACC,WAAW,GAChCD,OAAe,CAACC,WAAW,CACxB,aAAa,EACbP,MAAM,EACNC,YAAY,CACf,GACDO,SAAS;IACnB,IAAI,CAACN,IAAI,IAAIG,mBAAmB;MAC5B;MACAH,IAAI,GAAGG,mBAAmB;IAE9B;IACA,IAAIH,IAAI,EAAEH,OAAO,CAACG,IAAI,GAAGA,IAAI;IAE7B;IACA,IAAIH,OAAO,CAACG,IAAI,KAAK,QAAQ,IAAI,CAACH,OAAO,CAACU,UAAU,EAChDV,OAAO,CAACU,UAAU,GACdJ,mBAAmB,KAAKK,MAAM,GAAG,QAAQ,GAAG,QAAQ;IAE5D;IACA,IAAI,CAACX,OAAO,CAACG,IAAI,EACb,MAAM,IAAIP,wBAAwB,CAACK,MAAM,EAAEC,YAAY,CAAC;IAE5DL,sBAAsB,EAAE,CAACe,OAAO,CAACC,IAAI,CAAC;MAClCC,MAAM,EAAEb,MAAM,CAACc,WAAW;MAC1Bb,YAAY,EAAEA,YAAY;MAC1Bc,IAAI,EAAE,kBAAkB;MACxBhB,OAAO,EAAEA,OAAO,IAAI;KACD,CAAC;EAC5B,CAAC;AACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}