{"ast":null,"code":"import { CannotAttachTreeChildrenEntityError } from \"../../error/CannotAttachTreeChildrenEntityError\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\n/**\n * Executes subject operations for closure entities.\n */\nexport class ClosureSubjectExecutor {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(queryRunner) {\n    this.queryRunner = queryRunner;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Executes operations when subject is being inserted.\n   */\n  async insert(subject) {\n    // create values to be inserted into the closure junction\n    const closureJunctionInsertMap = {};\n    subject.metadata.closureJunctionTable.ancestorColumns.forEach(column => {\n      closureJunctionInsertMap[column.databaseName] = subject.identifier;\n    });\n    subject.metadata.closureJunctionTable.descendantColumns.forEach(column => {\n      closureJunctionInsertMap[column.databaseName] = subject.identifier;\n    });\n    // insert values into the closure junction table\n    await this.queryRunner.manager.createQueryBuilder().insert().into(subject.metadata.closureJunctionTable.tablePath).values(closureJunctionInsertMap).updateEntity(false).callListeners(false).execute();\n    let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent\n    if (!parent && subject.parentSubject && subject.parentSubject.entity)\n      // if entity was attached via children\n      parent = subject.parentSubject.insertedValueSet ? subject.parentSubject.insertedValueSet : subject.parentSubject.entity;\n    if (parent) {\n      const escape = alias => this.queryRunner.connection.driver.escape(alias);\n      const tableName = this.getTableName(subject.metadata.closureJunctionTable.tablePath);\n      const queryParams = [];\n      const ancestorColumnNames = subject.metadata.closureJunctionTable.ancestorColumns.map(column => {\n        return escape(column.databaseName);\n      });\n      const descendantColumnNames = subject.metadata.closureJunctionTable.descendantColumns.map(column => {\n        return escape(column.databaseName);\n      });\n      const childEntityIds1 = subject.metadata.primaryColumns.map(column => {\n        queryParams.push(column.getEntityValue(subject.insertedValueSet ? subject.insertedValueSet : subject.entity));\n        return this.queryRunner.connection.driver.createParameter(\"child_entity_\" + column.databaseName, queryParams.length - 1);\n      });\n      const whereCondition = subject.metadata.closureJunctionTable.descendantColumns.map(column => {\n        const columnName = escape(column.databaseName);\n        const parentId = column.referencedColumn.getEntityValue(parent);\n        if (!parentId) throw new CannotAttachTreeChildrenEntityError(subject.metadata.name);\n        queryParams.push(parentId);\n        const parameterName = this.queryRunner.connection.driver.createParameter(\"parent_entity_\" + column.referencedColumn.databaseName, queryParams.length - 1);\n        return `${columnName} = ${parameterName}`;\n      });\n      await this.queryRunner.query(`INSERT INTO ${tableName} (${[...ancestorColumnNames, ...descendantColumnNames].join(\", \")}) ` + `SELECT ${ancestorColumnNames.join(\", \")}, ${childEntityIds1.join(\", \")} FROM ${tableName} WHERE ${whereCondition.join(\" AND \")}`, queryParams);\n    }\n  }\n  /**\n   * Executes operations when subject is being updated.\n   */\n  async update(subject) {\n    let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent\n    if (!parent && subject.parentSubject && subject.parentSubject.entity)\n      // if entity was attached via children\n      parent = subject.parentSubject.entity;\n    let entity = subject.databaseEntity; // if entity was attached via parent\n    if (!entity && parent)\n      // if entity was attached via children\n      entity = subject.metadata.treeChildrenRelation.getEntityValue(parent).find(child => {\n        return Object.entries(subject.identifier).every(([key, value]) => child[key] === value);\n      });\n    // Exit if the parent or the entity where never set\n    if (entity === undefined || parent === undefined) {\n      return;\n    }\n    const oldParent = subject.metadata.treeParentRelation.getEntityValue(entity);\n    const oldParentId = subject.metadata.getEntityIdMap(oldParent);\n    const parentId = subject.metadata.getEntityIdMap(parent);\n    // Exit if the new and old parents are the same\n    if (OrmUtils.compareIds(oldParentId, parentId)) {\n      return;\n    }\n    const escape = alias => this.queryRunner.connection.driver.escape(alias);\n    const closureTable = subject.metadata.closureJunctionTable;\n    const ancestorColumnNames = closureTable.ancestorColumns.map(column => {\n      return escape(column.databaseName);\n    });\n    const descendantColumnNames = closureTable.descendantColumns.map(column => {\n      return escape(column.databaseName);\n    });\n    // Delete logic\n    const createSubQuery = (qb, alias) => {\n      const subAlias = `sub${alias}`;\n      const subSelect = qb.createQueryBuilder().select(descendantColumnNames.join(\", \")).from(closureTable.tablePath, subAlias);\n      // Create where conditions e.g. (WHERE \"subdescendant\".\"id_ancestor\" = :value_id)\n      for (const column of closureTable.ancestorColumns) {\n        subSelect.andWhere(`${escape(subAlias)}.${escape(column.databaseName)} = :value_${column.referencedColumn.databaseName}`);\n      }\n      return qb.createQueryBuilder().select(descendantColumnNames.join(\", \")).from(`(${subSelect.getQuery()})`, alias).setParameters(subSelect.getParameters()).getQuery();\n    };\n    const parameters = {};\n    for (const column of subject.metadata.primaryColumns) {\n      parameters[`value_${column.databaseName}`] = entity[column.databaseName];\n    }\n    await this.queryRunner.manager.createQueryBuilder().delete().from(closureTable.tablePath).where(qb => `(${descendantColumnNames.join(\", \")}) IN (${createSubQuery(qb, \"descendant\")})`).andWhere(qb => `(${ancestorColumnNames.join(\", \")}) NOT IN (${createSubQuery(qb, \"ancestor\")})`).setParameters(parameters).execute();\n    /**\n     * Only insert new parent if it exits\n     *\n     * This only happens if the entity doesn't become a root entity\n     */\n    if (parent) {\n      // Insert logic\n      const queryParams = [];\n      const tableName = this.getTableName(closureTable.tablePath);\n      const superAlias = escape(\"supertree\");\n      const subAlias = escape(\"subtree\");\n      const select = [...ancestorColumnNames.map(columnName => `${superAlias}.${columnName}`), ...descendantColumnNames.map(columnName => `${subAlias}.${columnName}`)];\n      const entityWhereCondition = subject.metadata.closureJunctionTable.ancestorColumns.map(column => {\n        const columnName = escape(column.databaseName);\n        const entityId = column.referencedColumn.getEntityValue(entity);\n        queryParams.push(entityId);\n        const parameterName = this.queryRunner.connection.driver.createParameter(\"entity_\" + column.referencedColumn.databaseName, queryParams.length - 1);\n        return `${subAlias}.${columnName} = ${parameterName}`;\n      });\n      const parentWhereCondition = subject.metadata.closureJunctionTable.descendantColumns.map(column => {\n        const columnName = escape(column.databaseName);\n        const parentId = column.referencedColumn.getEntityValue(parent);\n        if (!parentId) throw new CannotAttachTreeChildrenEntityError(subject.metadata.name);\n        queryParams.push(parentId);\n        const parameterName = this.queryRunner.connection.driver.createParameter(\"parent_entity_\" + column.referencedColumn.databaseName, queryParams.length - 1);\n        return `${superAlias}.${columnName} = ${parameterName}`;\n      });\n      await this.queryRunner.query(`INSERT INTO ${tableName} (${[...ancestorColumnNames, ...descendantColumnNames].join(\", \")}) ` + `SELECT ${select.join(\", \")} ` + `FROM ${tableName} AS ${superAlias}, ${tableName} AS ${subAlias} ` + `WHERE ${[...entityWhereCondition, ...parentWhereCondition].join(\" AND \")}`, queryParams);\n    }\n  }\n  /**\n   * Executes operations when subject is being removed.\n   */\n  async remove(subjects) {\n    // Only mssql need to execute deletes for the juntion table as it doesn't support multi cascade paths.\n    if (!(this.queryRunner.connection.driver.options.type === \"mssql\")) {\n      return;\n    }\n    if (!Array.isArray(subjects)) subjects = [subjects];\n    const escape = alias => this.queryRunner.connection.driver.escape(alias);\n    const identifiers = subjects.map(subject => subject.identifier);\n    const closureTable = subjects[0].metadata.closureJunctionTable;\n    const generateWheres = columns => {\n      return columns.map(column => {\n        const data = identifiers.map(identifier => identifier[column.referencedColumn.databaseName]);\n        return `${escape(column.databaseName)} IN (${data.join(\", \")})`;\n      }).join(\" AND \");\n    };\n    const ancestorWhere = generateWheres(closureTable.ancestorColumns);\n    const descendantWhere = generateWheres(closureTable.descendantColumns);\n    await this.queryRunner.manager.createQueryBuilder().delete().from(closureTable.tablePath).where(ancestorWhere).orWhere(descendantWhere).execute();\n  }\n  /**\n   * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom\n   * schema name, otherwise returns escaped table name.\n   */\n  getTableName(tablePath) {\n    return tablePath.split(\".\").map(i => {\n      // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n      return i === \"\" ? i : this.queryRunner.connection.driver.escape(i);\n    }).join(\".\");\n  }\n}","map":{"version":3,"names":["CannotAttachTreeChildrenEntityError","OrmUtils","ClosureSubjectExecutor","constructor","queryRunner","insert","subject","closureJunctionInsertMap","metadata","closureJunctionTable","ancestorColumns","forEach","column","databaseName","identifier","descendantColumns","manager","createQueryBuilder","into","tablePath","values","updateEntity","callListeners","execute","parent","treeParentRelation","getEntityValue","entity","parentSubject","insertedValueSet","escape","alias","connection","driver","tableName","getTableName","queryParams","ancestorColumnNames","map","descendantColumnNames","childEntityIds1","primaryColumns","push","createParameter","length","whereCondition","columnName","parentId","referencedColumn","name","parameterName","query","join","update","databaseEntity","treeChildrenRelation","find","child","Object","entries","every","key","value","undefined","oldParent","oldParentId","getEntityIdMap","compareIds","closureTable","createSubQuery","qb","subAlias","subSelect","select","from","andWhere","getQuery","setParameters","getParameters","parameters","delete","where","superAlias","entityWhereCondition","entityId","parentWhereCondition","remove","subjects","options","type","Array","isArray","identifiers","generateWheres","columns","data","ancestorWhere","descendantWhere","orWhere","split","i"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\persistence\\tree\\ClosureSubjectExecutor.ts"],"sourcesContent":["import { Subject } from \"../Subject\"\nimport { QueryRunner } from \"../../query-runner/QueryRunner\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { CannotAttachTreeChildrenEntityError } from \"../../error/CannotAttachTreeChildrenEntityError\"\nimport { DeleteQueryBuilder } from \"../../query-builder/DeleteQueryBuilder\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { ColumnMetadata } from \"../../metadata/ColumnMetadata\"\n\n/**\n * Executes subject operations for closure entities.\n */\nexport class ClosureSubjectExecutor {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected queryRunner: QueryRunner) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes operations when subject is being inserted.\n     */\n    async insert(subject: Subject): Promise<void> {\n        // create values to be inserted into the closure junction\n        const closureJunctionInsertMap: ObjectLiteral = {}\n        subject.metadata.closureJunctionTable.ancestorColumns.forEach(\n            (column) => {\n                closureJunctionInsertMap[column.databaseName] =\n                    subject.identifier\n            },\n        )\n        subject.metadata.closureJunctionTable.descendantColumns.forEach(\n            (column) => {\n                closureJunctionInsertMap[column.databaseName] =\n                    subject.identifier\n            },\n        )\n\n        // insert values into the closure junction table\n        await this.queryRunner.manager\n            .createQueryBuilder()\n            .insert()\n            .into(subject.metadata.closureJunctionTable.tablePath)\n            .values(closureJunctionInsertMap)\n            .updateEntity(false)\n            .callListeners(false)\n            .execute()\n\n        let parent = subject.metadata.treeParentRelation!.getEntityValue(\n            subject.entity!,\n        ) // if entity was attached via parent\n        if (!parent && subject.parentSubject && subject.parentSubject.entity)\n            // if entity was attached via children\n            parent = subject.parentSubject.insertedValueSet\n                ? subject.parentSubject.insertedValueSet\n                : subject.parentSubject.entity\n\n        if (parent) {\n            const escape = (alias: string) =>\n                this.queryRunner.connection.driver.escape(alias)\n            const tableName = this.getTableName(\n                subject.metadata.closureJunctionTable.tablePath,\n            )\n            const queryParams: any[] = []\n\n            const ancestorColumnNames =\n                subject.metadata.closureJunctionTable.ancestorColumns.map(\n                    (column) => {\n                        return escape(column.databaseName)\n                    },\n                )\n            const descendantColumnNames =\n                subject.metadata.closureJunctionTable.descendantColumns.map(\n                    (column) => {\n                        return escape(column.databaseName)\n                    },\n                )\n            const childEntityIds1 = subject.metadata.primaryColumns.map(\n                (column) => {\n                    queryParams.push(\n                        column.getEntityValue(\n                            subject.insertedValueSet\n                                ? subject.insertedValueSet\n                                : subject.entity!,\n                        ),\n                    )\n                    return this.queryRunner.connection.driver.createParameter(\n                        \"child_entity_\" + column.databaseName,\n                        queryParams.length - 1,\n                    )\n                },\n            )\n\n            const whereCondition =\n                subject.metadata.closureJunctionTable.descendantColumns.map(\n                    (column) => {\n                        const columnName = escape(column.databaseName)\n                        const parentId =\n                            column.referencedColumn!.getEntityValue(parent)\n\n                        if (!parentId)\n                            throw new CannotAttachTreeChildrenEntityError(\n                                subject.metadata.name,\n                            )\n\n                        queryParams.push(parentId)\n                        const parameterName =\n                            this.queryRunner.connection.driver.createParameter(\n                                \"parent_entity_\" +\n                                    column.referencedColumn!.databaseName,\n                                queryParams.length - 1,\n                            )\n                        return `${columnName} = ${parameterName}`\n                    },\n                )\n\n            await this.queryRunner.query(\n                `INSERT INTO ${tableName} (${[\n                    ...ancestorColumnNames,\n                    ...descendantColumnNames,\n                ].join(\", \")}) ` +\n                    `SELECT ${ancestorColumnNames.join(\n                        \", \",\n                    )}, ${childEntityIds1.join(\n                        \", \",\n                    )} FROM ${tableName} WHERE ${whereCondition.join(\" AND \")}`,\n                queryParams,\n            )\n        }\n    }\n\n    /**\n     * Executes operations when subject is being updated.\n     */\n    async update(subject: Subject): Promise<void> {\n        let parent = subject.metadata.treeParentRelation!.getEntityValue(\n            subject.entity!,\n        ) // if entity was attached via parent\n        if (!parent && subject.parentSubject && subject.parentSubject.entity)\n            // if entity was attached via children\n            parent = subject.parentSubject.entity\n\n        let entity = subject.databaseEntity // if entity was attached via parent\n        if (!entity && parent)\n            // if entity was attached via children\n            entity = subject.metadata\n                .treeChildrenRelation!.getEntityValue(parent)\n                .find((child: any) => {\n                    return Object.entries(subject.identifier!).every(\n                        ([key, value]) => child[key] === value,\n                    )\n                })\n\n        // Exit if the parent or the entity where never set\n        if (entity === undefined || parent === undefined) {\n            return\n        }\n\n        const oldParent = subject.metadata.treeParentRelation!.getEntityValue(\n            entity!,\n        )\n        const oldParentId = subject.metadata.getEntityIdMap(oldParent)\n        const parentId = subject.metadata.getEntityIdMap(parent)\n\n        // Exit if the new and old parents are the same\n        if (OrmUtils.compareIds(oldParentId, parentId)) {\n            return\n        }\n\n        const escape = (alias: string) =>\n            this.queryRunner.connection.driver.escape(alias)\n        const closureTable = subject.metadata.closureJunctionTable\n\n        const ancestorColumnNames = closureTable.ancestorColumns.map(\n            (column) => {\n                return escape(column.databaseName)\n            },\n        )\n\n        const descendantColumnNames = closureTable.descendantColumns.map(\n            (column) => {\n                return escape(column.databaseName)\n            },\n        )\n\n        // Delete logic\n        const createSubQuery = (qb: DeleteQueryBuilder<any>, alias: string) => {\n            const subAlias = `sub${alias}`\n\n            const subSelect = qb\n                .createQueryBuilder()\n                .select(descendantColumnNames.join(\", \"))\n                .from(closureTable.tablePath, subAlias)\n\n            // Create where conditions e.g. (WHERE \"subdescendant\".\"id_ancestor\" = :value_id)\n            for (const column of closureTable.ancestorColumns) {\n                subSelect.andWhere(\n                    `${escape(subAlias)}.${escape(\n                        column.databaseName,\n                    )} = :value_${column.referencedColumn!.databaseName}`,\n                )\n            }\n\n            return qb\n                .createQueryBuilder()\n                .select(descendantColumnNames.join(\", \"))\n                .from(`(${subSelect.getQuery()})`, alias)\n                .setParameters(subSelect.getParameters())\n                .getQuery()\n        }\n\n        const parameters: ObjectLiteral = {}\n        for (const column of subject.metadata.primaryColumns) {\n            parameters[`value_${column.databaseName}`] =\n                entity![column.databaseName]\n        }\n\n        await this.queryRunner.manager\n            .createQueryBuilder()\n            .delete()\n            .from(closureTable.tablePath)\n            .where(\n                (qb) =>\n                    `(${descendantColumnNames.join(\", \")}) IN (${createSubQuery(\n                        qb,\n                        \"descendant\",\n                    )})`,\n            )\n            .andWhere(\n                (qb) =>\n                    `(${ancestorColumnNames.join(\n                        \", \",\n                    )}) NOT IN (${createSubQuery(qb, \"ancestor\")})`,\n            )\n            .setParameters(parameters)\n            .execute()\n\n        /**\n         * Only insert new parent if it exits\n         *\n         * This only happens if the entity doesn't become a root entity\n         */\n        if (parent) {\n            // Insert logic\n            const queryParams: any[] = []\n\n            const tableName = this.getTableName(closureTable.tablePath)\n            const superAlias = escape(\"supertree\")\n            const subAlias = escape(\"subtree\")\n\n            const select = [\n                ...ancestorColumnNames.map(\n                    (columnName) => `${superAlias}.${columnName}`,\n                ),\n                ...descendantColumnNames.map(\n                    (columnName) => `${subAlias}.${columnName}`,\n                ),\n            ]\n\n            const entityWhereCondition =\n                subject.metadata.closureJunctionTable.ancestorColumns.map(\n                    (column) => {\n                        const columnName = escape(column.databaseName)\n                        const entityId =\n                            column.referencedColumn!.getEntityValue(entity!)\n\n                        queryParams.push(entityId)\n                        const parameterName =\n                            this.queryRunner.connection.driver.createParameter(\n                                \"entity_\" +\n                                    column.referencedColumn!.databaseName,\n                                queryParams.length - 1,\n                            )\n                        return `${subAlias}.${columnName} = ${parameterName}`\n                    },\n                )\n\n            const parentWhereCondition =\n                subject.metadata.closureJunctionTable.descendantColumns.map(\n                    (column) => {\n                        const columnName = escape(column.databaseName)\n                        const parentId =\n                            column.referencedColumn!.getEntityValue(parent)\n\n                        if (!parentId)\n                            throw new CannotAttachTreeChildrenEntityError(\n                                subject.metadata.name,\n                            )\n\n                        queryParams.push(parentId)\n                        const parameterName =\n                            this.queryRunner.connection.driver.createParameter(\n                                \"parent_entity_\" +\n                                    column.referencedColumn!.databaseName,\n                                queryParams.length - 1,\n                            )\n                        return `${superAlias}.${columnName} = ${parameterName}`\n                    },\n                )\n\n            await this.queryRunner.query(\n                `INSERT INTO ${tableName} (${[\n                    ...ancestorColumnNames,\n                    ...descendantColumnNames,\n                ].join(\", \")}) ` +\n                    `SELECT ${select.join(\", \")} ` +\n                    `FROM ${tableName} AS ${superAlias}, ${tableName} AS ${subAlias} ` +\n                    `WHERE ${[\n                        ...entityWhereCondition,\n                        ...parentWhereCondition,\n                    ].join(\" AND \")}`,\n                queryParams,\n            )\n        }\n    }\n\n    /**\n     * Executes operations when subject is being removed.\n     */\n    async remove(subjects: Subject | Subject[]): Promise<void> {\n        // Only mssql need to execute deletes for the juntion table as it doesn't support multi cascade paths.\n        if (!(this.queryRunner.connection.driver.options.type === \"mssql\")) {\n            return\n        }\n\n        if (!Array.isArray(subjects)) subjects = [subjects]\n\n        const escape = (alias: string) =>\n            this.queryRunner.connection.driver.escape(alias)\n        const identifiers = subjects.map((subject) => subject.identifier)\n        const closureTable = subjects[0].metadata.closureJunctionTable\n\n        const generateWheres = (columns: ColumnMetadata[]) => {\n            return columns\n                .map((column) => {\n                    const data = identifiers.map(\n                        (identifier) =>\n                            identifier![column.referencedColumn!.databaseName],\n                    )\n                    return `${escape(column.databaseName)} IN (${data.join(\n                        \", \",\n                    )})`\n                })\n                .join(\" AND \")\n        }\n\n        const ancestorWhere = generateWheres(closureTable.ancestorColumns)\n        const descendantWhere = generateWheres(closureTable.descendantColumns)\n\n        await this.queryRunner.manager\n            .createQueryBuilder()\n            .delete()\n            .from(closureTable.tablePath)\n            .where(ancestorWhere)\n            .orWhere(descendantWhere)\n            .execute()\n    }\n\n    /**\n     * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom\n     * schema name, otherwise returns escaped table name.\n     */\n    protected getTableName(tablePath: string): string {\n        return tablePath\n            .split(\".\")\n            .map((i) => {\n                // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n                return i === \"\"\n                    ? i\n                    : this.queryRunner.connection.driver.escape(i)\n            })\n            .join(\".\")\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}