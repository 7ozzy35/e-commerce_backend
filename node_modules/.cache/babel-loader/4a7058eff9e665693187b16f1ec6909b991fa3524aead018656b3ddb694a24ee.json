{"ast":null,"code":"import { QueryBuilder } from \"./QueryBuilder\";\nimport { UpdateResult } from \"./result/UpdateResult\";\nimport { ReturningStatementNotSupportedError } from \"../error/ReturningStatementNotSupportedError\";\nimport { ReturningResultsEntityUpdator } from \"./ReturningResultsEntityUpdator\";\nimport { LimitOnUpdateNotSupportedError } from \"../error/LimitOnUpdateNotSupportedError\";\nimport { UpdateValuesMissingError } from \"../error/UpdateValuesMissingError\";\nimport { TypeORMError } from \"../error\";\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class UpdateQueryBuilder extends QueryBuilder {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connectionOrQueryBuilder, queryRunner) {\n    super(connectionOrQueryBuilder, queryRunner);\n    this[\"@instanceof\"] = Symbol.for(\"UpdateQueryBuilder\");\n    this.expressionMap.aliasNamePrefixingEnabled = false;\n  }\n  // -------------------------------------------------------------------------\n  // Public Implemented Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Gets generated SQL query without parameters being replaced.\n   */\n  getQuery() {\n    let sql = this.createComment();\n    sql += this.createCteExpression();\n    sql += this.createUpdateExpression();\n    sql += this.createOrderByExpression();\n    sql += this.createLimitExpression();\n    return this.replacePropertyNamesForTheWholeQuery(sql.trim());\n  }\n  /**\n   * Executes sql generated by query builder and returns raw database results.\n   */\n  async execute() {\n    const queryRunner = this.obtainQueryRunner();\n    let transactionStartedByUs = false;\n    try {\n      // start transaction if it was enabled\n      if (this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n        await queryRunner.startTransaction();\n        transactionStartedByUs = true;\n      }\n      // call before updation methods in listeners and subscribers\n      if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {\n        await queryRunner.broadcaster.broadcast(\"BeforeUpdate\", this.expressionMap.mainAlias.metadata, this.expressionMap.valuesSet);\n      }\n      let declareSql = null;\n      let selectOutputSql = null;\n      // if update entity mode is enabled we may need extra columns for the returning statement\n      const returningResultsEntityUpdator = new ReturningResultsEntityUpdator(queryRunner, this.expressionMap);\n      const returningColumns = [];\n      if (Array.isArray(this.expressionMap.returning) && this.expressionMap.mainAlias.hasMetadata) {\n        for (const columnPath of this.expressionMap.returning) {\n          returningColumns.push(...this.expressionMap.mainAlias.metadata.findColumnsWithPropertyPath(columnPath));\n        }\n      }\n      if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata && this.expressionMap.whereEntities.length > 0) {\n        this.expressionMap.extraReturningColumns = returningResultsEntityUpdator.getUpdationReturningColumns();\n        returningColumns.push(...this.expressionMap.extraReturningColumns.filter(c => !returningColumns.includes(c)));\n      }\n      if (returningColumns.length > 0 && this.connection.driver.options.type === \"mssql\") {\n        declareSql = this.connection.driver.buildTableVariableDeclaration(\"@OutputTable\", returningColumns);\n        selectOutputSql = `SELECT * FROM @OutputTable`;\n      }\n      // execute update query\n      const [updateSql, parameters] = this.getQueryAndParameters();\n      const statements = [declareSql, updateSql, selectOutputSql];\n      const queryResult = await queryRunner.query(statements.filter(sql => sql != null).join(\";\\n\\n\"), parameters, true);\n      const updateResult = UpdateResult.from(queryResult);\n      // if we are updating entities and entity updation is enabled we must update some of entity columns (like version, update date, etc.)\n      if (this.expressionMap.updateEntity === true && this.expressionMap.mainAlias.hasMetadata && this.expressionMap.whereEntities.length > 0) {\n        await returningResultsEntityUpdator.update(updateResult, this.expressionMap.whereEntities);\n      }\n      // call after updation methods in listeners and subscribers\n      if (this.expressionMap.callListeners === true && this.expressionMap.mainAlias.hasMetadata) {\n        await queryRunner.broadcaster.broadcast(\"AfterUpdate\", this.expressionMap.mainAlias.metadata, this.expressionMap.valuesSet);\n      }\n      // close transaction if we started it\n      if (transactionStartedByUs) await queryRunner.commitTransaction();\n      return updateResult;\n    } catch (error) {\n      // rollback transaction if we started it\n      if (transactionStartedByUs) {\n        try {\n          await queryRunner.rollbackTransaction();\n        } catch (rollbackError) {}\n      }\n      throw error;\n    } finally {\n      if (queryRunner !== this.queryRunner) {\n        // means we created our own query runner\n        await queryRunner.release();\n      }\n    }\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Values needs to be updated.\n   */\n  set(values) {\n    this.expressionMap.valuesSet = values;\n    return this;\n  }\n  /**\n   * Sets WHERE condition in the query builder.\n   * If you had previously WHERE expression defined,\n   * calling this function will override previously set WHERE conditions.\n   * Additionally you can add parameters used in where expression.\n   */\n  where(where, parameters) {\n    this.expressionMap.wheres = []; // don't move this block below since computeWhereParameter can add where expressions\n    const condition = this.getWhereCondition(where);\n    if (condition) this.expressionMap.wheres = [{\n      type: \"simple\",\n      condition: condition\n    }];\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Adds new AND WHERE condition in the query builder.\n   * Additionally you can add parameters used in where expression.\n   */\n  andWhere(where, parameters) {\n    this.expressionMap.wheres.push({\n      type: \"and\",\n      condition: this.getWhereCondition(where)\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Adds new OR WHERE condition in the query builder.\n   * Additionally you can add parameters used in where expression.\n   */\n  orWhere(where, parameters) {\n    this.expressionMap.wheres.push({\n      type: \"or\",\n      condition: this.getWhereCondition(where)\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Sets WHERE condition in the query builder with a condition for the given ids.\n   * If you had previously WHERE expression defined,\n   * calling this function will override previously set WHERE conditions.\n   */\n  whereInIds(ids) {\n    return this.where(this.getWhereInIdsCondition(ids));\n  }\n  /**\n   * Adds new AND WHERE with conditions for the given ids.\n   */\n  andWhereInIds(ids) {\n    return this.andWhere(this.getWhereInIdsCondition(ids));\n  }\n  /**\n   * Adds new OR WHERE with conditions for the given ids.\n   */\n  orWhereInIds(ids) {\n    return this.orWhere(this.getWhereInIdsCondition(ids));\n  }\n  /**\n   * Optional returning/output clause.\n   */\n  output(output) {\n    return this.returning(output);\n  }\n  /**\n   * Optional returning/output clause.\n   */\n  returning(returning) {\n    // not all databases support returning/output cause\n    if (!this.connection.driver.isReturningSqlSupported(\"update\")) {\n      throw new ReturningStatementNotSupportedError();\n    }\n    this.expressionMap.returning = returning;\n    return this;\n  }\n  /**\n   * Sets ORDER BY condition in the query builder.\n   * If you had previously ORDER BY expression defined,\n   * calling this function will override previously set ORDER BY conditions.\n   */\n  orderBy(sort, order = \"ASC\", nulls) {\n    if (sort) {\n      if (typeof sort === \"object\") {\n        this.expressionMap.orderBys = sort;\n      } else {\n        if (nulls) {\n          this.expressionMap.orderBys = {\n            [sort]: {\n              order,\n              nulls\n            }\n          };\n        } else {\n          this.expressionMap.orderBys = {\n            [sort]: order\n          };\n        }\n      }\n    } else {\n      this.expressionMap.orderBys = {};\n    }\n    return this;\n  }\n  /**\n   * Adds ORDER BY condition in the query builder.\n   */\n  addOrderBy(sort, order = \"ASC\", nulls) {\n    if (nulls) {\n      this.expressionMap.orderBys[sort] = {\n        order,\n        nulls\n      };\n    } else {\n      this.expressionMap.orderBys[sort] = order;\n    }\n    return this;\n  }\n  /**\n   * Sets LIMIT - maximum number of rows to be selected.\n   */\n  limit(limit) {\n    this.expressionMap.limit = limit;\n    return this;\n  }\n  /**\n   * Indicates if entity must be updated after update operation.\n   * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n   * Enabled by default.\n   */\n  whereEntity(entity) {\n    if (!this.expressionMap.mainAlias.hasMetadata) throw new TypeORMError(`.whereEntity method can only be used on queries which update real entity table.`);\n    this.expressionMap.wheres = [];\n    const entities = Array.isArray(entity) ? entity : [entity];\n    entities.forEach(entity => {\n      const entityIdMap = this.expressionMap.mainAlias.metadata.getEntityIdMap(entity);\n      if (!entityIdMap) throw new TypeORMError(`Provided entity does not have ids set, cannot perform operation.`);\n      this.orWhereInIds(entityIdMap);\n    });\n    this.expressionMap.whereEntities = entities;\n    return this;\n  }\n  /**\n   * Indicates if entity must be updated after update operation.\n   * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n   * Enabled by default.\n   */\n  updateEntity(enabled) {\n    this.expressionMap.updateEntity = enabled;\n    return this;\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates UPDATE express used to perform insert query.\n   */\n  createUpdateExpression() {\n    const valuesSet = this.getValueSet();\n    const metadata = this.expressionMap.mainAlias.hasMetadata ? this.expressionMap.mainAlias.metadata : undefined;\n    // it doesn't make sense to update undefined properties, so just skip them\n    const valuesSetNormalized = {};\n    for (let key in valuesSet) {\n      if (valuesSet[key] !== undefined) {\n        valuesSetNormalized[key] = valuesSet[key];\n      }\n    }\n    // prepare columns and values to be updated\n    const updateColumnAndValues = [];\n    const updatedColumns = [];\n    if (metadata) {\n      this.createPropertyPath(metadata, valuesSetNormalized).forEach(propertyPath => {\n        // todo: make this and other query builder to work with properly with tables without metadata\n        const columns = metadata.findColumnsWithPropertyPath(propertyPath);\n        if (columns.length <= 0) {\n          throw new EntityPropertyNotFoundError(propertyPath, metadata);\n        }\n        columns.forEach(column => {\n          if (!column.isUpdate || updatedColumns.includes(column)) {\n            return;\n          }\n          updatedColumns.push(column);\n          //\n          let value = column.getEntityValue(valuesSetNormalized);\n          if (column.referencedColumn && typeof value === \"object\" && !(value instanceof Date) && value !== null && !Buffer.isBuffer(value)) {\n            value = column.referencedColumn.getEntityValue(value);\n          } else if (!(typeof value === \"function\")) {\n            value = this.connection.driver.preparePersistentValue(value, column);\n          }\n          // todo: duplication zone\n          if (typeof value === \"function\") {\n            // support for SQL expressions in update query\n            updateColumnAndValues.push(this.escape(column.databaseName) + \" = \" + value());\n          } else if ((this.connection.driver.options.type === \"sap\" || this.connection.driver.options.type === \"spanner\") && value === null) {\n            updateColumnAndValues.push(this.escape(column.databaseName) + \" = NULL\");\n          } else {\n            if (this.connection.driver.options.type === \"mssql\") {\n              value = this.connection.driver.parametrizeValue(column, value);\n            }\n            const paramName = this.createParameter(value);\n            let expression = null;\n            if ((DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\") && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n              const useLegacy = this.connection.driver.options.legacySpatialSupport;\n              const geomFromText = useLegacy ? \"GeomFromText\" : \"ST_GeomFromText\";\n              if (column.srid != null) {\n                expression = `${geomFromText}(${paramName}, ${column.srid})`;\n              } else {\n                expression = `${geomFromText}(${paramName})`;\n              }\n            } else if (DriverUtils.isPostgresFamily(this.connection.driver) && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n              if (column.srid != null) {\n                expression = `ST_SetSRID(ST_GeomFromGeoJSON(${paramName}), ${column.srid})::${column.type}`;\n              } else {\n                expression = `ST_GeomFromGeoJSON(${paramName})::${column.type}`;\n              }\n            } else if (this.connection.driver.options.type === \"mssql\" && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n              expression = column.type + \"::STGeomFromText(\" + paramName + \", \" + (column.srid || \"0\") + \")\";\n            } else {\n              expression = paramName;\n            }\n            updateColumnAndValues.push(this.escape(column.databaseName) + \" = \" + expression);\n          }\n        });\n      });\n      // Don't allow calling update only with columns that are `update: false`\n      if (updateColumnAndValues.length > 0 || Object.keys(valuesSetNormalized).length === 0) {\n        if (metadata.versionColumn && updatedColumns.indexOf(metadata.versionColumn) === -1) updateColumnAndValues.push(this.escape(metadata.versionColumn.databaseName) + \" = \" + this.escape(metadata.versionColumn.databaseName) + \" + 1\");\n        if (metadata.updateDateColumn && updatedColumns.indexOf(metadata.updateDateColumn) === -1) updateColumnAndValues.push(this.escape(metadata.updateDateColumn.databaseName) + \" = CURRENT_TIMESTAMP\"); // todo: fix issue with CURRENT_TIMESTAMP(6) being used, can \"DEFAULT\" be used?!\n      }\n    } else {\n      Object.keys(valuesSetNormalized).map(key => {\n        let value = valuesSetNormalized[key];\n        // todo: duplication zone\n        if (typeof value === \"function\") {\n          // support for SQL expressions in update query\n          updateColumnAndValues.push(this.escape(key) + \" = \" + value());\n        } else if ((this.connection.driver.options.type === \"sap\" || this.connection.driver.options.type === \"spanner\") && value === null) {\n          updateColumnAndValues.push(this.escape(key) + \" = NULL\");\n        } else {\n          // we need to store array values in a special class to make sure parameter replacement will work correctly\n          // if (value instanceof Array)\n          //     value = new ArrayParameter(value);\n          const paramName = this.createParameter(value);\n          updateColumnAndValues.push(this.escape(key) + \" = \" + paramName);\n        }\n      });\n    }\n    if (updateColumnAndValues.length <= 0) {\n      throw new UpdateValuesMissingError();\n    }\n    // get a table name and all column database names\n    const whereExpression = this.createWhereExpression();\n    const returningExpression = this.createReturningExpression(\"update\");\n    if (returningExpression === \"\") {\n      return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(\", \")}${whereExpression}`; // todo: how do we replace aliases in where to nothing?\n    }\n    if (this.connection.driver.options.type === \"mssql\") {\n      return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(\", \")} OUTPUT ${returningExpression}${whereExpression}`;\n    }\n    return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(\", \")}${whereExpression} RETURNING ${returningExpression}`;\n  }\n  /**\n   * Creates \"ORDER BY\" part of SQL query.\n   */\n  createOrderByExpression() {\n    const orderBys = this.expressionMap.orderBys;\n    if (Object.keys(orderBys).length > 0) return \" ORDER BY \" + Object.keys(orderBys).map(columnName => {\n      if (typeof orderBys[columnName] === \"string\") {\n        return this.replacePropertyNames(columnName) + \" \" + orderBys[columnName];\n      } else {\n        return this.replacePropertyNames(columnName) + \" \" + orderBys[columnName].order + \" \" + orderBys[columnName].nulls;\n      }\n    }).join(\", \");\n    return \"\";\n  }\n  /**\n   * Creates \"LIMIT\" parts of SQL query.\n   */\n  createLimitExpression() {\n    let limit = this.expressionMap.limit;\n    if (limit) {\n      if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\") {\n        return \" LIMIT \" + limit;\n      } else {\n        throw new LimitOnUpdateNotSupportedError();\n      }\n    }\n    return \"\";\n  }\n  /**\n   * Gets array of values need to be inserted into the target table.\n   */\n  getValueSet() {\n    if (typeof this.expressionMap.valuesSet === \"object\") return this.expressionMap.valuesSet;\n    throw new UpdateValuesMissingError();\n  }\n}","map":{"version":3,"names":["QueryBuilder","UpdateResult","ReturningStatementNotSupportedError","ReturningResultsEntityUpdator","LimitOnUpdateNotSupportedError","UpdateValuesMissingError","TypeORMError","EntityPropertyNotFoundError","DriverUtils","UpdateQueryBuilder","constructor","connectionOrQueryBuilder","queryRunner","Symbol","for","expressionMap","aliasNamePrefixingEnabled","getQuery","sql","createComment","createCteExpression","createUpdateExpression","createOrderByExpression","createLimitExpression","replacePropertyNamesForTheWholeQuery","trim","execute","obtainQueryRunner","transactionStartedByUs","useTransaction","isTransactionActive","startTransaction","callListeners","mainAlias","hasMetadata","broadcaster","broadcast","metadata","valuesSet","declareSql","selectOutputSql","returningResultsEntityUpdator","returningColumns","Array","isArray","returning","columnPath","push","findColumnsWithPropertyPath","updateEntity","whereEntities","length","extraReturningColumns","getUpdationReturningColumns","filter","c","includes","connection","driver","options","type","buildTableVariableDeclaration","updateSql","parameters","getQueryAndParameters","statements","queryResult","query","join","updateResult","from","update","commitTransaction","error","rollbackTransaction","rollbackError","release","set","values","where","wheres","condition","getWhereCondition","setParameters","andWhere","orWhere","whereInIds","ids","getWhereInIdsCondition","andWhereInIds","orWhereInIds","output","isReturningSqlSupported","orderBy","sort","order","nulls","orderBys","addOrderBy","limit","whereEntity","entity","entities","forEach","entityIdMap","getEntityIdMap","enabled","getValueSet","undefined","valuesSetNormalized","key","updateColumnAndValues","updatedColumns","createPropertyPath","propertyPath","columns","column","isUpdate","value","getEntityValue","referencedColumn","Date","Buffer","isBuffer","preparePersistentValue","escape","databaseName","parametrizeValue","paramName","createParameter","expression","isMySQLFamily","spatialTypes","indexOf","useLegacy","legacySpatialSupport","geomFromText","srid","isPostgresFamily","Object","keys","versionColumn","updateDateColumn","map","whereExpression","createWhereExpression","returningExpression","createReturningExpression","getTableName","getMainTableName","columnName","replacePropertyNames"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\query-builder\\UpdateQueryBuilder.ts"],"sourcesContent":["import { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { QueryBuilder } from \"./QueryBuilder\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { WhereExpressionBuilder } from \"./WhereExpressionBuilder\"\nimport { Brackets } from \"./Brackets\"\nimport { UpdateResult } from \"./result/UpdateResult\"\nimport { ReturningStatementNotSupportedError } from \"../error/ReturningStatementNotSupportedError\"\nimport { ReturningResultsEntityUpdator } from \"./ReturningResultsEntityUpdator\"\nimport { MysqlDriver } from \"../driver/mysql/MysqlDriver\"\nimport { OrderByCondition } from \"../find-options/OrderByCondition\"\nimport { LimitOnUpdateNotSupportedError } from \"../error/LimitOnUpdateNotSupportedError\"\nimport { UpdateValuesMissingError } from \"../error/UpdateValuesMissingError\"\nimport { QueryDeepPartialEntity } from \"./QueryPartialEntity\"\nimport { AuroraMysqlDriver } from \"../driver/aurora-mysql/AuroraMysqlDriver\"\nimport { TypeORMError } from \"../error\"\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\"\nimport { SqlServerDriver } from \"../driver/sqlserver/SqlServerDriver\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\n\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class UpdateQueryBuilder<Entity extends ObjectLiteral>\n    extends QueryBuilder<Entity>\n    implements WhereExpressionBuilder\n{\n    readonly \"@instanceof\" = Symbol.for(\"UpdateQueryBuilder\")\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        connectionOrQueryBuilder: DataSource | QueryBuilder<any>,\n        queryRunner?: QueryRunner,\n    ) {\n        super(connectionOrQueryBuilder as any, queryRunner)\n        this.expressionMap.aliasNamePrefixingEnabled = false\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets generated SQL query without parameters being replaced.\n     */\n    getQuery(): string {\n        let sql = this.createComment()\n        sql += this.createCteExpression()\n        sql += this.createUpdateExpression()\n        sql += this.createOrderByExpression()\n        sql += this.createLimitExpression()\n        return this.replacePropertyNamesForTheWholeQuery(sql.trim())\n    }\n\n    /**\n     * Executes sql generated by query builder and returns raw database results.\n     */\n    async execute(): Promise<UpdateResult> {\n        const queryRunner = this.obtainQueryRunner()\n        let transactionStartedByUs: boolean = false\n\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction()\n                transactionStartedByUs = true\n            }\n\n            // call before updation methods in listeners and subscribers\n            if (\n                this.expressionMap.callListeners === true &&\n                this.expressionMap.mainAlias!.hasMetadata\n            ) {\n                await queryRunner.broadcaster.broadcast(\n                    \"BeforeUpdate\",\n                    this.expressionMap.mainAlias!.metadata,\n                    this.expressionMap.valuesSet,\n                )\n            }\n\n            let declareSql: string | null = null\n            let selectOutputSql: string | null = null\n\n            // if update entity mode is enabled we may need extra columns for the returning statement\n            const returningResultsEntityUpdator =\n                new ReturningResultsEntityUpdator(\n                    queryRunner,\n                    this.expressionMap,\n                )\n\n            const returningColumns: ColumnMetadata[] = []\n\n            if (\n                Array.isArray(this.expressionMap.returning) &&\n                this.expressionMap.mainAlias!.hasMetadata\n            ) {\n                for (const columnPath of this.expressionMap.returning) {\n                    returningColumns.push(\n                        ...this.expressionMap.mainAlias!.metadata.findColumnsWithPropertyPath(\n                            columnPath,\n                        ),\n                    )\n                }\n            }\n\n            if (\n                this.expressionMap.updateEntity === true &&\n                this.expressionMap.mainAlias!.hasMetadata &&\n                this.expressionMap.whereEntities.length > 0\n            ) {\n                this.expressionMap.extraReturningColumns =\n                    returningResultsEntityUpdator.getUpdationReturningColumns()\n\n                returningColumns.push(\n                    ...this.expressionMap.extraReturningColumns.filter(\n                        (c) => !returningColumns.includes(c),\n                    ),\n                )\n            }\n\n            if (\n                returningColumns.length > 0 &&\n                this.connection.driver.options.type === \"mssql\"\n            ) {\n                declareSql = (\n                    this.connection.driver as SqlServerDriver\n                ).buildTableVariableDeclaration(\n                    \"@OutputTable\",\n                    returningColumns,\n                )\n                selectOutputSql = `SELECT * FROM @OutputTable`\n            }\n\n            // execute update query\n            const [updateSql, parameters] = this.getQueryAndParameters()\n\n            const statements = [declareSql, updateSql, selectOutputSql]\n            const queryResult = await queryRunner.query(\n                statements.filter((sql) => sql != null).join(\";\\n\\n\"),\n                parameters,\n                true,\n            )\n            const updateResult = UpdateResult.from(queryResult)\n\n            // if we are updating entities and entity updation is enabled we must update some of entity columns (like version, update date, etc.)\n            if (\n                this.expressionMap.updateEntity === true &&\n                this.expressionMap.mainAlias!.hasMetadata &&\n                this.expressionMap.whereEntities.length > 0\n            ) {\n                await returningResultsEntityUpdator.update(\n                    updateResult,\n                    this.expressionMap.whereEntities,\n                )\n            }\n\n            // call after updation methods in listeners and subscribers\n            if (\n                this.expressionMap.callListeners === true &&\n                this.expressionMap.mainAlias!.hasMetadata\n            ) {\n                await queryRunner.broadcaster.broadcast(\n                    \"AfterUpdate\",\n                    this.expressionMap.mainAlias!.metadata,\n                    this.expressionMap.valuesSet,\n                )\n            }\n\n            // close transaction if we started it\n            if (transactionStartedByUs) await queryRunner.commitTransaction()\n\n            return updateResult\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n            throw error\n        } finally {\n            if (queryRunner !== this.queryRunner) {\n                // means we created our own query runner\n                await queryRunner.release()\n            }\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Values needs to be updated.\n     */\n    set(values: QueryDeepPartialEntity<Entity>): this {\n        this.expressionMap.valuesSet = values\n        return this\n    }\n\n    /**\n     * Sets WHERE condition in the query builder.\n     * If you had previously WHERE expression defined,\n     * calling this function will override previously set WHERE conditions.\n     * Additionally you can add parameters used in where expression.\n     */\n    where(\n        where:\n            | string\n            | ((qb: this) => string)\n            | Brackets\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres = [] // don't move this block below since computeWhereParameter can add where expressions\n        const condition = this.getWhereCondition(where)\n        if (condition)\n            this.expressionMap.wheres = [\n                { type: \"simple\", condition: condition },\n            ]\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new AND WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    andWhere(\n        where:\n            | string\n            | ((qb: this) => string)\n            | Brackets\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres.push({\n            type: \"and\",\n            condition: this.getWhereCondition(where),\n        })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new OR WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    orWhere(\n        where:\n            | string\n            | ((qb: this) => string)\n            | Brackets\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres.push({\n            type: \"or\",\n            condition: this.getWhereCondition(where),\n        })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Sets WHERE condition in the query builder with a condition for the given ids.\n     * If you had previously WHERE expression defined,\n     * calling this function will override previously set WHERE conditions.\n     */\n    whereInIds(ids: any | any[]): this {\n        return this.where(this.getWhereInIdsCondition(ids))\n    }\n\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     */\n    andWhereInIds(ids: any | any[]): this {\n        return this.andWhere(this.getWhereInIdsCondition(ids))\n    }\n\n    /**\n     * Adds new OR WHERE with conditions for the given ids.\n     */\n    orWhereInIds(ids: any | any[]): this {\n        return this.orWhere(this.getWhereInIdsCondition(ids))\n    }\n    /**\n     * Optional returning/output clause.\n     * This will return given column values.\n     */\n    output(columns: string[]): this\n\n    /**\n     * Optional returning/output clause.\n     * Returning is a SQL string containing returning statement.\n     */\n    output(output: string): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    output(output: string | string[]): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    output(output: string | string[]): this {\n        return this.returning(output)\n    }\n\n    /**\n     * Optional returning/output clause.\n     * This will return given column values.\n     */\n    returning(columns: string[]): this\n\n    /**\n     * Optional returning/output clause.\n     * Returning is a SQL string containing returning statement.\n     */\n    returning(returning: string): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    returning(returning: string | string[]): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    returning(returning: string | string[]): this {\n        // not all databases support returning/output cause\n        if (!this.connection.driver.isReturningSqlSupported(\"update\")) {\n            throw new ReturningStatementNotSupportedError()\n        }\n\n        this.expressionMap.returning = returning\n        return this\n    }\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     *\n     * Calling order by without order set will remove all previously set order bys.\n     */\n    orderBy(): this\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(\n        sort: string,\n        order?: \"ASC\" | \"DESC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\n    ): this\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(order: OrderByCondition): this\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(\n        sort?: string | OrderByCondition,\n        order: \"ASC\" | \"DESC\" = \"ASC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\n    ): this {\n        if (sort) {\n            if (typeof sort === \"object\") {\n                this.expressionMap.orderBys = sort as OrderByCondition\n            } else {\n                if (nulls) {\n                    this.expressionMap.orderBys = {\n                        [sort as string]: { order, nulls },\n                    }\n                } else {\n                    this.expressionMap.orderBys = { [sort as string]: order }\n                }\n            }\n        } else {\n            this.expressionMap.orderBys = {}\n        }\n        return this\n    }\n\n    /**\n     * Adds ORDER BY condition in the query builder.\n     */\n    addOrderBy(\n        sort: string,\n        order: \"ASC\" | \"DESC\" = \"ASC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\n    ): this {\n        if (nulls) {\n            this.expressionMap.orderBys[sort] = { order, nulls }\n        } else {\n            this.expressionMap.orderBys[sort] = order\n        }\n        return this\n    }\n\n    /**\n     * Sets LIMIT - maximum number of rows to be selected.\n     */\n    limit(limit?: number): this {\n        this.expressionMap.limit = limit\n        return this\n    }\n\n    /**\n     * Indicates if entity must be updated after update operation.\n     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n     * Enabled by default.\n     */\n    whereEntity(entity: Entity | Entity[]): this {\n        if (!this.expressionMap.mainAlias!.hasMetadata)\n            throw new TypeORMError(\n                `.whereEntity method can only be used on queries which update real entity table.`,\n            )\n\n        this.expressionMap.wheres = []\n        const entities: Entity[] = Array.isArray(entity) ? entity : [entity]\n        entities.forEach((entity) => {\n            const entityIdMap =\n                this.expressionMap.mainAlias!.metadata.getEntityIdMap(entity)\n            if (!entityIdMap)\n                throw new TypeORMError(\n                    `Provided entity does not have ids set, cannot perform operation.`,\n                )\n\n            this.orWhereInIds(entityIdMap)\n        })\n\n        this.expressionMap.whereEntities = entities\n        return this\n    }\n\n    /**\n     * Indicates if entity must be updated after update operation.\n     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n     * Enabled by default.\n     */\n    updateEntity(enabled: boolean): this {\n        this.expressionMap.updateEntity = enabled\n        return this\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates UPDATE express used to perform insert query.\n     */\n    protected createUpdateExpression() {\n        const valuesSet = this.getValueSet()\n        const metadata = this.expressionMap.mainAlias!.hasMetadata\n            ? this.expressionMap.mainAlias!.metadata\n            : undefined\n\n        // it doesn't make sense to update undefined properties, so just skip them\n        const valuesSetNormalized: ObjectLiteral = {}\n        for (let key in valuesSet) {\n            if (valuesSet[key] !== undefined) {\n                valuesSetNormalized[key] = valuesSet[key]\n            }\n        }\n\n        // prepare columns and values to be updated\n        const updateColumnAndValues: string[] = []\n        const updatedColumns: ColumnMetadata[] = []\n        if (metadata) {\n            this.createPropertyPath(metadata, valuesSetNormalized).forEach(\n                (propertyPath) => {\n                    // todo: make this and other query builder to work with properly with tables without metadata\n                    const columns =\n                        metadata.findColumnsWithPropertyPath(propertyPath)\n\n                    if (columns.length <= 0) {\n                        throw new EntityPropertyNotFoundError(\n                            propertyPath,\n                            metadata,\n                        )\n                    }\n\n                    columns.forEach((column) => {\n                        if (\n                            !column.isUpdate ||\n                            updatedColumns.includes(column)\n                        ) {\n                            return\n                        }\n\n                        updatedColumns.push(column)\n\n                        //\n                        let value = column.getEntityValue(valuesSetNormalized)\n                        if (\n                            column.referencedColumn &&\n                            typeof value === \"object\" &&\n                            !(value instanceof Date) &&\n                            value !== null &&\n                            !Buffer.isBuffer(value)\n                        ) {\n                            value =\n                                column.referencedColumn.getEntityValue(value)\n                        } else if (!(typeof value === \"function\")) {\n                            value =\n                                this.connection.driver.preparePersistentValue(\n                                    value,\n                                    column,\n                                )\n                        }\n\n                        // todo: duplication zone\n                        if (typeof value === \"function\") {\n                            // support for SQL expressions in update query\n                            updateColumnAndValues.push(\n                                this.escape(column.databaseName) +\n                                    \" = \" +\n                                    value(),\n                            )\n                        } else if (\n                            (this.connection.driver.options.type === \"sap\" ||\n                                this.connection.driver.options.type ===\n                                    \"spanner\") &&\n                            value === null\n                        ) {\n                            updateColumnAndValues.push(\n                                this.escape(column.databaseName) + \" = NULL\",\n                            )\n                        } else {\n                            if (\n                                this.connection.driver.options.type === \"mssql\"\n                            ) {\n                                value = (\n                                    this.connection.driver as SqlServerDriver\n                                ).parametrizeValue(column, value)\n                            }\n\n                            const paramName = this.createParameter(value)\n\n                            let expression = null\n                            if (\n                                (DriverUtils.isMySQLFamily(\n                                    this.connection.driver,\n                                ) ||\n                                    this.connection.driver.options.type ===\n                                        \"aurora-mysql\") &&\n                                this.connection.driver.spatialTypes.indexOf(\n                                    column.type,\n                                ) !== -1\n                            ) {\n                                const useLegacy = (\n                                    this.connection.driver as\n                                        | MysqlDriver\n                                        | AuroraMysqlDriver\n                                ).options.legacySpatialSupport\n                                const geomFromText = useLegacy\n                                    ? \"GeomFromText\"\n                                    : \"ST_GeomFromText\"\n                                if (column.srid != null) {\n                                    expression = `${geomFromText}(${paramName}, ${column.srid})`\n                                } else {\n                                    expression = `${geomFromText}(${paramName})`\n                                }\n                            } else if (\n                                DriverUtils.isPostgresFamily(\n                                    this.connection.driver,\n                                ) &&\n                                this.connection.driver.spatialTypes.indexOf(\n                                    column.type,\n                                ) !== -1\n                            ) {\n                                if (column.srid != null) {\n                                    expression = `ST_SetSRID(ST_GeomFromGeoJSON(${paramName}), ${column.srid})::${column.type}`\n                                } else {\n                                    expression = `ST_GeomFromGeoJSON(${paramName})::${column.type}`\n                                }\n                            } else if (\n                                this.connection.driver.options.type ===\n                                    \"mssql\" &&\n                                this.connection.driver.spatialTypes.indexOf(\n                                    column.type,\n                                ) !== -1\n                            ) {\n                                expression =\n                                    column.type +\n                                    \"::STGeomFromText(\" +\n                                    paramName +\n                                    \", \" +\n                                    (column.srid || \"0\") +\n                                    \")\"\n                            } else {\n                                expression = paramName\n                            }\n                            updateColumnAndValues.push(\n                                this.escape(column.databaseName) +\n                                    \" = \" +\n                                    expression,\n                            )\n                        }\n                    })\n                },\n            )\n\n            // Don't allow calling update only with columns that are `update: false`\n            if (\n                updateColumnAndValues.length > 0 ||\n                Object.keys(valuesSetNormalized).length === 0\n            ) {\n                if (\n                    metadata.versionColumn &&\n                    updatedColumns.indexOf(metadata.versionColumn) === -1\n                )\n                    updateColumnAndValues.push(\n                        this.escape(metadata.versionColumn.databaseName) +\n                            \" = \" +\n                            this.escape(metadata.versionColumn.databaseName) +\n                            \" + 1\",\n                    )\n                if (\n                    metadata.updateDateColumn &&\n                    updatedColumns.indexOf(metadata.updateDateColumn) === -1\n                )\n                    updateColumnAndValues.push(\n                        this.escape(metadata.updateDateColumn.databaseName) +\n                            \" = CURRENT_TIMESTAMP\",\n                    ) // todo: fix issue with CURRENT_TIMESTAMP(6) being used, can \"DEFAULT\" be used?!\n            }\n        } else {\n            Object.keys(valuesSetNormalized).map((key) => {\n                let value = valuesSetNormalized[key]\n\n                // todo: duplication zone\n                if (typeof value === \"function\") {\n                    // support for SQL expressions in update query\n                    updateColumnAndValues.push(\n                        this.escape(key) + \" = \" + value(),\n                    )\n                } else if (\n                    (this.connection.driver.options.type === \"sap\" ||\n                        this.connection.driver.options.type === \"spanner\") &&\n                    value === null\n                ) {\n                    updateColumnAndValues.push(this.escape(key) + \" = NULL\")\n                } else {\n                    // we need to store array values in a special class to make sure parameter replacement will work correctly\n                    // if (value instanceof Array)\n                    //     value = new ArrayParameter(value);\n\n                    const paramName = this.createParameter(value)\n                    updateColumnAndValues.push(\n                        this.escape(key) + \" = \" + paramName,\n                    )\n                }\n            })\n        }\n\n        if (updateColumnAndValues.length <= 0) {\n            throw new UpdateValuesMissingError()\n        }\n\n        // get a table name and all column database names\n        const whereExpression = this.createWhereExpression()\n        const returningExpression = this.createReturningExpression(\"update\")\n\n        if (returningExpression === \"\") {\n            return `UPDATE ${this.getTableName(\n                this.getMainTableName(),\n            )} SET ${updateColumnAndValues.join(\", \")}${whereExpression}` // todo: how do we replace aliases in where to nothing?\n        }\n        if (this.connection.driver.options.type === \"mssql\") {\n            return `UPDATE ${this.getTableName(\n                this.getMainTableName(),\n            )} SET ${updateColumnAndValues.join(\n                \", \",\n            )} OUTPUT ${returningExpression}${whereExpression}`\n        }\n        return `UPDATE ${this.getTableName(\n            this.getMainTableName(),\n        )} SET ${updateColumnAndValues.join(\n            \", \",\n        )}${whereExpression} RETURNING ${returningExpression}`\n    }\n\n    /**\n     * Creates \"ORDER BY\" part of SQL query.\n     */\n    protected createOrderByExpression() {\n        const orderBys = this.expressionMap.orderBys\n        if (Object.keys(orderBys).length > 0)\n            return (\n                \" ORDER BY \" +\n                Object.keys(orderBys)\n                    .map((columnName) => {\n                        if (typeof orderBys[columnName] === \"string\") {\n                            return (\n                                this.replacePropertyNames(columnName) +\n                                \" \" +\n                                orderBys[columnName]\n                            )\n                        } else {\n                            return (\n                                this.replacePropertyNames(columnName) +\n                                \" \" +\n                                (orderBys[columnName] as any).order +\n                                \" \" +\n                                (orderBys[columnName] as any).nulls\n                            )\n                        }\n                    })\n                    .join(\", \")\n            )\n\n        return \"\"\n    }\n\n    /**\n     * Creates \"LIMIT\" parts of SQL query.\n     */\n    protected createLimitExpression(): string {\n        let limit: number | undefined = this.expressionMap.limit\n\n        if (limit) {\n            if (\n                DriverUtils.isMySQLFamily(this.connection.driver) ||\n                this.connection.driver.options.type === \"aurora-mysql\"\n            ) {\n                return \" LIMIT \" + limit\n            } else {\n                throw new LimitOnUpdateNotSupportedError()\n            }\n        }\n\n        return \"\"\n    }\n\n    /**\n     * Gets array of values need to be inserted into the target table.\n     */\n    protected getValueSet(): ObjectLiteral {\n        if (typeof this.expressionMap.valuesSet === \"object\")\n            return this.expressionMap.valuesSet\n\n        throw new UpdateValuesMissingError()\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}