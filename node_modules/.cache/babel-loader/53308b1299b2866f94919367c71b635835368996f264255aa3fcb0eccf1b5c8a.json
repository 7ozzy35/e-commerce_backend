{"ast":null,"code":"import { DriverPackageNotInstalledError } from \"../../error/DriverPackageNotInstalledError\";\nimport { SpannerQueryRunner } from \"./SpannerQueryRunner\";\nimport { DateUtils } from \"../../util/DateUtils\";\nimport { PlatformTools } from \"../../platform/PlatformTools\";\nimport { RdbmsSchemaBuilder } from \"../../schema-builder/RdbmsSchemaBuilder\";\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { ApplyValueTransformers } from \"../../util/ApplyValueTransformers\";\nimport { Table } from \"../../schema-builder/table/Table\";\nimport { View } from \"../../schema-builder/view/View\";\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\";\n/**\n * Organizes communication with Spanner DBMS.\n */\nexport class SpannerDriver {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    /**\n     * Indicates if replication is enabled.\n     */\n    this.isReplicated = false;\n    /**\n     * Indicates if tree tables are supported by this driver.\n     */\n    this.treeSupport = true;\n    /**\n     * Represent transaction support by this driver\n     */\n    this.transactionSupport = \"none\";\n    /**\n     * Gets list of supported column data types by a driver.\n     *\n     * @see https://cloud.google.com/spanner/docs/reference/standard-sql/data-types\n     */\n    this.supportedDataTypes = [\"bool\", \"int64\", \"float64\", \"numeric\", \"string\", \"json\", \"bytes\", \"date\", \"timestamp\", \"array\"];\n    /**\n     * Returns type of upsert supported by driver if any\n     */\n    this.supportedUpsertTypes = [];\n    /**\n     * Gets list of spatial column data types.\n     */\n    this.spatialTypes = [];\n    /**\n     * Gets list of column data types that support length by a driver.\n     */\n    this.withLengthColumnTypes = [\"string\", \"bytes\"];\n    /**\n     * Gets list of column data types that support length by a driver.\n     */\n    this.withWidthColumnTypes = [];\n    /**\n     * Gets list of column data types that support precision by a driver.\n     */\n    this.withPrecisionColumnTypes = [];\n    /**\n     * Gets list of column data types that supports scale by a driver.\n     */\n    this.withScaleColumnTypes = [];\n    /**\n     * ORM has special columns and we need to know what database column types should be for those columns.\n     * Column types are driver dependant.\n     */\n    this.mappedDataTypes = {\n      createDate: \"timestamp\",\n      createDateDefault: \"\",\n      updateDate: \"timestamp\",\n      updateDateDefault: \"\",\n      deleteDate: \"timestamp\",\n      deleteDateNullable: true,\n      version: \"int64\",\n      treeLevel: \"int64\",\n      migrationId: \"int64\",\n      migrationName: \"string\",\n      migrationTimestamp: \"int64\",\n      cacheId: \"string\",\n      cacheIdentifier: \"string\",\n      cacheTime: \"int64\",\n      cacheDuration: \"int64\",\n      cacheQuery: \"string\",\n      cacheResult: \"string\",\n      metadataType: \"string\",\n      metadataDatabase: \"string\",\n      metadataSchema: \"string\",\n      metadataTable: \"string\",\n      metadataName: \"string\",\n      metadataValue: \"string\"\n    };\n    /**\n     * The prefix used for the parameters\n     */\n    this.parametersPrefix = \"@param\";\n    /**\n     * Default values of length, precision and scale depends on column data type.\n     * Used in the cases when length/precision/scale is not specified by user.\n     */\n    this.dataTypeDefaults = {};\n    /**\n     * Max length allowed by MySQL for aliases.\n     * @see https://dev.mysql.com/doc/refman/5.5/en/identifiers.html\n     */\n    this.maxAliasLength = 63;\n    this.cteCapabilities = {\n      enabled: true\n    };\n    /**\n     * Supported returning types\n     */\n    this._isReturningSqlSupported = {\n      delete: false,\n      insert: false,\n      update: false\n    };\n    this.connection = connection;\n    this.options = connection.options;\n    this.isReplicated = this.options.replication ? true : false;\n    // load mysql package\n    this.loadDependencies();\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Performs connection to the database.\n   */\n  async connect() {\n    this.instance = this.spanner.instance(this.options.instanceId);\n    this.instanceDatabase = this.instance.database(this.options.databaseId);\n  }\n  /**\n   * Makes any action after connection (e.g. create extensions in Postgres driver).\n   */\n  afterConnect() {\n    return Promise.resolve();\n  }\n  /**\n   * Closes connection with the database.\n   */\n  async disconnect() {\n    this.instanceDatabase.close();\n  }\n  /**\n   * Creates a schema builder used to build and sync a schema.\n   */\n  createSchemaBuilder() {\n    return new RdbmsSchemaBuilder(this.connection);\n  }\n  /**\n   * Creates a query runner used to execute database queries.\n   */\n  createQueryRunner(mode) {\n    return new SpannerQueryRunner(this, mode);\n  }\n  /**\n   * Replaces parameters in the given sql with special escaping character\n   * and an array of parameter names to be passed to a query.\n   */\n  escapeQueryWithParameters(sql, parameters, nativeParameters) {\n    const escapedParameters = Object.keys(nativeParameters).map(key => nativeParameters[key]);\n    if (!parameters || !Object.keys(parameters).length) return [sql, escapedParameters];\n    const parameterIndexMap = new Map();\n    sql = sql.replace(/:(\\.\\.\\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key) => {\n      if (!parameters.hasOwnProperty(key)) {\n        return full;\n      }\n      if (parameterIndexMap.has(key)) {\n        return this.parametersPrefix + parameterIndexMap.get(key);\n      }\n      let value = parameters[key];\n      if (value === null) {\n        return full;\n      }\n      if (isArray) {\n        return value.map(v => {\n          escapedParameters.push(v);\n          return this.createParameter(key, escapedParameters.length - 1);\n        }).join(\", \");\n      }\n      if (value instanceof Function) {\n        return value();\n      }\n      escapedParameters.push(value);\n      parameterIndexMap.set(key, escapedParameters.length - 1);\n      return this.createParameter(key, escapedParameters.length - 1);\n    }); // todo: make replace only in value statements, otherwise problems\n    sql = sql.replace(/([ ]+)?=([ ]+)?:(\\.\\.\\.)?([A-Za-z0-9_.]+)/g, (full, emptySpaceBefore, emptySpaceAfter, isArray, key) => {\n      if (!parameters.hasOwnProperty(key)) {\n        return full;\n      }\n      let value = parameters[key];\n      if (value === null) {\n        return \" IS NULL\";\n      }\n      return full;\n    });\n    return [sql, escapedParameters];\n  }\n  /**\n   * Escapes a column name.\n   */\n  escape(columnName) {\n    return `\\`${columnName}\\``;\n  }\n  /**\n   * Build full table name with database name, schema name and table name.\n   * E.g. myDB.mySchema.myTable\n   */\n  buildTableName(tableName, schema, database) {\n    let tablePath = [tableName];\n    if (database) {\n      tablePath.unshift(database);\n    }\n    return tablePath.join(\".\");\n  }\n  /**\n   * Parse a target table name or other types and return a normalized table definition.\n   */\n  parseTableName(target) {\n    const driverDatabase = this.database;\n    const driverSchema = undefined;\n    if (target instanceof Table || target instanceof View) {\n      const parsed = this.parseTableName(target.name);\n      return {\n        database: target.database || parsed.database || driverDatabase,\n        schema: target.schema || parsed.schema || driverSchema,\n        tableName: parsed.tableName\n      };\n    }\n    if (target instanceof TableForeignKey) {\n      const parsed = this.parseTableName(target.referencedTableName);\n      return {\n        database: target.referencedDatabase || parsed.database || driverDatabase,\n        schema: target.referencedSchema || parsed.schema || driverSchema,\n        tableName: parsed.tableName\n      };\n    }\n    if (target instanceof EntityMetadata) {\n      // EntityMetadata tableName is never a path\n      return {\n        database: target.database || driverDatabase,\n        schema: target.schema || driverSchema,\n        tableName: target.tableName\n      };\n    }\n    const parts = target.split(\".\");\n    return {\n      database: (parts.length > 1 ? parts[0] : undefined) || driverDatabase,\n      schema: driverSchema,\n      tableName: parts.length > 1 ? parts[1] : parts[0]\n    };\n  }\n  /**\n   * Prepares given value to a value to be persisted, based on its column type and metadata.\n   */\n  preparePersistentValue(value, columnMetadata) {\n    if (columnMetadata.transformer) value = ApplyValueTransformers.transformTo(columnMetadata.transformer, value);\n    if (value === null || value === undefined) return value;\n    if (columnMetadata.type === \"numeric\") {\n      const lib = this.options.driver || PlatformTools.load(\"spanner\");\n      return lib.Spanner.numeric(value);\n    } else if (columnMetadata.type === \"date\") {\n      return DateUtils.mixedDateToDateString(value);\n    } else if (columnMetadata.type === \"json\") {\n      return value;\n    } else if (columnMetadata.type === \"timestamp\" || columnMetadata.type === Date) {\n      return DateUtils.mixedDateToDate(value);\n    }\n    return value;\n  }\n  /**\n   * Prepares given value to a value to be persisted, based on its column type or metadata.\n   */\n  prepareHydratedValue(value, columnMetadata) {\n    if (value === null || value === undefined) return columnMetadata.transformer ? ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;\n    if (columnMetadata.type === Boolean || columnMetadata.type === \"bool\") {\n      value = value ? true : false;\n    } else if (columnMetadata.type === \"timestamp\" || columnMetadata.type === Date) {\n      value = new Date(value);\n    } else if (columnMetadata.type === \"numeric\") {\n      value = value.value;\n    } else if (columnMetadata.type === \"date\") {\n      value = DateUtils.mixedDateToDateString(value);\n    } else if (columnMetadata.type === \"json\") {\n      value = typeof value === \"string\" ? JSON.parse(value) : value;\n    } else if (columnMetadata.type === Number) {\n      // convert to number if number\n      value = !isNaN(+value) ? parseInt(value) : value;\n    }\n    if (columnMetadata.transformer) value = ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);\n    return value;\n  }\n  /**\n   * Creates a database type from a given column metadata.\n   */\n  normalizeType(column) {\n    if (column.type === Number) {\n      return \"int64\";\n    } else if (column.type === String || column.type === \"uuid\") {\n      return \"string\";\n    } else if (column.type === Date) {\n      return \"timestamp\";\n    } else if (column.type === Buffer) {\n      return \"bytes\";\n    } else if (column.type === Boolean) {\n      return \"bool\";\n    } else {\n      return column.type || \"\";\n    }\n  }\n  /**\n   * Normalizes \"default\" value of the column.\n   *\n   * Spanner does not support default values.\n   */\n  normalizeDefault(columnMetadata) {\n    return columnMetadata.default === \"\" ? `\"${columnMetadata.default}\"` : `${columnMetadata.default}`;\n  }\n  /**\n   * Normalizes \"isUnique\" value of the column.\n   */\n  normalizeIsUnique(column) {\n    return column.entityMetadata.indices.some(idx => idx.isUnique && idx.columns.length === 1 && idx.columns[0] === column);\n  }\n  /**\n   * Returns default column lengths, which is required on column creation.\n   */\n  getColumnLength(column) {\n    if (column.length) return column.length.toString();\n    if (column.generationStrategy === \"uuid\") return \"36\";\n    switch (column.type) {\n      case String:\n      case \"string\":\n      case \"bytes\":\n        return \"max\";\n      default:\n        return \"\";\n    }\n  }\n  /**\n   * Creates column type definition including length, precision and scale\n   */\n  createFullType(column) {\n    let type = column.type;\n    // used 'getColumnLength()' method, because Spanner requires column length for `string` and `bytes` data types\n    if (this.getColumnLength(column)) {\n      type += `(${this.getColumnLength(column)})`;\n    } else if (column.width) {\n      type += `(${column.width})`;\n    } else if (column.precision !== null && column.precision !== undefined && column.scale !== null && column.scale !== undefined) {\n      type += `(${column.precision},${column.scale})`;\n    } else if (column.precision !== null && column.precision !== undefined) {\n      type += `(${column.precision})`;\n    }\n    if (column.isArray) type = `array<${type}>`;\n    return type;\n  }\n  /**\n   * Obtains a new database connection to a master server.\n   * Used for replication.\n   * If replication is not setup then returns default connection's database connection.\n   */\n  obtainMasterConnection() {\n    return this.instanceDatabase;\n  }\n  /**\n   * Obtains a new database connection to a slave server.\n   * Used for replication.\n   * If replication is not setup then returns master (default) connection's database connection.\n   */\n  obtainSlaveConnection() {\n    return this.instanceDatabase;\n  }\n  /**\n   * Creates generated map of values generated or returned by database after INSERT query.\n   */\n  createGeneratedMap(metadata, insertResult, entityIndex) {\n    if (!insertResult) {\n      return undefined;\n    }\n    if (insertResult.insertId === undefined) {\n      return Object.keys(insertResult).reduce((map, key) => {\n        const column = metadata.findColumnWithDatabaseName(key);\n        if (column) {\n          OrmUtils.mergeDeep(map, column.createValueMap(insertResult[key]));\n          // OrmUtils.mergeDeep(map, column.createValueMap(this.prepareHydratedValue(insertResult[key], column))); // TODO: probably should be like there, but fails on enums, fix later\n        }\n        return map;\n      }, {});\n    }\n    const generatedMap = metadata.generatedColumns.reduce((map, generatedColumn) => {\n      let value;\n      if (generatedColumn.generationStrategy === \"increment\" && insertResult.insertId) {\n        // NOTE: When multiple rows is inserted by a single INSERT statement,\n        // `insertId` is the value generated for the first inserted row only.\n        value = insertResult.insertId + entityIndex;\n        // } else if (generatedColumn.generationStrategy === \"uuid\") {\n        //     console.log(\"getting db value:\", generatedColumn.databaseName);\n        //     value = generatedColumn.getEntityValue(uuidMap);\n      }\n      return OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));\n    }, {});\n    return Object.keys(generatedMap).length > 0 ? generatedMap : undefined;\n  }\n  /**\n   * Differentiate columns of this table and columns from the given column metadatas columns\n   * and returns only changed.\n   */\n  findChangedColumns(tableColumns, columnMetadatas) {\n    return columnMetadatas.filter(columnMetadata => {\n      const tableColumn = tableColumns.find(c => c.name === columnMetadata.databaseName);\n      if (!tableColumn) return false; // we don't need new columns, we only need exist and changed\n      const isColumnChanged = tableColumn.name !== columnMetadata.databaseName || tableColumn.type !== this.normalizeType(columnMetadata) || tableColumn.length !== this.getColumnLength(columnMetadata) || tableColumn.asExpression !== columnMetadata.asExpression || tableColumn.generatedType !== columnMetadata.generatedType || tableColumn.isPrimary !== columnMetadata.isPrimary || !this.compareNullableValues(columnMetadata, tableColumn) || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata);\n      // DEBUG SECTION\n      // if (isColumnChanged) {\n      //     console.log(\"table:\", columnMetadata.entityMetadata.tableName)\n      //     console.log(\n      //         \"name:\",\n      //         tableColumn.name,\n      //         columnMetadata.databaseName,\n      //     )\n      //     console.log(\n      //         \"type:\",\n      //         tableColumn.type,\n      //         this.normalizeType(columnMetadata),\n      //     )\n      //     console.log(\n      //         \"length:\",\n      //         tableColumn.length,\n      //         this.getColumnLength(columnMetadata),\n      //     )\n      //     console.log(\n      //         \"asExpression:\",\n      //         tableColumn.asExpression,\n      //         columnMetadata.asExpression,\n      //     )\n      //     console.log(\n      //         \"generatedType:\",\n      //         tableColumn.generatedType,\n      //         columnMetadata.generatedType,\n      //     )\n      //     console.log(\n      //         \"isPrimary:\",\n      //         tableColumn.isPrimary,\n      //         columnMetadata.isPrimary,\n      //     )\n      //     console.log(\n      //         \"isNullable:\",\n      //         tableColumn.isNullable,\n      //         columnMetadata.isNullable,\n      //     )\n      //     console.log(\n      //         \"isUnique:\",\n      //         tableColumn.isUnique,\n      //         this.normalizeIsUnique(columnMetadata),\n      //     )\n      //     console.log(\"==========================================\")\n      // }\n      return isColumnChanged;\n    });\n  }\n  /**\n   * Returns true if driver supports RETURNING / OUTPUT statement.\n   */\n  isReturningSqlSupported(returningType) {\n    return this._isReturningSqlSupported[returningType];\n  }\n  /**\n   * Returns true if driver supports uuid values generation on its own.\n   */\n  isUUIDGenerationSupported() {\n    return false;\n  }\n  /**\n   * Returns true if driver supports fulltext indices.\n   */\n  isFullTextColumnTypeSupported() {\n    return false;\n  }\n  /**\n   * Creates an escaped parameter.\n   */\n  createParameter(parameterName, index) {\n    return this.parametersPrefix + index;\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Loads all driver dependencies.\n   */\n  loadDependencies() {\n    try {\n      const lib = this.options.driver || PlatformTools.load(\"spanner\");\n      this.spanner = new lib.Spanner({\n        projectId: this.options.projectId\n      });\n    } catch (e) {\n      console.error(e);\n      throw new DriverPackageNotInstalledError(\"Spanner\", \"@google-cloud/spanner\");\n    }\n  }\n  compareNullableValues(columnMetadata, tableColumn) {\n    // Spanner does not support NULL/NOT NULL expressions for generated columns\n    if (columnMetadata.generatedType) {\n      return true;\n    }\n    return columnMetadata.isNullable === tableColumn.isNullable;\n  }\n  /**\n   * Checks if \"DEFAULT\" values in the column metadata and in the database are equal.\n   */\n  compareDefaultValues(columnMetadataValue, databaseValue) {\n    if (typeof columnMetadataValue === \"string\" && typeof databaseValue === \"string\") {\n      // we need to cut out \"'\" because in mysql we can understand returned value is a string or a function\n      // as result compare cannot understand if default is really changed or not\n      columnMetadataValue = columnMetadataValue.replace(/^'+|'+$/g, \"\");\n      databaseValue = databaseValue.replace(/^'+|'+$/g, \"\");\n    }\n    return columnMetadataValue === databaseValue;\n  }\n  /**\n   * If parameter is a datetime function, e.g. \"CURRENT_TIMESTAMP\", normalizes it.\n   * Otherwise returns original input.\n   */\n  normalizeDatetimeFunction(value) {\n    if (!value) return value;\n    // check if input is datetime function\n    const isDatetimeFunction = value.toUpperCase().indexOf(\"CURRENT_TIMESTAMP\") !== -1 || value.toUpperCase().indexOf(\"NOW\") !== -1;\n    if (isDatetimeFunction) {\n      // extract precision, e.g. \"(3)\"\n      const precision = value.match(/\\(\\d+\\)/);\n      return precision ? `CURRENT_TIMESTAMP${precision[0]}` : \"CURRENT_TIMESTAMP\";\n    } else {\n      return value;\n    }\n  }\n  /**\n   * Escapes a given comment.\n   */\n  escapeComment(comment) {\n    if (!comment) return comment;\n    comment = comment.replace(/\\u0000/g, \"\"); // Null bytes aren't allowed in comments\n    return comment;\n  }\n}","map":{"version":3,"names":["DriverPackageNotInstalledError","SpannerQueryRunner","DateUtils","PlatformTools","RdbmsSchemaBuilder","EntityMetadata","OrmUtils","ApplyValueTransformers","Table","View","TableForeignKey","SpannerDriver","constructor","connection","isReplicated","treeSupport","transactionSupport","supportedDataTypes","supportedUpsertTypes","spatialTypes","withLengthColumnTypes","withWidthColumnTypes","withPrecisionColumnTypes","withScaleColumnTypes","mappedDataTypes","createDate","createDateDefault","updateDate","updateDateDefault","deleteDate","deleteDateNullable","version","treeLevel","migrationId","migrationName","migrationTimestamp","cacheId","cacheIdentifier","cacheTime","cacheDuration","cacheQuery","cacheResult","metadataType","metadataDatabase","metadataSchema","metadataTable","metadataName","metadataValue","parametersPrefix","dataTypeDefaults","maxAliasLength","cteCapabilities","enabled","_isReturningSqlSupported","delete","insert","update","options","replication","loadDependencies","connect","instance","spanner","instanceId","instanceDatabase","database","databaseId","afterConnect","Promise","resolve","disconnect","close","createSchemaBuilder","createQueryRunner","mode","escapeQueryWithParameters","sql","parameters","nativeParameters","escapedParameters","Object","keys","map","key","length","parameterIndexMap","Map","replace","full","isArray","hasOwnProperty","has","get","value","v","push","createParameter","join","Function","set","emptySpaceBefore","emptySpaceAfter","escape","columnName","buildTableName","tableName","schema","tablePath","unshift","parseTableName","target","driverDatabase","driverSchema","undefined","parsed","name","referencedTableName","referencedDatabase","referencedSchema","parts","split","preparePersistentValue","columnMetadata","transformer","transformTo","type","lib","driver","load","Spanner","numeric","mixedDateToDateString","Date","mixedDateToDate","prepareHydratedValue","transformFrom","Boolean","JSON","parse","Number","isNaN","parseInt","normalizeType","column","String","Buffer","normalizeDefault","default","normalizeIsUnique","entityMetadata","indices","some","idx","isUnique","columns","getColumnLength","toString","generationStrategy","createFullType","width","precision","scale","obtainMasterConnection","obtainSlaveConnection","createGeneratedMap","metadata","insertResult","entityIndex","insertId","reduce","findColumnWithDatabaseName","mergeDeep","createValueMap","generatedMap","generatedColumns","generatedColumn","findChangedColumns","tableColumns","columnMetadatas","filter","tableColumn","find","c","databaseName","isColumnChanged","asExpression","generatedType","isPrimary","compareNullableValues","isReturningSqlSupported","returningType","isUUIDGenerationSupported","isFullTextColumnTypeSupported","parameterName","index","projectId","e","console","error","isNullable","compareDefaultValues","columnMetadataValue","databaseValue","normalizeDatetimeFunction","isDatetimeFunction","toUpperCase","indexOf","match","escapeComment","comment"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\driver\\spanner\\SpannerDriver.ts"],"sourcesContent":["import { Driver, ReturningType } from \"../Driver\"\nimport { DriverPackageNotInstalledError } from \"../../error/DriverPackageNotInstalledError\"\nimport { SpannerQueryRunner } from \"./SpannerQueryRunner\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { ColumnMetadata } from \"../../metadata/ColumnMetadata\"\nimport { DateUtils } from \"../../util/DateUtils\"\nimport { PlatformTools } from \"../../platform/PlatformTools\"\nimport { Connection } from \"../../connection/Connection\"\nimport { RdbmsSchemaBuilder } from \"../../schema-builder/RdbmsSchemaBuilder\"\nimport { SpannerConnectionOptions } from \"./SpannerConnectionOptions\"\nimport { MappedColumnTypes } from \"../types/MappedColumnTypes\"\nimport { ColumnType } from \"../types/ColumnTypes\"\nimport { DataTypeDefaults } from \"../types/DataTypeDefaults\"\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\"\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { ApplyValueTransformers } from \"../../util/ApplyValueTransformers\"\nimport { ReplicationMode } from \"../types/ReplicationMode\"\nimport { Table } from \"../../schema-builder/table/Table\"\nimport { View } from \"../../schema-builder/view/View\"\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\"\nimport { CteCapabilities } from \"../types/CteCapabilities\"\nimport { UpsertType } from \"../types/UpsertType\"\n\n/**\n * Organizes communication with Spanner DBMS.\n */\nexport class SpannerDriver implements Driver {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection used by driver.\n     */\n    connection: Connection\n\n    /**\n     * Cloud Spanner underlying library.\n     */\n    spanner: any\n\n    /**\n     * Cloud Spanner instance.\n     */\n    instance: any\n\n    /**\n     * Cloud Spanner database.\n     */\n    instanceDatabase: any\n\n    /**\n     * Database name.\n     */\n    database?: string\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection options.\n     */\n    options: SpannerConnectionOptions\n\n    /**\n     * Indicates if replication is enabled.\n     */\n    isReplicated: boolean = false\n\n    /**\n     * Indicates if tree tables are supported by this driver.\n     */\n    treeSupport = true\n\n    /**\n     * Represent transaction support by this driver\n     */\n    transactionSupport = \"none\" as const\n\n    /**\n     * Gets list of supported column data types by a driver.\n     *\n     * @see https://cloud.google.com/spanner/docs/reference/standard-sql/data-types\n     */\n    supportedDataTypes: ColumnType[] = [\n        \"bool\",\n        \"int64\",\n        \"float64\",\n        \"numeric\",\n        \"string\",\n        \"json\",\n        \"bytes\",\n        \"date\",\n        \"timestamp\",\n        \"array\",\n    ]\n\n    /**\n     * Returns type of upsert supported by driver if any\n     */\n    supportedUpsertTypes: UpsertType[] = []\n\n    /**\n     * Gets list of spatial column data types.\n     */\n    spatialTypes: ColumnType[] = []\n\n    /**\n     * Gets list of column data types that support length by a driver.\n     */\n    withLengthColumnTypes: ColumnType[] = [\"string\", \"bytes\"]\n\n    /**\n     * Gets list of column data types that support length by a driver.\n     */\n    withWidthColumnTypes: ColumnType[] = []\n\n    /**\n     * Gets list of column data types that support precision by a driver.\n     */\n    withPrecisionColumnTypes: ColumnType[] = []\n\n    /**\n     * Gets list of column data types that supports scale by a driver.\n     */\n    withScaleColumnTypes: ColumnType[] = []\n\n    /**\n     * ORM has special columns and we need to know what database column types should be for those columns.\n     * Column types are driver dependant.\n     */\n    mappedDataTypes: MappedColumnTypes = {\n        createDate: \"timestamp\",\n        createDateDefault: \"\",\n        updateDate: \"timestamp\",\n        updateDateDefault: \"\",\n        deleteDate: \"timestamp\",\n        deleteDateNullable: true,\n        version: \"int64\",\n        treeLevel: \"int64\",\n        migrationId: \"int64\",\n        migrationName: \"string\",\n        migrationTimestamp: \"int64\",\n        cacheId: \"string\",\n        cacheIdentifier: \"string\",\n        cacheTime: \"int64\",\n        cacheDuration: \"int64\",\n        cacheQuery: \"string\",\n        cacheResult: \"string\",\n        metadataType: \"string\",\n        metadataDatabase: \"string\",\n        metadataSchema: \"string\",\n        metadataTable: \"string\",\n        metadataName: \"string\",\n        metadataValue: \"string\",\n    }\n\n    /**\n     * The prefix used for the parameters\n     */\n    parametersPrefix: string = \"@param\"\n\n    /**\n     * Default values of length, precision and scale depends on column data type.\n     * Used in the cases when length/precision/scale is not specified by user.\n     */\n    dataTypeDefaults: DataTypeDefaults = {}\n\n    /**\n     * Max length allowed by MySQL for aliases.\n     * @see https://dev.mysql.com/doc/refman/5.5/en/identifiers.html\n     */\n    maxAliasLength = 63\n\n    cteCapabilities: CteCapabilities = {\n        enabled: true,\n    }\n\n    /**\n     * Supported returning types\n     */\n    private readonly _isReturningSqlSupported: Record<ReturningType, boolean> =\n        {\n            delete: false,\n            insert: false,\n            update: false,\n        }\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(connection: Connection) {\n        this.connection = connection\n        this.options = connection.options as SpannerConnectionOptions\n        this.isReplicated = this.options.replication ? true : false\n\n        // load mysql package\n        this.loadDependencies()\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs connection to the database.\n     */\n    async connect(): Promise<void> {\n        this.instance = this.spanner.instance(this.options.instanceId)\n        this.instanceDatabase = this.instance.database(this.options.databaseId)\n    }\n\n    /**\n     * Makes any action after connection (e.g. create extensions in Postgres driver).\n     */\n    afterConnect(): Promise<void> {\n        return Promise.resolve()\n    }\n\n    /**\n     * Closes connection with the database.\n     */\n    async disconnect(): Promise<void> {\n        this.instanceDatabase.close()\n    }\n\n    /**\n     * Creates a schema builder used to build and sync a schema.\n     */\n    createSchemaBuilder() {\n        return new RdbmsSchemaBuilder(this.connection)\n    }\n\n    /**\n     * Creates a query runner used to execute database queries.\n     */\n    createQueryRunner(mode: ReplicationMode) {\n        return new SpannerQueryRunner(this, mode)\n    }\n\n    /**\n     * Replaces parameters in the given sql with special escaping character\n     * and an array of parameter names to be passed to a query.\n     */\n    escapeQueryWithParameters(\n        sql: string,\n        parameters: ObjectLiteral,\n        nativeParameters: ObjectLiteral,\n    ): [string, any[]] {\n        const escapedParameters: any[] = Object.keys(nativeParameters).map(\n            (key) => nativeParameters[key],\n        )\n        if (!parameters || !Object.keys(parameters).length)\n            return [sql, escapedParameters]\n\n        const parameterIndexMap = new Map<string, number>()\n        sql = sql.replace(\n            /:(\\.\\.\\.)?([A-Za-z0-9_.]+)/g,\n            (full, isArray: string, key: string): string => {\n                if (!parameters.hasOwnProperty(key)) {\n                    return full\n                }\n\n                if (parameterIndexMap.has(key)) {\n                    return this.parametersPrefix + parameterIndexMap.get(key)\n                }\n\n                let value: any = parameters[key]\n\n                if (value === null) {\n                    return full\n                }\n\n                if (isArray) {\n                    return value\n                        .map((v: any) => {\n                            escapedParameters.push(v)\n                            return this.createParameter(\n                                key,\n                                escapedParameters.length - 1,\n                            )\n                        })\n                        .join(\", \")\n                }\n\n                if (value instanceof Function) {\n                    return value()\n                }\n\n                escapedParameters.push(value)\n                parameterIndexMap.set(key, escapedParameters.length - 1)\n                return this.createParameter(key, escapedParameters.length - 1)\n            },\n        ) // todo: make replace only in value statements, otherwise problems\n\n        sql = sql.replace(\n            /([ ]+)?=([ ]+)?:(\\.\\.\\.)?([A-Za-z0-9_.]+)/g,\n            (\n                full,\n                emptySpaceBefore: string,\n                emptySpaceAfter: string,\n                isArray: string,\n                key: string,\n            ): string => {\n                if (!parameters.hasOwnProperty(key)) {\n                    return full\n                }\n\n                let value: any = parameters[key]\n                if (value === null) {\n                    return \" IS NULL\"\n                }\n\n                return full\n            },\n        )\n        return [sql, escapedParameters]\n    }\n\n    /**\n     * Escapes a column name.\n     */\n    escape(columnName: string): string {\n        return `\\`${columnName}\\``\n    }\n\n    /**\n     * Build full table name with database name, schema name and table name.\n     * E.g. myDB.mySchema.myTable\n     */\n    buildTableName(\n        tableName: string,\n        schema?: string,\n        database?: string,\n    ): string {\n        let tablePath = [tableName]\n\n        if (database) {\n            tablePath.unshift(database)\n        }\n\n        return tablePath.join(\".\")\n    }\n\n    /**\n     * Parse a target table name or other types and return a normalized table definition.\n     */\n    parseTableName(\n        target: EntityMetadata | Table | View | TableForeignKey | string,\n    ): { database?: string; schema?: string; tableName: string } {\n        const driverDatabase = this.database\n        const driverSchema = undefined\n\n        if (target instanceof Table || target instanceof View) {\n            const parsed = this.parseTableName(target.name)\n\n            return {\n                database: target.database || parsed.database || driverDatabase,\n                schema: target.schema || parsed.schema || driverSchema,\n                tableName: parsed.tableName,\n            }\n        }\n\n        if (target instanceof TableForeignKey) {\n            const parsed = this.parseTableName(target.referencedTableName)\n\n            return {\n                database:\n                    target.referencedDatabase ||\n                    parsed.database ||\n                    driverDatabase,\n                schema:\n                    target.referencedSchema || parsed.schema || driverSchema,\n                tableName: parsed.tableName,\n            }\n        }\n\n        if (target instanceof EntityMetadata) {\n            // EntityMetadata tableName is never a path\n\n            return {\n                database: target.database || driverDatabase,\n                schema: target.schema || driverSchema,\n                tableName: target.tableName,\n            }\n        }\n\n        const parts = target.split(\".\")\n\n        return {\n            database:\n                (parts.length > 1 ? parts[0] : undefined) || driverDatabase,\n            schema: driverSchema,\n            tableName: parts.length > 1 ? parts[1] : parts[0],\n        }\n    }\n\n    /**\n     * Prepares given value to a value to be persisted, based on its column type and metadata.\n     */\n    preparePersistentValue(value: any, columnMetadata: ColumnMetadata): any {\n        if (columnMetadata.transformer)\n            value = ApplyValueTransformers.transformTo(\n                columnMetadata.transformer,\n                value,\n            )\n\n        if (value === null || value === undefined) return value\n\n        if (columnMetadata.type === \"numeric\") {\n            const lib = this.options.driver || PlatformTools.load(\"spanner\")\n            return lib.Spanner.numeric(value)\n        } else if (columnMetadata.type === \"date\") {\n            return DateUtils.mixedDateToDateString(value)\n        } else if (columnMetadata.type === \"json\") {\n            return value\n        } else if (\n            columnMetadata.type === \"timestamp\" ||\n            columnMetadata.type === Date\n        ) {\n            return DateUtils.mixedDateToDate(value)\n        }\n\n        return value\n    }\n\n    /**\n     * Prepares given value to a value to be persisted, based on its column type or metadata.\n     */\n    prepareHydratedValue(value: any, columnMetadata: ColumnMetadata): any {\n        if (value === null || value === undefined)\n            return columnMetadata.transformer\n                ? ApplyValueTransformers.transformFrom(\n                      columnMetadata.transformer,\n                      value,\n                  )\n                : value\n\n        if (columnMetadata.type === Boolean || columnMetadata.type === \"bool\") {\n            value = value ? true : false\n        } else if (\n            columnMetadata.type === \"timestamp\" ||\n            columnMetadata.type === Date\n        ) {\n            value = new Date(value)\n        } else if (columnMetadata.type === \"numeric\") {\n            value = value.value\n        } else if (columnMetadata.type === \"date\") {\n            value = DateUtils.mixedDateToDateString(value)\n        } else if (columnMetadata.type === \"json\") {\n            value = typeof value === \"string\" ? JSON.parse(value) : value\n        } else if (columnMetadata.type === Number) {\n            // convert to number if number\n            value = !isNaN(+value) ? parseInt(value) : value\n        }\n\n        if (columnMetadata.transformer)\n            value = ApplyValueTransformers.transformFrom(\n                columnMetadata.transformer,\n                value,\n            )\n\n        return value\n    }\n\n    /**\n     * Creates a database type from a given column metadata.\n     */\n    normalizeType(column: {\n        type: ColumnType\n        length?: number | string\n        precision?: number | null\n        scale?: number\n    }): string {\n        if (column.type === Number) {\n            return \"int64\"\n        } else if (column.type === String || column.type === \"uuid\") {\n            return \"string\"\n        } else if (column.type === Date) {\n            return \"timestamp\"\n        } else if ((column.type as any) === Buffer) {\n            return \"bytes\"\n        } else if (column.type === Boolean) {\n            return \"bool\"\n        } else {\n            return (column.type as string) || \"\"\n        }\n    }\n\n    /**\n     * Normalizes \"default\" value of the column.\n     *\n     * Spanner does not support default values.\n     */\n    normalizeDefault(columnMetadata: ColumnMetadata): string | undefined {\n        return columnMetadata.default === \"\"\n            ? `\"${columnMetadata.default}\"`\n            : `${columnMetadata.default}`\n    }\n\n    /**\n     * Normalizes \"isUnique\" value of the column.\n     */\n    normalizeIsUnique(column: ColumnMetadata): boolean {\n        return column.entityMetadata.indices.some(\n            (idx) =>\n                idx.isUnique &&\n                idx.columns.length === 1 &&\n                idx.columns[0] === column,\n        )\n    }\n\n    /**\n     * Returns default column lengths, which is required on column creation.\n     */\n    getColumnLength(column: ColumnMetadata | TableColumn): string {\n        if (column.length) return column.length.toString()\n        if (column.generationStrategy === \"uuid\") return \"36\"\n\n        switch (column.type) {\n            case String:\n            case \"string\":\n            case \"bytes\":\n                return \"max\"\n            default:\n                return \"\"\n        }\n    }\n\n    /**\n     * Creates column type definition including length, precision and scale\n     */\n    createFullType(column: TableColumn): string {\n        let type = column.type\n\n        // used 'getColumnLength()' method, because Spanner requires column length for `string` and `bytes` data types\n        if (this.getColumnLength(column)) {\n            type += `(${this.getColumnLength(column)})`\n        } else if (column.width) {\n            type += `(${column.width})`\n        } else if (\n            column.precision !== null &&\n            column.precision !== undefined &&\n            column.scale !== null &&\n            column.scale !== undefined\n        ) {\n            type += `(${column.precision},${column.scale})`\n        } else if (\n            column.precision !== null &&\n            column.precision !== undefined\n        ) {\n            type += `(${column.precision})`\n        }\n\n        if (column.isArray) type = `array<${type}>`\n\n        return type\n    }\n\n    /**\n     * Obtains a new database connection to a master server.\n     * Used for replication.\n     * If replication is not setup then returns default connection's database connection.\n     */\n    obtainMasterConnection(): Promise<any> {\n        return this.instanceDatabase\n    }\n\n    /**\n     * Obtains a new database connection to a slave server.\n     * Used for replication.\n     * If replication is not setup then returns master (default) connection's database connection.\n     */\n    obtainSlaveConnection(): Promise<any> {\n        return this.instanceDatabase\n    }\n\n    /**\n     * Creates generated map of values generated or returned by database after INSERT query.\n     */\n    createGeneratedMap(\n        metadata: EntityMetadata,\n        insertResult: any,\n        entityIndex: number,\n    ) {\n        if (!insertResult) {\n            return undefined\n        }\n\n        if (insertResult.insertId === undefined) {\n            return Object.keys(insertResult).reduce((map, key) => {\n                const column = metadata.findColumnWithDatabaseName(key)\n                if (column) {\n                    OrmUtils.mergeDeep(\n                        map,\n                        column.createValueMap(insertResult[key]),\n                    )\n                    // OrmUtils.mergeDeep(map, column.createValueMap(this.prepareHydratedValue(insertResult[key], column))); // TODO: probably should be like there, but fails on enums, fix later\n                }\n                return map\n            }, {} as ObjectLiteral)\n        }\n\n        const generatedMap = metadata.generatedColumns.reduce(\n            (map, generatedColumn) => {\n                let value: any\n                if (\n                    generatedColumn.generationStrategy === \"increment\" &&\n                    insertResult.insertId\n                ) {\n                    // NOTE: When multiple rows is inserted by a single INSERT statement,\n                    // `insertId` is the value generated for the first inserted row only.\n                    value = insertResult.insertId + entityIndex\n                    // } else if (generatedColumn.generationStrategy === \"uuid\") {\n                    //     console.log(\"getting db value:\", generatedColumn.databaseName);\n                    //     value = generatedColumn.getEntityValue(uuidMap);\n                }\n\n                return OrmUtils.mergeDeep(\n                    map,\n                    generatedColumn.createValueMap(value),\n                )\n            },\n            {} as ObjectLiteral,\n        )\n\n        return Object.keys(generatedMap).length > 0 ? generatedMap : undefined\n    }\n\n    /**\n     * Differentiate columns of this table and columns from the given column metadatas columns\n     * and returns only changed.\n     */\n    findChangedColumns(\n        tableColumns: TableColumn[],\n        columnMetadatas: ColumnMetadata[],\n    ): ColumnMetadata[] {\n        return columnMetadatas.filter((columnMetadata) => {\n            const tableColumn = tableColumns.find(\n                (c) => c.name === columnMetadata.databaseName,\n            )\n            if (!tableColumn) return false // we don't need new columns, we only need exist and changed\n\n            const isColumnChanged =\n                tableColumn.name !== columnMetadata.databaseName ||\n                tableColumn.type !== this.normalizeType(columnMetadata) ||\n                tableColumn.length !== this.getColumnLength(columnMetadata) ||\n                tableColumn.asExpression !== columnMetadata.asExpression ||\n                tableColumn.generatedType !== columnMetadata.generatedType ||\n                tableColumn.isPrimary !== columnMetadata.isPrimary ||\n                !this.compareNullableValues(columnMetadata, tableColumn) ||\n                tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata)\n\n            // DEBUG SECTION\n            // if (isColumnChanged) {\n            //     console.log(\"table:\", columnMetadata.entityMetadata.tableName)\n            //     console.log(\n            //         \"name:\",\n            //         tableColumn.name,\n            //         columnMetadata.databaseName,\n            //     )\n            //     console.log(\n            //         \"type:\",\n            //         tableColumn.type,\n            //         this.normalizeType(columnMetadata),\n            //     )\n            //     console.log(\n            //         \"length:\",\n            //         tableColumn.length,\n            //         this.getColumnLength(columnMetadata),\n            //     )\n            //     console.log(\n            //         \"asExpression:\",\n            //         tableColumn.asExpression,\n            //         columnMetadata.asExpression,\n            //     )\n            //     console.log(\n            //         \"generatedType:\",\n            //         tableColumn.generatedType,\n            //         columnMetadata.generatedType,\n            //     )\n            //     console.log(\n            //         \"isPrimary:\",\n            //         tableColumn.isPrimary,\n            //         columnMetadata.isPrimary,\n            //     )\n            //     console.log(\n            //         \"isNullable:\",\n            //         tableColumn.isNullable,\n            //         columnMetadata.isNullable,\n            //     )\n            //     console.log(\n            //         \"isUnique:\",\n            //         tableColumn.isUnique,\n            //         this.normalizeIsUnique(columnMetadata),\n            //     )\n            //     console.log(\"==========================================\")\n            // }\n\n            return isColumnChanged\n        })\n    }\n\n    /**\n     * Returns true if driver supports RETURNING / OUTPUT statement.\n     */\n    isReturningSqlSupported(returningType: ReturningType): boolean {\n        return this._isReturningSqlSupported[returningType]\n    }\n\n    /**\n     * Returns true if driver supports uuid values generation on its own.\n     */\n    isUUIDGenerationSupported(): boolean {\n        return false\n    }\n\n    /**\n     * Returns true if driver supports fulltext indices.\n     */\n    isFullTextColumnTypeSupported(): boolean {\n        return false\n    }\n\n    /**\n     * Creates an escaped parameter.\n     */\n    createParameter(parameterName: string, index: number): string {\n        return this.parametersPrefix + index\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Loads all driver dependencies.\n     */\n    protected loadDependencies(): void {\n        try {\n            const lib = this.options.driver || PlatformTools.load(\"spanner\")\n            this.spanner = new lib.Spanner({\n                projectId: this.options.projectId,\n            })\n        } catch (e) {\n            console.error(e)\n            throw new DriverPackageNotInstalledError(\n                \"Spanner\",\n                \"@google-cloud/spanner\",\n            )\n        }\n    }\n\n    compareNullableValues(\n        columnMetadata: ColumnMetadata,\n        tableColumn: TableColumn,\n    ): boolean {\n        // Spanner does not support NULL/NOT NULL expressions for generated columns\n        if (columnMetadata.generatedType) {\n            return true\n        }\n\n        return columnMetadata.isNullable === tableColumn.isNullable\n    }\n\n    /**\n     * Checks if \"DEFAULT\" values in the column metadata and in the database are equal.\n     */\n    protected compareDefaultValues(\n        columnMetadataValue: string | undefined,\n        databaseValue: string | undefined,\n    ): boolean {\n        if (\n            typeof columnMetadataValue === \"string\" &&\n            typeof databaseValue === \"string\"\n        ) {\n            // we need to cut out \"'\" because in mysql we can understand returned value is a string or a function\n            // as result compare cannot understand if default is really changed or not\n            columnMetadataValue = columnMetadataValue.replace(/^'+|'+$/g, \"\")\n            databaseValue = databaseValue.replace(/^'+|'+$/g, \"\")\n        }\n\n        return columnMetadataValue === databaseValue\n    }\n\n    /**\n     * If parameter is a datetime function, e.g. \"CURRENT_TIMESTAMP\", normalizes it.\n     * Otherwise returns original input.\n     */\n    protected normalizeDatetimeFunction(value?: string) {\n        if (!value) return value\n\n        // check if input is datetime function\n        const isDatetimeFunction =\n            value.toUpperCase().indexOf(\"CURRENT_TIMESTAMP\") !== -1 ||\n            value.toUpperCase().indexOf(\"NOW\") !== -1\n\n        if (isDatetimeFunction) {\n            // extract precision, e.g. \"(3)\"\n            const precision = value.match(/\\(\\d+\\)/)\n            return precision\n                ? `CURRENT_TIMESTAMP${precision[0]}`\n                : \"CURRENT_TIMESTAMP\"\n        } else {\n            return value\n        }\n    }\n\n    /**\n     * Escapes a given comment.\n     */\n    protected escapeComment(comment?: string) {\n        if (!comment) return comment\n\n        comment = comment.replace(/\\u0000/g, \"\") // Null bytes aren't allowed in comments\n\n        return comment\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}