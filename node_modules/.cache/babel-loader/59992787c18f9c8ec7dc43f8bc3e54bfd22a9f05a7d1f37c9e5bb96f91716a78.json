{"ast":null,"code":"import { OrmUtils } from \"../util/OrmUtils\";\nimport { ApplyValueTransformers } from \"../util/ApplyValueTransformers\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\n/**\n * This metadata contains all information about entity's column.\n */\nexport class ColumnMetadata {\n  // ---------------------------------------------------------------------\n  // Constructor\n  // ---------------------------------------------------------------------\n  constructor(options) {\n    this[\"@instanceof\"] = Symbol.for(\"ColumnMetadata\");\n    /**\n     * Type's length in the database.\n     */\n    this.length = \"\";\n    /**\n     * Indicates if this column is a primary key.\n     */\n    this.isPrimary = false;\n    /**\n     * Indicates if this column is generated (auto increment or generated other way).\n     */\n    this.isGenerated = false;\n    /**\n     * Indicates if column can contain nulls or not.\n     */\n    this.isNullable = false;\n    /**\n     * Indicates if column is selected by query builder or not.\n     */\n    this.isSelect = true;\n    /**\n     * Indicates if column is inserted by default or not.\n     */\n    this.isInsert = true;\n    /**\n     * Indicates if column allows updates or not.\n     */\n    this.isUpdate = true;\n    /**\n     * Puts ZEROFILL attribute on to numeric column. Works only for MySQL.\n     * If you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column\n     */\n    this.zerofill = false;\n    /**\n     * Puts UNSIGNED attribute on to numeric column. Works only for MySQL.\n     */\n    this.unsigned = false;\n    /**\n     * Indicates if this column is an array.\n     */\n    this.isArray = false;\n    /**\n     * Indicates if column is virtual. Virtual columns are not mapped to the entity.\n     */\n    this.isVirtual = false;\n    /**\n     * Indicates if column is a virtual property. Virtual properties are not mapped to the entity.\n     * This property is used in tandem the virtual column decorator.\n     * @See https://typeorm.io/decorator-reference#virtualcolumn for more details.\n     */\n    this.isVirtualProperty = false;\n    /**\n     * Indicates if column is discriminator. Discriminator columns are not mapped to the entity.\n     */\n    this.isDiscriminator = false;\n    /**\n     * Indicates if column is tree-level column. Tree-level columns are used in closure entities.\n     */\n    this.isTreeLevel = false;\n    /**\n     * Indicates if this column contains an entity creation date.\n     */\n    this.isCreateDate = false;\n    /**\n     * Indicates if this column contains an entity update date.\n     */\n    this.isUpdateDate = false;\n    /**\n     * Indicates if this column contains an entity delete date.\n     */\n    this.isDeleteDate = false;\n    /**\n     * Indicates if this column contains an entity version.\n     */\n    this.isVersion = false;\n    /**\n     * Indicates if this column contains an object id.\n     */\n    this.isObjectId = false;\n    /**\n     * Indicates if this column is nested set's left column.\n     * Used only in tree entities with nested-set type.\n     */\n    this.isNestedSetLeft = false;\n    /**\n     * Indicates if this column is nested set's right column.\n     * Used only in tree entities with nested-set type.\n     */\n    this.isNestedSetRight = false;\n    /**\n     * Indicates if this column is materialized path's path column.\n     * Used only in tree entities with materialized path type.\n     */\n    this.isMaterializedPath = false;\n    this.entityMetadata = options.entityMetadata;\n    this.embeddedMetadata = options.embeddedMetadata;\n    this.referencedColumn = options.referencedColumn;\n    if (options.args.target) this.target = options.args.target;\n    if (options.args.propertyName) this.propertyName = options.args.propertyName;\n    if (options.args.options.name) this.givenDatabaseName = options.args.options.name;\n    if (options.args.options.type) this.type = options.args.options.type;\n    if (options.args.options.length) this.length = options.args.options.length ? options.args.options.length.toString() : \"\";\n    if (options.args.options.width) this.width = options.args.options.width;\n    if (options.args.options.charset) this.charset = options.args.options.charset;\n    if (options.args.options.collation) this.collation = options.args.options.collation;\n    if (options.args.options.primary) this.isPrimary = options.args.options.primary;\n    if (options.args.options.default === null)\n      // to make sure default: null is the same as nullable: true\n      this.isNullable = true;\n    if (options.args.options.nullable !== undefined) this.isNullable = options.args.options.nullable;\n    if (options.args.options.select !== undefined) this.isSelect = options.args.options.select;\n    if (options.args.options.insert !== undefined) this.isInsert = options.args.options.insert;\n    if (options.args.options.update !== undefined) this.isUpdate = options.args.options.update;\n    if (options.args.options.readonly !== undefined) this.isUpdate = !options.args.options.readonly;\n    if (options.args.options.comment) this.comment = options.args.options.comment;\n    if (options.args.options.default !== undefined) this.default = options.args.options.default;\n    if (options.args.options.onUpdate) this.onUpdate = options.args.options.onUpdate;\n    if (options.args.options.generatedIdentity) this.generatedIdentity = options.args.options.generatedIdentity;\n    if (options.args.options.scale !== null && options.args.options.scale !== undefined) this.scale = options.args.options.scale;\n    if (options.args.options.zerofill) {\n      this.zerofill = options.args.options.zerofill;\n      this.unsigned = true; // if you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column\n    }\n    if (options.args.options.unsigned) this.unsigned = options.args.options.unsigned;\n    if (options.args.options.precision !== null) this.precision = options.args.options.precision;\n    if (options.args.options.enum) {\n      if (ObjectUtils.isObject(options.args.options.enum) && !Array.isArray(options.args.options.enum)) {\n        this.enum = Object.keys(options.args.options.enum)\n        // remove numeric keys - typescript numeric enum types generate them\n        // From the documentation: “declaration merging” means that the compiler merges two separate declarations\n        // declared with the same name into a single definition. This concept is often used to merge enum with namespace\n        // where in namespace we define e.g. utility methods for creating enum. This is well known in other languages\n        // like Java (enum methods). Here in case if enum have function, we need to remove it from metadata, otherwise\n        // generated SQL statements contains string representation of that function which leads into syntax error\n        // at database side.\n        .filter(key => isNaN(+key) && typeof options.args.options.enum[key] !== \"function\").map(key => options.args.options.enum[key]);\n      } else {\n        this.enum = options.args.options.enum;\n      }\n    }\n    if (options.args.options.enumName) {\n      this.enumName = options.args.options.enumName;\n    }\n    if (options.args.options.primaryKeyConstraintName) {\n      this.primaryKeyConstraintName = options.args.options.primaryKeyConstraintName;\n    }\n    if (options.args.options.foreignKeyConstraintName) {\n      this.foreignKeyConstraintName = options.args.options.foreignKeyConstraintName;\n    }\n    if (options.args.options.asExpression) {\n      this.asExpression = options.args.options.asExpression;\n      this.generatedType = options.args.options.generatedType ? options.args.options.generatedType : \"VIRTUAL\";\n    }\n    if (options.args.options.hstoreType) this.hstoreType = options.args.options.hstoreType;\n    if (options.args.options.array) this.isArray = options.args.options.array;\n    if (options.args.mode) {\n      this.isVirtualProperty = options.args.mode === \"virtual-property\";\n      this.isVirtual = options.args.mode === \"virtual\";\n      this.isTreeLevel = options.args.mode === \"treeLevel\";\n      this.isCreateDate = options.args.mode === \"createDate\";\n      this.isUpdateDate = options.args.mode === \"updateDate\";\n      this.isDeleteDate = options.args.mode === \"deleteDate\";\n      this.isVersion = options.args.mode === \"version\";\n      this.isObjectId = options.args.mode === \"objectId\";\n    }\n    if (this.isVirtualProperty) {\n      this.isInsert = false;\n      this.isUpdate = false;\n    }\n    if (options.args.options.transformer) this.transformer = options.args.options.transformer;\n    if (options.args.options.spatialFeatureType) this.spatialFeatureType = options.args.options.spatialFeatureType;\n    if (options.args.options.srid !== undefined) this.srid = options.args.options.srid;\n    if (options.args.options.query) this.query = options.args.options.query;\n    if (this.isTreeLevel) this.type = options.connection.driver.mappedDataTypes.treeLevel;\n    if (this.isCreateDate) {\n      if (!this.type) this.type = options.connection.driver.mappedDataTypes.createDate;\n      if (!this.default) this.default = () => options.connection.driver.mappedDataTypes.createDateDefault;\n      // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n      if (this.precision === undefined && options.args.options.precision === undefined && options.connection.driver.mappedDataTypes.createDatePrecision) this.precision = options.connection.driver.mappedDataTypes.createDatePrecision;\n    }\n    if (this.isUpdateDate) {\n      if (!this.type) this.type = options.connection.driver.mappedDataTypes.updateDate;\n      if (!this.default) this.default = () => options.connection.driver.mappedDataTypes.updateDateDefault;\n      if (!this.onUpdate) this.onUpdate = options.connection.driver.mappedDataTypes.updateDateDefault;\n      // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n      if (this.precision === undefined && options.args.options.precision === undefined && options.connection.driver.mappedDataTypes.updateDatePrecision) this.precision = options.connection.driver.mappedDataTypes.updateDatePrecision;\n    }\n    if (this.isDeleteDate) {\n      if (!this.type) this.type = options.connection.driver.mappedDataTypes.deleteDate;\n      if (!this.isNullable) this.isNullable = options.connection.driver.mappedDataTypes.deleteDateNullable;\n      // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n      if (this.precision === undefined && options.args.options.precision === undefined && options.connection.driver.mappedDataTypes.deleteDatePrecision) this.precision = options.connection.driver.mappedDataTypes.deleteDatePrecision;\n    }\n    if (this.isVersion) this.type = options.connection.driver.mappedDataTypes.version;\n    if (options.closureType) this.closureType = options.closureType;\n    if (options.nestedSetLeft) this.isNestedSetLeft = options.nestedSetLeft;\n    if (options.nestedSetRight) this.isNestedSetRight = options.nestedSetRight;\n    if (options.materializedPath) this.isMaterializedPath = options.materializedPath;\n  }\n  // ---------------------------------------------------------------------\n  // Public Methods\n  // ---------------------------------------------------------------------\n  /**\n   * Creates entity id map from the given entity ids array.\n   */\n  createValueMap(value, useDatabaseName = false) {\n    // extract column value from embeds of entity if column is in embedded\n    if (this.embeddedMetadata) {\n      // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n      // we need to get value of \"id\" column from the post real entity object and return it in a\n      // { data: { information: { counters: { id: ... } } } } format\n      // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n      const propertyNames = [...this.embeddedMetadata.parentPropertyNames];\n      // now need to access post[data][information][counters] to get column value from the counters\n      // and on each step we need to create complex literal object, e.g. first { data },\n      // then { data: { information } }, then { data: { information: { counters } } },\n      // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n      // this recursive function helps doing that\n      const extractEmbeddedColumnValue = (propertyNames, map) => {\n        const propertyName = propertyNames.shift();\n        if (propertyName) {\n          map[propertyName] = {};\n          extractEmbeddedColumnValue(propertyNames, map[propertyName]);\n          return map;\n        }\n        // this is bugfix for #720 when increment number is bigint we need to make sure its a string\n        if ((this.generationStrategy === \"increment\" || this.generationStrategy === \"rowid\") && this.type === \"bigint\" && value !== null) value = String(value);\n        map[useDatabaseName ? this.databaseName : this.propertyName] = value;\n        return map;\n      };\n      return extractEmbeddedColumnValue(propertyNames, {});\n    } else {\n      // no embeds - no problems. Simply return column property name and its value of the entity\n      // this is bugfix for #720 when increment number is bigint we need to make sure its a string\n      if ((this.generationStrategy === \"increment\" || this.generationStrategy === \"rowid\") && this.type === \"bigint\" && value !== null) value = String(value);\n      return {\n        [useDatabaseName ? this.databaseName : this.propertyName]: value\n      };\n    }\n  }\n  /**\n   * Extracts column value and returns its column name with this value in a literal object.\n   * If column is in embedded (or recursive embedded) it returns complex literal object.\n   *\n   * Examples what this method can return depend if this column is in embeds.\n   * { id: 1 } or { title: \"hello\" }, { counters: { code: 1 } }, { data: { information: { counters: { code: 1 } } } }\n   */\n  getEntityValueMap(entity, options) {\n    const returnNulls = false; // options && options.skipNulls === false ? false : true; // todo: remove if current will not bring problems, uncomment if it will.\n    // extract column value from embeds of entity if column is in embedded\n    if (this.embeddedMetadata) {\n      // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n      // we need to get value of \"id\" column from the post real entity object and return it in a\n      // { data: { information: { counters: { id: ... } } } } format\n      // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n      const propertyNames = [...this.embeddedMetadata.parentPropertyNames];\n      const isEmbeddedArray = this.embeddedMetadata.isArray;\n      // now need to access post[data][information][counters] to get column value from the counters\n      // and on each step we need to create complex literal object, e.g. first { data },\n      // then { data: { information } }, then { data: { information: { counters } } },\n      // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n      // this recursive function helps doing that\n      const extractEmbeddedColumnValue = (propertyNames, value) => {\n        if (value === undefined) {\n          return {};\n        }\n        const propertyName = propertyNames.shift();\n        if (propertyName) {\n          const submap = extractEmbeddedColumnValue(propertyNames, value[propertyName]);\n          if (Object.keys(submap).length > 0) {\n            return {\n              [propertyName]: submap\n            };\n          }\n          return {};\n        }\n        if (isEmbeddedArray && Array.isArray(value)) {\n          return value.map(v => ({\n            [this.propertyName]: v[this.propertyName]\n          }));\n        }\n        if (value[this.propertyName] !== undefined && (returnNulls === false || value[this.propertyName] !== null)) {\n          return {\n            [this.propertyName]: value[this.propertyName]\n          };\n        }\n        return {};\n      };\n      const map = extractEmbeddedColumnValue(propertyNames, entity);\n      return Object.keys(map).length > 0 ? map : undefined;\n    } else {\n      // no embeds - no problems. Simply return column property name and its value of the entity\n      /**\n       * Object.getOwnPropertyDescriptor checks if the relation is lazy, in which case value is a Promise\n       * DO NOT use `entity[\n          this.relationMetadata.propertyName] instanceof Promise`, which will invoke property getter and make unwanted DB request\n       * refer: https://github.com/typeorm/typeorm/pull/8676#issuecomment-1049906331\n       */\n      if (this.relationMetadata && !Object.getOwnPropertyDescriptor(entity, this.relationMetadata.propertyName)?.get && entity[this.relationMetadata.propertyName] && ObjectUtils.isObject(entity[this.relationMetadata.propertyName])) {\n        const map = this.relationMetadata.joinColumns.reduce((map, joinColumn) => {\n          const value = joinColumn.referencedColumn.getEntityValueMap(entity[this.relationMetadata.propertyName]);\n          if (value === undefined) return map;\n          return OrmUtils.mergeDeep(map, value);\n        }, {});\n        if (Object.keys(map).length > 0) return {\n          [this.propertyName]: map\n        };\n        return undefined;\n      } else {\n        if (entity[this.propertyName] !== undefined && (returnNulls === false || entity[this.propertyName] !== null)) return {\n          [this.propertyName]: entity[this.propertyName]\n        };\n        return undefined;\n      }\n    }\n  }\n  /**\n   * Extracts column value from the given entity.\n   * If column is in embedded (or recursive embedded) it extracts its value from there.\n   */\n  getEntityValue(entity, transform = false) {\n    if (entity === undefined || entity === null) return undefined;\n    // extract column value from embeddeds of entity if column is in embedded\n    let value = undefined;\n    if (this.embeddedMetadata) {\n      // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n      // we need to get value of \"id\" column from the post real entity object\n      // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n      const propertyNames = [...this.embeddedMetadata.parentPropertyNames];\n      const isEmbeddedArray = this.embeddedMetadata.isArray;\n      // next we need to access post[data][information][counters][this.propertyName] to get column value from the counters\n      // this recursive function takes array of generated property names and gets the post[data][information][counters] embed\n      const extractEmbeddedColumnValue = (propertyNames, value) => {\n        const propertyName = propertyNames.shift();\n        return propertyName && value ? extractEmbeddedColumnValue(propertyNames, value[propertyName]) : value;\n      };\n      // once we get nested embed object we get its column, e.g. post[data][information][counters][this.propertyName]\n      const embeddedObject = extractEmbeddedColumnValue(propertyNames, entity);\n      if (embeddedObject) {\n        if (this.relationMetadata && this.referencedColumn) {\n          const relatedEntity = this.relationMetadata.getEntityValue(embeddedObject);\n          if (relatedEntity && ObjectUtils.isObject(relatedEntity) && !InstanceChecker.isFindOperator(relatedEntity) && !Buffer.isBuffer(relatedEntity)) {\n            value = this.referencedColumn.getEntityValue(relatedEntity);\n          } else if (embeddedObject[this.propertyName] && ObjectUtils.isObject(embeddedObject[this.propertyName]) && !InstanceChecker.isFindOperator(embeddedObject[this.propertyName]) && !Buffer.isBuffer(embeddedObject[this.propertyName]) && !(embeddedObject[this.propertyName] instanceof Date)) {\n            value = this.referencedColumn.getEntityValue(embeddedObject[this.propertyName]);\n          } else {\n            value = embeddedObject[this.propertyName];\n          }\n        } else if (this.referencedColumn) {\n          value = this.referencedColumn.getEntityValue(embeddedObject[this.propertyName]);\n        } else if (isEmbeddedArray && Array.isArray(embeddedObject)) {\n          value = embeddedObject.map(o => o[this.propertyName]);\n        } else {\n          value = embeddedObject[this.propertyName];\n        }\n      }\n    } else {\n      // no embeds - no problems. Simply return column name by property name of the entity\n      if (this.relationMetadata && this.referencedColumn) {\n        const relatedEntity = this.relationMetadata.getEntityValue(entity);\n        if (relatedEntity && ObjectUtils.isObject(relatedEntity) && !InstanceChecker.isFindOperator(relatedEntity) && !(typeof relatedEntity === \"function\") && !Buffer.isBuffer(relatedEntity)) {\n          value = this.referencedColumn.getEntityValue(relatedEntity);\n        } else if (entity[this.propertyName] && ObjectUtils.isObject(entity[this.propertyName]) && !InstanceChecker.isFindOperator(entity[this.propertyName]) && !(typeof entity[this.propertyName] === \"function\") && !Buffer.isBuffer(entity[this.propertyName]) && !(entity[this.propertyName] instanceof Date)) {\n          value = this.referencedColumn.getEntityValue(entity[this.propertyName]);\n        } else {\n          value = entity[this.propertyName];\n        }\n      } else if (this.referencedColumn) {\n        value = this.referencedColumn.getEntityValue(entity[this.propertyName]);\n      } else {\n        value = entity[this.propertyName];\n      }\n    }\n    if (transform && this.transformer) value = ApplyValueTransformers.transformTo(this.transformer, value);\n    return value;\n  }\n  /**\n   * Sets given entity's column value.\n   * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.\n   */\n  setEntityValue(entity, value) {\n    if (this.embeddedMetadata) {\n      // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n      const extractEmbeddedColumnValue = (embeddedMetadatas, map) => {\n        // if (!object[embeddedMetadata.propertyName])\n        //     object[embeddedMetadata.propertyName] = embeddedMetadata.create();\n        const embeddedMetadata = embeddedMetadatas.shift();\n        if (embeddedMetadata) {\n          if (!map[embeddedMetadata.propertyName]) map[embeddedMetadata.propertyName] = embeddedMetadata.create();\n          extractEmbeddedColumnValue(embeddedMetadatas, map[embeddedMetadata.propertyName]);\n          return map;\n        }\n        map[this.propertyName] = value;\n        return map;\n      };\n      return extractEmbeddedColumnValue([...this.embeddedMetadata.embeddedMetadataTree], entity);\n    } else {\n      // we write a deep object in this entity only if the column is virtual\n      // because if its not virtual it means the user defined a real column for this relation\n      // also we don't do it if column is inside a junction table\n      if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.propertyName !== this.propertyName) {\n        if (!(this.propertyName in entity)) {\n          entity[this.propertyName] = {};\n        }\n        entity[this.propertyName][this.referencedColumn.propertyName] = value;\n      } else {\n        entity[this.propertyName] = value;\n      }\n    }\n  }\n  /**\n   * Compares given entity's column value with a given value.\n   */\n  compareEntityValue(entity, valueToCompareWith) {\n    const columnValue = this.getEntityValue(entity);\n    if (ObjectUtils.isObject(columnValue)) {\n      return columnValue.equals(valueToCompareWith);\n    }\n    return columnValue === valueToCompareWith;\n  }\n  // ---------------------------------------------------------------------\n  // Builder Methods\n  // ---------------------------------------------------------------------\n  build(connection) {\n    this.propertyPath = this.buildPropertyPath();\n    this.propertyAliasName = this.propertyPath.replace(\".\", \"_\");\n    this.databaseName = this.buildDatabaseName(connection);\n    this.databasePath = this.buildDatabasePath();\n    this.databaseNameWithoutPrefixes = connection.namingStrategy.columnName(this.propertyName, this.givenDatabaseName, []);\n    return this;\n  }\n  buildPropertyPath() {\n    let path = \"\";\n    if (this.embeddedMetadata && this.embeddedMetadata.parentPropertyNames.length) path = this.embeddedMetadata.parentPropertyNames.join(\".\") + \".\";\n    path += this.propertyName;\n    // we add reference column to property path only if this column is virtual\n    // because if its not virtual it means user defined a real column for this relation\n    // also we don't do it if column is inside a junction table\n    if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.propertyName !== this.propertyName) path += \".\" + this.referencedColumn.propertyName;\n    return path;\n  }\n  buildDatabasePath() {\n    let path = \"\";\n    if (this.embeddedMetadata && this.embeddedMetadata.parentPropertyNames.length) path = this.embeddedMetadata.parentPropertyNames.join(\".\") + \".\";\n    path += this.databaseName;\n    // we add reference column to property path only if this column is virtual\n    // because if its not virtual it means user defined a real column for this relation\n    // also we don't do it if column is inside a junction table\n    if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.databaseName !== this.databaseName) path += \".\" + this.referencedColumn.databaseName;\n    return path;\n  }\n  buildDatabaseName(connection) {\n    let propertyNames = this.embeddedMetadata ? this.embeddedMetadata.parentPrefixes : [];\n    if (connection.driver.options.type === \"mongodb\")\n      // we don't need to include embedded name for the mongodb column names\n      propertyNames = [];\n    return connection.namingStrategy.columnName(this.propertyName, this.givenDatabaseName, propertyNames);\n  }\n}","map":{"version":3,"names":["OrmUtils","ApplyValueTransformers","ObjectUtils","InstanceChecker","ColumnMetadata","constructor","options","Symbol","for","length","isPrimary","isGenerated","isNullable","isSelect","isInsert","isUpdate","zerofill","unsigned","isArray","isVirtual","isVirtualProperty","isDiscriminator","isTreeLevel","isCreateDate","isUpdateDate","isDeleteDate","isVersion","isObjectId","isNestedSetLeft","isNestedSetRight","isMaterializedPath","entityMetadata","embeddedMetadata","referencedColumn","args","target","propertyName","name","givenDatabaseName","type","toString","width","charset","collation","primary","default","nullable","undefined","select","insert","update","readonly","comment","onUpdate","generatedIdentity","scale","precision","enum","isObject","Array","Object","keys","filter","key","isNaN","map","enumName","primaryKeyConstraintName","foreignKeyConstraintName","asExpression","generatedType","hstoreType","array","mode","transformer","spatialFeatureType","srid","query","connection","driver","mappedDataTypes","treeLevel","createDate","createDateDefault","createDatePrecision","updateDate","updateDateDefault","updateDatePrecision","deleteDate","deleteDateNullable","deleteDatePrecision","version","closureType","nestedSetLeft","nestedSetRight","materializedPath","createValueMap","value","useDatabaseName","propertyNames","parentPropertyNames","extractEmbeddedColumnValue","shift","generationStrategy","String","databaseName","getEntityValueMap","entity","returnNulls","isEmbeddedArray","submap","v","relationMetadata","getOwnPropertyDescriptor","get","joinColumns","reduce","joinColumn","mergeDeep","getEntityValue","transform","embeddedObject","relatedEntity","isFindOperator","Buffer","isBuffer","Date","o","transformTo","setEntityValue","embeddedMetadatas","create","embeddedMetadataTree","isJunction","compareEntityValue","valueToCompareWith","columnValue","equals","build","propertyPath","buildPropertyPath","propertyAliasName","replace","buildDatabaseName","databasePath","buildDatabasePath","databaseNameWithoutPrefixes","namingStrategy","columnName","path","join","parentPrefixes"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\metadata\\ColumnMetadata.ts"],"sourcesContent":["import { ColumnType } from \"../driver/types/ColumnTypes\"\nimport { EntityMetadata } from \"./EntityMetadata\"\nimport { EmbeddedMetadata } from \"./EmbeddedMetadata\"\nimport { RelationMetadata } from \"./RelationMetadata\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { ColumnMetadataArgs } from \"../metadata-args/ColumnMetadataArgs\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { OrmUtils } from \"../util/OrmUtils\"\nimport { ValueTransformer } from \"../decorator/options/ValueTransformer\"\nimport { ApplyValueTransformers } from \"../util/ApplyValueTransformers\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\nimport { VirtualColumnOptions } from \"../decorator/options/VirtualColumnOptions\"\n\n/**\n * This metadata contains all information about entity's column.\n */\nexport class ColumnMetadata {\n    readonly \"@instanceof\" = Symbol.for(\"ColumnMetadata\")\n\n    // ---------------------------------------------------------------------\n    // Public Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Target class where column decorator is used.\n     * This may not be always equal to entity metadata (for example embeds or inheritance cases).\n     */\n    target: Function | string\n\n    /**\n     * Entity metadata where this column metadata is.\n     *\n     * For example for @Column() name: string in Post, entityMetadata will be metadata of Post entity.\n     */\n    entityMetadata: EntityMetadata\n\n    /**\n     * Embedded metadata where this column metadata is.\n     * If this column is not in embed then this property value is undefined.\n     */\n    embeddedMetadata?: EmbeddedMetadata\n\n    /**\n     * If column is a foreign key of some relation then this relation's metadata will be there.\n     * If this column does not have a foreign key then this property value is undefined.\n     */\n    relationMetadata?: RelationMetadata\n\n    /**\n     * Class's property name on which this column is applied.\n     */\n    propertyName: string\n\n    /**\n     * The database type of the column.\n     */\n    type: ColumnType\n\n    /**\n     * Type's length in the database.\n     */\n    length: string = \"\"\n\n    /**\n     * Type's display width in the database.\n     */\n    width?: number\n\n    /**\n     * Defines column character set.\n     */\n    charset?: string\n\n    /**\n     * Defines column collation.\n     */\n    collation?: string\n\n    /**\n     * Indicates if this column is a primary key.\n     */\n    isPrimary: boolean = false\n\n    /**\n     * Indicates if this column is generated (auto increment or generated other way).\n     */\n    isGenerated: boolean = false\n\n    /**\n     * Indicates if column can contain nulls or not.\n     */\n    isNullable: boolean = false\n\n    /**\n     * Indicates if column is selected by query builder or not.\n     */\n    isSelect: boolean = true\n\n    /**\n     * Indicates if column is inserted by default or not.\n     */\n    isInsert: boolean = true\n\n    /**\n     * Indicates if column allows updates or not.\n     */\n    isUpdate: boolean = true\n\n    /**\n     * Specifies generation strategy if this column will use auto increment.\n     */\n    generationStrategy?: \"uuid\" | \"increment\" | \"rowid\"\n\n    /**\n     * Identity column type. Supports only in Postgres 10+.\n     */\n    generatedIdentity?: \"ALWAYS\" | \"BY DEFAULT\"\n\n    /**\n     * Column comment.\n     * This feature is not supported by all databases.\n     */\n    comment?: string\n\n    /**\n     * Default database value.\n     */\n    default?:\n        | number\n        | boolean\n        | string\n        | null\n        | (number | boolean | string)[]\n        | Record<string, object>\n        | (() => string)\n\n    /**\n     * ON UPDATE trigger. Works only for MySQL.\n     */\n    onUpdate?: string\n\n    /**\n     * The precision for a decimal (exact numeric) column (applies only for decimal column),\n     * which is the maximum number of digits that are stored for the values.\n     */\n    precision?: number | null\n\n    /**\n     * The scale for a decimal (exact numeric) column (applies only for decimal column),\n     * which represents the number of digits to the right of the decimal point and must not be greater than precision.\n     */\n    scale?: number\n\n    /**\n     * Puts ZEROFILL attribute on to numeric column. Works only for MySQL.\n     * If you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column\n     */\n    zerofill: boolean = false\n\n    /**\n     * Puts UNSIGNED attribute on to numeric column. Works only for MySQL.\n     */\n    unsigned: boolean = false\n\n    /**\n     * Array of possible enumerated values.\n     *\n     * `postgres` and `mysql` store enum values as strings but we want to keep support\n     * for numeric and heterogeneous based typescript enums, so we need (string|number)[]\n     */\n    enum?: (string | number)[]\n\n    /**\n     * Exact name of enum\n     */\n    enumName?: string\n\n    /**\n     * Generated column expression.\n     */\n    asExpression?: string\n\n    /**\n     * Generated column type.\n     */\n    generatedType?: \"VIRTUAL\" | \"STORED\"\n\n    /**\n     * Return type of HSTORE column.\n     * Returns value as string or as object.\n     */\n    hstoreType?: \"object\" | \"string\"\n\n    /**\n     * Indicates if this column is an array.\n     */\n    isArray: boolean = false\n\n    /**\n     * Gets full path to this column property (including column property name).\n     * Full path is relevant when column is used in embeds (one or multiple nested).\n     * For example it will return \"counters.subcounters.likes\".\n     * If property is not in embeds then it returns just property name of the column.\n     */\n    propertyPath: string\n\n    /**\n     * Same as property path, but dots are replaced with '_'.\n     * Used in query builder statements.\n     */\n    propertyAliasName: string\n\n    /**\n     * Gets full path to this column database name (including column database name).\n     * Full path is relevant when column is used in embeds (one or multiple nested).\n     * For example it will return \"counters.subcounters.likes\".\n     * If property is not in embeds then it returns just database name of the column.\n     */\n    databasePath: string\n\n    /**\n     * Complete column name in the database including its embedded prefixes.\n     */\n    databaseName: string\n\n    /**\n     * Database name in the database without embedded prefixes applied.\n     */\n    databaseNameWithoutPrefixes: string\n\n    /**\n     * Database name set by entity metadata builder, not yet passed naming strategy process and without embedded prefixes.\n     */\n    givenDatabaseName?: string\n\n    /**\n     * Indicates if column is virtual. Virtual columns are not mapped to the entity.\n     */\n    isVirtual: boolean = false\n\n    /**\n     * Indicates if column is a virtual property. Virtual properties are not mapped to the entity.\n     * This property is used in tandem the virtual column decorator.\n     * @See https://typeorm.io/decorator-reference#virtualcolumn for more details.\n     */\n    isVirtualProperty: boolean = false\n\n    /**\n     * Query to be used to populate the column data. This query is used when generating the relational db script.\n     * The query function is called with the current entities alias either defined by the Entity Decorator or automatically\n     * @See https://typeorm.io/decorator-reference#virtualcolumn for more details.\n     */\n    query?: (alias: string) => string\n\n    /**\n     * Indicates if column is discriminator. Discriminator columns are not mapped to the entity.\n     */\n    isDiscriminator: boolean = false\n\n    /**\n     * Indicates if column is tree-level column. Tree-level columns are used in closure entities.\n     */\n    isTreeLevel: boolean = false\n\n    /**\n     * Indicates if this column contains an entity creation date.\n     */\n    isCreateDate: boolean = false\n\n    /**\n     * Indicates if this column contains an entity update date.\n     */\n    isUpdateDate: boolean = false\n\n    /**\n     * Indicates if this column contains an entity delete date.\n     */\n    isDeleteDate: boolean = false\n\n    /**\n     * Indicates if this column contains an entity version.\n     */\n    isVersion: boolean = false\n\n    /**\n     * Indicates if this column contains an object id.\n     */\n    isObjectId: boolean = false\n\n    /**\n     * If this column is foreign key then it references some other column,\n     * and this property will contain reference to this column.\n     */\n    referencedColumn: ColumnMetadata | undefined\n\n    /**\n     * If this column is primary key then this specifies the name for it.\n     */\n    primaryKeyConstraintName?: string\n\n    /**\n     * If this column is foreign key then this specifies the name for it.\n     */\n    foreignKeyConstraintName?: string\n\n    /**\n     * Specifies a value transformer that is to be used to (un)marshal\n     * this column when reading or writing to the database.\n     */\n    transformer?: ValueTransformer | ValueTransformer[]\n\n    /**\n     * Column type in the case if this column is in the closure table.\n     * Column can be ancestor or descendant in the closure tables.\n     */\n    closureType?: \"ancestor\" | \"descendant\"\n\n    /**\n     * Indicates if this column is nested set's left column.\n     * Used only in tree entities with nested-set type.\n     */\n    isNestedSetLeft: boolean = false\n\n    /**\n     * Indicates if this column is nested set's right column.\n     * Used only in tree entities with nested-set type.\n     */\n    isNestedSetRight: boolean = false\n\n    /**\n     * Indicates if this column is materialized path's path column.\n     * Used only in tree entities with materialized path type.\n     */\n    isMaterializedPath: boolean = false\n\n    /**\n     * Spatial Feature Type (Geometry, Point, Polygon, etc.)\n     */\n    spatialFeatureType?: string\n\n    /**\n     * SRID (Spatial Reference ID (EPSG code))\n     */\n    srid?: number\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(options: {\n        connection: DataSource\n        entityMetadata: EntityMetadata\n        embeddedMetadata?: EmbeddedMetadata\n        referencedColumn?: ColumnMetadata\n        args: ColumnMetadataArgs\n        closureType?: \"ancestor\" | \"descendant\"\n        nestedSetLeft?: boolean\n        nestedSetRight?: boolean\n        materializedPath?: boolean\n    }) {\n        this.entityMetadata = options.entityMetadata\n        this.embeddedMetadata = options.embeddedMetadata!\n        this.referencedColumn = options.referencedColumn\n        if (options.args.target) this.target = options.args.target\n        if (options.args.propertyName)\n            this.propertyName = options.args.propertyName\n        if (options.args.options.name)\n            this.givenDatabaseName = options.args.options.name\n        if (options.args.options.type) this.type = options.args.options.type\n        if (options.args.options.length)\n            this.length = options.args.options.length\n                ? options.args.options.length.toString()\n                : \"\"\n        if (options.args.options.width) this.width = options.args.options.width\n        if (options.args.options.charset)\n            this.charset = options.args.options.charset\n        if (options.args.options.collation)\n            this.collation = options.args.options.collation\n        if (options.args.options.primary)\n            this.isPrimary = options.args.options.primary\n        if (options.args.options.default === null)\n            // to make sure default: null is the same as nullable: true\n            this.isNullable = true\n        if (options.args.options.nullable !== undefined)\n            this.isNullable = options.args.options.nullable\n        if (options.args.options.select !== undefined)\n            this.isSelect = options.args.options.select\n        if (options.args.options.insert !== undefined)\n            this.isInsert = options.args.options.insert\n        if (options.args.options.update !== undefined)\n            this.isUpdate = options.args.options.update\n        if (options.args.options.readonly !== undefined)\n            this.isUpdate = !options.args.options.readonly\n        if (options.args.options.comment)\n            this.comment = options.args.options.comment\n        if (options.args.options.default !== undefined)\n            this.default = options.args.options.default\n        if (options.args.options.onUpdate)\n            this.onUpdate = options.args.options.onUpdate\n        if (options.args.options.generatedIdentity)\n            this.generatedIdentity = options.args.options.generatedIdentity\n        if (\n            options.args.options.scale !== null &&\n            options.args.options.scale !== undefined\n        )\n            this.scale = options.args.options.scale\n        if (options.args.options.zerofill) {\n            this.zerofill = options.args.options.zerofill\n            this.unsigned = true // if you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column\n        }\n        if (options.args.options.unsigned)\n            this.unsigned = options.args.options.unsigned\n        if (options.args.options.precision !== null)\n            this.precision = options.args.options.precision\n        if (options.args.options.enum) {\n            if (\n                ObjectUtils.isObject(options.args.options.enum) &&\n                !Array.isArray(options.args.options.enum)\n            ) {\n                this.enum = Object.keys(options.args.options.enum)\n                    // remove numeric keys - typescript numeric enum types generate them\n                    // From the documentation: “declaration merging” means that the compiler merges two separate declarations\n                    // declared with the same name into a single definition. This concept is often used to merge enum with namespace\n                    // where in namespace we define e.g. utility methods for creating enum. This is well known in other languages\n                    // like Java (enum methods). Here in case if enum have function, we need to remove it from metadata, otherwise\n                    // generated SQL statements contains string representation of that function which leads into syntax error\n                    // at database side.\n                    .filter(\n                        (key) =>\n                            isNaN(+key) &&\n                            typeof (options.args.options.enum as ObjectLiteral)[\n                                key\n                            ] !== \"function\",\n                    )\n                    .map(\n                        (key) =>\n                            (options.args.options.enum as ObjectLiteral)[key],\n                    )\n            } else {\n                this.enum = options.args.options.enum\n            }\n        }\n        if (options.args.options.enumName) {\n            this.enumName = options.args.options.enumName\n        }\n        if (options.args.options.primaryKeyConstraintName) {\n            this.primaryKeyConstraintName =\n                options.args.options.primaryKeyConstraintName\n        }\n        if (options.args.options.foreignKeyConstraintName) {\n            this.foreignKeyConstraintName =\n                options.args.options.foreignKeyConstraintName\n        }\n        if (options.args.options.asExpression) {\n            this.asExpression = options.args.options.asExpression\n            this.generatedType = options.args.options.generatedType\n                ? options.args.options.generatedType\n                : \"VIRTUAL\"\n        }\n        if (options.args.options.hstoreType)\n            this.hstoreType = options.args.options.hstoreType\n        if (options.args.options.array)\n            this.isArray = options.args.options.array\n        if (options.args.mode) {\n            this.isVirtualProperty = options.args.mode === \"virtual-property\"\n            this.isVirtual = options.args.mode === \"virtual\"\n            this.isTreeLevel = options.args.mode === \"treeLevel\"\n            this.isCreateDate = options.args.mode === \"createDate\"\n            this.isUpdateDate = options.args.mode === \"updateDate\"\n            this.isDeleteDate = options.args.mode === \"deleteDate\"\n            this.isVersion = options.args.mode === \"version\"\n            this.isObjectId = options.args.mode === \"objectId\"\n        }\n        if (this.isVirtualProperty) {\n            this.isInsert = false\n            this.isUpdate = false\n        }\n        if (options.args.options.transformer)\n            this.transformer = options.args.options.transformer\n        if (options.args.options.spatialFeatureType)\n            this.spatialFeatureType = options.args.options.spatialFeatureType\n        if (options.args.options.srid !== undefined)\n            this.srid = options.args.options.srid\n        if ((options.args.options as VirtualColumnOptions).query)\n            this.query = (options.args.options as VirtualColumnOptions).query\n        if (this.isTreeLevel)\n            this.type = options.connection.driver.mappedDataTypes.treeLevel\n        if (this.isCreateDate) {\n            if (!this.type)\n                this.type = options.connection.driver.mappedDataTypes.createDate\n            if (!this.default)\n                this.default = () =>\n                    options.connection.driver.mappedDataTypes.createDateDefault\n            // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n            if (\n                this.precision === undefined &&\n                options.args.options.precision === undefined &&\n                options.connection.driver.mappedDataTypes.createDatePrecision\n            )\n                this.precision =\n                    options.connection.driver.mappedDataTypes.createDatePrecision\n        }\n        if (this.isUpdateDate) {\n            if (!this.type)\n                this.type = options.connection.driver.mappedDataTypes.updateDate\n            if (!this.default)\n                this.default = () =>\n                    options.connection.driver.mappedDataTypes.updateDateDefault\n            if (!this.onUpdate)\n                this.onUpdate =\n                    options.connection.driver.mappedDataTypes.updateDateDefault\n            // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n            if (\n                this.precision === undefined &&\n                options.args.options.precision === undefined &&\n                options.connection.driver.mappedDataTypes.updateDatePrecision\n            )\n                this.precision =\n                    options.connection.driver.mappedDataTypes.updateDatePrecision\n        }\n        if (this.isDeleteDate) {\n            if (!this.type)\n                this.type = options.connection.driver.mappedDataTypes.deleteDate\n            if (!this.isNullable)\n                this.isNullable =\n                    options.connection.driver.mappedDataTypes.deleteDateNullable\n            // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n            if (\n                this.precision === undefined &&\n                options.args.options.precision === undefined &&\n                options.connection.driver.mappedDataTypes.deleteDatePrecision\n            )\n                this.precision =\n                    options.connection.driver.mappedDataTypes.deleteDatePrecision\n        }\n        if (this.isVersion)\n            this.type = options.connection.driver.mappedDataTypes.version\n        if (options.closureType) this.closureType = options.closureType\n        if (options.nestedSetLeft) this.isNestedSetLeft = options.nestedSetLeft\n        if (options.nestedSetRight)\n            this.isNestedSetRight = options.nestedSetRight\n        if (options.materializedPath)\n            this.isMaterializedPath = options.materializedPath\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Creates entity id map from the given entity ids array.\n     */\n    createValueMap(value: any, useDatabaseName = false) {\n        // extract column value from embeds of entity if column is in embedded\n        if (this.embeddedMetadata) {\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object and return it in a\n            // { data: { information: { counters: { id: ... } } } } format\n\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames]\n\n            // now need to access post[data][information][counters] to get column value from the counters\n            // and on each step we need to create complex literal object, e.g. first { data },\n            // then { data: { information } }, then { data: { information: { counters } } },\n            // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n            // this recursive function helps doing that\n            const extractEmbeddedColumnValue = (\n                propertyNames: string[],\n                map: ObjectLiteral,\n            ): any => {\n                const propertyName = propertyNames.shift()\n                if (propertyName) {\n                    map[propertyName] = {}\n                    extractEmbeddedColumnValue(propertyNames, map[propertyName])\n                    return map\n                }\n\n                // this is bugfix for #720 when increment number is bigint we need to make sure its a string\n                if (\n                    (this.generationStrategy === \"increment\" ||\n                        this.generationStrategy === \"rowid\") &&\n                    this.type === \"bigint\" &&\n                    value !== null\n                )\n                    value = String(value)\n\n                map[useDatabaseName ? this.databaseName : this.propertyName] =\n                    value\n                return map\n            }\n            return extractEmbeddedColumnValue(propertyNames, {})\n        } else {\n            // no embeds - no problems. Simply return column property name and its value of the entity\n\n            // this is bugfix for #720 when increment number is bigint we need to make sure its a string\n            if (\n                (this.generationStrategy === \"increment\" ||\n                    this.generationStrategy === \"rowid\") &&\n                this.type === \"bigint\" &&\n                value !== null\n            )\n                value = String(value)\n\n            return {\n                [useDatabaseName ? this.databaseName : this.propertyName]:\n                    value,\n            }\n        }\n    }\n\n    /**\n     * Extracts column value and returns its column name with this value in a literal object.\n     * If column is in embedded (or recursive embedded) it returns complex literal object.\n     *\n     * Examples what this method can return depend if this column is in embeds.\n     * { id: 1 } or { title: \"hello\" }, { counters: { code: 1 } }, { data: { information: { counters: { code: 1 } } } }\n     */\n    getEntityValueMap(\n        entity: ObjectLiteral,\n        options?: { skipNulls?: boolean },\n    ): ObjectLiteral | undefined {\n        const returnNulls = false // options && options.skipNulls === false ? false : true; // todo: remove if current will not bring problems, uncomment if it will.\n\n        // extract column value from embeds of entity if column is in embedded\n        if (this.embeddedMetadata) {\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object and return it in a\n            // { data: { information: { counters: { id: ... } } } } format\n\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames]\n            const isEmbeddedArray = this.embeddedMetadata.isArray\n\n            // now need to access post[data][information][counters] to get column value from the counters\n            // and on each step we need to create complex literal object, e.g. first { data },\n            // then { data: { information } }, then { data: { information: { counters } } },\n            // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n            // this recursive function helps doing that\n            const extractEmbeddedColumnValue = (\n                propertyNames: string[],\n                value: ObjectLiteral,\n            ): ObjectLiteral => {\n                if (value === undefined) {\n                    return {}\n                }\n\n                const propertyName = propertyNames.shift()\n\n                if (propertyName) {\n                    const submap = extractEmbeddedColumnValue(\n                        propertyNames,\n                        value[propertyName],\n                    )\n                    if (Object.keys(submap).length > 0) {\n                        return { [propertyName]: submap }\n                    }\n                    return {}\n                }\n\n                if (isEmbeddedArray && Array.isArray(value)) {\n                    return value.map((v) => ({\n                        [this.propertyName]: v[this.propertyName],\n                    }))\n                }\n\n                if (\n                    value[this.propertyName] !== undefined &&\n                    (returnNulls === false || value[this.propertyName] !== null)\n                ) {\n                    return { [this.propertyName]: value[this.propertyName] }\n                }\n\n                return {}\n            }\n            const map = extractEmbeddedColumnValue(propertyNames, entity)\n\n            return Object.keys(map).length > 0 ? map : undefined\n        } else {\n            // no embeds - no problems. Simply return column property name and its value of the entity\n            /**\n             * Object.getOwnPropertyDescriptor checks if the relation is lazy, in which case value is a Promise\n             * DO NOT use `entity[\n                this.relationMetadata.propertyName] instanceof Promise`, which will invoke property getter and make unwanted DB request\n             * refer: https://github.com/typeorm/typeorm/pull/8676#issuecomment-1049906331\n             */\n            if (\n                this.relationMetadata &&\n                !Object.getOwnPropertyDescriptor(\n                    entity,\n                    this.relationMetadata.propertyName,\n                )?.get &&\n                entity[this.relationMetadata.propertyName] &&\n                ObjectUtils.isObject(entity[this.relationMetadata.propertyName])\n            ) {\n                const map = this.relationMetadata.joinColumns.reduce(\n                    (map, joinColumn) => {\n                        const value =\n                            joinColumn.referencedColumn!.getEntityValueMap(\n                                entity[this.relationMetadata!.propertyName],\n                            )\n                        if (value === undefined) return map\n                        return OrmUtils.mergeDeep(map, value)\n                    },\n                    {},\n                )\n                if (Object.keys(map).length > 0)\n                    return { [this.propertyName]: map }\n\n                return undefined\n            } else {\n                if (\n                    entity[this.propertyName] !== undefined &&\n                    (returnNulls === false ||\n                        entity[this.propertyName] !== null)\n                )\n                    return { [this.propertyName]: entity[this.propertyName] }\n\n                return undefined\n            }\n        }\n    }\n\n    /**\n     * Extracts column value from the given entity.\n     * If column is in embedded (or recursive embedded) it extracts its value from there.\n     */\n    getEntityValue(\n        entity: ObjectLiteral,\n        transform: boolean = false,\n    ): any | undefined {\n        if (entity === undefined || entity === null) return undefined\n\n        // extract column value from embeddeds of entity if column is in embedded\n        let value: any = undefined\n        if (this.embeddedMetadata) {\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object\n\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames]\n            const isEmbeddedArray = this.embeddedMetadata.isArray\n\n            // next we need to access post[data][information][counters][this.propertyName] to get column value from the counters\n            // this recursive function takes array of generated property names and gets the post[data][information][counters] embed\n            const extractEmbeddedColumnValue = (\n                propertyNames: string[],\n                value: ObjectLiteral,\n            ): any => {\n                const propertyName = propertyNames.shift()\n                return propertyName && value\n                    ? extractEmbeddedColumnValue(\n                          propertyNames,\n                          value[propertyName],\n                      )\n                    : value\n            }\n\n            // once we get nested embed object we get its column, e.g. post[data][information][counters][this.propertyName]\n            const embeddedObject = extractEmbeddedColumnValue(\n                propertyNames,\n                entity,\n            )\n            if (embeddedObject) {\n                if (this.relationMetadata && this.referencedColumn) {\n                    const relatedEntity =\n                        this.relationMetadata.getEntityValue(embeddedObject)\n                    if (\n                        relatedEntity &&\n                        ObjectUtils.isObject(relatedEntity) &&\n                        !InstanceChecker.isFindOperator(relatedEntity) &&\n                        !Buffer.isBuffer(relatedEntity)\n                    ) {\n                        value =\n                            this.referencedColumn.getEntityValue(relatedEntity)\n                    } else if (\n                        embeddedObject[this.propertyName] &&\n                        ObjectUtils.isObject(\n                            embeddedObject[this.propertyName],\n                        ) &&\n                        !InstanceChecker.isFindOperator(\n                            embeddedObject[this.propertyName],\n                        ) &&\n                        !Buffer.isBuffer(embeddedObject[this.propertyName]) &&\n                        !(embeddedObject[this.propertyName] instanceof Date)\n                    ) {\n                        value = this.referencedColumn.getEntityValue(\n                            embeddedObject[this.propertyName],\n                        )\n                    } else {\n                        value = embeddedObject[this.propertyName]\n                    }\n                } else if (this.referencedColumn) {\n                    value = this.referencedColumn.getEntityValue(\n                        embeddedObject[this.propertyName],\n                    )\n                } else if (isEmbeddedArray && Array.isArray(embeddedObject)) {\n                    value = embeddedObject.map((o) => o[this.propertyName])\n                } else {\n                    value = embeddedObject[this.propertyName]\n                }\n            }\n        } else {\n            // no embeds - no problems. Simply return column name by property name of the entity\n            if (this.relationMetadata && this.referencedColumn) {\n                const relatedEntity =\n                    this.relationMetadata.getEntityValue(entity)\n                if (\n                    relatedEntity &&\n                    ObjectUtils.isObject(relatedEntity) &&\n                    !InstanceChecker.isFindOperator(relatedEntity) &&\n                    !(typeof relatedEntity === \"function\") &&\n                    !Buffer.isBuffer(relatedEntity)\n                ) {\n                    value = this.referencedColumn.getEntityValue(relatedEntity)\n                } else if (\n                    entity[this.propertyName] &&\n                    ObjectUtils.isObject(entity[this.propertyName]) &&\n                    !InstanceChecker.isFindOperator(\n                        entity[this.propertyName],\n                    ) &&\n                    !(typeof entity[this.propertyName] === \"function\") &&\n                    !Buffer.isBuffer(entity[this.propertyName]) &&\n                    !(entity[this.propertyName] instanceof Date)\n                ) {\n                    value = this.referencedColumn.getEntityValue(\n                        entity[this.propertyName],\n                    )\n                } else {\n                    value = entity[this.propertyName]\n                }\n            } else if (this.referencedColumn) {\n                value = this.referencedColumn.getEntityValue(\n                    entity[this.propertyName],\n                )\n            } else {\n                value = entity[this.propertyName]\n            }\n        }\n\n        if (transform && this.transformer)\n            value = ApplyValueTransformers.transformTo(this.transformer, value)\n\n        return value\n    }\n\n    /**\n     * Sets given entity's column value.\n     * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.\n     */\n    setEntityValue(entity: ObjectLiteral, value: any): void {\n        if (this.embeddedMetadata) {\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const extractEmbeddedColumnValue = (\n                embeddedMetadatas: EmbeddedMetadata[],\n                map: ObjectLiteral,\n            ): any => {\n                // if (!object[embeddedMetadata.propertyName])\n                //     object[embeddedMetadata.propertyName] = embeddedMetadata.create();\n\n                const embeddedMetadata = embeddedMetadatas.shift()\n                if (embeddedMetadata) {\n                    if (!map[embeddedMetadata.propertyName])\n                        map[embeddedMetadata.propertyName] =\n                            embeddedMetadata.create()\n\n                    extractEmbeddedColumnValue(\n                        embeddedMetadatas,\n                        map[embeddedMetadata.propertyName],\n                    )\n                    return map\n                }\n                map[this.propertyName] = value\n                return map\n            }\n            return extractEmbeddedColumnValue(\n                [...this.embeddedMetadata.embeddedMetadataTree],\n                entity,\n            )\n        } else {\n            // we write a deep object in this entity only if the column is virtual\n            // because if its not virtual it means the user defined a real column for this relation\n            // also we don't do it if column is inside a junction table\n            if (\n                !this.entityMetadata.isJunction &&\n                this.isVirtual &&\n                this.referencedColumn &&\n                this.referencedColumn.propertyName !== this.propertyName\n            ) {\n                if (!(this.propertyName in entity)) {\n                    entity[this.propertyName] = {}\n                }\n\n                entity[this.propertyName][this.referencedColumn.propertyName] =\n                    value\n            } else {\n                entity[this.propertyName] = value\n            }\n        }\n    }\n\n    /**\n     * Compares given entity's column value with a given value.\n     */\n    compareEntityValue(entity: any, valueToCompareWith: any) {\n        const columnValue = this.getEntityValue(entity)\n        if (ObjectUtils.isObject(columnValue)) {\n            return columnValue.equals(valueToCompareWith)\n        }\n        return columnValue === valueToCompareWith\n    }\n\n    // ---------------------------------------------------------------------\n    // Builder Methods\n    // ---------------------------------------------------------------------\n\n    build(connection: DataSource): this {\n        this.propertyPath = this.buildPropertyPath()\n        this.propertyAliasName = this.propertyPath.replace(\".\", \"_\")\n        this.databaseName = this.buildDatabaseName(connection)\n        this.databasePath = this.buildDatabasePath()\n        this.databaseNameWithoutPrefixes = connection.namingStrategy.columnName(\n            this.propertyName,\n            this.givenDatabaseName,\n            [],\n        )\n        return this\n    }\n\n    protected buildPropertyPath(): string {\n        let path = \"\"\n        if (\n            this.embeddedMetadata &&\n            this.embeddedMetadata.parentPropertyNames.length\n        )\n            path = this.embeddedMetadata.parentPropertyNames.join(\".\") + \".\"\n\n        path += this.propertyName\n\n        // we add reference column to property path only if this column is virtual\n        // because if its not virtual it means user defined a real column for this relation\n        // also we don't do it if column is inside a junction table\n        if (\n            !this.entityMetadata.isJunction &&\n            this.isVirtual &&\n            this.referencedColumn &&\n            this.referencedColumn.propertyName !== this.propertyName\n        )\n            path += \".\" + this.referencedColumn.propertyName\n\n        return path\n    }\n\n    protected buildDatabasePath(): string {\n        let path = \"\"\n        if (\n            this.embeddedMetadata &&\n            this.embeddedMetadata.parentPropertyNames.length\n        )\n            path = this.embeddedMetadata.parentPropertyNames.join(\".\") + \".\"\n\n        path += this.databaseName\n\n        // we add reference column to property path only if this column is virtual\n        // because if its not virtual it means user defined a real column for this relation\n        // also we don't do it if column is inside a junction table\n        if (\n            !this.entityMetadata.isJunction &&\n            this.isVirtual &&\n            this.referencedColumn &&\n            this.referencedColumn.databaseName !== this.databaseName\n        )\n            path += \".\" + this.referencedColumn.databaseName\n\n        return path\n    }\n\n    protected buildDatabaseName(connection: DataSource): string {\n        let propertyNames = this.embeddedMetadata\n            ? this.embeddedMetadata.parentPrefixes\n            : []\n        if (connection.driver.options.type === \"mongodb\")\n            // we don't need to include embedded name for the mongodb column names\n            propertyNames = []\n        return connection.namingStrategy.columnName(\n            this.propertyName,\n            this.givenDatabaseName,\n            propertyNames,\n        )\n    }\n}\n"],"mappings":"AAOA,SAASA,QAAQ,QAAQ,kBAAkB;AAE3C,SAASC,sBAAsB,QAAQ,gCAAgC;AACvE,SAASC,WAAW,QAAQ,qBAAqB;AACjD,SAASC,eAAe,QAAQ,yBAAyB;AAGzD;;;AAGA,OAAM,MAAOC,cAAc;EAyUvB;EACA;EACA;EAEAC,YAAYC,OAUX;IAtVQ,mBAAa,GAAGC,MAAM,CAACC,GAAG,CAAC,gBAAgB,CAAC;IAyCrD;;;IAGA,KAAAC,MAAM,GAAW,EAAE;IAiBnB;;;IAGA,KAAAC,SAAS,GAAY,KAAK;IAE1B;;;IAGA,KAAAC,WAAW,GAAY,KAAK;IAE5B;;;IAGA,KAAAC,UAAU,GAAY,KAAK;IAE3B;;;IAGA,KAAAC,QAAQ,GAAY,IAAI;IAExB;;;IAGA,KAAAC,QAAQ,GAAY,IAAI;IAExB;;;IAGA,KAAAC,QAAQ,GAAY,IAAI;IA+CxB;;;;IAIA,KAAAC,QAAQ,GAAY,KAAK;IAEzB;;;IAGA,KAAAC,QAAQ,GAAY,KAAK;IA+BzB;;;IAGA,KAAAC,OAAO,GAAY,KAAK;IAuCxB;;;IAGA,KAAAC,SAAS,GAAY,KAAK;IAE1B;;;;;IAKA,KAAAC,iBAAiB,GAAY,KAAK;IASlC;;;IAGA,KAAAC,eAAe,GAAY,KAAK;IAEhC;;;IAGA,KAAAC,WAAW,GAAY,KAAK;IAE5B;;;IAGA,KAAAC,YAAY,GAAY,KAAK;IAE7B;;;IAGA,KAAAC,YAAY,GAAY,KAAK;IAE7B;;;IAGA,KAAAC,YAAY,GAAY,KAAK;IAE7B;;;IAGA,KAAAC,SAAS,GAAY,KAAK;IAE1B;;;IAGA,KAAAC,UAAU,GAAY,KAAK;IA8B3B;;;;IAIA,KAAAC,eAAe,GAAY,KAAK;IAEhC;;;;IAIA,KAAAC,gBAAgB,GAAY,KAAK;IAEjC;;;;IAIA,KAAAC,kBAAkB,GAAY,KAAK;IA2B/B,IAAI,CAACC,cAAc,GAAGzB,OAAO,CAACyB,cAAc;IAC5C,IAAI,CAACC,gBAAgB,GAAG1B,OAAO,CAAC0B,gBAAiB;IACjD,IAAI,CAACC,gBAAgB,GAAG3B,OAAO,CAAC2B,gBAAgB;IAChD,IAAI3B,OAAO,CAAC4B,IAAI,CAACC,MAAM,EAAE,IAAI,CAACA,MAAM,GAAG7B,OAAO,CAAC4B,IAAI,CAACC,MAAM;IAC1D,IAAI7B,OAAO,CAAC4B,IAAI,CAACE,YAAY,EACzB,IAAI,CAACA,YAAY,GAAG9B,OAAO,CAAC4B,IAAI,CAACE,YAAY;IACjD,IAAI9B,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAAC+B,IAAI,EACzB,IAAI,CAACC,iBAAiB,GAAGhC,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAAC+B,IAAI;IACtD,IAAI/B,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACiC,IAAI,EAAE,IAAI,CAACA,IAAI,GAAGjC,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACiC,IAAI;IACpE,IAAIjC,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACG,MAAM,EAC3B,IAAI,CAACA,MAAM,GAAGH,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACG,MAAM,GACnCH,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACG,MAAM,CAAC+B,QAAQ,EAAE,GACtC,EAAE;IACZ,IAAIlC,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACmC,KAAK,EAAE,IAAI,CAACA,KAAK,GAAGnC,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACmC,KAAK;IACvE,IAAInC,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACoC,OAAO,EAC5B,IAAI,CAACA,OAAO,GAAGpC,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACoC,OAAO;IAC/C,IAAIpC,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACqC,SAAS,EAC9B,IAAI,CAACA,SAAS,GAAGrC,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACqC,SAAS;IACnD,IAAIrC,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACsC,OAAO,EAC5B,IAAI,CAAClC,SAAS,GAAGJ,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACsC,OAAO;IACjD,IAAItC,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACuC,OAAO,KAAK,IAAI;MACrC;MACA,IAAI,CAACjC,UAAU,GAAG,IAAI;IAC1B,IAAIN,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACwC,QAAQ,KAAKC,SAAS,EAC3C,IAAI,CAACnC,UAAU,GAAGN,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACwC,QAAQ;IACnD,IAAIxC,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAAC0C,MAAM,KAAKD,SAAS,EACzC,IAAI,CAAClC,QAAQ,GAAGP,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAAC0C,MAAM;IAC/C,IAAI1C,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAAC2C,MAAM,KAAKF,SAAS,EACzC,IAAI,CAACjC,QAAQ,GAAGR,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAAC2C,MAAM;IAC/C,IAAI3C,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAAC4C,MAAM,KAAKH,SAAS,EACzC,IAAI,CAAChC,QAAQ,GAAGT,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAAC4C,MAAM;IAC/C,IAAI5C,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAAC6C,QAAQ,KAAKJ,SAAS,EAC3C,IAAI,CAAChC,QAAQ,GAAG,CAACT,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAAC6C,QAAQ;IAClD,IAAI7C,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAAC8C,OAAO,EAC5B,IAAI,CAACA,OAAO,GAAG9C,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAAC8C,OAAO;IAC/C,IAAI9C,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACuC,OAAO,KAAKE,SAAS,EAC1C,IAAI,CAACF,OAAO,GAAGvC,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACuC,OAAO;IAC/C,IAAIvC,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAAC+C,QAAQ,EAC7B,IAAI,CAACA,QAAQ,GAAG/C,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAAC+C,QAAQ;IACjD,IAAI/C,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACgD,iBAAiB,EACtC,IAAI,CAACA,iBAAiB,GAAGhD,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACgD,iBAAiB;IACnE,IACIhD,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACiD,KAAK,KAAK,IAAI,IACnCjD,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACiD,KAAK,KAAKR,SAAS,EAExC,IAAI,CAACQ,KAAK,GAAGjD,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACiD,KAAK;IAC3C,IAAIjD,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACU,QAAQ,EAAE;MAC/B,IAAI,CAACA,QAAQ,GAAGV,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACU,QAAQ;MAC7C,IAAI,CAACC,QAAQ,GAAG,IAAI,EAAC;IACzB;IACA,IAAIX,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACW,QAAQ,EAC7B,IAAI,CAACA,QAAQ,GAAGX,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACW,QAAQ;IACjD,IAAIX,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACkD,SAAS,KAAK,IAAI,EACvC,IAAI,CAACA,SAAS,GAAGlD,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACkD,SAAS;IACnD,IAAIlD,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACmD,IAAI,EAAE;MAC3B,IACIvD,WAAW,CAACwD,QAAQ,CAACpD,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACmD,IAAI,CAAC,IAC/C,CAACE,KAAK,CAACzC,OAAO,CAACZ,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACmD,IAAI,CAAC,EAC3C;QACE,IAAI,CAACA,IAAI,GAAGG,MAAM,CAACC,IAAI,CAACvD,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACmD,IAAI;QAC7C;QACA;QACA;QACA;QACA;QACA;QACA;QAAA,CACCK,MAAM,CACFC,GAAG,IACAC,KAAK,CAAC,CAACD,GAAG,CAAC,IACX,OAAQzD,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACmD,IAAsB,CAC/CM,GAAG,CACN,KAAK,UAAU,CACvB,CACAE,GAAG,CACCF,GAAG,IACCzD,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACmD,IAAsB,CAACM,GAAG,CAAC,CACxD;MACT,CAAC,MAAM;QACH,IAAI,CAACN,IAAI,GAAGnD,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACmD,IAAI;MACzC;IACJ;IACA,IAAInD,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAAC4D,QAAQ,EAAE;MAC/B,IAAI,CAACA,QAAQ,GAAG5D,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAAC4D,QAAQ;IACjD;IACA,IAAI5D,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAAC6D,wBAAwB,EAAE;MAC/C,IAAI,CAACA,wBAAwB,GACzB7D,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAAC6D,wBAAwB;IACrD;IACA,IAAI7D,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAAC8D,wBAAwB,EAAE;MAC/C,IAAI,CAACA,wBAAwB,GACzB9D,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAAC8D,wBAAwB;IACrD;IACA,IAAI9D,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAAC+D,YAAY,EAAE;MACnC,IAAI,CAACA,YAAY,GAAG/D,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAAC+D,YAAY;MACrD,IAAI,CAACC,aAAa,GAAGhE,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACgE,aAAa,GACjDhE,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACgE,aAAa,GAClC,SAAS;IACnB;IACA,IAAIhE,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACiE,UAAU,EAC/B,IAAI,CAACA,UAAU,GAAGjE,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACiE,UAAU;IACrD,IAAIjE,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACkE,KAAK,EAC1B,IAAI,CAACtD,OAAO,GAAGZ,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACkE,KAAK;IAC7C,IAAIlE,OAAO,CAAC4B,IAAI,CAACuC,IAAI,EAAE;MACnB,IAAI,CAACrD,iBAAiB,GAAGd,OAAO,CAAC4B,IAAI,CAACuC,IAAI,KAAK,kBAAkB;MACjE,IAAI,CAACtD,SAAS,GAAGb,OAAO,CAAC4B,IAAI,CAACuC,IAAI,KAAK,SAAS;MAChD,IAAI,CAACnD,WAAW,GAAGhB,OAAO,CAAC4B,IAAI,CAACuC,IAAI,KAAK,WAAW;MACpD,IAAI,CAAClD,YAAY,GAAGjB,OAAO,CAAC4B,IAAI,CAACuC,IAAI,KAAK,YAAY;MACtD,IAAI,CAACjD,YAAY,GAAGlB,OAAO,CAAC4B,IAAI,CAACuC,IAAI,KAAK,YAAY;MACtD,IAAI,CAAChD,YAAY,GAAGnB,OAAO,CAAC4B,IAAI,CAACuC,IAAI,KAAK,YAAY;MACtD,IAAI,CAAC/C,SAAS,GAAGpB,OAAO,CAAC4B,IAAI,CAACuC,IAAI,KAAK,SAAS;MAChD,IAAI,CAAC9C,UAAU,GAAGrB,OAAO,CAAC4B,IAAI,CAACuC,IAAI,KAAK,UAAU;IACtD;IACA,IAAI,IAAI,CAACrD,iBAAiB,EAAE;MACxB,IAAI,CAACN,QAAQ,GAAG,KAAK;MACrB,IAAI,CAACC,QAAQ,GAAG,KAAK;IACzB;IACA,IAAIT,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACoE,WAAW,EAChC,IAAI,CAACA,WAAW,GAAGpE,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACoE,WAAW;IACvD,IAAIpE,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACqE,kBAAkB,EACvC,IAAI,CAACA,kBAAkB,GAAGrE,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACqE,kBAAkB;IACrE,IAAIrE,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACsE,IAAI,KAAK7B,SAAS,EACvC,IAAI,CAAC6B,IAAI,GAAGtE,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACsE,IAAI;IACzC,IAAKtE,OAAO,CAAC4B,IAAI,CAAC5B,OAAgC,CAACuE,KAAK,EACpD,IAAI,CAACA,KAAK,GAAIvE,OAAO,CAAC4B,IAAI,CAAC5B,OAAgC,CAACuE,KAAK;IACrE,IAAI,IAAI,CAACvD,WAAW,EAChB,IAAI,CAACiB,IAAI,GAAGjC,OAAO,CAACwE,UAAU,CAACC,MAAM,CAACC,eAAe,CAACC,SAAS;IACnE,IAAI,IAAI,CAAC1D,YAAY,EAAE;MACnB,IAAI,CAAC,IAAI,CAACgB,IAAI,EACV,IAAI,CAACA,IAAI,GAAGjC,OAAO,CAACwE,UAAU,CAACC,MAAM,CAACC,eAAe,CAACE,UAAU;MACpE,IAAI,CAAC,IAAI,CAACrC,OAAO,EACb,IAAI,CAACA,OAAO,GAAG,MACXvC,OAAO,CAACwE,UAAU,CAACC,MAAM,CAACC,eAAe,CAACG,iBAAiB;MACnE;MACA,IACI,IAAI,CAAC3B,SAAS,KAAKT,SAAS,IAC5BzC,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACkD,SAAS,KAAKT,SAAS,IAC5CzC,OAAO,CAACwE,UAAU,CAACC,MAAM,CAACC,eAAe,CAACI,mBAAmB,EAE7D,IAAI,CAAC5B,SAAS,GACVlD,OAAO,CAACwE,UAAU,CAACC,MAAM,CAACC,eAAe,CAACI,mBAAmB;IACzE;IACA,IAAI,IAAI,CAAC5D,YAAY,EAAE;MACnB,IAAI,CAAC,IAAI,CAACe,IAAI,EACV,IAAI,CAACA,IAAI,GAAGjC,OAAO,CAACwE,UAAU,CAACC,MAAM,CAACC,eAAe,CAACK,UAAU;MACpE,IAAI,CAAC,IAAI,CAACxC,OAAO,EACb,IAAI,CAACA,OAAO,GAAG,MACXvC,OAAO,CAACwE,UAAU,CAACC,MAAM,CAACC,eAAe,CAACM,iBAAiB;MACnE,IAAI,CAAC,IAAI,CAACjC,QAAQ,EACd,IAAI,CAACA,QAAQ,GACT/C,OAAO,CAACwE,UAAU,CAACC,MAAM,CAACC,eAAe,CAACM,iBAAiB;MACnE;MACA,IACI,IAAI,CAAC9B,SAAS,KAAKT,SAAS,IAC5BzC,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACkD,SAAS,KAAKT,SAAS,IAC5CzC,OAAO,CAACwE,UAAU,CAACC,MAAM,CAACC,eAAe,CAACO,mBAAmB,EAE7D,IAAI,CAAC/B,SAAS,GACVlD,OAAO,CAACwE,UAAU,CAACC,MAAM,CAACC,eAAe,CAACO,mBAAmB;IACzE;IACA,IAAI,IAAI,CAAC9D,YAAY,EAAE;MACnB,IAAI,CAAC,IAAI,CAACc,IAAI,EACV,IAAI,CAACA,IAAI,GAAGjC,OAAO,CAACwE,UAAU,CAACC,MAAM,CAACC,eAAe,CAACQ,UAAU;MACpE,IAAI,CAAC,IAAI,CAAC5E,UAAU,EAChB,IAAI,CAACA,UAAU,GACXN,OAAO,CAACwE,UAAU,CAACC,MAAM,CAACC,eAAe,CAACS,kBAAkB;MACpE;MACA,IACI,IAAI,CAACjC,SAAS,KAAKT,SAAS,IAC5BzC,OAAO,CAAC4B,IAAI,CAAC5B,OAAO,CAACkD,SAAS,KAAKT,SAAS,IAC5CzC,OAAO,CAACwE,UAAU,CAACC,MAAM,CAACC,eAAe,CAACU,mBAAmB,EAE7D,IAAI,CAAClC,SAAS,GACVlD,OAAO,CAACwE,UAAU,CAACC,MAAM,CAACC,eAAe,CAACU,mBAAmB;IACzE;IACA,IAAI,IAAI,CAAChE,SAAS,EACd,IAAI,CAACa,IAAI,GAAGjC,OAAO,CAACwE,UAAU,CAACC,MAAM,CAACC,eAAe,CAACW,OAAO;IACjE,IAAIrF,OAAO,CAACsF,WAAW,EAAE,IAAI,CAACA,WAAW,GAAGtF,OAAO,CAACsF,WAAW;IAC/D,IAAItF,OAAO,CAACuF,aAAa,EAAE,IAAI,CAACjE,eAAe,GAAGtB,OAAO,CAACuF,aAAa;IACvE,IAAIvF,OAAO,CAACwF,cAAc,EACtB,IAAI,CAACjE,gBAAgB,GAAGvB,OAAO,CAACwF,cAAc;IAClD,IAAIxF,OAAO,CAACyF,gBAAgB,EACxB,IAAI,CAACjE,kBAAkB,GAAGxB,OAAO,CAACyF,gBAAgB;EAC1D;EAEA;EACA;EACA;EAEA;;;EAGAC,cAAcA,CAACC,KAAU,EAAEC,eAAe,GAAG,KAAK;IAC9C;IACA,IAAI,IAAI,CAAClE,gBAAgB,EAAE;MACvB;MACA;MACA;MAEA;MACA,MAAMmE,aAAa,GAAG,CAAC,GAAG,IAAI,CAACnE,gBAAgB,CAACoE,mBAAmB,CAAC;MAEpE;MACA;MACA;MACA;MACA;MACA,MAAMC,0BAA0B,GAAGA,CAC/BF,aAAuB,EACvBlC,GAAkB,KACb;QACL,MAAM7B,YAAY,GAAG+D,aAAa,CAACG,KAAK,EAAE;QAC1C,IAAIlE,YAAY,EAAE;UACd6B,GAAG,CAAC7B,YAAY,CAAC,GAAG,EAAE;UACtBiE,0BAA0B,CAACF,aAAa,EAAElC,GAAG,CAAC7B,YAAY,CAAC,CAAC;UAC5D,OAAO6B,GAAG;QACd;QAEA;QACA,IACI,CAAC,IAAI,CAACsC,kBAAkB,KAAK,WAAW,IACpC,IAAI,CAACA,kBAAkB,KAAK,OAAO,KACvC,IAAI,CAAChE,IAAI,KAAK,QAAQ,IACtB0D,KAAK,KAAK,IAAI,EAEdA,KAAK,GAAGO,MAAM,CAACP,KAAK,CAAC;QAEzBhC,GAAG,CAACiC,eAAe,GAAG,IAAI,CAACO,YAAY,GAAG,IAAI,CAACrE,YAAY,CAAC,GACxD6D,KAAK;QACT,OAAOhC,GAAG;MACd,CAAC;MACD,OAAOoC,0BAA0B,CAACF,aAAa,EAAE,EAAE,CAAC;IACxD,CAAC,MAAM;MACH;MAEA;MACA,IACI,CAAC,IAAI,CAACI,kBAAkB,KAAK,WAAW,IACpC,IAAI,CAACA,kBAAkB,KAAK,OAAO,KACvC,IAAI,CAAChE,IAAI,KAAK,QAAQ,IACtB0D,KAAK,KAAK,IAAI,EAEdA,KAAK,GAAGO,MAAM,CAACP,KAAK,CAAC;MAEzB,OAAO;QACH,CAACC,eAAe,GAAG,IAAI,CAACO,YAAY,GAAG,IAAI,CAACrE,YAAY,GACpD6D;OACP;IACL;EACJ;EAEA;;;;;;;EAOAS,iBAAiBA,CACbC,MAAqB,EACrBrG,OAAiC;IAEjC,MAAMsG,WAAW,GAAG,KAAK,EAAC;IAE1B;IACA,IAAI,IAAI,CAAC5E,gBAAgB,EAAE;MACvB;MACA;MACA;MAEA;MACA,MAAMmE,aAAa,GAAG,CAAC,GAAG,IAAI,CAACnE,gBAAgB,CAACoE,mBAAmB,CAAC;MACpE,MAAMS,eAAe,GAAG,IAAI,CAAC7E,gBAAgB,CAACd,OAAO;MAErD;MACA;MACA;MACA;MACA;MACA,MAAMmF,0BAA0B,GAAGA,CAC/BF,aAAuB,EACvBF,KAAoB,KACL;QACf,IAAIA,KAAK,KAAKlD,SAAS,EAAE;UACrB,OAAO,EAAE;QACb;QAEA,MAAMX,YAAY,GAAG+D,aAAa,CAACG,KAAK,EAAE;QAE1C,IAAIlE,YAAY,EAAE;UACd,MAAM0E,MAAM,GAAGT,0BAA0B,CACrCF,aAAa,EACbF,KAAK,CAAC7D,YAAY,CAAC,CACtB;UACD,IAAIwB,MAAM,CAACC,IAAI,CAACiD,MAAM,CAAC,CAACrG,MAAM,GAAG,CAAC,EAAE;YAChC,OAAO;cAAE,CAAC2B,YAAY,GAAG0E;YAAM,CAAE;UACrC;UACA,OAAO,EAAE;QACb;QAEA,IAAID,eAAe,IAAIlD,KAAK,CAACzC,OAAO,CAAC+E,KAAK,CAAC,EAAE;UACzC,OAAOA,KAAK,CAAChC,GAAG,CAAE8C,CAAC,KAAM;YACrB,CAAC,IAAI,CAAC3E,YAAY,GAAG2E,CAAC,CAAC,IAAI,CAAC3E,YAAY;WAC3C,CAAC,CAAC;QACP;QAEA,IACI6D,KAAK,CAAC,IAAI,CAAC7D,YAAY,CAAC,KAAKW,SAAS,KACrC6D,WAAW,KAAK,KAAK,IAAIX,KAAK,CAAC,IAAI,CAAC7D,YAAY,CAAC,KAAK,IAAI,CAAC,EAC9D;UACE,OAAO;YAAE,CAAC,IAAI,CAACA,YAAY,GAAG6D,KAAK,CAAC,IAAI,CAAC7D,YAAY;UAAC,CAAE;QAC5D;QAEA,OAAO,EAAE;MACb,CAAC;MACD,MAAM6B,GAAG,GAAGoC,0BAA0B,CAACF,aAAa,EAAEQ,MAAM,CAAC;MAE7D,OAAO/C,MAAM,CAACC,IAAI,CAACI,GAAG,CAAC,CAACxD,MAAM,GAAG,CAAC,GAAGwD,GAAG,GAAGlB,SAAS;IACxD,CAAC,MAAM;MACH;MACA;;;;;;MAMA,IACI,IAAI,CAACiE,gBAAgB,IACrB,CAACpD,MAAM,CAACqD,wBAAwB,CAC5BN,MAAM,EACN,IAAI,CAACK,gBAAgB,CAAC5E,YAAY,CACrC,EAAE8E,GAAG,IACNP,MAAM,CAAC,IAAI,CAACK,gBAAgB,CAAC5E,YAAY,CAAC,IAC1ClC,WAAW,CAACwD,QAAQ,CAACiD,MAAM,CAAC,IAAI,CAACK,gBAAgB,CAAC5E,YAAY,CAAC,CAAC,EAClE;QACE,MAAM6B,GAAG,GAAG,IAAI,CAAC+C,gBAAgB,CAACG,WAAW,CAACC,MAAM,CAChD,CAACnD,GAAG,EAAEoD,UAAU,KAAI;UAChB,MAAMpB,KAAK,GACPoB,UAAU,CAACpF,gBAAiB,CAACyE,iBAAiB,CAC1CC,MAAM,CAAC,IAAI,CAACK,gBAAiB,CAAC5E,YAAY,CAAC,CAC9C;UACL,IAAI6D,KAAK,KAAKlD,SAAS,EAAE,OAAOkB,GAAG;UACnC,OAAOjE,QAAQ,CAACsH,SAAS,CAACrD,GAAG,EAAEgC,KAAK,CAAC;QACzC,CAAC,EACD,EAAE,CACL;QACD,IAAIrC,MAAM,CAACC,IAAI,CAACI,GAAG,CAAC,CAACxD,MAAM,GAAG,CAAC,EAC3B,OAAO;UAAE,CAAC,IAAI,CAAC2B,YAAY,GAAG6B;QAAG,CAAE;QAEvC,OAAOlB,SAAS;MACpB,CAAC,MAAM;QACH,IACI4D,MAAM,CAAC,IAAI,CAACvE,YAAY,CAAC,KAAKW,SAAS,KACtC6D,WAAW,KAAK,KAAK,IAClBD,MAAM,CAAC,IAAI,CAACvE,YAAY,CAAC,KAAK,IAAI,CAAC,EAEvC,OAAO;UAAE,CAAC,IAAI,CAACA,YAAY,GAAGuE,MAAM,CAAC,IAAI,CAACvE,YAAY;QAAC,CAAE;QAE7D,OAAOW,SAAS;MACpB;IACJ;EACJ;EAEA;;;;EAIAwE,cAAcA,CACVZ,MAAqB,EACrBa,SAAA,GAAqB,KAAK;IAE1B,IAAIb,MAAM,KAAK5D,SAAS,IAAI4D,MAAM,KAAK,IAAI,EAAE,OAAO5D,SAAS;IAE7D;IACA,IAAIkD,KAAK,GAAQlD,SAAS;IAC1B,IAAI,IAAI,CAACf,gBAAgB,EAAE;MACvB;MACA;MAEA;MACA,MAAMmE,aAAa,GAAG,CAAC,GAAG,IAAI,CAACnE,gBAAgB,CAACoE,mBAAmB,CAAC;MACpE,MAAMS,eAAe,GAAG,IAAI,CAAC7E,gBAAgB,CAACd,OAAO;MAErD;MACA;MACA,MAAMmF,0BAA0B,GAAGA,CAC/BF,aAAuB,EACvBF,KAAoB,KACf;QACL,MAAM7D,YAAY,GAAG+D,aAAa,CAACG,KAAK,EAAE;QAC1C,OAAOlE,YAAY,IAAI6D,KAAK,GACtBI,0BAA0B,CACtBF,aAAa,EACbF,KAAK,CAAC7D,YAAY,CAAC,CACtB,GACD6D,KAAK;MACf,CAAC;MAED;MACA,MAAMwB,cAAc,GAAGpB,0BAA0B,CAC7CF,aAAa,EACbQ,MAAM,CACT;MACD,IAAIc,cAAc,EAAE;QAChB,IAAI,IAAI,CAACT,gBAAgB,IAAI,IAAI,CAAC/E,gBAAgB,EAAE;UAChD,MAAMyF,aAAa,GACf,IAAI,CAACV,gBAAgB,CAACO,cAAc,CAACE,cAAc,CAAC;UACxD,IACIC,aAAa,IACbxH,WAAW,CAACwD,QAAQ,CAACgE,aAAa,CAAC,IACnC,CAACvH,eAAe,CAACwH,cAAc,CAACD,aAAa,CAAC,IAC9C,CAACE,MAAM,CAACC,QAAQ,CAACH,aAAa,CAAC,EACjC;YACEzB,KAAK,GACD,IAAI,CAAChE,gBAAgB,CAACsF,cAAc,CAACG,aAAa,CAAC;UAC3D,CAAC,MAAM,IACHD,cAAc,CAAC,IAAI,CAACrF,YAAY,CAAC,IACjClC,WAAW,CAACwD,QAAQ,CAChB+D,cAAc,CAAC,IAAI,CAACrF,YAAY,CAAC,CACpC,IACD,CAACjC,eAAe,CAACwH,cAAc,CAC3BF,cAAc,CAAC,IAAI,CAACrF,YAAY,CAAC,CACpC,IACD,CAACwF,MAAM,CAACC,QAAQ,CAACJ,cAAc,CAAC,IAAI,CAACrF,YAAY,CAAC,CAAC,IACnD,EAAEqF,cAAc,CAAC,IAAI,CAACrF,YAAY,CAAC,YAAY0F,IAAI,CAAC,EACtD;YACE7B,KAAK,GAAG,IAAI,CAAChE,gBAAgB,CAACsF,cAAc,CACxCE,cAAc,CAAC,IAAI,CAACrF,YAAY,CAAC,CACpC;UACL,CAAC,MAAM;YACH6D,KAAK,GAAGwB,cAAc,CAAC,IAAI,CAACrF,YAAY,CAAC;UAC7C;QACJ,CAAC,MAAM,IAAI,IAAI,CAACH,gBAAgB,EAAE;UAC9BgE,KAAK,GAAG,IAAI,CAAChE,gBAAgB,CAACsF,cAAc,CACxCE,cAAc,CAAC,IAAI,CAACrF,YAAY,CAAC,CACpC;QACL,CAAC,MAAM,IAAIyE,eAAe,IAAIlD,KAAK,CAACzC,OAAO,CAACuG,cAAc,CAAC,EAAE;UACzDxB,KAAK,GAAGwB,cAAc,CAACxD,GAAG,CAAE8D,CAAC,IAAKA,CAAC,CAAC,IAAI,CAAC3F,YAAY,CAAC,CAAC;QAC3D,CAAC,MAAM;UACH6D,KAAK,GAAGwB,cAAc,CAAC,IAAI,CAACrF,YAAY,CAAC;QAC7C;MACJ;IACJ,CAAC,MAAM;MACH;MACA,IAAI,IAAI,CAAC4E,gBAAgB,IAAI,IAAI,CAAC/E,gBAAgB,EAAE;QAChD,MAAMyF,aAAa,GACf,IAAI,CAACV,gBAAgB,CAACO,cAAc,CAACZ,MAAM,CAAC;QAChD,IACIe,aAAa,IACbxH,WAAW,CAACwD,QAAQ,CAACgE,aAAa,CAAC,IACnC,CAACvH,eAAe,CAACwH,cAAc,CAACD,aAAa,CAAC,IAC9C,EAAE,OAAOA,aAAa,KAAK,UAAU,CAAC,IACtC,CAACE,MAAM,CAACC,QAAQ,CAACH,aAAa,CAAC,EACjC;UACEzB,KAAK,GAAG,IAAI,CAAChE,gBAAgB,CAACsF,cAAc,CAACG,aAAa,CAAC;QAC/D,CAAC,MAAM,IACHf,MAAM,CAAC,IAAI,CAACvE,YAAY,CAAC,IACzBlC,WAAW,CAACwD,QAAQ,CAACiD,MAAM,CAAC,IAAI,CAACvE,YAAY,CAAC,CAAC,IAC/C,CAACjC,eAAe,CAACwH,cAAc,CAC3BhB,MAAM,CAAC,IAAI,CAACvE,YAAY,CAAC,CAC5B,IACD,EAAE,OAAOuE,MAAM,CAAC,IAAI,CAACvE,YAAY,CAAC,KAAK,UAAU,CAAC,IAClD,CAACwF,MAAM,CAACC,QAAQ,CAAClB,MAAM,CAAC,IAAI,CAACvE,YAAY,CAAC,CAAC,IAC3C,EAAEuE,MAAM,CAAC,IAAI,CAACvE,YAAY,CAAC,YAAY0F,IAAI,CAAC,EAC9C;UACE7B,KAAK,GAAG,IAAI,CAAChE,gBAAgB,CAACsF,cAAc,CACxCZ,MAAM,CAAC,IAAI,CAACvE,YAAY,CAAC,CAC5B;QACL,CAAC,MAAM;UACH6D,KAAK,GAAGU,MAAM,CAAC,IAAI,CAACvE,YAAY,CAAC;QACrC;MACJ,CAAC,MAAM,IAAI,IAAI,CAACH,gBAAgB,EAAE;QAC9BgE,KAAK,GAAG,IAAI,CAAChE,gBAAgB,CAACsF,cAAc,CACxCZ,MAAM,CAAC,IAAI,CAACvE,YAAY,CAAC,CAC5B;MACL,CAAC,MAAM;QACH6D,KAAK,GAAGU,MAAM,CAAC,IAAI,CAACvE,YAAY,CAAC;MACrC;IACJ;IAEA,IAAIoF,SAAS,IAAI,IAAI,CAAC9C,WAAW,EAC7BuB,KAAK,GAAGhG,sBAAsB,CAAC+H,WAAW,CAAC,IAAI,CAACtD,WAAW,EAAEuB,KAAK,CAAC;IAEvE,OAAOA,KAAK;EAChB;EAEA;;;;EAIAgC,cAAcA,CAACtB,MAAqB,EAAEV,KAAU;IAC5C,IAAI,IAAI,CAACjE,gBAAgB,EAAE;MACvB;MACA,MAAMqE,0BAA0B,GAAGA,CAC/B6B,iBAAqC,EACrCjE,GAAkB,KACb;QACL;QACA;QAEA,MAAMjC,gBAAgB,GAAGkG,iBAAiB,CAAC5B,KAAK,EAAE;QAClD,IAAItE,gBAAgB,EAAE;UAClB,IAAI,CAACiC,GAAG,CAACjC,gBAAgB,CAACI,YAAY,CAAC,EACnC6B,GAAG,CAACjC,gBAAgB,CAACI,YAAY,CAAC,GAC9BJ,gBAAgB,CAACmG,MAAM,EAAE;UAEjC9B,0BAA0B,CACtB6B,iBAAiB,EACjBjE,GAAG,CAACjC,gBAAgB,CAACI,YAAY,CAAC,CACrC;UACD,OAAO6B,GAAG;QACd;QACAA,GAAG,CAAC,IAAI,CAAC7B,YAAY,CAAC,GAAG6D,KAAK;QAC9B,OAAOhC,GAAG;MACd,CAAC;MACD,OAAOoC,0BAA0B,CAC7B,CAAC,GAAG,IAAI,CAACrE,gBAAgB,CAACoG,oBAAoB,CAAC,EAC/CzB,MAAM,CACT;IACL,CAAC,MAAM;MACH;MACA;MACA;MACA,IACI,CAAC,IAAI,CAAC5E,cAAc,CAACsG,UAAU,IAC/B,IAAI,CAAClH,SAAS,IACd,IAAI,CAACc,gBAAgB,IACrB,IAAI,CAACA,gBAAgB,CAACG,YAAY,KAAK,IAAI,CAACA,YAAY,EAC1D;QACE,IAAI,EAAE,IAAI,CAACA,YAAY,IAAIuE,MAAM,CAAC,EAAE;UAChCA,MAAM,CAAC,IAAI,CAACvE,YAAY,CAAC,GAAG,EAAE;QAClC;QAEAuE,MAAM,CAAC,IAAI,CAACvE,YAAY,CAAC,CAAC,IAAI,CAACH,gBAAgB,CAACG,YAAY,CAAC,GACzD6D,KAAK;MACb,CAAC,MAAM;QACHU,MAAM,CAAC,IAAI,CAACvE,YAAY,CAAC,GAAG6D,KAAK;MACrC;IACJ;EACJ;EAEA;;;EAGAqC,kBAAkBA,CAAC3B,MAAW,EAAE4B,kBAAuB;IACnD,MAAMC,WAAW,GAAG,IAAI,CAACjB,cAAc,CAACZ,MAAM,CAAC;IAC/C,IAAIzG,WAAW,CAACwD,QAAQ,CAAC8E,WAAW,CAAC,EAAE;MACnC,OAAOA,WAAW,CAACC,MAAM,CAACF,kBAAkB,CAAC;IACjD;IACA,OAAOC,WAAW,KAAKD,kBAAkB;EAC7C;EAEA;EACA;EACA;EAEAG,KAAKA,CAAC5D,UAAsB;IACxB,IAAI,CAAC6D,YAAY,GAAG,IAAI,CAACC,iBAAiB,EAAE;IAC5C,IAAI,CAACC,iBAAiB,GAAG,IAAI,CAACF,YAAY,CAACG,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC;IAC5D,IAAI,CAACrC,YAAY,GAAG,IAAI,CAACsC,iBAAiB,CAACjE,UAAU,CAAC;IACtD,IAAI,CAACkE,YAAY,GAAG,IAAI,CAACC,iBAAiB,EAAE;IAC5C,IAAI,CAACC,2BAA2B,GAAGpE,UAAU,CAACqE,cAAc,CAACC,UAAU,CACnE,IAAI,CAAChH,YAAY,EACjB,IAAI,CAACE,iBAAiB,EACtB,EAAE,CACL;IACD,OAAO,IAAI;EACf;EAEUsG,iBAAiBA,CAAA;IACvB,IAAIS,IAAI,GAAG,EAAE;IACb,IACI,IAAI,CAACrH,gBAAgB,IACrB,IAAI,CAACA,gBAAgB,CAACoE,mBAAmB,CAAC3F,MAAM,EAEhD4I,IAAI,GAAG,IAAI,CAACrH,gBAAgB,CAACoE,mBAAmB,CAACkD,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG;IAEpED,IAAI,IAAI,IAAI,CAACjH,YAAY;IAEzB;IACA;IACA;IACA,IACI,CAAC,IAAI,CAACL,cAAc,CAACsG,UAAU,IAC/B,IAAI,CAAClH,SAAS,IACd,IAAI,CAACc,gBAAgB,IACrB,IAAI,CAACA,gBAAgB,CAACG,YAAY,KAAK,IAAI,CAACA,YAAY,EAExDiH,IAAI,IAAI,GAAG,GAAG,IAAI,CAACpH,gBAAgB,CAACG,YAAY;IAEpD,OAAOiH,IAAI;EACf;EAEUJ,iBAAiBA,CAAA;IACvB,IAAII,IAAI,GAAG,EAAE;IACb,IACI,IAAI,CAACrH,gBAAgB,IACrB,IAAI,CAACA,gBAAgB,CAACoE,mBAAmB,CAAC3F,MAAM,EAEhD4I,IAAI,GAAG,IAAI,CAACrH,gBAAgB,CAACoE,mBAAmB,CAACkD,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG;IAEpED,IAAI,IAAI,IAAI,CAAC5C,YAAY;IAEzB;IACA;IACA;IACA,IACI,CAAC,IAAI,CAAC1E,cAAc,CAACsG,UAAU,IAC/B,IAAI,CAAClH,SAAS,IACd,IAAI,CAACc,gBAAgB,IACrB,IAAI,CAACA,gBAAgB,CAACwE,YAAY,KAAK,IAAI,CAACA,YAAY,EAExD4C,IAAI,IAAI,GAAG,GAAG,IAAI,CAACpH,gBAAgB,CAACwE,YAAY;IAEpD,OAAO4C,IAAI;EACf;EAEUN,iBAAiBA,CAACjE,UAAsB;IAC9C,IAAIqB,aAAa,GAAG,IAAI,CAACnE,gBAAgB,GACnC,IAAI,CAACA,gBAAgB,CAACuH,cAAc,GACpC,EAAE;IACR,IAAIzE,UAAU,CAACC,MAAM,CAACzE,OAAO,CAACiC,IAAI,KAAK,SAAS;MAC5C;MACA4D,aAAa,GAAG,EAAE;IACtB,OAAOrB,UAAU,CAACqE,cAAc,CAACC,UAAU,CACvC,IAAI,CAAChH,YAAY,EACjB,IAAI,CAACE,iBAAiB,EACtB6D,aAAa,CAChB;EACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}