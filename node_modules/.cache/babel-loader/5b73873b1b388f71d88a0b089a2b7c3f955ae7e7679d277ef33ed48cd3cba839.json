{"ast":null,"code":"import { DateUtils } from \"../../util/DateUtils\";\nimport { RdbmsSchemaBuilder } from \"../../schema-builder/RdbmsSchemaBuilder\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { ApplyValueTransformers } from \"../../util/ApplyValueTransformers\";\nimport { DriverUtils } from \"../DriverUtils\";\nimport { TypeORMError } from \"../../error\";\nimport { InstanceChecker } from \"../../util/InstanceChecker\";\n/**\n * Organizes communication with sqlite DBMS.\n */\nexport class AbstractSqliteDriver {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    /**\n     * Indicates if replication is enabled.\n     */\n    this.isReplicated = false;\n    /**\n     * Indicates if tree tables are supported by this driver.\n     */\n    this.treeSupport = true;\n    /**\n     * Represent transaction support by this driver\n     */\n    this.transactionSupport = \"nested\";\n    /**\n     * Gets list of supported column data types by a driver.\n     *\n     * @see https://www.tutorialspoint.com/sqlite/sqlite_data_types.htm\n     * @see https://sqlite.org/datatype3.html\n     */\n    this.supportedDataTypes = [\"int\", \"integer\", \"tinyint\", \"smallint\", \"mediumint\", \"bigint\", \"unsigned big int\", \"int2\", \"int8\", \"integer\", \"character\", \"varchar\", \"varying character\", \"nchar\", \"native character\", \"nvarchar\", \"text\", \"clob\", \"text\", \"blob\", \"real\", \"double\", \"double precision\", \"float\", \"real\", \"numeric\", \"decimal\", \"boolean\", \"date\", \"time\", \"datetime\", \"json\"];\n    /**\n     * Returns type of upsert supported by driver if any\n     */\n    this.supportedUpsertTypes = [\"on-conflict-do-update\"];\n    /**\n     * Gets list of column data types that support length by a driver.\n     */\n    this.withLengthColumnTypes = [\"character\", \"varchar\", \"varying character\", \"nchar\", \"native character\", \"nvarchar\", \"text\", \"blob\", \"clob\"];\n    /**\n     * Gets list of spatial column data types.\n     */\n    this.spatialTypes = [];\n    /**\n     * Gets list of column data types that support precision by a driver.\n     */\n    this.withPrecisionColumnTypes = [\"real\", \"double\", \"double precision\", \"float\", \"real\", \"numeric\", \"decimal\", \"date\", \"time\", \"datetime\"];\n    /**\n     * Gets list of column data types that support scale by a driver.\n     */\n    this.withScaleColumnTypes = [\"real\", \"double\", \"double precision\", \"float\", \"real\", \"numeric\", \"decimal\"];\n    /**\n     * Orm has special columns and we need to know what database column types should be for those types.\n     * Column types are driver dependant.\n     */\n    this.mappedDataTypes = {\n      createDate: \"datetime\",\n      createDateDefault: \"datetime('now')\",\n      updateDate: \"datetime\",\n      updateDateDefault: \"datetime('now')\",\n      deleteDate: \"datetime\",\n      deleteDateNullable: true,\n      version: \"integer\",\n      treeLevel: \"integer\",\n      migrationId: \"integer\",\n      migrationName: \"varchar\",\n      migrationTimestamp: \"bigint\",\n      cacheId: \"int\",\n      cacheIdentifier: \"varchar\",\n      cacheTime: \"bigint\",\n      cacheDuration: \"int\",\n      cacheQuery: \"text\",\n      cacheResult: \"text\",\n      metadataType: \"varchar\",\n      metadataDatabase: \"varchar\",\n      metadataSchema: \"varchar\",\n      metadataTable: \"varchar\",\n      metadataName: \"varchar\",\n      metadataValue: \"text\"\n    };\n    this.cteCapabilities = {\n      enabled: true,\n      requiresRecursiveHint: true\n    };\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n    /**\n     * Any attached databases (excepting default 'main')\n     */\n    this.attachedDatabases = {};\n    this.connection = connection;\n    this.options = connection.options;\n    this.database = DriverUtils.buildDriverOptions(this.options).database;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Performs connection to the database.\n   */\n  async connect() {\n    this.databaseConnection = await this.createDatabaseConnection();\n  }\n  /**\n   * Makes any action after connection (e.g. create extensions in Postgres driver).\n   */\n  afterConnect() {\n    return Promise.resolve();\n  }\n  /**\n   * Closes connection with database.\n   */\n  async disconnect() {\n    return new Promise((ok, fail) => {\n      this.queryRunner = undefined;\n      this.databaseConnection.close(err => err ? fail(err) : ok());\n    });\n  }\n  hasAttachedDatabases() {\n    return !!Object.keys(this.attachedDatabases).length;\n  }\n  getAttachedDatabaseHandleByRelativePath(path) {\n    return this.attachedDatabases?.[path]?.attachHandle;\n  }\n  getAttachedDatabasePathRelativeByHandle(handle) {\n    return Object.values(this.attachedDatabases).find(({\n      attachHandle\n    }) => handle === attachHandle)?.attachFilepathRelative;\n  }\n  /**\n   * Creates a schema builder used to build and sync a schema.\n   */\n  createSchemaBuilder() {\n    return new RdbmsSchemaBuilder(this.connection);\n  }\n  /**\n   * Prepares given value to a value to be persisted, based on its column type and metadata.\n   */\n  preparePersistentValue(value, columnMetadata) {\n    if (columnMetadata.transformer) value = ApplyValueTransformers.transformTo(columnMetadata.transformer, value);\n    if (value === null || value === undefined) return value;\n    if (columnMetadata.type === Boolean || columnMetadata.type === \"boolean\") {\n      return value === true ? 1 : 0;\n    } else if (columnMetadata.type === \"date\") {\n      return DateUtils.mixedDateToDateString(value);\n    } else if (columnMetadata.type === \"time\") {\n      return DateUtils.mixedDateToTimeString(value);\n    } else if (columnMetadata.type === \"datetime\" || columnMetadata.type === Date) {\n      // to string conversation needs because SQLite stores date as integer number, when date came as Object\n      // TODO: think about `toUTC` conversion\n      return DateUtils.mixedDateToUtcDatetimeString(value);\n    } else if (columnMetadata.type === \"json\" || columnMetadata.type === \"simple-json\") {\n      return DateUtils.simpleJsonToString(value);\n    } else if (columnMetadata.type === \"simple-array\") {\n      return DateUtils.simpleArrayToString(value);\n    } else if (columnMetadata.type === \"simple-enum\") {\n      return DateUtils.simpleEnumToString(value);\n    }\n    return value;\n  }\n  /**\n   * Prepares given value to a value to be hydrated, based on its column type or metadata.\n   */\n  prepareHydratedValue(value, columnMetadata) {\n    if (value === null || value === undefined) return columnMetadata.transformer ? ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;\n    if (columnMetadata.type === Boolean || columnMetadata.type === \"boolean\") {\n      value = value ? true : false;\n    } else if (columnMetadata.type === \"datetime\" || columnMetadata.type === Date) {\n      /**\n       * Fix date conversion issue\n       *\n       * If the format of the date string is \"2018-03-14 02:33:33.906\", Safari (and iOS WKWebView) will convert it to an invalid date object.\n       * We need to modify the date string to \"2018-03-14T02:33:33.906Z\" and Safari will convert it correctly.\n       *\n       * ISO 8601\n       * https://www.w3.org/TR/NOTE-datetime\n       */\n      if (value && typeof value === \"string\") {\n        // There are various valid time string formats a sqlite time string might have:\n        // https://www.sqlite.org/lang_datefunc.html\n        // There are two separate fixes we may need to do:\n        //   1) Add 'T' separator if space is used instead\n        //   2) Add 'Z' UTC suffix if no timezone or offset specified\n        if (/^\\d\\d\\d\\d-\\d\\d-\\d\\d \\d\\d:\\d\\d/.test(value)) {\n          value = value.replace(\" \", \"T\");\n        }\n        if (/^\\d\\d\\d\\d-\\d\\d-\\d\\dT\\d\\d:\\d\\d(:\\d\\d(\\.\\d\\d\\d)?)?$/.test(value)) {\n          value += \"Z\";\n        }\n      }\n      value = DateUtils.normalizeHydratedDate(value);\n    } else if (columnMetadata.type === \"date\") {\n      value = DateUtils.mixedDateToDateString(value);\n    } else if (columnMetadata.type === \"time\") {\n      value = DateUtils.mixedTimeToString(value);\n    } else if (columnMetadata.type === \"json\" || columnMetadata.type === \"simple-json\") {\n      value = DateUtils.stringToSimpleJson(value);\n    } else if (columnMetadata.type === \"simple-array\") {\n      value = DateUtils.stringToSimpleArray(value);\n    } else if (columnMetadata.type === \"simple-enum\") {\n      value = DateUtils.stringToSimpleEnum(value, columnMetadata);\n    } else if (columnMetadata.type === Number) {\n      // convert to number if number\n      value = !isNaN(+value) ? parseInt(value) : value;\n    }\n    if (columnMetadata.transformer) value = ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);\n    return value;\n  }\n  /**\n   * Replaces parameters in the given sql with special escaping character\n   * and an array of parameter names to be passed to a query.\n   */\n  escapeQueryWithParameters(sql, parameters, nativeParameters) {\n    const escapedParameters = Object.keys(nativeParameters).map(key => {\n      // Mapping boolean values to their numeric representation\n      if (typeof nativeParameters[key] === \"boolean\") {\n        return nativeParameters[key] === true ? 1 : 0;\n      }\n      if (nativeParameters[key] instanceof Date) {\n        return DateUtils.mixedDateToUtcDatetimeString(nativeParameters[key]);\n      }\n      return nativeParameters[key];\n    });\n    if (!parameters || !Object.keys(parameters).length) return [sql, escapedParameters];\n    sql = sql.replace(/:(\\.\\.\\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key) => {\n      if (!parameters.hasOwnProperty(key)) {\n        return full;\n      }\n      let value = parameters[key];\n      if (isArray) {\n        return value.map(v => {\n          escapedParameters.push(v);\n          return this.createParameter(key, escapedParameters.length - 1);\n        }).join(\", \");\n      }\n      if (typeof value === \"function\") {\n        return value();\n      } else if (typeof value === \"number\") {\n        return String(value);\n      }\n      // Sqlite does not have a boolean data type so we have to transform\n      // it to 1 or 0\n      if (typeof value === \"boolean\") {\n        escapedParameters.push(+value);\n        return this.createParameter(key, escapedParameters.length - 1);\n      }\n      if (value instanceof Date) {\n        escapedParameters.push(DateUtils.mixedDateToUtcDatetimeString(value));\n        return this.createParameter(key, escapedParameters.length - 1);\n      }\n      escapedParameters.push(value);\n      return this.createParameter(key, escapedParameters.length - 1);\n    }); // todo: make replace only in value statements, otherwise problems\n    return [sql, escapedParameters];\n  }\n  /**\n   * Escapes a column name.\n   */\n  escape(columnName) {\n    return '\"' + columnName + '\"';\n  }\n  /**\n   * Build full table name with database name, schema name and table name.\n   * E.g. myDB.mySchema.myTable\n   *\n   * Returns only simple table name because all inherited drivers does not supports schema and database.\n   */\n  buildTableName(tableName, schema, database) {\n    return tableName;\n  }\n  /**\n   * Parse a target table name or other types and return a normalized table definition.\n   */\n  parseTableName(target) {\n    const driverDatabase = this.database;\n    const driverSchema = undefined;\n    if (InstanceChecker.isTable(target) || InstanceChecker.isView(target)) {\n      const parsed = this.parseTableName(target.schema ? `\"${target.schema}\".\"${target.name}\"` : target.name);\n      return {\n        database: target.database || parsed.database || driverDatabase,\n        schema: target.schema || parsed.schema || driverSchema,\n        tableName: parsed.tableName\n      };\n    }\n    if (InstanceChecker.isTableForeignKey(target)) {\n      const parsed = this.parseTableName(target.referencedTableName);\n      return {\n        database: target.referencedDatabase || parsed.database || driverDatabase,\n        schema: target.referencedSchema || parsed.schema || driverSchema,\n        tableName: parsed.tableName\n      };\n    }\n    if (InstanceChecker.isEntityMetadata(target)) {\n      // EntityMetadata tableName is never a path\n      return {\n        database: target.database || driverDatabase,\n        schema: target.schema || driverSchema,\n        tableName: target.tableName\n      };\n    }\n    const parts = target.split(\".\");\n    if (parts.length === 3) {\n      return {\n        database: parts[0] || driverDatabase,\n        schema: parts[1] || driverSchema,\n        tableName: parts[2]\n      };\n    } else if (parts.length === 2) {\n      const database = this.getAttachedDatabasePathRelativeByHandle(parts[0]) ?? driverDatabase;\n      return {\n        database: database,\n        schema: parts[0],\n        tableName: parts[1]\n      };\n    } else {\n      return {\n        database: driverDatabase,\n        schema: driverSchema,\n        tableName: target\n      };\n    }\n  }\n  /**\n   * Creates a database type from a given column metadata.\n   */\n  normalizeType(column) {\n    if (column.type === Number || column.type === \"int\") {\n      return \"integer\";\n    } else if (column.type === String) {\n      return \"varchar\";\n    } else if (column.type === Date) {\n      return \"datetime\";\n    } else if (column.type === Boolean) {\n      return \"boolean\";\n    } else if (column.type === \"uuid\") {\n      return \"varchar\";\n    } else if (column.type === \"simple-array\") {\n      return \"text\";\n    } else if (column.type === \"simple-json\") {\n      return \"text\";\n    } else if (column.type === \"simple-enum\") {\n      return \"varchar\";\n    } else {\n      return column.type || \"\";\n    }\n  }\n  /**\n   * Normalizes \"default\" value of the column.\n   */\n  normalizeDefault(columnMetadata) {\n    const defaultValue = columnMetadata.default;\n    if (typeof defaultValue === \"number\") {\n      return \"\" + defaultValue;\n    }\n    if (typeof defaultValue === \"boolean\") {\n      return defaultValue ? \"1\" : \"0\";\n    }\n    if (typeof defaultValue === \"function\") {\n      return defaultValue();\n    }\n    if (typeof defaultValue === \"string\") {\n      return `'${defaultValue}'`;\n    }\n    if (defaultValue === null || defaultValue === undefined) {\n      return undefined;\n    }\n    return `${defaultValue}`;\n  }\n  /**\n   * Normalizes \"isUnique\" value of the column.\n   */\n  normalizeIsUnique(column) {\n    return column.entityMetadata.uniques.some(uq => uq.columns.length === 1 && uq.columns[0] === column);\n  }\n  /**\n   * Calculates column length taking into account the default length values.\n   */\n  getColumnLength(column) {\n    return column.length ? column.length.toString() : \"\";\n  }\n  /**\n   * Normalizes \"default\" value of the column.\n   */\n  createFullType(column) {\n    let type = column.type;\n    if (column.enum) {\n      return \"varchar\";\n    }\n    if (column.length) {\n      type += \"(\" + column.length + \")\";\n    } else if (column.precision !== null && column.precision !== undefined && column.scale !== null && column.scale !== undefined) {\n      type += \"(\" + column.precision + \",\" + column.scale + \")\";\n    } else if (column.precision !== null && column.precision !== undefined) {\n      type += \"(\" + column.precision + \")\";\n    }\n    if (column.isArray) type += \" array\";\n    return type;\n  }\n  /**\n   * Obtains a new database connection to a master server.\n   * Used for replication.\n   * If replication is not setup then returns default connection's database connection.\n   */\n  obtainMasterConnection() {\n    return Promise.resolve();\n  }\n  /**\n   * Obtains a new database connection to a slave server.\n   * Used for replication.\n   * If replication is not setup then returns master (default) connection's database connection.\n   */\n  obtainSlaveConnection() {\n    return Promise.resolve();\n  }\n  /**\n   * Creates generated map of values generated or returned by database after INSERT query.\n   */\n  createGeneratedMap(metadata, insertResult, entityIndex, entityNum) {\n    const generatedMap = metadata.generatedColumns.reduce((map, generatedColumn) => {\n      let value;\n      if (generatedColumn.generationStrategy === \"increment\" && insertResult) {\n        // NOTE: When INSERT statement is successfully completed, the last inserted row ID is returned.\n        // see also: SqliteQueryRunner.query()\n        value = insertResult - entityNum + entityIndex + 1;\n        // } else if (generatedColumn.generationStrategy === \"uuid\") {\n        //     value = insertValue[generatedColumn.databaseName];\n      }\n      if (!value) return map;\n      return OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));\n    }, {});\n    return Object.keys(generatedMap).length > 0 ? generatedMap : undefined;\n  }\n  /**\n   * Differentiate columns of this table and columns from the given column metadatas columns\n   * and returns only changed.\n   */\n  findChangedColumns(tableColumns, columnMetadatas) {\n    return columnMetadatas.filter(columnMetadata => {\n      const tableColumn = tableColumns.find(c => c.name === columnMetadata.databaseName);\n      if (!tableColumn) return false; // we don't need new columns, we only need exist and changed\n      const isColumnChanged = tableColumn.name !== columnMetadata.databaseName || tableColumn.type !== this.normalizeType(columnMetadata) || tableColumn.length !== columnMetadata.length || tableColumn.precision !== columnMetadata.precision || tableColumn.scale !== columnMetadata.scale || this.normalizeDefault(columnMetadata) !== tableColumn.default || tableColumn.isPrimary !== columnMetadata.isPrimary || tableColumn.isNullable !== columnMetadata.isNullable || tableColumn.generatedType !== columnMetadata.generatedType || tableColumn.asExpression !== columnMetadata.asExpression || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata) || tableColumn.enum && columnMetadata.enum && !OrmUtils.isArraysEqual(tableColumn.enum, columnMetadata.enum.map(val => val + \"\")) || columnMetadata.generationStrategy !== \"uuid\" && tableColumn.isGenerated !== columnMetadata.isGenerated;\n      // DEBUG SECTION\n      // if (isColumnChanged) {\n      //     console.log(\"table:\", columnMetadata.entityMetadata.tableName)\n      //     console.log(\n      //         \"name:\",\n      //         tableColumn.name,\n      //         columnMetadata.databaseName,\n      //     )\n      //     console.log(\n      //         \"type:\",\n      //         tableColumn.type,\n      //         this.normalizeType(columnMetadata),\n      //     )\n      //     console.log(\n      //         \"length:\",\n      //         tableColumn.length,\n      //         columnMetadata.length,\n      //     )\n      //     console.log(\n      //         \"precision:\",\n      //         tableColumn.precision,\n      //         columnMetadata.precision,\n      //     )\n      //     console.log(\"scale:\", tableColumn.scale, columnMetadata.scale)\n      //     console.log(\n      //         \"default:\",\n      //         this.normalizeDefault(columnMetadata),\n      //         columnMetadata.default,\n      //     )\n      //     console.log(\n      //         \"isPrimary:\",\n      //         tableColumn.isPrimary,\n      //         columnMetadata.isPrimary,\n      //     )\n      //     console.log(\n      //         \"isNullable:\",\n      //         tableColumn.isNullable,\n      //         columnMetadata.isNullable,\n      //     )\n      //     console.log(\n      //         \"generatedType:\",\n      //         tableColumn.generatedType,\n      //         columnMetadata.generatedType,\n      //     )\n      //     console.log(\n      //         \"asExpression:\",\n      //         tableColumn.asExpression,\n      //         columnMetadata.asExpression,\n      //     )\n      //     console.log(\n      //         \"isUnique:\",\n      //         tableColumn.isUnique,\n      //         this.normalizeIsUnique(columnMetadata),\n      //     )\n      //     console.log(\n      //         \"enum:\",\n      //         tableColumn.enum &&\n      //             columnMetadata.enum &&\n      //             !OrmUtils.isArraysEqual(\n      //                 tableColumn.enum,\n      //                 columnMetadata.enum.map((val) => val + \"\"),\n      //             ),\n      //     )\n      //     console.log(\n      //         \"isGenerated:\",\n      //         tableColumn.isGenerated,\n      //         columnMetadata.isGenerated,\n      //     )\n      // }\n      return isColumnChanged;\n    });\n  }\n  /**\n   * Returns true if driver supports RETURNING / OUTPUT statement.\n   */\n  isReturningSqlSupported() {\n    return false;\n  }\n  /**\n   * Returns true if driver supports uuid values generation on its own.\n   */\n  isUUIDGenerationSupported() {\n    return false;\n  }\n  /**\n   * Returns true if driver supports fulltext indices.\n   */\n  isFullTextColumnTypeSupported() {\n    return false;\n  }\n  /**\n   * Creates an escaped parameter.\n   */\n  createParameter(parameterName, index) {\n    // return \"$\" + (index + 1);\n    return \"?\";\n    // return \"$\" + parameterName;\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates connection with the database.\n   */\n  createDatabaseConnection() {\n    throw new TypeORMError(\"Do not use AbstractSqlite directly, it has to be used with one of the sqlite drivers\");\n  }\n  /**\n   * If driver dependency is not given explicitly, then try to load it via \"require\".\n   */\n  loadDependencies() {\n    // dependencies have to be loaded in the specific driver\n  }\n}","map":{"version":3,"names":["DateUtils","RdbmsSchemaBuilder","OrmUtils","ApplyValueTransformers","DriverUtils","TypeORMError","InstanceChecker","AbstractSqliteDriver","constructor","connection","isReplicated","treeSupport","transactionSupport","supportedDataTypes","supportedUpsertTypes","withLengthColumnTypes","spatialTypes","withPrecisionColumnTypes","withScaleColumnTypes","mappedDataTypes","createDate","createDateDefault","updateDate","updateDateDefault","deleteDate","deleteDateNullable","version","treeLevel","migrationId","migrationName","migrationTimestamp","cacheId","cacheIdentifier","cacheTime","cacheDuration","cacheQuery","cacheResult","metadataType","metadataDatabase","metadataSchema","metadataTable","metadataName","metadataValue","cteCapabilities","enabled","requiresRecursiveHint","attachedDatabases","options","database","buildDriverOptions","connect","databaseConnection","createDatabaseConnection","afterConnect","Promise","resolve","disconnect","ok","fail","queryRunner","undefined","close","err","hasAttachedDatabases","Object","keys","length","getAttachedDatabaseHandleByRelativePath","path","attachHandle","getAttachedDatabasePathRelativeByHandle","handle","values","find","attachFilepathRelative","createSchemaBuilder","preparePersistentValue","value","columnMetadata","transformer","transformTo","type","Boolean","mixedDateToDateString","mixedDateToTimeString","Date","mixedDateToUtcDatetimeString","simpleJsonToString","simpleArrayToString","simpleEnumToString","prepareHydratedValue","transformFrom","test","replace","normalizeHydratedDate","mixedTimeToString","stringToSimpleJson","stringToSimpleArray","stringToSimpleEnum","Number","isNaN","parseInt","escapeQueryWithParameters","sql","parameters","nativeParameters","escapedParameters","map","key","full","isArray","hasOwnProperty","v","push","createParameter","join","String","escape","columnName","buildTableName","tableName","schema","parseTableName","target","driverDatabase","driverSchema","isTable","isView","parsed","name","isTableForeignKey","referencedTableName","referencedDatabase","referencedSchema","isEntityMetadata","parts","split","normalizeType","column","normalizeDefault","defaultValue","default","normalizeIsUnique","entityMetadata","uniques","some","uq","columns","getColumnLength","toString","createFullType","enum","precision","scale","obtainMasterConnection","obtainSlaveConnection","createGeneratedMap","metadata","insertResult","entityIndex","entityNum","generatedMap","generatedColumns","reduce","generatedColumn","generationStrategy","mergeDeep","createValueMap","findChangedColumns","tableColumns","columnMetadatas","filter","tableColumn","c","databaseName","isColumnChanged","isPrimary","isNullable","generatedType","asExpression","isUnique","isArraysEqual","val","isGenerated","isReturningSqlSupported","isUUIDGenerationSupported","isFullTextColumnTypeSupported","parameterName","index","loadDependencies"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\driver\\sqlite-abstract\\AbstractSqliteDriver.ts"],"sourcesContent":["import { Driver } from \"../Driver\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { ColumnMetadata } from \"../../metadata/ColumnMetadata\"\nimport { DateUtils } from \"../../util/DateUtils\"\nimport { DataSource } from \"../../data-source/DataSource\"\nimport { RdbmsSchemaBuilder } from \"../../schema-builder/RdbmsSchemaBuilder\"\nimport { CteCapabilities } from \"../types/CteCapabilities\"\nimport { MappedColumnTypes } from \"../types/MappedColumnTypes\"\nimport { ColumnType } from \"../types/ColumnTypes\"\nimport { QueryRunner } from \"../../query-runner/QueryRunner\"\nimport { DataTypeDefaults } from \"../types/DataTypeDefaults\"\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\"\nimport { BaseDataSourceOptions } from \"../../data-source/BaseDataSourceOptions\"\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { ApplyValueTransformers } from \"../../util/ApplyValueTransformers\"\nimport { ReplicationMode } from \"../types/ReplicationMode\"\nimport { DriverUtils } from \"../DriverUtils\"\nimport { TypeORMError } from \"../../error\"\nimport { Table } from \"../../schema-builder/table/Table\"\nimport { View } from \"../../schema-builder/view/View\"\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\"\nimport { InstanceChecker } from \"../../util/InstanceChecker\"\nimport { UpsertType } from \"../types/UpsertType\"\n\ntype DatabasesMap = Record<\n    string,\n    {\n        attachFilepathAbsolute: string\n        attachFilepathRelative: string\n        attachHandle: string\n    }\n>\n\n/**\n * Organizes communication with sqlite DBMS.\n */\nexport abstract class AbstractSqliteDriver implements Driver {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection used by driver.\n     */\n    connection: DataSource\n\n    /**\n     * Sqlite has a single QueryRunner because it works on a single database connection.\n     */\n    queryRunner?: QueryRunner\n\n    /**\n     * Real database connection with sqlite database.\n     */\n    databaseConnection: any\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection options.\n     */\n    options: BaseDataSourceOptions\n\n    /**\n     * Master database used to perform all write queries.\n     */\n    database?: string\n\n    /**\n     * Indicates if replication is enabled.\n     */\n    isReplicated: boolean = false\n\n    /**\n     * SQLite underlying library.\n     */\n    sqlite: any\n\n    /**\n     * Indicates if tree tables are supported by this driver.\n     */\n    treeSupport = true\n\n    /**\n     * Represent transaction support by this driver\n     */\n    transactionSupport: \"simple\" | \"nested\" | \"none\" = \"nested\"\n\n    /**\n     * Gets list of supported column data types by a driver.\n     *\n     * @see https://www.tutorialspoint.com/sqlite/sqlite_data_types.htm\n     * @see https://sqlite.org/datatype3.html\n     */\n    supportedDataTypes: ColumnType[] = [\n        \"int\",\n        \"integer\",\n        \"tinyint\",\n        \"smallint\",\n        \"mediumint\",\n        \"bigint\",\n        \"unsigned big int\",\n        \"int2\",\n        \"int8\",\n        \"integer\",\n        \"character\",\n        \"varchar\",\n        \"varying character\",\n        \"nchar\",\n        \"native character\",\n        \"nvarchar\",\n        \"text\",\n        \"clob\",\n        \"text\",\n        \"blob\",\n        \"real\",\n        \"double\",\n        \"double precision\",\n        \"float\",\n        \"real\",\n        \"numeric\",\n        \"decimal\",\n        \"boolean\",\n        \"date\",\n        \"time\",\n        \"datetime\",\n        \"json\",\n    ]\n\n    /**\n     * Returns type of upsert supported by driver if any\n     */\n    supportedUpsertTypes: UpsertType[] = [\"on-conflict-do-update\"]\n\n    /**\n     * Gets list of column data types that support length by a driver.\n     */\n    withLengthColumnTypes: ColumnType[] = [\n        \"character\",\n        \"varchar\",\n        \"varying character\",\n        \"nchar\",\n        \"native character\",\n        \"nvarchar\",\n        \"text\",\n        \"blob\",\n        \"clob\",\n    ]\n\n    /**\n     * Gets list of spatial column data types.\n     */\n    spatialTypes: ColumnType[] = []\n\n    /**\n     * Gets list of column data types that support precision by a driver.\n     */\n    withPrecisionColumnTypes: ColumnType[] = [\n        \"real\",\n        \"double\",\n        \"double precision\",\n        \"float\",\n        \"real\",\n        \"numeric\",\n        \"decimal\",\n        \"date\",\n        \"time\",\n        \"datetime\",\n    ]\n\n    /**\n     * Gets list of column data types that support scale by a driver.\n     */\n    withScaleColumnTypes: ColumnType[] = [\n        \"real\",\n        \"double\",\n        \"double precision\",\n        \"float\",\n        \"real\",\n        \"numeric\",\n        \"decimal\",\n    ]\n\n    /**\n     * Orm has special columns and we need to know what database column types should be for those types.\n     * Column types are driver dependant.\n     */\n    mappedDataTypes: MappedColumnTypes = {\n        createDate: \"datetime\",\n        createDateDefault: \"datetime('now')\",\n        updateDate: \"datetime\",\n        updateDateDefault: \"datetime('now')\",\n        deleteDate: \"datetime\",\n        deleteDateNullable: true,\n        version: \"integer\",\n        treeLevel: \"integer\",\n        migrationId: \"integer\",\n        migrationName: \"varchar\",\n        migrationTimestamp: \"bigint\",\n        cacheId: \"int\",\n        cacheIdentifier: \"varchar\",\n        cacheTime: \"bigint\",\n        cacheDuration: \"int\",\n        cacheQuery: \"text\",\n        cacheResult: \"text\",\n        metadataType: \"varchar\",\n        metadataDatabase: \"varchar\",\n        metadataSchema: \"varchar\",\n        metadataTable: \"varchar\",\n        metadataName: \"varchar\",\n        metadataValue: \"text\",\n    }\n\n    /**\n     * Default values of length, precision and scale depends on column data type.\n     * Used in the cases when length/precision/scale is not specified by user.\n     */\n    dataTypeDefaults: DataTypeDefaults\n\n    /**\n     * No documentation specifying a maximum length for identifiers could be found\n     * for SQLite.\n     */\n    maxAliasLength?: number\n\n    cteCapabilities: CteCapabilities = {\n        enabled: true,\n        requiresRecursiveHint: true,\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Any attached databases (excepting default 'main')\n     */\n    attachedDatabases: DatabasesMap = {}\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(connection: DataSource) {\n        this.connection = connection\n        this.options = connection.options as BaseDataSourceOptions\n\n        this.database = DriverUtils.buildDriverOptions(this.options).database\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Abstract\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a query runner used to execute database queries.\n     */\n    abstract createQueryRunner(mode: ReplicationMode): QueryRunner\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs connection to the database.\n     */\n    async connect(): Promise<void> {\n        this.databaseConnection = await this.createDatabaseConnection()\n    }\n\n    /**\n     * Makes any action after connection (e.g. create extensions in Postgres driver).\n     */\n    afterConnect(): Promise<void> {\n        return Promise.resolve()\n    }\n\n    /**\n     * Closes connection with database.\n     */\n    async disconnect(): Promise<void> {\n        return new Promise<void>((ok, fail) => {\n            this.queryRunner = undefined\n            this.databaseConnection.close((err: any) =>\n                err ? fail(err) : ok(),\n            )\n        })\n    }\n\n    hasAttachedDatabases(): boolean {\n        return !!Object.keys(this.attachedDatabases).length\n    }\n\n    getAttachedDatabaseHandleByRelativePath(path: string): string | undefined {\n        return this.attachedDatabases?.[path]?.attachHandle\n    }\n\n    getAttachedDatabasePathRelativeByHandle(\n        handle: string,\n    ): string | undefined {\n        return Object.values(this.attachedDatabases).find(\n            ({ attachHandle }) => handle === attachHandle,\n        )?.attachFilepathRelative\n    }\n\n    /**\n     * Creates a schema builder used to build and sync a schema.\n     */\n    createSchemaBuilder() {\n        return new RdbmsSchemaBuilder(this.connection)\n    }\n\n    /**\n     * Prepares given value to a value to be persisted, based on its column type and metadata.\n     */\n    preparePersistentValue(value: any, columnMetadata: ColumnMetadata): any {\n        if (columnMetadata.transformer)\n            value = ApplyValueTransformers.transformTo(\n                columnMetadata.transformer,\n                value,\n            )\n\n        if (value === null || value === undefined) return value\n\n        if (\n            columnMetadata.type === Boolean ||\n            columnMetadata.type === \"boolean\"\n        ) {\n            return value === true ? 1 : 0\n        } else if (columnMetadata.type === \"date\") {\n            return DateUtils.mixedDateToDateString(value)\n        } else if (columnMetadata.type === \"time\") {\n            return DateUtils.mixedDateToTimeString(value)\n        } else if (\n            columnMetadata.type === \"datetime\" ||\n            columnMetadata.type === Date\n        ) {\n            // to string conversation needs because SQLite stores date as integer number, when date came as Object\n            // TODO: think about `toUTC` conversion\n            return DateUtils.mixedDateToUtcDatetimeString(value)\n        } else if (\n            columnMetadata.type === \"json\" ||\n            columnMetadata.type === \"simple-json\"\n        ) {\n            return DateUtils.simpleJsonToString(value)\n        } else if (columnMetadata.type === \"simple-array\") {\n            return DateUtils.simpleArrayToString(value)\n        } else if (columnMetadata.type === \"simple-enum\") {\n            return DateUtils.simpleEnumToString(value)\n        }\n\n        return value\n    }\n\n    /**\n     * Prepares given value to a value to be hydrated, based on its column type or metadata.\n     */\n    prepareHydratedValue(value: any, columnMetadata: ColumnMetadata): any {\n        if (value === null || value === undefined)\n            return columnMetadata.transformer\n                ? ApplyValueTransformers.transformFrom(\n                      columnMetadata.transformer,\n                      value,\n                  )\n                : value\n\n        if (\n            columnMetadata.type === Boolean ||\n            columnMetadata.type === \"boolean\"\n        ) {\n            value = value ? true : false\n        } else if (\n            columnMetadata.type === \"datetime\" ||\n            columnMetadata.type === Date\n        ) {\n            /**\n             * Fix date conversion issue\n             *\n             * If the format of the date string is \"2018-03-14 02:33:33.906\", Safari (and iOS WKWebView) will convert it to an invalid date object.\n             * We need to modify the date string to \"2018-03-14T02:33:33.906Z\" and Safari will convert it correctly.\n             *\n             * ISO 8601\n             * https://www.w3.org/TR/NOTE-datetime\n             */\n            if (value && typeof value === \"string\") {\n                // There are various valid time string formats a sqlite time string might have:\n                // https://www.sqlite.org/lang_datefunc.html\n                // There are two separate fixes we may need to do:\n                //   1) Add 'T' separator if space is used instead\n                //   2) Add 'Z' UTC suffix if no timezone or offset specified\n\n                if (/^\\d\\d\\d\\d-\\d\\d-\\d\\d \\d\\d:\\d\\d/.test(value)) {\n                    value = value.replace(\" \", \"T\")\n                }\n                if (\n                    /^\\d\\d\\d\\d-\\d\\d-\\d\\dT\\d\\d:\\d\\d(:\\d\\d(\\.\\d\\d\\d)?)?$/.test(\n                        value,\n                    )\n                ) {\n                    value += \"Z\"\n                }\n            }\n\n            value = DateUtils.normalizeHydratedDate(value)\n        } else if (columnMetadata.type === \"date\") {\n            value = DateUtils.mixedDateToDateString(value)\n        } else if (columnMetadata.type === \"time\") {\n            value = DateUtils.mixedTimeToString(value)\n        } else if (\n            columnMetadata.type === \"json\" ||\n            columnMetadata.type === \"simple-json\"\n        ) {\n            value = DateUtils.stringToSimpleJson(value)\n        } else if (columnMetadata.type === \"simple-array\") {\n            value = DateUtils.stringToSimpleArray(value)\n        } else if (columnMetadata.type === \"simple-enum\") {\n            value = DateUtils.stringToSimpleEnum(value, columnMetadata)\n        } else if (columnMetadata.type === Number) {\n            // convert to number if number\n            value = !isNaN(+value) ? parseInt(value) : value\n        }\n\n        if (columnMetadata.transformer)\n            value = ApplyValueTransformers.transformFrom(\n                columnMetadata.transformer,\n                value,\n            )\n\n        return value\n    }\n\n    /**\n     * Replaces parameters in the given sql with special escaping character\n     * and an array of parameter names to be passed to a query.\n     */\n    escapeQueryWithParameters(\n        sql: string,\n        parameters: ObjectLiteral,\n        nativeParameters: ObjectLiteral,\n    ): [string, any[]] {\n        const escapedParameters: any[] = Object.keys(nativeParameters).map(\n            (key) => {\n                // Mapping boolean values to their numeric representation\n                if (typeof nativeParameters[key] === \"boolean\") {\n                    return nativeParameters[key] === true ? 1 : 0\n                }\n\n                if (nativeParameters[key] instanceof Date) {\n                    return DateUtils.mixedDateToUtcDatetimeString(\n                        nativeParameters[key],\n                    )\n                }\n\n                return nativeParameters[key]\n            },\n        )\n\n        if (!parameters || !Object.keys(parameters).length)\n            return [sql, escapedParameters]\n\n        sql = sql.replace(\n            /:(\\.\\.\\.)?([A-Za-z0-9_.]+)/g,\n            (full, isArray: string, key: string): string => {\n                if (!parameters.hasOwnProperty(key)) {\n                    return full\n                }\n\n                let value: any = parameters[key]\n\n                if (isArray) {\n                    return value\n                        .map((v: any) => {\n                            escapedParameters.push(v)\n                            return this.createParameter(\n                                key,\n                                escapedParameters.length - 1,\n                            )\n                        })\n                        .join(\", \")\n                }\n\n                if (typeof value === \"function\") {\n                    return value()\n                } else if (typeof value === \"number\") {\n                    return String(value)\n                }\n\n                // Sqlite does not have a boolean data type so we have to transform\n                // it to 1 or 0\n                if (typeof value === \"boolean\") {\n                    escapedParameters.push(+value)\n                    return this.createParameter(\n                        key,\n                        escapedParameters.length - 1,\n                    )\n                }\n\n                if (value instanceof Date) {\n                    escapedParameters.push(\n                        DateUtils.mixedDateToUtcDatetimeString(value),\n                    )\n                    return this.createParameter(\n                        key,\n                        escapedParameters.length - 1,\n                    )\n                }\n\n                escapedParameters.push(value)\n                return this.createParameter(key, escapedParameters.length - 1)\n            },\n        ) // todo: make replace only in value statements, otherwise problems\n        return [sql, escapedParameters]\n    }\n\n    /**\n     * Escapes a column name.\n     */\n    escape(columnName: string): string {\n        return '\"' + columnName + '\"'\n    }\n\n    /**\n     * Build full table name with database name, schema name and table name.\n     * E.g. myDB.mySchema.myTable\n     *\n     * Returns only simple table name because all inherited drivers does not supports schema and database.\n     */\n    buildTableName(\n        tableName: string,\n        schema?: string,\n        database?: string,\n    ): string {\n        return tableName\n    }\n\n    /**\n     * Parse a target table name or other types and return a normalized table definition.\n     */\n    parseTableName(\n        target: EntityMetadata | Table | View | TableForeignKey | string,\n    ): { database?: string; schema?: string; tableName: string } {\n        const driverDatabase = this.database\n        const driverSchema = undefined\n\n        if (InstanceChecker.isTable(target) || InstanceChecker.isView(target)) {\n            const parsed = this.parseTableName(\n                target.schema\n                    ? `\"${target.schema}\".\"${target.name}\"`\n                    : target.name,\n            )\n\n            return {\n                database: target.database || parsed.database || driverDatabase,\n                schema: target.schema || parsed.schema || driverSchema,\n                tableName: parsed.tableName,\n            }\n        }\n\n        if (InstanceChecker.isTableForeignKey(target)) {\n            const parsed = this.parseTableName(target.referencedTableName)\n\n            return {\n                database:\n                    target.referencedDatabase ||\n                    parsed.database ||\n                    driverDatabase,\n                schema:\n                    target.referencedSchema || parsed.schema || driverSchema,\n                tableName: parsed.tableName,\n            }\n        }\n\n        if (InstanceChecker.isEntityMetadata(target)) {\n            // EntityMetadata tableName is never a path\n\n            return {\n                database: target.database || driverDatabase,\n                schema: target.schema || driverSchema,\n                tableName: target.tableName,\n            }\n        }\n\n        const parts = target.split(\".\")\n\n        if (parts.length === 3) {\n            return {\n                database: parts[0] || driverDatabase,\n                schema: parts[1] || driverSchema,\n                tableName: parts[2],\n            }\n        } else if (parts.length === 2) {\n            const database =\n                this.getAttachedDatabasePathRelativeByHandle(parts[0]) ??\n                driverDatabase\n            return {\n                database: database,\n                schema: parts[0],\n                tableName: parts[1],\n            }\n        } else {\n            return {\n                database: driverDatabase,\n                schema: driverSchema,\n                tableName: target,\n            }\n        }\n    }\n\n    /**\n     * Creates a database type from a given column metadata.\n     */\n    normalizeType(column: {\n        type?: ColumnType\n        length?: number | string\n        precision?: number | null\n        scale?: number\n    }): string {\n        if (column.type === Number || column.type === \"int\") {\n            return \"integer\"\n        } else if (column.type === String) {\n            return \"varchar\"\n        } else if (column.type === Date) {\n            return \"datetime\"\n        } else if (column.type === Boolean) {\n            return \"boolean\"\n        } else if (column.type === \"uuid\") {\n            return \"varchar\"\n        } else if (column.type === \"simple-array\") {\n            return \"text\"\n        } else if (column.type === \"simple-json\") {\n            return \"text\"\n        } else if (column.type === \"simple-enum\") {\n            return \"varchar\"\n        } else {\n            return (column.type as string) || \"\"\n        }\n    }\n\n    /**\n     * Normalizes \"default\" value of the column.\n     */\n    normalizeDefault(columnMetadata: ColumnMetadata): string | undefined {\n        const defaultValue = columnMetadata.default\n\n        if (typeof defaultValue === \"number\") {\n            return \"\" + defaultValue\n        }\n\n        if (typeof defaultValue === \"boolean\") {\n            return defaultValue ? \"1\" : \"0\"\n        }\n\n        if (typeof defaultValue === \"function\") {\n            return defaultValue()\n        }\n\n        if (typeof defaultValue === \"string\") {\n            return `'${defaultValue}'`\n        }\n\n        if (defaultValue === null || defaultValue === undefined) {\n            return undefined\n        }\n\n        return `${defaultValue}`\n    }\n\n    /**\n     * Normalizes \"isUnique\" value of the column.\n     */\n    normalizeIsUnique(column: ColumnMetadata): boolean {\n        return column.entityMetadata.uniques.some(\n            (uq) => uq.columns.length === 1 && uq.columns[0] === column,\n        )\n    }\n\n    /**\n     * Calculates column length taking into account the default length values.\n     */\n    getColumnLength(column: ColumnMetadata): string {\n        return column.length ? column.length.toString() : \"\"\n    }\n\n    /**\n     * Normalizes \"default\" value of the column.\n     */\n    createFullType(column: TableColumn): string {\n        let type = column.type\n        if (column.enum) {\n            return \"varchar\"\n        }\n        if (column.length) {\n            type += \"(\" + column.length + \")\"\n        } else if (\n            column.precision !== null &&\n            column.precision !== undefined &&\n            column.scale !== null &&\n            column.scale !== undefined\n        ) {\n            type += \"(\" + column.precision + \",\" + column.scale + \")\"\n        } else if (\n            column.precision !== null &&\n            column.precision !== undefined\n        ) {\n            type += \"(\" + column.precision + \")\"\n        }\n\n        if (column.isArray) type += \" array\"\n\n        return type\n    }\n\n    /**\n     * Obtains a new database connection to a master server.\n     * Used for replication.\n     * If replication is not setup then returns default connection's database connection.\n     */\n    obtainMasterConnection(): Promise<any> {\n        return Promise.resolve()\n    }\n\n    /**\n     * Obtains a new database connection to a slave server.\n     * Used for replication.\n     * If replication is not setup then returns master (default) connection's database connection.\n     */\n    obtainSlaveConnection(): Promise<any> {\n        return Promise.resolve()\n    }\n\n    /**\n     * Creates generated map of values generated or returned by database after INSERT query.\n     */\n    createGeneratedMap(\n        metadata: EntityMetadata,\n        insertResult: any,\n        entityIndex: number,\n        entityNum: number,\n    ) {\n        const generatedMap = metadata.generatedColumns.reduce(\n            (map, generatedColumn) => {\n                let value: any\n                if (\n                    generatedColumn.generationStrategy === \"increment\" &&\n                    insertResult\n                ) {\n                    // NOTE: When INSERT statement is successfully completed, the last inserted row ID is returned.\n                    // see also: SqliteQueryRunner.query()\n                    value = insertResult - entityNum + entityIndex + 1\n                    // } else if (generatedColumn.generationStrategy === \"uuid\") {\n                    //     value = insertValue[generatedColumn.databaseName];\n                }\n\n                if (!value) return map\n                return OrmUtils.mergeDeep(\n                    map,\n                    generatedColumn.createValueMap(value),\n                )\n            },\n            {} as ObjectLiteral,\n        )\n\n        return Object.keys(generatedMap).length > 0 ? generatedMap : undefined\n    }\n\n    /**\n     * Differentiate columns of this table and columns from the given column metadatas columns\n     * and returns only changed.\n     */\n    findChangedColumns(\n        tableColumns: TableColumn[],\n        columnMetadatas: ColumnMetadata[],\n    ): ColumnMetadata[] {\n        return columnMetadatas.filter((columnMetadata) => {\n            const tableColumn = tableColumns.find(\n                (c) => c.name === columnMetadata.databaseName,\n            )\n            if (!tableColumn) return false // we don't need new columns, we only need exist and changed\n\n            const isColumnChanged =\n                tableColumn.name !== columnMetadata.databaseName ||\n                tableColumn.type !== this.normalizeType(columnMetadata) ||\n                tableColumn.length !== columnMetadata.length ||\n                tableColumn.precision !== columnMetadata.precision ||\n                tableColumn.scale !== columnMetadata.scale ||\n                this.normalizeDefault(columnMetadata) !== tableColumn.default ||\n                tableColumn.isPrimary !== columnMetadata.isPrimary ||\n                tableColumn.isNullable !== columnMetadata.isNullable ||\n                tableColumn.generatedType !== columnMetadata.generatedType ||\n                tableColumn.asExpression !== columnMetadata.asExpression ||\n                tableColumn.isUnique !==\n                    this.normalizeIsUnique(columnMetadata) ||\n                (tableColumn.enum &&\n                    columnMetadata.enum &&\n                    !OrmUtils.isArraysEqual(\n                        tableColumn.enum,\n                        columnMetadata.enum.map((val) => val + \"\"),\n                    )) ||\n                (columnMetadata.generationStrategy !== \"uuid\" &&\n                    tableColumn.isGenerated !== columnMetadata.isGenerated)\n\n            // DEBUG SECTION\n            // if (isColumnChanged) {\n            //     console.log(\"table:\", columnMetadata.entityMetadata.tableName)\n            //     console.log(\n            //         \"name:\",\n            //         tableColumn.name,\n            //         columnMetadata.databaseName,\n            //     )\n            //     console.log(\n            //         \"type:\",\n            //         tableColumn.type,\n            //         this.normalizeType(columnMetadata),\n            //     )\n            //     console.log(\n            //         \"length:\",\n            //         tableColumn.length,\n            //         columnMetadata.length,\n            //     )\n            //     console.log(\n            //         \"precision:\",\n            //         tableColumn.precision,\n            //         columnMetadata.precision,\n            //     )\n            //     console.log(\"scale:\", tableColumn.scale, columnMetadata.scale)\n            //     console.log(\n            //         \"default:\",\n            //         this.normalizeDefault(columnMetadata),\n            //         columnMetadata.default,\n            //     )\n            //     console.log(\n            //         \"isPrimary:\",\n            //         tableColumn.isPrimary,\n            //         columnMetadata.isPrimary,\n            //     )\n            //     console.log(\n            //         \"isNullable:\",\n            //         tableColumn.isNullable,\n            //         columnMetadata.isNullable,\n            //     )\n            //     console.log(\n            //         \"generatedType:\",\n            //         tableColumn.generatedType,\n            //         columnMetadata.generatedType,\n            //     )\n            //     console.log(\n            //         \"asExpression:\",\n            //         tableColumn.asExpression,\n            //         columnMetadata.asExpression,\n            //     )\n            //     console.log(\n            //         \"isUnique:\",\n            //         tableColumn.isUnique,\n            //         this.normalizeIsUnique(columnMetadata),\n            //     )\n            //     console.log(\n            //         \"enum:\",\n            //         tableColumn.enum &&\n            //             columnMetadata.enum &&\n            //             !OrmUtils.isArraysEqual(\n            //                 tableColumn.enum,\n            //                 columnMetadata.enum.map((val) => val + \"\"),\n            //             ),\n            //     )\n            //     console.log(\n            //         \"isGenerated:\",\n            //         tableColumn.isGenerated,\n            //         columnMetadata.isGenerated,\n            //     )\n            // }\n\n            return isColumnChanged\n        })\n    }\n\n    /**\n     * Returns true if driver supports RETURNING / OUTPUT statement.\n     */\n    isReturningSqlSupported(): boolean {\n        return false\n    }\n\n    /**\n     * Returns true if driver supports uuid values generation on its own.\n     */\n    isUUIDGenerationSupported(): boolean {\n        return false\n    }\n\n    /**\n     * Returns true if driver supports fulltext indices.\n     */\n    isFullTextColumnTypeSupported(): boolean {\n        return false\n    }\n\n    /**\n     * Creates an escaped parameter.\n     */\n    createParameter(parameterName: string, index: number): string {\n        // return \"$\" + (index + 1);\n        return \"?\"\n        // return \"$\" + parameterName;\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates connection with the database.\n     */\n    protected createDatabaseConnection() {\n        throw new TypeORMError(\n            \"Do not use AbstractSqlite directly, it has to be used with one of the sqlite drivers\",\n        )\n    }\n\n    /**\n     * If driver dependency is not given explicitly, then try to load it via \"require\".\n     */\n    protected loadDependencies(): void {\n        // dependencies have to be loaded in the specific driver\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}