{"ast":null,"code":"import { DriverUtils } from \"../../driver/DriverUtils\";\nimport { TypeORMError } from \"../../error/TypeORMError\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nexport class RelationIdLoader {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection, queryRunner, relationIdAttributes) {\n    this.connection = connection;\n    this.queryRunner = queryRunner;\n    this.relationIdAttributes = relationIdAttributes;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  async load(rawEntities) {\n    const promises = this.relationIdAttributes.map(async relationIdAttr => {\n      if (relationIdAttr.relation.isManyToOne || relationIdAttr.relation.isOneToOneOwner) {\n        // example: Post and Tag\n        // loadRelationIdAndMap(\"post.tagId\", \"post.tag\")\n        // we expect it to load id of tag\n        if (relationIdAttr.queryBuilderFactory) throw new TypeORMError(\"Additional condition can not be used with ManyToOne or OneToOne owner relations.\");\n        const duplicates = {};\n        const results = rawEntities.map(rawEntity => {\n          const result = {};\n          const duplicateParts = [];\n          relationIdAttr.relation.joinColumns.forEach(joinColumn => {\n            result[joinColumn.databaseName] = this.connection.driver.prepareHydratedValue(rawEntity[DriverUtils.buildAlias(this.connection.driver, undefined, relationIdAttr.parentAlias, joinColumn.databaseName)], joinColumn.referencedColumn);\n            const duplicatePart = `${joinColumn.databaseName}:${result[joinColumn.databaseName]}`;\n            if (duplicateParts.indexOf(duplicatePart) === -1) {\n              duplicateParts.push(duplicatePart);\n            }\n          });\n          relationIdAttr.relation.entityMetadata.primaryColumns.forEach(primaryColumn => {\n            result[primaryColumn.databaseName] = this.connection.driver.prepareHydratedValue(rawEntity[DriverUtils.buildAlias(this.connection.driver, undefined, relationIdAttr.parentAlias, primaryColumn.databaseName)], primaryColumn);\n            const duplicatePart = `${primaryColumn.databaseName}:${result[primaryColumn.databaseName]}`;\n            if (duplicateParts.indexOf(duplicatePart) === -1) {\n              duplicateParts.push(duplicatePart);\n            }\n          });\n          duplicateParts.sort();\n          const duplicate = duplicateParts.join(\"::\");\n          if (duplicates[duplicate]) {\n            return null;\n          }\n          duplicates[duplicate] = true;\n          return result;\n        }).filter(v => v);\n        return {\n          relationIdAttribute: relationIdAttr,\n          results: results\n        };\n      } else if (relationIdAttr.relation.isOneToMany || relationIdAttr.relation.isOneToOneNotOwner) {\n        // example: Post and Category\n        // loadRelationIdAndMap(\"post.categoryIds\", \"post.categories\")\n        // we expect it to load array of category ids\n        const relation = relationIdAttr.relation; // \"post.categories\"\n        const joinColumns = relation.isOwning ? relation.joinColumns : relation.inverseRelation.joinColumns;\n        const table = relation.inverseEntityMetadata.target; // category\n        const tableName = relation.inverseEntityMetadata.tableName; // category\n        const tableAlias = relationIdAttr.alias || tableName; // if condition (custom query builder factory) is set then relationIdAttr.alias defined\n        const duplicates = {};\n        const parameters = {};\n        const condition = rawEntities.map((rawEntity, index) => {\n          const duplicateParts = [];\n          const parameterParts = {};\n          const queryPart = joinColumns.map(joinColumn => {\n            const parameterName = joinColumn.databaseName + index;\n            const parameterValue = rawEntity[DriverUtils.buildAlias(this.connection.driver, undefined, relationIdAttr.parentAlias, joinColumn.referencedColumn.databaseName)];\n            const duplicatePart = `${tableAlias}:${joinColumn.propertyPath}:${parameterValue}`;\n            if (duplicateParts.indexOf(duplicatePart) !== -1) {\n              return \"\";\n            }\n            duplicateParts.push(duplicatePart);\n            parameterParts[parameterName] = parameterValue;\n            return tableAlias + \".\" + joinColumn.propertyPath + \" = :\" + parameterName;\n          }).filter(v => v).join(\" AND \");\n          duplicateParts.sort();\n          const duplicate = duplicateParts.join(\"::\");\n          if (duplicates[duplicate]) {\n            return \"\";\n          }\n          duplicates[duplicate] = true;\n          Object.assign(parameters, parameterParts);\n          return queryPart;\n        }).filter(v => v).map(condition => \"(\" + condition + \")\").join(\" OR \");\n        // ensure we won't perform redundant queries for joined data which was not found in selection\n        // example: if post.category was not found in db then no need to execute query for category.imageIds\n        if (!condition) return {\n          relationIdAttribute: relationIdAttr,\n          results: []\n        };\n        // generate query:\n        // SELECT category.id, category.postId FROM category category ON category.postId = :postId\n        const qb = this.connection.createQueryBuilder(this.queryRunner);\n        const columns = OrmUtils.uniq([...joinColumns, ...relation.inverseRelation.entityMetadata.primaryColumns], column => column.propertyPath);\n        columns.forEach(joinColumn => {\n          qb.addSelect(tableAlias + \".\" + joinColumn.propertyPath, joinColumn.databaseName);\n        });\n        qb.from(table, tableAlias).where(\"(\" + condition + \")\") // need brackets because if we have additional condition and no brackets, it looks like (a = 1) OR (a = 2) AND b = 1, that is incorrect\n        .setParameters(parameters);\n        // apply condition (custom query builder factory)\n        if (relationIdAttr.queryBuilderFactory) relationIdAttr.queryBuilderFactory(qb);\n        const results = await qb.getRawMany();\n        results.forEach(result => {\n          joinColumns.forEach(column => {\n            result[column.databaseName] = this.connection.driver.prepareHydratedValue(result[column.databaseName], column.referencedColumn);\n          });\n          relation.inverseRelation.entityMetadata.primaryColumns.forEach(column => {\n            result[column.databaseName] = this.connection.driver.prepareHydratedValue(result[column.databaseName], column);\n          });\n        });\n        return {\n          relationIdAttribute: relationIdAttr,\n          results\n        };\n      } else {\n        // many-to-many\n        // example: Post and Category\n        // owner side: loadRelationIdAndMap(\"post.categoryIds\", \"post.categories\")\n        // inverse side: loadRelationIdAndMap(\"category.postIds\", \"category.posts\")\n        // we expect it to load array of post ids\n        const relation = relationIdAttr.relation;\n        const joinColumns = relation.isOwning ? relation.joinColumns : relation.inverseRelation.inverseJoinColumns;\n        const inverseJoinColumns = relation.isOwning ? relation.inverseJoinColumns : relation.inverseRelation.joinColumns;\n        const junctionAlias = relationIdAttr.junctionAlias;\n        const inverseSideTableName = relationIdAttr.joinInverseSideMetadata.tableName;\n        const inverseSideTableAlias = relationIdAttr.alias || inverseSideTableName;\n        const junctionTableName = relation.isOwning ? relation.junctionEntityMetadata.tableName : relation.inverseRelation.junctionEntityMetadata.tableName;\n        const mappedColumns = rawEntities.map(rawEntity => {\n          return joinColumns.reduce((map, joinColumn) => {\n            map[joinColumn.propertyPath] = rawEntity[DriverUtils.buildAlias(this.connection.driver, undefined, relationIdAttr.parentAlias, joinColumn.referencedColumn.databaseName)];\n            return map;\n          }, {});\n        });\n        // ensure we won't perform redundant queries for joined data which was not found in selection\n        // example: if post.category was not found in db then no need to execute query for category.imageIds\n        if (mappedColumns.length === 0) return {\n          relationIdAttribute: relationIdAttr,\n          results: []\n        };\n        const parameters = {};\n        const duplicates = {};\n        const joinColumnConditions = mappedColumns.map((mappedColumn, index) => {\n          const duplicateParts = [];\n          const parameterParts = {};\n          const queryPart = Object.keys(mappedColumn).map(key => {\n            const parameterName = key + index;\n            const parameterValue = mappedColumn[key];\n            const duplicatePart = `${junctionAlias}:${key}:${parameterValue}`;\n            if (duplicateParts.indexOf(duplicatePart) !== -1) {\n              return \"\";\n            }\n            duplicateParts.push(duplicatePart);\n            parameterParts[parameterName] = parameterValue;\n            return junctionAlias + \".\" + key + \" = :\" + parameterName;\n          }).filter(s => s).join(\" AND \");\n          duplicateParts.sort();\n          const duplicate = duplicateParts.join(\"::\");\n          if (duplicates[duplicate]) {\n            return \"\";\n          }\n          duplicates[duplicate] = true;\n          Object.assign(parameters, parameterParts);\n          return queryPart;\n        }).filter(s => s);\n        const inverseJoinColumnCondition = inverseJoinColumns.map(joinColumn => {\n          return junctionAlias + \".\" + joinColumn.propertyPath + \" = \" + inverseSideTableAlias + \".\" + joinColumn.referencedColumn.propertyPath;\n        }).join(\" AND \");\n        const condition = joinColumnConditions.map(condition => {\n          return \"(\" + condition + \" AND \" + inverseJoinColumnCondition + \")\";\n        }).join(\" OR \");\n        const qb = this.connection.createQueryBuilder(this.queryRunner);\n        inverseJoinColumns.forEach(joinColumn => {\n          qb.addSelect(junctionAlias + \".\" + joinColumn.propertyPath, joinColumn.databaseName).addOrderBy(junctionAlias + \".\" + joinColumn.propertyPath);\n        });\n        joinColumns.forEach(joinColumn => {\n          qb.addSelect(junctionAlias + \".\" + joinColumn.propertyPath, joinColumn.databaseName).addOrderBy(junctionAlias + \".\" + joinColumn.propertyPath);\n        });\n        qb.from(inverseSideTableName, inverseSideTableAlias).innerJoin(junctionTableName, junctionAlias, condition).setParameters(parameters);\n        // apply condition (custom query builder factory)\n        if (relationIdAttr.queryBuilderFactory) relationIdAttr.queryBuilderFactory(qb);\n        const results = await qb.getRawMany();\n        results.forEach(result => {\n          ;\n          [...joinColumns, ...inverseJoinColumns].forEach(column => {\n            result[column.databaseName] = this.connection.driver.prepareHydratedValue(result[column.databaseName], column.referencedColumn);\n          });\n        });\n        return {\n          relationIdAttribute: relationIdAttr,\n          results\n        };\n      }\n    });\n    return Promise.all(promises);\n  }\n}","map":{"version":3,"names":["DriverUtils","TypeORMError","OrmUtils","RelationIdLoader","constructor","connection","queryRunner","relationIdAttributes","load","rawEntities","promises","map","relationIdAttr","relation","isManyToOne","isOneToOneOwner","queryBuilderFactory","duplicates","results","rawEntity","result","duplicateParts","joinColumns","forEach","joinColumn","databaseName","driver","prepareHydratedValue","buildAlias","undefined","parentAlias","referencedColumn","duplicatePart","indexOf","push","entityMetadata","primaryColumns","primaryColumn","sort","duplicate","join","filter","v","relationIdAttribute","isOneToMany","isOneToOneNotOwner","isOwning","inverseRelation","table","inverseEntityMetadata","target","tableName","tableAlias","alias","parameters","condition","index","parameterParts","queryPart","parameterName","parameterValue","propertyPath","Object","assign","qb","createQueryBuilder","columns","uniq","column","addSelect","from","where","setParameters","getRawMany","inverseJoinColumns","junctionAlias","inverseSideTableName","joinInverseSideMetadata","inverseSideTableAlias","junctionTableName","junctionEntityMetadata","mappedColumns","reduce","length","joinColumnConditions","mappedColumn","keys","key","s","inverseJoinColumnCondition","addOrderBy","innerJoin","Promise","all"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\query-builder\\relation-id\\RelationIdLoader.ts"],"sourcesContent":["import { RelationIdAttribute } from \"./RelationIdAttribute\"\nimport { DataSource } from \"../../data-source/DataSource\"\nimport { RelationIdLoadResult } from \"./RelationIdLoadResult\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { QueryRunner } from \"../../query-runner/QueryRunner\"\nimport { DriverUtils } from \"../../driver/DriverUtils\"\nimport { TypeORMError } from \"../../error/TypeORMError\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\n\nexport class RelationIdLoader {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        protected connection: DataSource,\n        protected queryRunner: QueryRunner | undefined,\n        protected relationIdAttributes: RelationIdAttribute[],\n    ) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    async load(rawEntities: any[]): Promise<RelationIdLoadResult[]> {\n        const promises = this.relationIdAttributes.map(\n            async (relationIdAttr) => {\n                if (\n                    relationIdAttr.relation.isManyToOne ||\n                    relationIdAttr.relation.isOneToOneOwner\n                ) {\n                    // example: Post and Tag\n                    // loadRelationIdAndMap(\"post.tagId\", \"post.tag\")\n                    // we expect it to load id of tag\n\n                    if (relationIdAttr.queryBuilderFactory)\n                        throw new TypeORMError(\n                            \"Additional condition can not be used with ManyToOne or OneToOne owner relations.\",\n                        )\n\n                    const duplicates: { [duplicateKey: string]: boolean } = {}\n                    const results = rawEntities\n                        .map((rawEntity) => {\n                            const result: ObjectLiteral = {}\n                            const duplicateParts: Array<string> = []\n                            relationIdAttr.relation.joinColumns.forEach(\n                                (joinColumn) => {\n                                    result[joinColumn.databaseName] =\n                                        this.connection.driver.prepareHydratedValue(\n                                            rawEntity[\n                                                DriverUtils.buildAlias(\n                                                    this.connection.driver,\n                                                    undefined,\n                                                    relationIdAttr.parentAlias,\n                                                    joinColumn.databaseName,\n                                                )\n                                            ],\n                                            joinColumn.referencedColumn!,\n                                        )\n                                    const duplicatePart = `${\n                                        joinColumn.databaseName\n                                    }:${result[joinColumn.databaseName]}`\n                                    if (\n                                        duplicateParts.indexOf(\n                                            duplicatePart,\n                                        ) === -1\n                                    ) {\n                                        duplicateParts.push(duplicatePart)\n                                    }\n                                },\n                            )\n\n                            relationIdAttr.relation.entityMetadata.primaryColumns.forEach(\n                                (primaryColumn) => {\n                                    result[primaryColumn.databaseName] =\n                                        this.connection.driver.prepareHydratedValue(\n                                            rawEntity[\n                                                DriverUtils.buildAlias(\n                                                    this.connection.driver,\n                                                    undefined,\n                                                    relationIdAttr.parentAlias,\n                                                    primaryColumn.databaseName,\n                                                )\n                                            ],\n                                            primaryColumn,\n                                        )\n                                    const duplicatePart = `${\n                                        primaryColumn.databaseName\n                                    }:${result[primaryColumn.databaseName]}`\n                                    if (\n                                        duplicateParts.indexOf(\n                                            duplicatePart,\n                                        ) === -1\n                                    ) {\n                                        duplicateParts.push(duplicatePart)\n                                    }\n                                },\n                            )\n\n                            duplicateParts.sort()\n                            const duplicate = duplicateParts.join(\"::\")\n                            if (duplicates[duplicate]) {\n                                return null\n                            }\n                            duplicates[duplicate] = true\n                            return result\n                        })\n                        .filter((v) => v)\n\n                    return {\n                        relationIdAttribute: relationIdAttr,\n                        results: results,\n                    }\n                } else if (\n                    relationIdAttr.relation.isOneToMany ||\n                    relationIdAttr.relation.isOneToOneNotOwner\n                ) {\n                    // example: Post and Category\n                    // loadRelationIdAndMap(\"post.categoryIds\", \"post.categories\")\n                    // we expect it to load array of category ids\n\n                    const relation = relationIdAttr.relation // \"post.categories\"\n                    const joinColumns = relation.isOwning\n                        ? relation.joinColumns\n                        : relation.inverseRelation!.joinColumns\n                    const table = relation.inverseEntityMetadata.target // category\n                    const tableName = relation.inverseEntityMetadata.tableName // category\n                    const tableAlias = relationIdAttr.alias || tableName // if condition (custom query builder factory) is set then relationIdAttr.alias defined\n\n                    const duplicates: { [duplicateKey: string]: boolean } = {}\n                    const parameters: ObjectLiteral = {}\n                    const condition = rawEntities\n                        .map((rawEntity, index) => {\n                            const duplicateParts: Array<string> = []\n                            const parameterParts: ObjectLiteral = {}\n                            const queryPart = joinColumns\n                                .map((joinColumn) => {\n                                    const parameterName =\n                                        joinColumn.databaseName + index\n                                    const parameterValue =\n                                        rawEntity[\n                                            DriverUtils.buildAlias(\n                                                this.connection.driver,\n                                                undefined,\n                                                relationIdAttr.parentAlias,\n                                                joinColumn.referencedColumn!\n                                                    .databaseName,\n                                            )\n                                        ]\n                                    const duplicatePart = `${tableAlias}:${joinColumn.propertyPath}:${parameterValue}`\n                                    if (\n                                        duplicateParts.indexOf(\n                                            duplicatePart,\n                                        ) !== -1\n                                    ) {\n                                        return \"\"\n                                    }\n                                    duplicateParts.push(duplicatePart)\n                                    parameterParts[parameterName] =\n                                        parameterValue\n                                    return (\n                                        tableAlias +\n                                        \".\" +\n                                        joinColumn.propertyPath +\n                                        \" = :\" +\n                                        parameterName\n                                    )\n                                })\n                                .filter((v) => v)\n                                .join(\" AND \")\n                            duplicateParts.sort()\n                            const duplicate = duplicateParts.join(\"::\")\n                            if (duplicates[duplicate]) {\n                                return \"\"\n                            }\n                            duplicates[duplicate] = true\n                            Object.assign(parameters, parameterParts)\n                            return queryPart\n                        })\n                        .filter((v) => v)\n                        .map((condition) => \"(\" + condition + \")\")\n                        .join(\" OR \")\n\n                    // ensure we won't perform redundant queries for joined data which was not found in selection\n                    // example: if post.category was not found in db then no need to execute query for category.imageIds\n                    if (!condition)\n                        return {\n                            relationIdAttribute: relationIdAttr,\n                            results: [],\n                        }\n\n                    // generate query:\n                    // SELECT category.id, category.postId FROM category category ON category.postId = :postId\n                    const qb = this.connection.createQueryBuilder(\n                        this.queryRunner,\n                    )\n\n                    const columns = OrmUtils.uniq(\n                        [\n                            ...joinColumns,\n                            ...relation.inverseRelation!.entityMetadata\n                                .primaryColumns,\n                        ],\n                        (column) => column.propertyPath,\n                    )\n\n                    columns.forEach((joinColumn) => {\n                        qb.addSelect(\n                            tableAlias + \".\" + joinColumn.propertyPath,\n                            joinColumn.databaseName,\n                        )\n                    })\n\n                    qb.from(table, tableAlias)\n                        .where(\"(\" + condition + \")\") // need brackets because if we have additional condition and no brackets, it looks like (a = 1) OR (a = 2) AND b = 1, that is incorrect\n                        .setParameters(parameters)\n\n                    // apply condition (custom query builder factory)\n                    if (relationIdAttr.queryBuilderFactory)\n                        relationIdAttr.queryBuilderFactory(qb)\n\n                    const results = await qb.getRawMany()\n                    results.forEach((result) => {\n                        joinColumns.forEach((column) => {\n                            result[column.databaseName] =\n                                this.connection.driver.prepareHydratedValue(\n                                    result[column.databaseName],\n                                    column.referencedColumn!,\n                                )\n                        })\n                        relation.inverseRelation!.entityMetadata.primaryColumns.forEach(\n                            (column) => {\n                                result[column.databaseName] =\n                                    this.connection.driver.prepareHydratedValue(\n                                        result[column.databaseName],\n                                        column,\n                                    )\n                            },\n                        )\n                    })\n\n                    return {\n                        relationIdAttribute: relationIdAttr,\n                        results,\n                    }\n                } else {\n                    // many-to-many\n                    // example: Post and Category\n                    // owner side: loadRelationIdAndMap(\"post.categoryIds\", \"post.categories\")\n                    // inverse side: loadRelationIdAndMap(\"category.postIds\", \"category.posts\")\n                    // we expect it to load array of post ids\n\n                    const relation = relationIdAttr.relation\n                    const joinColumns = relation.isOwning\n                        ? relation.joinColumns\n                        : relation.inverseRelation!.inverseJoinColumns\n                    const inverseJoinColumns = relation.isOwning\n                        ? relation.inverseJoinColumns\n                        : relation.inverseRelation!.joinColumns\n                    const junctionAlias = relationIdAttr.junctionAlias\n                    const inverseSideTableName =\n                        relationIdAttr.joinInverseSideMetadata.tableName\n                    const inverseSideTableAlias =\n                        relationIdAttr.alias || inverseSideTableName\n                    const junctionTableName = relation.isOwning\n                        ? relation.junctionEntityMetadata!.tableName\n                        : relation.inverseRelation!.junctionEntityMetadata!\n                              .tableName\n\n                    const mappedColumns = rawEntities.map((rawEntity) => {\n                        return joinColumns.reduce((map, joinColumn) => {\n                            map[joinColumn.propertyPath] =\n                                rawEntity[\n                                    DriverUtils.buildAlias(\n                                        this.connection.driver,\n                                        undefined,\n                                        relationIdAttr.parentAlias,\n                                        joinColumn.referencedColumn!\n                                            .databaseName,\n                                    )\n                                ]\n                            return map\n                        }, {} as ObjectLiteral)\n                    })\n\n                    // ensure we won't perform redundant queries for joined data which was not found in selection\n                    // example: if post.category was not found in db then no need to execute query for category.imageIds\n                    if (mappedColumns.length === 0)\n                        return {\n                            relationIdAttribute: relationIdAttr,\n                            results: [],\n                        }\n\n                    const parameters: ObjectLiteral = {}\n                    const duplicates: { [duplicateKey: string]: boolean } = {}\n                    const joinColumnConditions = mappedColumns\n                        .map((mappedColumn, index) => {\n                            const duplicateParts: Array<string> = []\n                            const parameterParts: ObjectLiteral = {}\n                            const queryPart = Object.keys(mappedColumn)\n                                .map((key) => {\n                                    const parameterName = key + index\n                                    const parameterValue = mappedColumn[key]\n                                    const duplicatePart = `${junctionAlias}:${key}:${parameterValue}`\n                                    if (\n                                        duplicateParts.indexOf(\n                                            duplicatePart,\n                                        ) !== -1\n                                    ) {\n                                        return \"\"\n                                    }\n                                    duplicateParts.push(duplicatePart)\n                                    parameterParts[parameterName] =\n                                        parameterValue\n                                    return (\n                                        junctionAlias +\n                                        \".\" +\n                                        key +\n                                        \" = :\" +\n                                        parameterName\n                                    )\n                                })\n                                .filter((s) => s)\n                                .join(\" AND \")\n                            duplicateParts.sort()\n                            const duplicate = duplicateParts.join(\"::\")\n                            if (duplicates[duplicate]) {\n                                return \"\"\n                            }\n                            duplicates[duplicate] = true\n                            Object.assign(parameters, parameterParts)\n                            return queryPart\n                        })\n                        .filter((s) => s)\n\n                    const inverseJoinColumnCondition = inverseJoinColumns\n                        .map((joinColumn) => {\n                            return (\n                                junctionAlias +\n                                \".\" +\n                                joinColumn.propertyPath +\n                                \" = \" +\n                                inverseSideTableAlias +\n                                \".\" +\n                                joinColumn.referencedColumn!.propertyPath\n                            )\n                        })\n                        .join(\" AND \")\n\n                    const condition = joinColumnConditions\n                        .map((condition) => {\n                            return (\n                                \"(\" +\n                                condition +\n                                \" AND \" +\n                                inverseJoinColumnCondition +\n                                \")\"\n                            )\n                        })\n                        .join(\" OR \")\n\n                    const qb = this.connection.createQueryBuilder(\n                        this.queryRunner,\n                    )\n\n                    inverseJoinColumns.forEach((joinColumn) => {\n                        qb.addSelect(\n                            junctionAlias + \".\" + joinColumn.propertyPath,\n                            joinColumn.databaseName,\n                        ).addOrderBy(\n                            junctionAlias + \".\" + joinColumn.propertyPath,\n                        )\n                    })\n\n                    joinColumns.forEach((joinColumn) => {\n                        qb.addSelect(\n                            junctionAlias + \".\" + joinColumn.propertyPath,\n                            joinColumn.databaseName,\n                        ).addOrderBy(\n                            junctionAlias + \".\" + joinColumn.propertyPath,\n                        )\n                    })\n\n                    qb.from(inverseSideTableName, inverseSideTableAlias)\n                        .innerJoin(junctionTableName, junctionAlias, condition)\n                        .setParameters(parameters)\n\n                    // apply condition (custom query builder factory)\n                    if (relationIdAttr.queryBuilderFactory)\n                        relationIdAttr.queryBuilderFactory(qb)\n\n                    const results = await qb.getRawMany()\n                    results.forEach((result) => {\n                        ;[...joinColumns, ...inverseJoinColumns].forEach(\n                            (column) => {\n                                result[column.databaseName] =\n                                    this.connection.driver.prepareHydratedValue(\n                                        result[column.databaseName],\n                                        column.referencedColumn!,\n                                    )\n                            },\n                        )\n                    })\n\n                    return {\n                        relationIdAttribute: relationIdAttr,\n                        results,\n                    }\n                }\n            },\n        )\n\n        return Promise.all(promises)\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}