{"ast":null,"code":"/**\n * Database's table index stored in this class.\n */\nexport class TableIndex {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(options) {\n    this[\"@instanceof\"] = Symbol.for(\"TableIndex\");\n    /**\n     * Columns included in this index.\n     */\n    this.columnNames = [];\n    this.name = options.name;\n    this.columnNames = options.columnNames;\n    this.isUnique = !!options.isUnique;\n    this.isSpatial = !!options.isSpatial;\n    this.isConcurrent = !!options.isConcurrent;\n    this.isFulltext = !!options.isFulltext;\n    this.isNullFiltered = !!options.isNullFiltered;\n    this.parser = options.parser;\n    this.where = options.where ? options.where : \"\";\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates a new copy of this index with exactly same properties.\n   */\n  clone() {\n    return new TableIndex({\n      name: this.name,\n      columnNames: [...this.columnNames],\n      isUnique: this.isUnique,\n      isSpatial: this.isSpatial,\n      isConcurrent: this.isConcurrent,\n      isFulltext: this.isFulltext,\n      isNullFiltered: this.isNullFiltered,\n      parser: this.parser,\n      where: this.where\n    });\n  }\n  // -------------------------------------------------------------------------\n  // Static Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates index from the index metadata object.\n   */\n  static create(indexMetadata) {\n    return new TableIndex({\n      name: indexMetadata.name,\n      columnNames: indexMetadata.columns.map(column => column.databaseName),\n      isUnique: indexMetadata.isUnique,\n      isSpatial: indexMetadata.isSpatial,\n      isConcurrent: indexMetadata.isConcurrent,\n      isFulltext: indexMetadata.isFulltext,\n      isNullFiltered: indexMetadata.isNullFiltered,\n      parser: indexMetadata.parser,\n      where: indexMetadata.where\n    });\n  }\n}","map":{"version":3,"names":["TableIndex","constructor","options","Symbol","for","columnNames","name","isUnique","isSpatial","isConcurrent","isFulltext","isNullFiltered","parser","where","clone","create","indexMetadata","columns","map","column","databaseName"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\schema-builder\\table\\TableIndex.ts"],"sourcesContent":["import { IndexMetadata } from \"../../metadata/IndexMetadata\"\nimport { TableIndexOptions } from \"../options/TableIndexOptions\"\n\n/**\n * Database's table index stored in this class.\n */\nexport class TableIndex {\n    readonly \"@instanceof\" = Symbol.for(\"TableIndex\")\n\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Index name.\n     */\n    name?: string\n\n    /**\n     * Columns included in this index.\n     */\n    columnNames: string[] = []\n\n    /**\n     * Indicates if this index is unique.\n     */\n    isUnique: boolean\n\n    /**\n     * The SPATIAL modifier indexes the entire column and does not allow indexed columns to contain NULL values.\n     * Works only in MySQL.\n     */\n    isSpatial: boolean\n\n    /**\n     * Create the index using the CONCURRENTLY modifier\n     * Works only in postgres.\n     */\n    isConcurrent: boolean\n\n    /**\n     * The FULLTEXT modifier indexes the entire column and does not allow prefixing.\n     * Works only in MySQL.\n     */\n    isFulltext: boolean\n\n    /**\n     * NULL_FILTERED indexes are particularly useful for indexing sparse columns, where most rows contain a NULL value.\n     * In these cases, the NULL_FILTERED index can be considerably smaller and more efficient to maintain than\n     * a normal index that includes NULL values.\n     *\n     * Works only in Spanner.\n     */\n    isNullFiltered: boolean\n\n    /**\n     * Fulltext parser.\n     * Works only in MySQL.\n     */\n    parser?: string\n\n    /**\n     * Index filter condition.\n     */\n    where: string\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(options: TableIndexOptions) {\n        this.name = options.name\n        this.columnNames = options.columnNames\n        this.isUnique = !!options.isUnique\n        this.isSpatial = !!options.isSpatial\n        this.isConcurrent = !!options.isConcurrent\n        this.isFulltext = !!options.isFulltext\n        this.isNullFiltered = !!options.isNullFiltered\n        this.parser = options.parser\n        this.where = options.where ? options.where : \"\"\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a new copy of this index with exactly same properties.\n     */\n    clone(): TableIndex {\n        return new TableIndex(<TableIndexOptions>{\n            name: this.name,\n            columnNames: [...this.columnNames],\n            isUnique: this.isUnique,\n            isSpatial: this.isSpatial,\n            isConcurrent: this.isConcurrent,\n            isFulltext: this.isFulltext,\n            isNullFiltered: this.isNullFiltered,\n            parser: this.parser,\n            where: this.where,\n        })\n    }\n\n    // -------------------------------------------------------------------------\n    // Static Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates index from the index metadata object.\n     */\n    static create(indexMetadata: IndexMetadata): TableIndex {\n        return new TableIndex(<TableIndexOptions>{\n            name: indexMetadata.name,\n            columnNames: indexMetadata.columns.map(\n                (column) => column.databaseName,\n            ),\n            isUnique: indexMetadata.isUnique,\n            isSpatial: indexMetadata.isSpatial,\n            isConcurrent: indexMetadata.isConcurrent,\n            isFulltext: indexMetadata.isFulltext,\n            isNullFiltered: indexMetadata.isNullFiltered,\n            parser: indexMetadata.parser,\n            where: indexMetadata.where,\n        })\n    }\n}\n"],"mappings":"AAGA;;;AAGA,OAAM,MAAOA,UAAU;EA4DnB;EACA;EACA;EAEAC,YAAYC,OAA0B;IA/D7B,mBAAa,GAAGC,MAAM,CAACC,GAAG,CAAC,YAAY,CAAC;IAWjD;;;IAGA,KAAAC,WAAW,GAAa,EAAE;IAkDtB,IAAI,CAACC,IAAI,GAAGJ,OAAO,CAACI,IAAI;IACxB,IAAI,CAACD,WAAW,GAAGH,OAAO,CAACG,WAAW;IACtC,IAAI,CAACE,QAAQ,GAAG,CAAC,CAACL,OAAO,CAACK,QAAQ;IAClC,IAAI,CAACC,SAAS,GAAG,CAAC,CAACN,OAAO,CAACM,SAAS;IACpC,IAAI,CAACC,YAAY,GAAG,CAAC,CAACP,OAAO,CAACO,YAAY;IAC1C,IAAI,CAACC,UAAU,GAAG,CAAC,CAACR,OAAO,CAACQ,UAAU;IACtC,IAAI,CAACC,cAAc,GAAG,CAAC,CAACT,OAAO,CAACS,cAAc;IAC9C,IAAI,CAACC,MAAM,GAAGV,OAAO,CAACU,MAAM;IAC5B,IAAI,CAACC,KAAK,GAAGX,OAAO,CAACW,KAAK,GAAGX,OAAO,CAACW,KAAK,GAAG,EAAE;EACnD;EAEA;EACA;EACA;EAEA;;;EAGAC,KAAKA,CAAA;IACD,OAAO,IAAId,UAAU,CAAoB;MACrCM,IAAI,EAAE,IAAI,CAACA,IAAI;MACfD,WAAW,EAAE,CAAC,GAAG,IAAI,CAACA,WAAW,CAAC;MAClCE,QAAQ,EAAE,IAAI,CAACA,QAAQ;MACvBC,SAAS,EAAE,IAAI,CAACA,SAAS;MACzBC,YAAY,EAAE,IAAI,CAACA,YAAY;MAC/BC,UAAU,EAAE,IAAI,CAACA,UAAU;MAC3BC,cAAc,EAAE,IAAI,CAACA,cAAc;MACnCC,MAAM,EAAE,IAAI,CAACA,MAAM;MACnBC,KAAK,EAAE,IAAI,CAACA;KACf,CAAC;EACN;EAEA;EACA;EACA;EAEA;;;EAGA,OAAOE,MAAMA,CAACC,aAA4B;IACtC,OAAO,IAAIhB,UAAU,CAAoB;MACrCM,IAAI,EAAEU,aAAa,CAACV,IAAI;MACxBD,WAAW,EAAEW,aAAa,CAACC,OAAO,CAACC,GAAG,CACjCC,MAAM,IAAKA,MAAM,CAACC,YAAY,CAClC;MACDb,QAAQ,EAAES,aAAa,CAACT,QAAQ;MAChCC,SAAS,EAAEQ,aAAa,CAACR,SAAS;MAClCC,YAAY,EAAEO,aAAa,CAACP,YAAY;MACxCC,UAAU,EAAEM,aAAa,CAACN,UAAU;MACpCC,cAAc,EAAEK,aAAa,CAACL,cAAc;MAC5CC,MAAM,EAAEI,aAAa,CAACJ,MAAM;MAC5BC,KAAK,EAAEG,aAAa,CAACH;KACxB,CAAC;EACN","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}