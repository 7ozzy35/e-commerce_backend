{"ast":null,"code":"import { Alias } from \"./Alias\";\nimport { JoinAttribute } from \"./JoinAttribute\";\nimport { RelationIdAttribute } from \"./relation-id/RelationIdAttribute\";\nimport { RelationCountAttribute } from \"./relation-count/RelationCountAttribute\";\nimport { TypeORMError } from \"../error\";\n/**\n * Contains all properties of the QueryBuilder that needs to be build a final query.\n */\nexport class QueryExpressionMap {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    this.connection = connection;\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n    /**\n     * Strategy to load relations.\n     */\n    this.relationLoadStrategy = \"join\";\n    /**\n     * Indicates if QueryBuilder used to select entities and not a raw results.\n     */\n    this.queryEntity = false;\n    /**\n     * All aliases (including main alias) used in the query.\n     */\n    this.aliases = [];\n    /**\n     * Represents query type. QueryBuilder is able to build SELECT, UPDATE and DELETE queries.\n     */\n    this.queryType = \"select\";\n    /**\n     * Data needs to be SELECT-ed.\n     */\n    this.selects = [];\n    /**\n     * Max execution time in millisecond.\n     */\n    this.maxExecutionTime = 0;\n    /**\n     * Whether SELECT is DISTINCT.\n     */\n    this.selectDistinct = false;\n    /**\n     * SELECT DISTINCT ON query (postgres).\n     */\n    this.selectDistinctOn = [];\n    /**\n     * Extra returning columns to be added to the returning statement if driver supports it.\n     */\n    this.extraReturningColumns = [];\n    /**\n     * Optional on conflict statement used in insertion query in postgres.\n     */\n    this.onConflict = \"\";\n    /**\n     * Optional on ignore statement used in insertion query in databases.\n     */\n    this.onIgnore = false;\n    /**\n     * JOIN queries.\n     */\n    this.joinAttributes = [];\n    /**\n     * RelationId queries.\n     */\n    this.relationIdAttributes = [];\n    /**\n     * Relation count queries.\n     */\n    this.relationCountAttributes = [];\n    /**\n     * WHERE queries.\n     */\n    this.wheres = [];\n    /**\n     * HAVING queries.\n     */\n    this.havings = [];\n    /**\n     * ORDER BY queries.\n     */\n    this.orderBys = {};\n    /**\n     * GROUP BY queries.\n     */\n    this.groupBys = [];\n    /**\n     * Indicates if soft-deleted rows should be included in entity result.\n     * By default the soft-deleted rows are not included.\n     */\n    this.withDeleted = false;\n    /**\n     * Parameters used to be escaped in final query.\n     */\n    this.parameters = {};\n    /**\n     * Indicates if alias, table names and column names will be escaped by driver, or not.\n     *\n     * todo: rename to isQuotingDisabled, also think if it should be named \"escaping\"\n     */\n    this.disableEscaping = true;\n    /**\n     * Indicates if virtual columns should be included in entity result.\n     *\n     * todo: what to do with it? is it properly used? what about persistence?\n     */\n    this.enableRelationIdValues = false;\n    /**\n     * Extra where condition appended to the end of original where conditions with AND keyword.\n     * Original condition will be wrapped into brackets.\n     */\n    this.extraAppendedAndWhereCondition = \"\";\n    /**\n     * Indicates if query builder creates a subquery.\n     */\n    this.subQuery = false;\n    /**\n     * Indicates if property names are prefixed with alias names during property replacement.\n     * By default this is enabled, however we need this because aliases are not supported in UPDATE and DELETE queries,\n     * but user can use them in WHERE expressions.\n     */\n    this.aliasNamePrefixingEnabled = true;\n    /**\n     * Options that define QueryBuilder behaviour.\n     */\n    this.options = [];\n    /**\n     * List of columns where data should be inserted.\n     * Used in INSERT query.\n     */\n    this.insertColumns = [];\n    /**\n     * Used if user wants to update or delete a specific entities.\n     */\n    this.whereEntities = [];\n    /**\n     * Indicates if entity must be updated after insertion / updation.\n     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n     */\n    this.updateEntity = true;\n    /**\n     * Indicates if listeners and subscribers must be called before and after query execution.\n     */\n    this.callListeners = true;\n    /**\n     * Indicates if query must be wrapped into transaction.\n     */\n    this.useTransaction = false;\n    /**\n     * Extra parameters.\n     *\n     * @deprecated Use standard parameters instead\n     */\n    this.nativeParameters = {};\n    /**\n     * Items from an entity that have been locally generated & are recorded here for later use.\n     * Examples include the UUID generation when the database does not natively support it.\n     * These are included in the entity index order.\n     */\n    this.locallyGenerated = {};\n    this.commonTableExpressions = [];\n    if (connection.options.relationLoadStrategy) {\n      this.relationLoadStrategy = connection.options.relationLoadStrategy;\n    }\n    this.timeTravel = connection.options?.timeTravelQueries || false;\n  }\n  // -------------------------------------------------------------------------\n  // Accessors\n  // -------------------------------------------------------------------------\n  /**\n   * Get all ORDER BY queries - if order by is specified by user then it uses them,\n   * otherwise it uses default entity order by if it was set.\n   */\n  get allOrderBys() {\n    if (!Object.keys(this.orderBys).length && this.mainAlias.hasMetadata && this.options.indexOf(\"disable-global-order\") === -1) {\n      const entityOrderBy = this.mainAlias.metadata.orderBy || {};\n      return Object.keys(entityOrderBy).reduce((orderBy, key) => {\n        orderBy[this.mainAlias.name + \".\" + key] = entityOrderBy[key];\n        return orderBy;\n      }, {});\n    }\n    return this.orderBys;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates a main alias and adds it to the current expression map.\n   */\n  setMainAlias(alias) {\n    // if main alias is already set then remove it from the array\n    // if (this.mainAlias)\n    //     this.aliases.splice(this.aliases.indexOf(this.mainAlias));\n    // set new main alias\n    this.mainAlias = alias;\n    return alias;\n  }\n  /**\n   * Creates a new alias and adds it to the current expression map.\n   */\n  createAlias(options) {\n    let aliasName = options.name;\n    if (!aliasName && options.tablePath) aliasName = options.tablePath;\n    if (!aliasName && typeof options.target === \"function\") aliasName = options.target.name;\n    if (!aliasName && typeof options.target === \"string\") aliasName = options.target;\n    const alias = new Alias();\n    alias.type = options.type;\n    if (aliasName) alias.name = aliasName;\n    if (options.metadata) alias.metadata = options.metadata;\n    if (options.target && !alias.hasMetadata) alias.metadata = this.connection.getMetadata(options.target);\n    if (options.tablePath) alias.tablePath = options.tablePath;\n    if (options.subQuery) alias.subQuery = options.subQuery;\n    this.aliases.push(alias);\n    return alias;\n  }\n  /**\n   * Finds alias with the given name.\n   * If alias was not found it throw an exception.\n   */\n  findAliasByName(aliasName) {\n    const alias = this.aliases.find(alias => alias.name === aliasName);\n    if (!alias) throw new TypeORMError(`\"${aliasName}\" alias was not found. Maybe you forgot to join it?`);\n    return alias;\n  }\n  findColumnByAliasExpression(aliasExpression) {\n    const [aliasName, propertyPath] = aliasExpression.split(\".\");\n    const alias = this.findAliasByName(aliasName);\n    return alias.metadata.findColumnWithPropertyName(propertyPath);\n  }\n  /**\n   * Gets relation metadata of the relation this query builder works with.\n   *\n   * todo: add proper exceptions\n   */\n  get relationMetadata() {\n    if (!this.mainAlias) throw new TypeORMError(`Entity to work with is not specified!`); // todo: better message\n    const relationMetadata = this.mainAlias.metadata.findRelationWithPropertyPath(this.relationPropertyPath);\n    if (!relationMetadata) throw new TypeORMError(`Relation ${this.relationPropertyPath} was not found in entity ${this.mainAlias.name}`); // todo: better message\n    return relationMetadata;\n  }\n  /**\n   * Copies all properties of the current QueryExpressionMap into a new one.\n   * Useful when QueryBuilder needs to create a copy of itself.\n   */\n  clone() {\n    const map = new QueryExpressionMap(this.connection);\n    map.queryType = this.queryType;\n    map.selects = this.selects.map(select => select);\n    map.maxExecutionTime = this.maxExecutionTime;\n    map.selectDistinct = this.selectDistinct;\n    map.selectDistinctOn = this.selectDistinctOn;\n    this.aliases.forEach(alias => map.aliases.push(new Alias(alias)));\n    map.relationLoadStrategy = this.relationLoadStrategy;\n    map.mainAlias = this.mainAlias;\n    map.valuesSet = this.valuesSet;\n    map.returning = this.returning;\n    map.onConflict = this.onConflict;\n    map.onIgnore = this.onIgnore;\n    map.onUpdate = this.onUpdate;\n    map.joinAttributes = this.joinAttributes.map(join => new JoinAttribute(this.connection, this, join));\n    map.relationIdAttributes = this.relationIdAttributes.map(relationId => new RelationIdAttribute(this, relationId));\n    map.relationCountAttributes = this.relationCountAttributes.map(relationCount => new RelationCountAttribute(this, relationCount));\n    map.wheres = this.wheres.map(where => ({\n      ...where\n    }));\n    map.havings = this.havings.map(having => ({\n      ...having\n    }));\n    map.orderBys = Object.assign({}, this.orderBys);\n    map.groupBys = this.groupBys.map(groupBy => groupBy);\n    map.limit = this.limit;\n    map.offset = this.offset;\n    map.skip = this.skip;\n    map.take = this.take;\n    map.lockMode = this.lockMode;\n    map.onLocked = this.onLocked;\n    map.lockVersion = this.lockVersion;\n    map.lockTables = this.lockTables;\n    map.withDeleted = this.withDeleted;\n    map.parameters = Object.assign({}, this.parameters);\n    map.disableEscaping = this.disableEscaping;\n    map.enableRelationIdValues = this.enableRelationIdValues;\n    map.extraAppendedAndWhereCondition = this.extraAppendedAndWhereCondition;\n    map.subQuery = this.subQuery;\n    map.aliasNamePrefixingEnabled = this.aliasNamePrefixingEnabled;\n    map.cache = this.cache;\n    map.cacheId = this.cacheId;\n    map.cacheDuration = this.cacheDuration;\n    map.relationPropertyPath = this.relationPropertyPath;\n    map.of = this.of;\n    map.insertColumns = this.insertColumns;\n    map.whereEntities = this.whereEntities;\n    map.updateEntity = this.updateEntity;\n    map.callListeners = this.callListeners;\n    map.useTransaction = this.useTransaction;\n    map.timeTravel = this.timeTravel;\n    map.nativeParameters = Object.assign({}, this.nativeParameters);\n    map.comment = this.comment;\n    map.commonTableExpressions = this.commonTableExpressions.map(cteOptions => ({\n      alias: cteOptions.alias,\n      queryBuilder: typeof cteOptions.queryBuilder === \"string\" ? cteOptions.queryBuilder : cteOptions.queryBuilder.clone(),\n      options: cteOptions.options\n    }));\n    return map;\n  }\n}","map":{"version":3,"names":["Alias","JoinAttribute","RelationIdAttribute","RelationCountAttribute","TypeORMError","QueryExpressionMap","constructor","connection","relationLoadStrategy","queryEntity","aliases","queryType","selects","maxExecutionTime","selectDistinct","selectDistinctOn","extraReturningColumns","onConflict","onIgnore","joinAttributes","relationIdAttributes","relationCountAttributes","wheres","havings","orderBys","groupBys","withDeleted","parameters","disableEscaping","enableRelationIdValues","extraAppendedAndWhereCondition","subQuery","aliasNamePrefixingEnabled","options","insertColumns","whereEntities","updateEntity","callListeners","useTransaction","nativeParameters","locallyGenerated","commonTableExpressions","timeTravel","timeTravelQueries","allOrderBys","Object","keys","length","mainAlias","hasMetadata","indexOf","entityOrderBy","metadata","orderBy","reduce","key","name","setMainAlias","alias","createAlias","aliasName","tablePath","target","type","getMetadata","push","findAliasByName","find","findColumnByAliasExpression","aliasExpression","propertyPath","split","findColumnWithPropertyName","relationMetadata","findRelationWithPropertyPath","relationPropertyPath","clone","map","select","forEach","valuesSet","returning","onUpdate","join","relationId","relationCount","where","having","assign","groupBy","limit","offset","skip","take","lockMode","onLocked","lockVersion","lockTables","cache","cacheId","cacheDuration","of","comment","cteOptions","queryBuilder"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\query-builder\\QueryExpressionMap.ts"],"sourcesContent":["import { Alias } from \"./Alias\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { OrderByCondition } from \"../find-options/OrderByCondition\"\nimport { JoinAttribute } from \"./JoinAttribute\"\nimport { QueryBuilder } from \"./QueryBuilder\"\nimport { QueryBuilderCteOptions } from \"./QueryBuilderCte\"\nimport { RelationIdAttribute } from \"./relation-id/RelationIdAttribute\"\nimport { RelationCountAttribute } from \"./relation-count/RelationCountAttribute\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { SelectQuery } from \"./SelectQuery\"\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { RelationMetadata } from \"../metadata/RelationMetadata\"\nimport { SelectQueryBuilderOption } from \"./SelectQueryBuilderOption\"\nimport { TypeORMError } from \"../error\"\nimport { WhereClause } from \"./WhereClause\"\nimport { UpsertType } from \"../driver/types/UpsertType\"\nimport { CockroachConnectionOptions } from \"../driver/cockroachdb/CockroachConnectionOptions\"\n\n/**\n * Contains all properties of the QueryBuilder that needs to be build a final query.\n */\nexport class QueryExpressionMap {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Strategy to load relations.\n     */\n    relationLoadStrategy: \"join\" | \"query\" = \"join\"\n\n    /**\n     * Indicates if QueryBuilder used to select entities and not a raw results.\n     */\n    queryEntity: boolean = false\n\n    /**\n     * Main alias is a main selection object selected by QueryBuilder.\n     */\n    mainAlias?: Alias\n\n    /**\n     * All aliases (including main alias) used in the query.\n     */\n    aliases: Alias[] = []\n\n    /**\n     * Represents query type. QueryBuilder is able to build SELECT, UPDATE and DELETE queries.\n     */\n    queryType:\n        | \"select\"\n        | \"update\"\n        | \"delete\"\n        | \"insert\"\n        | \"relation\"\n        | \"soft-delete\"\n        | \"restore\" = \"select\"\n\n    /**\n     * Data needs to be SELECT-ed.\n     */\n    selects: SelectQuery[] = []\n\n    /**\n     * Max execution time in millisecond.\n     */\n    maxExecutionTime: number = 0\n\n    /**\n     * Whether SELECT is DISTINCT.\n     */\n    selectDistinct: boolean = false\n\n    /**\n     * SELECT DISTINCT ON query (postgres).\n     */\n    selectDistinctOn: string[] = []\n\n    /**\n     * FROM-s to be selected.\n     */\n    // froms: { target: string, alias: string }[] = [];\n\n    /**\n     * If update query was used, it needs \"update set\" - properties which will be updated by this query.\n     * If insert query was used, it needs \"insert set\" - values that needs to be inserted.\n     */\n    valuesSet?: ObjectLiteral | ObjectLiteral[]\n\n    /**\n     * Optional returning (or output) clause for insert, update or delete queries.\n     */\n    returning: string | string[]\n\n    /**\n     * Extra returning columns to be added to the returning statement if driver supports it.\n     */\n    extraReturningColumns: ColumnMetadata[] = []\n\n    /**\n     * Optional on conflict statement used in insertion query in postgres.\n     */\n    onConflict: string = \"\"\n\n    /**\n     * Optional on ignore statement used in insertion query in databases.\n     */\n    onIgnore: boolean = false\n\n    /**\n     * Optional on update statement used in insertion query in databases.\n     */\n    onUpdate: {\n        conflict?: string | string[]\n        columns?: string[]\n        overwrite?: string[]\n        skipUpdateIfNoValuesChanged?: boolean\n        indexPredicate?: string\n        upsertType?: UpsertType\n    }\n\n    /**\n     * JOIN queries.\n     */\n    joinAttributes: JoinAttribute[] = []\n\n    /**\n     * RelationId queries.\n     */\n    relationIdAttributes: RelationIdAttribute[] = []\n\n    /**\n     * Relation count queries.\n     */\n    relationCountAttributes: RelationCountAttribute[] = []\n\n    /**\n     * WHERE queries.\n     */\n    wheres: WhereClause[] = []\n\n    /**\n     * HAVING queries.\n     */\n    havings: { type: \"simple\" | \"and\" | \"or\"; condition: string }[] = []\n\n    /**\n     * ORDER BY queries.\n     */\n    orderBys: OrderByCondition = {}\n\n    /**\n     * GROUP BY queries.\n     */\n    groupBys: string[] = []\n\n    /**\n     * LIMIT query.\n     */\n    limit?: number\n\n    /**\n     * OFFSET query.\n     */\n    offset?: number\n\n    /**\n     * Number of rows to skip of result using pagination.\n     */\n    skip?: number\n\n    /**\n     * Number of rows to take using pagination.\n     */\n    take?: number\n\n    /**\n     * Use certain index for the query.\n     *\n     * SELECT * FROM table_name USE INDEX (col1_index, col2_index) WHERE col1=1 AND col2=2 AND col3=3;\n     */\n    useIndex?: string\n\n    /**\n     * Locking mode.\n     */\n    lockMode?:\n        | \"optimistic\"\n        | \"pessimistic_read\"\n        | \"pessimistic_write\"\n        | \"dirty_read\"\n        /*\n            \"pessimistic_partial_write\" and \"pessimistic_write_or_fail\" are deprecated and\n            will be removed in a future version.\n\n            Use onLocked instead.\n         */\n        | \"pessimistic_partial_write\"\n        | \"pessimistic_write_or_fail\"\n        | \"for_no_key_update\"\n        | \"for_key_share\"\n\n    /**\n     * Current version of the entity, used for locking.\n     */\n    lockVersion?: number | Date\n\n    /**\n     * Tables to be specified in the \"FOR UPDATE OF\" clause, referred by their alias\n     */\n    lockTables?: string[]\n\n    /**\n     * Modify behavior when encountering locked rows. NOWAIT or SKIP LOCKED\n     */\n    onLocked?: \"nowait\" | \"skip_locked\"\n\n    /**\n     * Indicates if soft-deleted rows should be included in entity result.\n     * By default the soft-deleted rows are not included.\n     */\n    withDeleted: boolean = false\n\n    /**\n     * Parameters used to be escaped in final query.\n     */\n    parameters: ObjectLiteral = {}\n\n    /**\n     * Indicates if alias, table names and column names will be escaped by driver, or not.\n     *\n     * todo: rename to isQuotingDisabled, also think if it should be named \"escaping\"\n     */\n    disableEscaping: boolean = true\n\n    /**\n     * Indicates if virtual columns should be included in entity result.\n     *\n     * todo: what to do with it? is it properly used? what about persistence?\n     */\n    enableRelationIdValues: boolean = false\n\n    /**\n     * Extra where condition appended to the end of original where conditions with AND keyword.\n     * Original condition will be wrapped into brackets.\n     */\n    extraAppendedAndWhereCondition: string = \"\"\n\n    /**\n     * Indicates if query builder creates a subquery.\n     */\n    subQuery: boolean = false\n\n    /**\n     * Indicates if property names are prefixed with alias names during property replacement.\n     * By default this is enabled, however we need this because aliases are not supported in UPDATE and DELETE queries,\n     * but user can use them in WHERE expressions.\n     */\n    aliasNamePrefixingEnabled: boolean = true\n\n    /**\n     * Indicates if query result cache is enabled or not.\n     * It is undefined by default to avoid overriding the `alwaysEnabled` config\n     */\n    cache?: boolean\n\n    /**\n     * Time in milliseconds in which cache will expire.\n     * If not set then global caching time will be used.\n     */\n    cacheDuration: number\n\n    /**\n     * Cache id.\n     * Used to identifier your cache queries.\n     */\n    cacheId: string\n\n    /**\n     * Options that define QueryBuilder behaviour.\n     */\n    options: SelectQueryBuilderOption[] = []\n\n    /**\n     * Property path of relation to work with.\n     * Used in relational query builder.\n     */\n    relationPropertyPath: string\n\n    /**\n     * Entity (target) which relations will be updated.\n     */\n    of: any | any[]\n\n    /**\n     * List of columns where data should be inserted.\n     * Used in INSERT query.\n     */\n    insertColumns: string[] = []\n\n    /**\n     * Used if user wants to update or delete a specific entities.\n     */\n    whereEntities: ObjectLiteral[] = []\n\n    /**\n     * Indicates if entity must be updated after insertion / updation.\n     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n     */\n    updateEntity: boolean = true\n\n    /**\n     * Indicates if listeners and subscribers must be called before and after query execution.\n     */\n    callListeners: boolean = true\n\n    /**\n     * Indicates if query must be wrapped into transaction.\n     */\n    useTransaction: boolean = false\n\n    /**\n     * Indicates if query should be time travel query\n     * https://www.cockroachlabs.com/docs/stable/as-of-system-time.html\n     */\n    timeTravel?: boolean | string\n\n    /**\n     * Extra parameters.\n     *\n     * @deprecated Use standard parameters instead\n     */\n    nativeParameters: ObjectLiteral = {}\n\n    /**\n     * Query Comment to include extra information for debugging or other purposes.\n     */\n    comment?: string\n\n    /**\n     * Items from an entity that have been locally generated & are recorded here for later use.\n     * Examples include the UUID generation when the database does not natively support it.\n     * These are included in the entity index order.\n     */\n    locallyGenerated: { [key: number]: ObjectLiteral } = {}\n\n    commonTableExpressions: {\n        queryBuilder: QueryBuilder<any> | string\n        alias: string\n        options: QueryBuilderCteOptions\n    }[] = []\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected connection: DataSource) {\n        if (connection.options.relationLoadStrategy) {\n            this.relationLoadStrategy = connection.options.relationLoadStrategy\n        }\n\n        this.timeTravel =\n            (connection.options as CockroachConnectionOptions)\n                ?.timeTravelQueries || false\n    }\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Get all ORDER BY queries - if order by is specified by user then it uses them,\n     * otherwise it uses default entity order by if it was set.\n     */\n    get allOrderBys() {\n        if (\n            !Object.keys(this.orderBys).length &&\n            this.mainAlias!.hasMetadata &&\n            this.options.indexOf(\"disable-global-order\") === -1\n        ) {\n            const entityOrderBy = this.mainAlias!.metadata.orderBy || {}\n            return Object.keys(entityOrderBy).reduce((orderBy, key) => {\n                orderBy[this.mainAlias!.name + \".\" + key] = entityOrderBy[key]\n                return orderBy\n            }, {} as OrderByCondition)\n        }\n\n        return this.orderBys\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a main alias and adds it to the current expression map.\n     */\n    setMainAlias(alias: Alias): Alias {\n        // if main alias is already set then remove it from the array\n        // if (this.mainAlias)\n        //     this.aliases.splice(this.aliases.indexOf(this.mainAlias));\n\n        // set new main alias\n        this.mainAlias = alias\n\n        return alias\n    }\n\n    /**\n     * Creates a new alias and adds it to the current expression map.\n     */\n    createAlias(options: {\n        type: \"from\" | \"select\" | \"join\" | \"other\"\n        name?: string\n        target?: Function | string\n        tablePath?: string\n        subQuery?: string\n        metadata?: EntityMetadata\n    }): Alias {\n        let aliasName = options.name\n        if (!aliasName && options.tablePath) aliasName = options.tablePath\n        if (!aliasName && typeof options.target === \"function\")\n            aliasName = options.target.name\n        if (!aliasName && typeof options.target === \"string\")\n            aliasName = options.target\n\n        const alias = new Alias()\n        alias.type = options.type\n        if (aliasName) alias.name = aliasName\n        if (options.metadata) alias.metadata = options.metadata\n        if (options.target && !alias.hasMetadata)\n            alias.metadata = this.connection.getMetadata(options.target)\n        if (options.tablePath) alias.tablePath = options.tablePath\n        if (options.subQuery) alias.subQuery = options.subQuery\n\n        this.aliases.push(alias)\n        return alias\n    }\n\n    /**\n     * Finds alias with the given name.\n     * If alias was not found it throw an exception.\n     */\n    findAliasByName(aliasName: string): Alias {\n        const alias = this.aliases.find((alias) => alias.name === aliasName)\n        if (!alias)\n            throw new TypeORMError(\n                `\"${aliasName}\" alias was not found. Maybe you forgot to join it?`,\n            )\n\n        return alias\n    }\n\n    findColumnByAliasExpression(\n        aliasExpression: string,\n    ): ColumnMetadata | undefined {\n        const [aliasName, propertyPath] = aliasExpression.split(\".\")\n        const alias = this.findAliasByName(aliasName)\n        return alias.metadata.findColumnWithPropertyName(propertyPath)\n    }\n\n    /**\n     * Gets relation metadata of the relation this query builder works with.\n     *\n     * todo: add proper exceptions\n     */\n    get relationMetadata(): RelationMetadata {\n        if (!this.mainAlias)\n            throw new TypeORMError(`Entity to work with is not specified!`) // todo: better message\n\n        const relationMetadata =\n            this.mainAlias.metadata.findRelationWithPropertyPath(\n                this.relationPropertyPath,\n            )\n        if (!relationMetadata)\n            throw new TypeORMError(\n                `Relation ${this.relationPropertyPath} was not found in entity ${this.mainAlias.name}`,\n            ) // todo: better message\n\n        return relationMetadata\n    }\n\n    /**\n     * Copies all properties of the current QueryExpressionMap into a new one.\n     * Useful when QueryBuilder needs to create a copy of itself.\n     */\n    clone(): QueryExpressionMap {\n        const map = new QueryExpressionMap(this.connection)\n        map.queryType = this.queryType\n        map.selects = this.selects.map((select) => select)\n        map.maxExecutionTime = this.maxExecutionTime\n        map.selectDistinct = this.selectDistinct\n        map.selectDistinctOn = this.selectDistinctOn\n        this.aliases.forEach((alias) => map.aliases.push(new Alias(alias)))\n        map.relationLoadStrategy = this.relationLoadStrategy\n        map.mainAlias = this.mainAlias\n        map.valuesSet = this.valuesSet\n        map.returning = this.returning\n        map.onConflict = this.onConflict\n        map.onIgnore = this.onIgnore\n        map.onUpdate = this.onUpdate\n        map.joinAttributes = this.joinAttributes.map(\n            (join) => new JoinAttribute(this.connection, this, join),\n        )\n        map.relationIdAttributes = this.relationIdAttributes.map(\n            (relationId) => new RelationIdAttribute(this, relationId),\n        )\n        map.relationCountAttributes = this.relationCountAttributes.map(\n            (relationCount) => new RelationCountAttribute(this, relationCount),\n        )\n        map.wheres = this.wheres.map((where) => ({ ...where }))\n        map.havings = this.havings.map((having) => ({ ...having }))\n        map.orderBys = Object.assign({}, this.orderBys)\n        map.groupBys = this.groupBys.map((groupBy) => groupBy)\n        map.limit = this.limit\n        map.offset = this.offset\n        map.skip = this.skip\n        map.take = this.take\n        map.lockMode = this.lockMode\n        map.onLocked = this.onLocked\n        map.lockVersion = this.lockVersion\n        map.lockTables = this.lockTables\n        map.withDeleted = this.withDeleted\n        map.parameters = Object.assign({}, this.parameters)\n        map.disableEscaping = this.disableEscaping\n        map.enableRelationIdValues = this.enableRelationIdValues\n        map.extraAppendedAndWhereCondition = this.extraAppendedAndWhereCondition\n        map.subQuery = this.subQuery\n        map.aliasNamePrefixingEnabled = this.aliasNamePrefixingEnabled\n        map.cache = this.cache\n        map.cacheId = this.cacheId\n        map.cacheDuration = this.cacheDuration\n        map.relationPropertyPath = this.relationPropertyPath\n        map.of = this.of\n        map.insertColumns = this.insertColumns\n        map.whereEntities = this.whereEntities\n        map.updateEntity = this.updateEntity\n        map.callListeners = this.callListeners\n        map.useTransaction = this.useTransaction\n        map.timeTravel = this.timeTravel\n        map.nativeParameters = Object.assign({}, this.nativeParameters)\n        map.comment = this.comment\n        map.commonTableExpressions = this.commonTableExpressions.map(\n            (cteOptions) => ({\n                alias: cteOptions.alias,\n                queryBuilder:\n                    typeof cteOptions.queryBuilder === \"string\"\n                        ? cteOptions.queryBuilder\n                        : cteOptions.queryBuilder.clone(),\n                options: cteOptions.options,\n            }),\n        )\n        return map\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}