{"ast":null,"code":"import { DriverUtils } from \"../DriverUtils\";\nimport { AuroraMysqlQueryRunner } from \"./AuroraMysqlQueryRunner\";\nimport { DateUtils } from \"../../util/DateUtils\";\nimport { PlatformTools } from \"../../platform/PlatformTools\";\nimport { RdbmsSchemaBuilder } from \"../../schema-builder/RdbmsSchemaBuilder\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { ApplyValueTransformers } from \"../../util/ApplyValueTransformers\";\nimport { TypeORMError } from \"../../error\";\nimport { InstanceChecker } from \"../../util/InstanceChecker\";\n/**\n * Organizes communication with MySQL DBMS.\n */\nexport class AuroraMysqlDriver {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    /**\n     * Indicates if replication is enabled.\n     */\n    this.isReplicated = false;\n    /**\n     * Indicates if tree tables are supported by this driver.\n     */\n    this.treeSupport = true;\n    /**\n     * Represent transaction support by this driver\n     */\n    this.transactionSupport = \"nested\";\n    /**\n     * Gets list of supported column data types by a driver.\n     *\n     * @see https://www.tutorialspoint.com/mysql/mysql-data-types.htm\n     * @see https://dev.mysql.com/doc/refman/8.0/en/data-types.html\n     */\n    this.supportedDataTypes = [\n    // numeric types\n    \"bit\", \"int\", \"integer\",\n    // synonym for int\n    \"tinyint\", \"smallint\", \"mediumint\", \"bigint\", \"float\", \"double\", \"double precision\",\n    // synonym for double\n    \"real\",\n    // synonym for double\n    \"decimal\", \"dec\",\n    // synonym for decimal\n    \"numeric\",\n    // synonym for decimal\n    \"fixed\",\n    // synonym for decimal\n    \"bool\",\n    // synonym for tinyint\n    \"boolean\",\n    // synonym for tinyint\n    // date and time types\n    \"date\", \"datetime\", \"timestamp\", \"time\", \"year\",\n    // string types\n    \"char\", \"nchar\",\n    // synonym for national char\n    \"national char\", \"varchar\", \"nvarchar\",\n    // synonym for national varchar\n    \"national varchar\", \"blob\", \"text\", \"tinyblob\", \"tinytext\", \"mediumblob\", \"mediumtext\", \"longblob\", \"longtext\", \"enum\", \"set\", \"binary\", \"varbinary\",\n    // json data type\n    \"json\",\n    // spatial data types\n    \"geometry\", \"point\", \"linestring\", \"polygon\", \"multipoint\", \"multilinestring\", \"multipolygon\", \"geometrycollection\"];\n    /**\n     * Returns type of upsert supported by driver if any\n     */\n    this.supportedUpsertTypes = [\"on-duplicate-key-update\"];\n    /**\n     * Gets list of spatial column data types.\n     */\n    this.spatialTypes = [\"geometry\", \"point\", \"linestring\", \"polygon\", \"multipoint\", \"multilinestring\", \"multipolygon\", \"geometrycollection\"];\n    /**\n     * Gets list of column data types that support length by a driver.\n     */\n    this.withLengthColumnTypes = [\"char\", \"varchar\", \"nvarchar\", \"binary\", \"varbinary\"];\n    /**\n     * Gets list of column data types that support length by a driver.\n     */\n    this.withWidthColumnTypes = [\"bit\", \"tinyint\", \"smallint\", \"mediumint\", \"int\", \"integer\", \"bigint\"];\n    /**\n     * Gets list of column data types that support precision by a driver.\n     */\n    this.withPrecisionColumnTypes = [\"decimal\", \"dec\", \"numeric\", \"fixed\", \"float\", \"double\", \"double precision\", \"real\", \"time\", \"datetime\", \"timestamp\"];\n    /**\n     * Gets list of column data types that supports scale by a driver.\n     */\n    this.withScaleColumnTypes = [\"decimal\", \"dec\", \"numeric\", \"fixed\", \"float\", \"double\", \"double precision\", \"real\"];\n    /**\n     * Gets list of column data types that supports UNSIGNED and ZEROFILL attributes.\n     */\n    this.unsignedAndZerofillTypes = [\"int\", \"integer\", \"smallint\", \"tinyint\", \"mediumint\", \"bigint\", \"decimal\", \"dec\", \"numeric\", \"fixed\", \"float\", \"double\", \"double precision\", \"real\"];\n    /**\n     * ORM has special columns and we need to know what database column types should be for those columns.\n     * Column types are driver dependant.\n     */\n    this.mappedDataTypes = {\n      createDate: \"datetime\",\n      createDatePrecision: 6,\n      createDateDefault: \"CURRENT_TIMESTAMP(6)\",\n      updateDate: \"datetime\",\n      updateDatePrecision: 6,\n      updateDateDefault: \"CURRENT_TIMESTAMP(6)\",\n      deleteDate: \"datetime\",\n      deleteDatePrecision: 6,\n      deleteDateNullable: true,\n      version: \"int\",\n      treeLevel: \"int\",\n      migrationId: \"int\",\n      migrationName: \"varchar\",\n      migrationTimestamp: \"bigint\",\n      cacheId: \"int\",\n      cacheIdentifier: \"varchar\",\n      cacheTime: \"bigint\",\n      cacheDuration: \"int\",\n      cacheQuery: \"text\",\n      cacheResult: \"text\",\n      metadataType: \"varchar\",\n      metadataDatabase: \"varchar\",\n      metadataSchema: \"varchar\",\n      metadataTable: \"varchar\",\n      metadataName: \"varchar\",\n      metadataValue: \"text\"\n    };\n    /**\n     * Default values of length, precision and scale depends on column data type.\n     * Used in the cases when length/precision/scale is not specified by user.\n     */\n    this.dataTypeDefaults = {\n      varchar: {\n        length: 255\n      },\n      nvarchar: {\n        length: 255\n      },\n      \"national varchar\": {\n        length: 255\n      },\n      char: {\n        length: 1\n      },\n      binary: {\n        length: 1\n      },\n      varbinary: {\n        length: 255\n      },\n      decimal: {\n        precision: 10,\n        scale: 0\n      },\n      dec: {\n        precision: 10,\n        scale: 0\n      },\n      numeric: {\n        precision: 10,\n        scale: 0\n      },\n      fixed: {\n        precision: 10,\n        scale: 0\n      },\n      float: {\n        precision: 12\n      },\n      double: {\n        precision: 22\n      },\n      time: {\n        precision: 0\n      },\n      datetime: {\n        precision: 0\n      },\n      timestamp: {\n        precision: 0\n      },\n      bit: {\n        width: 1\n      },\n      int: {\n        width: 11\n      },\n      integer: {\n        width: 11\n      },\n      tinyint: {\n        width: 4\n      },\n      smallint: {\n        width: 6\n      },\n      mediumint: {\n        width: 9\n      },\n      bigint: {\n        width: 20\n      }\n    };\n    /**\n     * Max length allowed by MySQL for aliases.\n     * @see https://dev.mysql.com/doc/refman/5.5/en/identifiers.html\n     */\n    this.maxAliasLength = 63;\n    this.cteCapabilities = {\n      enabled: false\n    };\n    this.connection = connection;\n    this.options = connection.options;\n    // load mysql package\n    this.loadDependencies();\n    this.client = new this.DataApiDriver(this.options.region, this.options.secretArn, this.options.resourceArn, this.options.database, (query, parameters) => this.connection.logger.logQuery(query, parameters), this.options.serviceConfigOptions, this.options.formatOptions);\n    this.database = DriverUtils.buildDriverOptions(this.options).database;\n    // validate options to make sure everything is set\n    // todo: revisit validation with replication in mind\n    // if (!(this.options.host || (this.options.extra && this.options.extra.socketPath)) && !this.options.socketPath)\n    //     throw new DriverOptionNotSetError(\"socketPath and host\");\n    // if (!this.options.username)\n    //     throw new DriverOptionNotSetError(\"username\");\n    // if (!this.options.database)\n    //     throw new DriverOptionNotSetError(\"database\");\n    // todo: check what is going on when connection is setup without database and how to connect to a database then?\n    // todo: provide options to auto-create a database if it does not exist yet\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Performs connection to the database.\n   */\n  async connect() {\n    if (!this.database) {\n      const queryRunner = await this.createQueryRunner(\"master\");\n      this.database = await queryRunner.getCurrentDatabase();\n      await queryRunner.release();\n    }\n  }\n  /**\n   * Makes any action after connection (e.g. create extensions in Postgres driver).\n   */\n  afterConnect() {\n    return Promise.resolve();\n  }\n  /**\n   * Closes connection with the database.\n   */\n  async disconnect() {}\n  /**\n   * Creates a schema builder used to build and sync a schema.\n   */\n  createSchemaBuilder() {\n    return new RdbmsSchemaBuilder(this.connection);\n  }\n  /**\n   * Creates a query runner used to execute database queries.\n   */\n  createQueryRunner(mode) {\n    return new AuroraMysqlQueryRunner(this, new this.DataApiDriver(this.options.region, this.options.secretArn, this.options.resourceArn, this.options.database, (query, parameters) => this.connection.logger.logQuery(query, parameters), this.options.serviceConfigOptions, this.options.formatOptions));\n  }\n  /**\n   * Replaces parameters in the given sql with special escaping character\n   * and an array of parameter names to be passed to a query.\n   */\n  escapeQueryWithParameters(sql, parameters, nativeParameters) {\n    const escapedParameters = Object.keys(nativeParameters).map(key => nativeParameters[key]);\n    if (!parameters || !Object.keys(parameters).length) return [sql, escapedParameters];\n    sql = sql.replace(/:(\\.\\.\\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key) => {\n      if (!parameters.hasOwnProperty(key)) {\n        return full;\n      }\n      let value = parameters[key];\n      if (isArray) {\n        return value.map(v => {\n          escapedParameters.push(v);\n          return this.createParameter(key, escapedParameters.length - 1);\n        }).join(\", \");\n      }\n      if (typeof value === \"function\") {\n        return value();\n      }\n      escapedParameters.push(value);\n      return this.createParameter(key, escapedParameters.length - 1);\n    }); // todo: make replace only in value statements, otherwise problems\n    return [sql, escapedParameters];\n  }\n  /**\n   * Escapes a column name.\n   */\n  escape(columnName) {\n    return \"`\" + columnName + \"`\";\n  }\n  /**\n   * Build full table name with database name, schema name and table name.\n   * E.g. myDB.mySchema.myTable\n   */\n  buildTableName(tableName, schema, database) {\n    let tablePath = [tableName];\n    if (database) {\n      tablePath.unshift(database);\n    }\n    return tablePath.join(\".\");\n  }\n  /**\n   * Parse a target table name or other types and return a normalized table definition.\n   */\n  parseTableName(target) {\n    const driverDatabase = this.database;\n    const driverSchema = undefined;\n    if (InstanceChecker.isTable(target) || InstanceChecker.isView(target)) {\n      const parsed = this.parseTableName(target.name);\n      return {\n        database: target.database || parsed.database || driverDatabase,\n        schema: target.schema || parsed.schema || driverSchema,\n        tableName: parsed.tableName\n      };\n    }\n    if (InstanceChecker.isTableForeignKey(target)) {\n      const parsed = this.parseTableName(target.referencedTableName);\n      return {\n        database: target.referencedDatabase || parsed.database || driverDatabase,\n        schema: target.referencedSchema || parsed.schema || driverSchema,\n        tableName: parsed.tableName\n      };\n    }\n    if (InstanceChecker.isEntityMetadata(target)) {\n      // EntityMetadata tableName is never a path\n      return {\n        database: target.database || driverDatabase,\n        schema: target.schema || driverSchema,\n        tableName: target.tableName\n      };\n    }\n    const parts = target.split(\".\");\n    return {\n      database: (parts.length > 1 ? parts[0] : undefined) || driverDatabase,\n      schema: driverSchema,\n      tableName: parts.length > 1 ? parts[1] : parts[0]\n    };\n  }\n  /**\n   * Prepares given value to a value to be persisted, based on its column type and metadata.\n   */\n  preparePersistentValue(value, columnMetadata) {\n    if (columnMetadata.transformer) value = ApplyValueTransformers.transformTo(columnMetadata.transformer, value);\n    if (!this.options.formatOptions || this.options.formatOptions.castParameters !== false) {\n      return this.client.preparePersistentValue(value, columnMetadata);\n    }\n    if (value === null || value === undefined) return value;\n    if (columnMetadata.type === Boolean) {\n      return value === true ? 1 : 0;\n    } else if (columnMetadata.type === \"date\") {\n      return DateUtils.mixedDateToDateString(value);\n    } else if (columnMetadata.type === \"time\") {\n      return DateUtils.mixedDateToTimeString(value);\n    } else if (columnMetadata.type === \"json\") {\n      return JSON.stringify(value);\n    } else if (columnMetadata.type === \"timestamp\" || columnMetadata.type === \"datetime\" || columnMetadata.type === Date) {\n      return DateUtils.mixedDateToDate(value);\n    } else if (columnMetadata.type === \"simple-array\" || columnMetadata.type === \"set\") {\n      return DateUtils.simpleArrayToString(value);\n    } else if (columnMetadata.type === \"simple-json\") {\n      return DateUtils.simpleJsonToString(value);\n    } else if (columnMetadata.type === \"enum\" || columnMetadata.type === \"simple-enum\") {\n      return \"\" + value;\n    }\n    return value;\n  }\n  /**\n   * Prepares given value to a value to be persisted, based on its column type or metadata.\n   */\n  prepareHydratedValue(value, columnMetadata) {\n    if (value === null || value === undefined) return columnMetadata.transformer ? ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;\n    if (!this.options.formatOptions || this.options.formatOptions.castParameters !== false) {\n      return this.client.prepareHydratedValue(value, columnMetadata);\n    }\n    if (columnMetadata.type === Boolean || columnMetadata.type === \"bool\" || columnMetadata.type === \"boolean\") {\n      value = value ? true : false;\n    } else if (columnMetadata.type === \"datetime\" || columnMetadata.type === Date) {\n      value = DateUtils.normalizeHydratedDate(value);\n    } else if (columnMetadata.type === \"date\") {\n      value = DateUtils.mixedDateToDateString(value);\n    } else if (columnMetadata.type === \"json\") {\n      value = typeof value === \"string\" ? JSON.parse(value) : value;\n    } else if (columnMetadata.type === \"time\") {\n      value = DateUtils.mixedTimeToString(value);\n    } else if (columnMetadata.type === \"simple-array\" || columnMetadata.type === \"set\") {\n      value = DateUtils.stringToSimpleArray(value);\n    } else if (columnMetadata.type === \"simple-json\") {\n      value = DateUtils.stringToSimpleJson(value);\n    } else if ((columnMetadata.type === \"enum\" || columnMetadata.type === \"simple-enum\") && columnMetadata.enum && !isNaN(value) && columnMetadata.enum.indexOf(parseInt(value)) >= 0) {\n      // convert to number if that exists in possible enum options\n      value = parseInt(value);\n    } else if (columnMetadata.type === Number) {\n      // convert to number if number\n      value = !isNaN(+value) ? parseInt(value) : value;\n    }\n    if (columnMetadata.transformer) value = ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);\n    return value;\n  }\n  /**\n   * Creates a database type from a given column metadata.\n   */\n  normalizeType(column) {\n    if (column.type === Number || column.type === \"integer\") {\n      return \"int\";\n    } else if (column.type === String) {\n      return \"varchar\";\n    } else if (column.type === Date) {\n      return \"datetime\";\n    } else if (column.type === Buffer) {\n      return \"blob\";\n    } else if (column.type === Boolean) {\n      return \"tinyint\";\n    } else if (column.type === \"uuid\") {\n      return \"varchar\";\n    } else if (column.type === \"simple-array\" || column.type === \"simple-json\") {\n      return \"text\";\n    } else if (column.type === \"simple-enum\") {\n      return \"enum\";\n    } else if (column.type === \"double precision\" || column.type === \"real\") {\n      return \"double\";\n    } else if (column.type === \"dec\" || column.type === \"numeric\" || column.type === \"fixed\") {\n      return \"decimal\";\n    } else if (column.type === \"bool\" || column.type === \"boolean\") {\n      return \"tinyint\";\n    } else if (column.type === \"nvarchar\" || column.type === \"national varchar\") {\n      return \"varchar\";\n    } else if (column.type === \"nchar\" || column.type === \"national char\") {\n      return \"char\";\n    } else {\n      return column.type || \"\";\n    }\n  }\n  /**\n   * Normalizes \"default\" value of the column.\n   */\n  normalizeDefault(columnMetadata) {\n    const defaultValue = columnMetadata.default;\n    if (defaultValue === null) {\n      return undefined;\n    }\n    if ((columnMetadata.type === \"enum\" || columnMetadata.type === \"simple-enum\") && defaultValue !== undefined) {\n      return `'${defaultValue}'`;\n    }\n    if (columnMetadata.type === \"set\" && defaultValue !== undefined) {\n      return `'${DateUtils.simpleArrayToString(defaultValue)}'`;\n    }\n    if (typeof defaultValue === \"number\") {\n      return `${defaultValue}`;\n    }\n    if (typeof defaultValue === \"boolean\") {\n      return defaultValue ? \"1\" : \"0\";\n    }\n    if (typeof defaultValue === \"function\") {\n      return defaultValue();\n    }\n    if (typeof defaultValue === \"string\") {\n      return `'${defaultValue}'`;\n    }\n    if (defaultValue === undefined) {\n      return undefined;\n    }\n    return `${defaultValue}`;\n  }\n  /**\n   * Normalizes \"isUnique\" value of the column.\n   */\n  normalizeIsUnique(column) {\n    return column.entityMetadata.indices.some(idx => idx.isUnique && idx.columns.length === 1 && idx.columns[0] === column);\n  }\n  /**\n   * Returns default column lengths, which is required on column creation.\n   */\n  getColumnLength(column) {\n    if (column.length) return column.length.toString();\n    /**\n     * fix https://github.com/typeorm/typeorm/issues/1139\n     */\n    if (column.generationStrategy === \"uuid\") return \"36\";\n    switch (column.type) {\n      case String:\n      case \"varchar\":\n      case \"nvarchar\":\n      case \"national varchar\":\n        return \"255\";\n      case \"varbinary\":\n        return \"255\";\n      default:\n        return \"\";\n    }\n  }\n  /**\n   * Creates column type definition including length, precision and scale\n   */\n  createFullType(column) {\n    let type = column.type;\n    // used 'getColumnLength()' method, because MySQL requires column length for `varchar`, `nvarchar` and `varbinary` data types\n    if (this.getColumnLength(column)) {\n      type += `(${this.getColumnLength(column)})`;\n    } else if (column.width) {\n      type += `(${column.width})`;\n    } else if (column.precision !== null && column.precision !== undefined && column.scale !== null && column.scale !== undefined) {\n      type += `(${column.precision},${column.scale})`;\n    } else if (column.precision !== null && column.precision !== undefined) {\n      type += `(${column.precision})`;\n    }\n    if (column.isArray) type += \" array\";\n    return type;\n  }\n  /**\n   * Obtains a new database connection to a master server.\n   * Used for replication.\n   * If replication is not setup then returns default connection's database connection.\n   */\n  obtainMasterConnection() {\n    return new Promise((ok, fail) => {\n      if (this.poolCluster) {\n        this.poolCluster.getConnection(\"MASTER\", (err, dbConnection) => {\n          err ? fail(err) : ok(this.prepareDbConnection(dbConnection));\n        });\n      } else if (this.pool) {\n        this.pool.getConnection((err, dbConnection) => {\n          err ? fail(err) : ok(this.prepareDbConnection(dbConnection));\n        });\n      } else {\n        fail(new TypeORMError(`Connection is not established with mysql database`));\n      }\n    });\n  }\n  /**\n   * Obtains a new database connection to a slave server.\n   * Used for replication.\n   * If replication is not setup then returns master (default) connection's database connection.\n   */\n  obtainSlaveConnection() {\n    if (!this.poolCluster) return this.obtainMasterConnection();\n    return new Promise((ok, fail) => {\n      this.poolCluster.getConnection(\"SLAVE*\", (err, dbConnection) => {\n        err ? fail(err) : ok(this.prepareDbConnection(dbConnection));\n      });\n    });\n  }\n  /**\n   * Creates generated map of values generated or returned by database after INSERT query.\n   */\n  createGeneratedMap(metadata, insertResult, entityIndex) {\n    const generatedMap = metadata.generatedColumns.reduce((map, generatedColumn) => {\n      let value;\n      if (generatedColumn.generationStrategy === \"increment\" && insertResult.insertId) {\n        // NOTE: When multiple rows is inserted by a single INSERT statement,\n        // `insertId` is the value generated for the first inserted row only.\n        value = insertResult.insertId + entityIndex;\n        // } else if (generatedColumn.generationStrategy === \"uuid\") {\n        //     console.log(\"getting db value:\", generatedColumn.databaseName);\n        //     value = generatedColumn.getEntityValue(uuidMap);\n      }\n      return OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));\n    }, {});\n    return Object.keys(generatedMap).length > 0 ? generatedMap : undefined;\n  }\n  /**\n   * Differentiate columns of this table and columns from the given column metadatas columns\n   * and returns only changed.\n   */\n  findChangedColumns(tableColumns, columnMetadatas) {\n    return columnMetadatas.filter(columnMetadata => {\n      const tableColumn = tableColumns.find(c => c.name === columnMetadata.databaseName);\n      if (!tableColumn) return false; // we don't need new columns, we only need exist and changed\n      // console.log(\"table:\", columnMetadata.entityMetadata.tableName);\n      // console.log(\"name:\", tableColumn.name, columnMetadata.databaseName);\n      // console.log(\"type:\", tableColumn.type, this.normalizeType(columnMetadata));\n      // console.log(\"length:\", tableColumn.length, columnMetadata.length);\n      // console.log(\"width:\", tableColumn.width, columnMetadata.width);\n      // console.log(\"precision:\", tableColumn.precision, columnMetadata.precision);\n      // console.log(\"scale:\", tableColumn.scale, columnMetadata.scale);\n      // console.log(\"zerofill:\", tableColumn.zerofill, columnMetadata.zerofill);\n      // console.log(\"unsigned:\", tableColumn.unsigned, columnMetadata.unsigned);\n      // console.log(\"asExpression:\", tableColumn.asExpression, columnMetadata.asExpression);\n      // console.log(\"generatedType:\", tableColumn.generatedType, columnMetadata.generatedType);\n      // console.log(\"comment:\", tableColumn.comment, this.escapeComment(columnMetadata.comment));\n      // console.log(\"default:\", tableColumn.default, columnMetadata.default);\n      // console.log(\"enum:\", tableColumn.enum, columnMetadata.enum);\n      // console.log(\"default changed:\", !this.compareDefaultValues(this.normalizeDefault(columnMetadata), tableColumn.default));\n      // console.log(\"onUpdate:\", tableColumn.onUpdate, columnMetadata.onUpdate);\n      // console.log(\"isPrimary:\", tableColumn.isPrimary, columnMetadata.isPrimary);\n      // console.log(\"isNullable:\", tableColumn.isNullable, columnMetadata.isNullable);\n      // console.log(\"isUnique:\", tableColumn.isUnique, this.normalizeIsUnique(columnMetadata));\n      // console.log(\"isGenerated:\", tableColumn.isGenerated, columnMetadata.isGenerated);\n      // console.log((columnMetadata.generationStrategy !== \"uuid\" && tableColumn.isGenerated !== columnMetadata.isGenerated));\n      // console.log(\"==========================================\");\n      let columnMetadataLength = columnMetadata.length;\n      if (!columnMetadataLength && columnMetadata.generationStrategy === \"uuid\") {\n        // fixing #3374\n        columnMetadataLength = this.getColumnLength(columnMetadata);\n      }\n      return tableColumn.name !== columnMetadata.databaseName || tableColumn.type !== this.normalizeType(columnMetadata) || tableColumn.length !== columnMetadataLength || tableColumn.width !== columnMetadata.width || tableColumn.precision !== columnMetadata.precision || tableColumn.scale !== columnMetadata.scale || tableColumn.zerofill !== columnMetadata.zerofill || tableColumn.unsigned !== columnMetadata.unsigned || tableColumn.asExpression !== columnMetadata.asExpression || tableColumn.generatedType !== columnMetadata.generatedType || tableColumn.comment !== this.escapeComment(columnMetadata.comment) || !this.compareDefaultValues(this.normalizeDefault(columnMetadata), tableColumn.default) || tableColumn.enum && columnMetadata.enum && !OrmUtils.isArraysEqual(tableColumn.enum, columnMetadata.enum.map(val => val + \"\")) || tableColumn.onUpdate !== columnMetadata.onUpdate || tableColumn.isPrimary !== columnMetadata.isPrimary || tableColumn.isNullable !== columnMetadata.isNullable || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata) || columnMetadata.generationStrategy !== \"uuid\" && tableColumn.isGenerated !== columnMetadata.isGenerated;\n    });\n  }\n  /**\n   * Returns true if driver supports RETURNING / OUTPUT statement.\n   */\n  isReturningSqlSupported() {\n    return false;\n  }\n  /**\n   * Returns true if driver supports uuid values generation on its own.\n   */\n  isUUIDGenerationSupported() {\n    return false;\n  }\n  /**\n   * Returns true if driver supports fulltext indices.\n   */\n  isFullTextColumnTypeSupported() {\n    return true;\n  }\n  /**\n   * Creates an escaped parameter.\n   */\n  createParameter(parameterName, index) {\n    return \"?\";\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Loads all driver dependencies.\n   */\n  loadDependencies() {\n    const DataApiDriver = this.options.driver || PlatformTools.load(\"typeorm-aurora-data-api-driver\");\n    this.DataApiDriver = DataApiDriver;\n    // Driver uses rollup for publishing, which has issues when using typeorm in combination with webpack\n    // See https://github.com/webpack/webpack/issues/4742#issuecomment-295556787\n    this.DataApiDriver = this.DataApiDriver.default || this.DataApiDriver;\n  }\n  /**\n   * Creates a new connection pool for a given database credentials.\n   */\n  createConnectionOptions(options, credentials) {\n    credentials = Object.assign({}, credentials, DriverUtils.buildDriverOptions(credentials)); // todo: do it better way\n    // build connection options for the driver\n    return Object.assign({}, {\n      resourceArn: options.resourceArn,\n      secretArn: options.secretArn,\n      database: options.database,\n      region: options.region,\n      type: options.type\n    }, {\n      host: credentials.host,\n      user: credentials.username,\n      password: credentials.password,\n      database: credentials.database,\n      port: credentials.port,\n      ssl: options.ssl\n    }, options.extra || {});\n  }\n  /**\n   * Creates a new connection pool for a given database credentials.\n   */\n  async createPool(connectionOptions) {\n    return {};\n  }\n  /**\n   * Attaches all required base handlers to a database connection, such as the unhandled error handler.\n   */\n  prepareDbConnection(connection) {\n    const {\n      logger\n    } = this.connection;\n    /**\n     * Attaching an error handler to connection errors is essential, as, otherwise, errors raised will go unhandled and\n     * cause the hosting app to crash.\n     */\n    if (connection.listeners(\"error\").length === 0) {\n      connection.on(\"error\", error => logger.log(\"warn\", `MySQL connection raised an error. ${error}`));\n    }\n    return connection;\n  }\n  /**\n   * Checks if \"DEFAULT\" values in the column metadata and in the database are equal.\n   */\n  compareDefaultValues(columnMetadataValue, databaseValue) {\n    if (typeof columnMetadataValue === \"string\" && typeof databaseValue === \"string\") {\n      // we need to cut out \"'\" because in mysql we can understand returned value is a string or a function\n      // as result compare cannot understand if default is really changed or not\n      columnMetadataValue = columnMetadataValue.replace(/^'+|'+$/g, \"\");\n      databaseValue = databaseValue.replace(/^'+|'+$/g, \"\");\n    }\n    return columnMetadataValue === databaseValue;\n  }\n  /**\n   * Escapes a given comment.\n   */\n  escapeComment(comment) {\n    if (!comment) return comment;\n    comment = comment.replace(/\\u0000/g, \"\"); // Null bytes aren't allowed in comments\n    return comment;\n  }\n}","map":{"version":3,"names":["DriverUtils","AuroraMysqlQueryRunner","DateUtils","PlatformTools","RdbmsSchemaBuilder","OrmUtils","ApplyValueTransformers","TypeORMError","InstanceChecker","AuroraMysqlDriver","constructor","connection","isReplicated","treeSupport","transactionSupport","supportedDataTypes","supportedUpsertTypes","spatialTypes","withLengthColumnTypes","withWidthColumnTypes","withPrecisionColumnTypes","withScaleColumnTypes","unsignedAndZerofillTypes","mappedDataTypes","createDate","createDatePrecision","createDateDefault","updateDate","updateDatePrecision","updateDateDefault","deleteDate","deleteDatePrecision","deleteDateNullable","version","treeLevel","migrationId","migrationName","migrationTimestamp","cacheId","cacheIdentifier","cacheTime","cacheDuration","cacheQuery","cacheResult","metadataType","metadataDatabase","metadataSchema","metadataTable","metadataName","metadataValue","dataTypeDefaults","varchar","length","nvarchar","char","binary","varbinary","decimal","precision","scale","dec","numeric","fixed","float","double","time","datetime","timestamp","bit","width","int","integer","tinyint","smallint","mediumint","bigint","maxAliasLength","cteCapabilities","enabled","options","loadDependencies","client","DataApiDriver","region","secretArn","resourceArn","database","query","parameters","logger","logQuery","serviceConfigOptions","formatOptions","buildDriverOptions","connect","queryRunner","createQueryRunner","getCurrentDatabase","release","afterConnect","Promise","resolve","disconnect","createSchemaBuilder","mode","escapeQueryWithParameters","sql","nativeParameters","escapedParameters","Object","keys","map","key","replace","full","isArray","hasOwnProperty","value","v","push","createParameter","join","escape","columnName","buildTableName","tableName","schema","tablePath","unshift","parseTableName","target","driverDatabase","driverSchema","undefined","isTable","isView","parsed","name","isTableForeignKey","referencedTableName","referencedDatabase","referencedSchema","isEntityMetadata","parts","split","preparePersistentValue","columnMetadata","transformer","transformTo","castParameters","type","Boolean","mixedDateToDateString","mixedDateToTimeString","JSON","stringify","Date","mixedDateToDate","simpleArrayToString","simpleJsonToString","prepareHydratedValue","transformFrom","normalizeHydratedDate","parse","mixedTimeToString","stringToSimpleArray","stringToSimpleJson","enum","isNaN","indexOf","parseInt","Number","normalizeType","column","String","Buffer","normalizeDefault","defaultValue","default","normalizeIsUnique","entityMetadata","indices","some","idx","isUnique","columns","getColumnLength","toString","generationStrategy","createFullType","obtainMasterConnection","ok","fail","poolCluster","getConnection","err","dbConnection","prepareDbConnection","pool","obtainSlaveConnection","createGeneratedMap","metadata","insertResult","entityIndex","generatedMap","generatedColumns","reduce","generatedColumn","insertId","mergeDeep","createValueMap","findChangedColumns","tableColumns","columnMetadatas","filter","tableColumn","find","c","databaseName","columnMetadataLength","zerofill","unsigned","asExpression","generatedType","comment","escapeComment","compareDefaultValues","isArraysEqual","val","onUpdate","isPrimary","isNullable","isGenerated","isReturningSqlSupported","isUUIDGenerationSupported","isFullTextColumnTypeSupported","parameterName","index","driver","load","createConnectionOptions","credentials","assign","host","user","username","password","port","ssl","extra","createPool","connectionOptions","listeners","on","error","log","columnMetadataValue","databaseValue"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\driver\\aurora-mysql\\AuroraMysqlDriver.ts"],"sourcesContent":["import { Driver } from \"../Driver\"\nimport { DriverUtils } from \"../DriverUtils\"\nimport { CteCapabilities } from \"../types/CteCapabilities\"\nimport { AuroraMysqlQueryRunner } from \"./AuroraMysqlQueryRunner\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { ColumnMetadata } from \"../../metadata/ColumnMetadata\"\nimport { DateUtils } from \"../../util/DateUtils\"\nimport { PlatformTools } from \"../../platform/PlatformTools\"\nimport { DataSource } from \"../../data-source\"\nimport { RdbmsSchemaBuilder } from \"../../schema-builder/RdbmsSchemaBuilder\"\nimport { AuroraMysqlConnectionOptions } from \"./AuroraMysqlConnectionOptions\"\nimport { MappedColumnTypes } from \"../types/MappedColumnTypes\"\nimport { ColumnType } from \"../types/ColumnTypes\"\nimport { DataTypeDefaults } from \"../types/DataTypeDefaults\"\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\"\nimport { AuroraMysqlConnectionCredentialsOptions } from \"./AuroraMysqlConnectionCredentialsOptions\"\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { ApplyValueTransformers } from \"../../util/ApplyValueTransformers\"\nimport { ReplicationMode } from \"../types/ReplicationMode\"\nimport { TypeORMError } from \"../../error\"\nimport { Table } from \"../../schema-builder/table/Table\"\nimport { View } from \"../../schema-builder/view/View\"\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\"\nimport { InstanceChecker } from \"../../util/InstanceChecker\"\nimport { UpsertType } from \"../types/UpsertType\"\n\n/**\n * Organizes communication with MySQL DBMS.\n */\nexport class AuroraMysqlDriver implements Driver {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    connection: DataSource\n\n    /**\n     * Aurora Data API underlying library.\n     */\n    DataApiDriver: any\n\n    client: any\n\n    /**\n     * Connection pool.\n     * Used in non-replication mode.\n     */\n    pool: any\n\n    /**\n     * Pool cluster used in replication mode.\n     */\n    poolCluster: any\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection options.\n     */\n    options: AuroraMysqlConnectionOptions\n\n    /**\n     * Database name used to perform all write queries.\n     */\n    database?: string\n\n    /**\n     * Schema name used to perform all write queries.\n     */\n    schema?: string\n\n    /**\n     * Indicates if replication is enabled.\n     */\n    isReplicated: boolean = false\n\n    /**\n     * Indicates if tree tables are supported by this driver.\n     */\n    treeSupport = true\n\n    /**\n     * Represent transaction support by this driver\n     */\n    transactionSupport = \"nested\" as const\n\n    /**\n     * Gets list of supported column data types by a driver.\n     *\n     * @see https://www.tutorialspoint.com/mysql/mysql-data-types.htm\n     * @see https://dev.mysql.com/doc/refman/8.0/en/data-types.html\n     */\n    supportedDataTypes: ColumnType[] = [\n        // numeric types\n        \"bit\",\n        \"int\",\n        \"integer\", // synonym for int\n        \"tinyint\",\n        \"smallint\",\n        \"mediumint\",\n        \"bigint\",\n        \"float\",\n        \"double\",\n        \"double precision\", // synonym for double\n        \"real\", // synonym for double\n        \"decimal\",\n        \"dec\", // synonym for decimal\n        \"numeric\", // synonym for decimal\n        \"fixed\", // synonym for decimal\n        \"bool\", // synonym for tinyint\n        \"boolean\", // synonym for tinyint\n        // date and time types\n        \"date\",\n        \"datetime\",\n        \"timestamp\",\n        \"time\",\n        \"year\",\n        // string types\n        \"char\",\n        \"nchar\", // synonym for national char\n        \"national char\",\n        \"varchar\",\n        \"nvarchar\", // synonym for national varchar\n        \"national varchar\",\n        \"blob\",\n        \"text\",\n        \"tinyblob\",\n        \"tinytext\",\n        \"mediumblob\",\n        \"mediumtext\",\n        \"longblob\",\n        \"longtext\",\n        \"enum\",\n        \"set\",\n        \"binary\",\n        \"varbinary\",\n        // json data type\n        \"json\",\n        // spatial data types\n        \"geometry\",\n        \"point\",\n        \"linestring\",\n        \"polygon\",\n        \"multipoint\",\n        \"multilinestring\",\n        \"multipolygon\",\n        \"geometrycollection\",\n    ]\n\n    /**\n     * Returns type of upsert supported by driver if any\n     */\n    supportedUpsertTypes: UpsertType[] = [\"on-duplicate-key-update\"]\n\n    /**\n     * Gets list of spatial column data types.\n     */\n    spatialTypes: ColumnType[] = [\n        \"geometry\",\n        \"point\",\n        \"linestring\",\n        \"polygon\",\n        \"multipoint\",\n        \"multilinestring\",\n        \"multipolygon\",\n        \"geometrycollection\",\n    ]\n\n    /**\n     * Gets list of column data types that support length by a driver.\n     */\n    withLengthColumnTypes: ColumnType[] = [\n        \"char\",\n        \"varchar\",\n        \"nvarchar\",\n        \"binary\",\n        \"varbinary\",\n    ]\n\n    /**\n     * Gets list of column data types that support length by a driver.\n     */\n    withWidthColumnTypes: ColumnType[] = [\n        \"bit\",\n        \"tinyint\",\n        \"smallint\",\n        \"mediumint\",\n        \"int\",\n        \"integer\",\n        \"bigint\",\n    ]\n\n    /**\n     * Gets list of column data types that support precision by a driver.\n     */\n    withPrecisionColumnTypes: ColumnType[] = [\n        \"decimal\",\n        \"dec\",\n        \"numeric\",\n        \"fixed\",\n        \"float\",\n        \"double\",\n        \"double precision\",\n        \"real\",\n        \"time\",\n        \"datetime\",\n        \"timestamp\",\n    ]\n\n    /**\n     * Gets list of column data types that supports scale by a driver.\n     */\n    withScaleColumnTypes: ColumnType[] = [\n        \"decimal\",\n        \"dec\",\n        \"numeric\",\n        \"fixed\",\n        \"float\",\n        \"double\",\n        \"double precision\",\n        \"real\",\n    ]\n\n    /**\n     * Gets list of column data types that supports UNSIGNED and ZEROFILL attributes.\n     */\n    unsignedAndZerofillTypes: ColumnType[] = [\n        \"int\",\n        \"integer\",\n        \"smallint\",\n        \"tinyint\",\n        \"mediumint\",\n        \"bigint\",\n        \"decimal\",\n        \"dec\",\n        \"numeric\",\n        \"fixed\",\n        \"float\",\n        \"double\",\n        \"double precision\",\n        \"real\",\n    ]\n\n    /**\n     * ORM has special columns and we need to know what database column types should be for those columns.\n     * Column types are driver dependant.\n     */\n    mappedDataTypes: MappedColumnTypes = {\n        createDate: \"datetime\",\n        createDatePrecision: 6,\n        createDateDefault: \"CURRENT_TIMESTAMP(6)\",\n        updateDate: \"datetime\",\n        updateDatePrecision: 6,\n        updateDateDefault: \"CURRENT_TIMESTAMP(6)\",\n        deleteDate: \"datetime\",\n        deleteDatePrecision: 6,\n        deleteDateNullable: true,\n        version: \"int\",\n        treeLevel: \"int\",\n        migrationId: \"int\",\n        migrationName: \"varchar\",\n        migrationTimestamp: \"bigint\",\n        cacheId: \"int\",\n        cacheIdentifier: \"varchar\",\n        cacheTime: \"bigint\",\n        cacheDuration: \"int\",\n        cacheQuery: \"text\",\n        cacheResult: \"text\",\n        metadataType: \"varchar\",\n        metadataDatabase: \"varchar\",\n        metadataSchema: \"varchar\",\n        metadataTable: \"varchar\",\n        metadataName: \"varchar\",\n        metadataValue: \"text\",\n    }\n\n    /**\n     * Default values of length, precision and scale depends on column data type.\n     * Used in the cases when length/precision/scale is not specified by user.\n     */\n    dataTypeDefaults: DataTypeDefaults = {\n        varchar: { length: 255 },\n        nvarchar: { length: 255 },\n        \"national varchar\": { length: 255 },\n        char: { length: 1 },\n        binary: { length: 1 },\n        varbinary: { length: 255 },\n        decimal: { precision: 10, scale: 0 },\n        dec: { precision: 10, scale: 0 },\n        numeric: { precision: 10, scale: 0 },\n        fixed: { precision: 10, scale: 0 },\n        float: { precision: 12 },\n        double: { precision: 22 },\n        time: { precision: 0 },\n        datetime: { precision: 0 },\n        timestamp: { precision: 0 },\n        bit: { width: 1 },\n        int: { width: 11 },\n        integer: { width: 11 },\n        tinyint: { width: 4 },\n        smallint: { width: 6 },\n        mediumint: { width: 9 },\n        bigint: { width: 20 },\n    }\n\n    /**\n     * Max length allowed by MySQL for aliases.\n     * @see https://dev.mysql.com/doc/refman/5.5/en/identifiers.html\n     */\n    maxAliasLength = 63\n\n    cteCapabilities: CteCapabilities = {\n        enabled: false,\n    }\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(connection: DataSource) {\n        this.connection = connection\n        this.options = connection.options as AuroraMysqlConnectionOptions\n\n        // load mysql package\n        this.loadDependencies()\n\n        this.client = new this.DataApiDriver(\n            this.options.region,\n            this.options.secretArn,\n            this.options.resourceArn,\n            this.options.database,\n            (query: string, parameters?: any[]) =>\n                this.connection.logger.logQuery(query, parameters),\n            this.options.serviceConfigOptions,\n            this.options.formatOptions,\n        )\n\n        this.database = DriverUtils.buildDriverOptions(this.options).database\n\n        // validate options to make sure everything is set\n        // todo: revisit validation with replication in mind\n        // if (!(this.options.host || (this.options.extra && this.options.extra.socketPath)) && !this.options.socketPath)\n        //     throw new DriverOptionNotSetError(\"socketPath and host\");\n        // if (!this.options.username)\n        //     throw new DriverOptionNotSetError(\"username\");\n        // if (!this.options.database)\n        //     throw new DriverOptionNotSetError(\"database\");\n        // todo: check what is going on when connection is setup without database and how to connect to a database then?\n        // todo: provide options to auto-create a database if it does not exist yet\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs connection to the database.\n     */\n    async connect(): Promise<void> {\n        if (!this.database) {\n            const queryRunner = await this.createQueryRunner(\"master\")\n\n            this.database = await queryRunner.getCurrentDatabase()\n\n            await queryRunner.release()\n        }\n    }\n\n    /**\n     * Makes any action after connection (e.g. create extensions in Postgres driver).\n     */\n    afterConnect(): Promise<void> {\n        return Promise.resolve()\n    }\n\n    /**\n     * Closes connection with the database.\n     */\n    async disconnect(): Promise<void> {}\n\n    /**\n     * Creates a schema builder used to build and sync a schema.\n     */\n    createSchemaBuilder() {\n        return new RdbmsSchemaBuilder(this.connection)\n    }\n\n    /**\n     * Creates a query runner used to execute database queries.\n     */\n    createQueryRunner(mode: ReplicationMode) {\n        return new AuroraMysqlQueryRunner(\n            this,\n            new this.DataApiDriver(\n                this.options.region,\n                this.options.secretArn,\n                this.options.resourceArn,\n                this.options.database,\n                (query: string, parameters?: any[]) =>\n                    this.connection.logger.logQuery(query, parameters),\n                this.options.serviceConfigOptions,\n                this.options.formatOptions,\n            ),\n        )\n    }\n\n    /**\n     * Replaces parameters in the given sql with special escaping character\n     * and an array of parameter names to be passed to a query.\n     */\n    escapeQueryWithParameters(\n        sql: string,\n        parameters: ObjectLiteral,\n        nativeParameters: ObjectLiteral,\n    ): [string, any[]] {\n        const escapedParameters: any[] = Object.keys(nativeParameters).map(\n            (key) => nativeParameters[key],\n        )\n        if (!parameters || !Object.keys(parameters).length)\n            return [sql, escapedParameters]\n\n        sql = sql.replace(\n            /:(\\.\\.\\.)?([A-Za-z0-9_.]+)/g,\n            (full, isArray: string, key: string): string => {\n                if (!parameters.hasOwnProperty(key)) {\n                    return full\n                }\n\n                let value: any = parameters[key]\n\n                if (isArray) {\n                    return value\n                        .map((v: any) => {\n                            escapedParameters.push(v)\n                            return this.createParameter(\n                                key,\n                                escapedParameters.length - 1,\n                            )\n                        })\n                        .join(\", \")\n                }\n\n                if (typeof value === \"function\") {\n                    return value()\n                }\n\n                escapedParameters.push(value)\n                return this.createParameter(key, escapedParameters.length - 1)\n            },\n        ) // todo: make replace only in value statements, otherwise problems\n        return [sql, escapedParameters]\n    }\n\n    /**\n     * Escapes a column name.\n     */\n    escape(columnName: string): string {\n        return \"`\" + columnName + \"`\"\n    }\n\n    /**\n     * Build full table name with database name, schema name and table name.\n     * E.g. myDB.mySchema.myTable\n     */\n    buildTableName(\n        tableName: string,\n        schema?: string,\n        database?: string,\n    ): string {\n        let tablePath = [tableName]\n\n        if (database) {\n            tablePath.unshift(database)\n        }\n\n        return tablePath.join(\".\")\n    }\n\n    /**\n     * Parse a target table name or other types and return a normalized table definition.\n     */\n    parseTableName(\n        target: EntityMetadata | Table | View | TableForeignKey | string,\n    ): { database?: string; schema?: string; tableName: string } {\n        const driverDatabase = this.database\n        const driverSchema = undefined\n\n        if (InstanceChecker.isTable(target) || InstanceChecker.isView(target)) {\n            const parsed = this.parseTableName(target.name)\n\n            return {\n                database: target.database || parsed.database || driverDatabase,\n                schema: target.schema || parsed.schema || driverSchema,\n                tableName: parsed.tableName,\n            }\n        }\n\n        if (InstanceChecker.isTableForeignKey(target)) {\n            const parsed = this.parseTableName(target.referencedTableName)\n\n            return {\n                database:\n                    target.referencedDatabase ||\n                    parsed.database ||\n                    driverDatabase,\n                schema:\n                    target.referencedSchema || parsed.schema || driverSchema,\n                tableName: parsed.tableName,\n            }\n        }\n\n        if (InstanceChecker.isEntityMetadata(target)) {\n            // EntityMetadata tableName is never a path\n\n            return {\n                database: target.database || driverDatabase,\n                schema: target.schema || driverSchema,\n                tableName: target.tableName,\n            }\n        }\n\n        const parts = target.split(\".\")\n\n        return {\n            database:\n                (parts.length > 1 ? parts[0] : undefined) || driverDatabase,\n            schema: driverSchema,\n            tableName: parts.length > 1 ? parts[1] : parts[0],\n        }\n    }\n\n    /**\n     * Prepares given value to a value to be persisted, based on its column type and metadata.\n     */\n    preparePersistentValue(value: any, columnMetadata: ColumnMetadata): any {\n        if (columnMetadata.transformer)\n            value = ApplyValueTransformers.transformTo(\n                columnMetadata.transformer,\n                value,\n            )\n\n        if (\n            !this.options.formatOptions ||\n            this.options.formatOptions.castParameters !== false\n        ) {\n            return this.client.preparePersistentValue(value, columnMetadata)\n        }\n\n        if (value === null || value === undefined) return value\n\n        if (columnMetadata.type === Boolean) {\n            return value === true ? 1 : 0\n        } else if (columnMetadata.type === \"date\") {\n            return DateUtils.mixedDateToDateString(value)\n        } else if (columnMetadata.type === \"time\") {\n            return DateUtils.mixedDateToTimeString(value)\n        } else if (columnMetadata.type === \"json\") {\n            return JSON.stringify(value)\n        } else if (\n            columnMetadata.type === \"timestamp\" ||\n            columnMetadata.type === \"datetime\" ||\n            columnMetadata.type === Date\n        ) {\n            return DateUtils.mixedDateToDate(value)\n        } else if (\n            columnMetadata.type === \"simple-array\" ||\n            columnMetadata.type === \"set\"\n        ) {\n            return DateUtils.simpleArrayToString(value)\n        } else if (columnMetadata.type === \"simple-json\") {\n            return DateUtils.simpleJsonToString(value)\n        } else if (\n            columnMetadata.type === \"enum\" ||\n            columnMetadata.type === \"simple-enum\"\n        ) {\n            return \"\" + value\n        }\n\n        return value\n    }\n\n    /**\n     * Prepares given value to a value to be persisted, based on its column type or metadata.\n     */\n    prepareHydratedValue(value: any, columnMetadata: ColumnMetadata): any {\n        if (value === null || value === undefined)\n            return columnMetadata.transformer\n                ? ApplyValueTransformers.transformFrom(\n                      columnMetadata.transformer,\n                      value,\n                  )\n                : value\n\n        if (\n            !this.options.formatOptions ||\n            this.options.formatOptions.castParameters !== false\n        ) {\n            return this.client.prepareHydratedValue(value, columnMetadata)\n        }\n\n        if (\n            columnMetadata.type === Boolean ||\n            columnMetadata.type === \"bool\" ||\n            columnMetadata.type === \"boolean\"\n        ) {\n            value = value ? true : false\n        } else if (\n            columnMetadata.type === \"datetime\" ||\n            columnMetadata.type === Date\n        ) {\n            value = DateUtils.normalizeHydratedDate(value)\n        } else if (columnMetadata.type === \"date\") {\n            value = DateUtils.mixedDateToDateString(value)\n        } else if (columnMetadata.type === \"json\") {\n            value = typeof value === \"string\" ? JSON.parse(value) : value\n        } else if (columnMetadata.type === \"time\") {\n            value = DateUtils.mixedTimeToString(value)\n        } else if (\n            columnMetadata.type === \"simple-array\" ||\n            columnMetadata.type === \"set\"\n        ) {\n            value = DateUtils.stringToSimpleArray(value)\n        } else if (columnMetadata.type === \"simple-json\") {\n            value = DateUtils.stringToSimpleJson(value)\n        } else if (\n            (columnMetadata.type === \"enum\" ||\n                columnMetadata.type === \"simple-enum\") &&\n            columnMetadata.enum &&\n            !isNaN(value) &&\n            columnMetadata.enum.indexOf(parseInt(value)) >= 0\n        ) {\n            // convert to number if that exists in possible enum options\n            value = parseInt(value)\n        } else if (columnMetadata.type === Number) {\n            // convert to number if number\n            value = !isNaN(+value) ? parseInt(value) : value\n        }\n\n        if (columnMetadata.transformer)\n            value = ApplyValueTransformers.transformFrom(\n                columnMetadata.transformer,\n                value,\n            )\n\n        return value\n    }\n\n    /**\n     * Creates a database type from a given column metadata.\n     */\n    normalizeType(column: {\n        type: ColumnType\n        length?: number | string\n        precision?: number | null\n        scale?: number\n    }): string {\n        if (column.type === Number || column.type === \"integer\") {\n            return \"int\"\n        } else if (column.type === String) {\n            return \"varchar\"\n        } else if (column.type === Date) {\n            return \"datetime\"\n        } else if ((column.type as any) === Buffer) {\n            return \"blob\"\n        } else if (column.type === Boolean) {\n            return \"tinyint\"\n        } else if (column.type === \"uuid\") {\n            return \"varchar\"\n        } else if (\n            column.type === \"simple-array\" ||\n            column.type === \"simple-json\"\n        ) {\n            return \"text\"\n        } else if (column.type === \"simple-enum\") {\n            return \"enum\"\n        } else if (\n            column.type === \"double precision\" ||\n            column.type === \"real\"\n        ) {\n            return \"double\"\n        } else if (\n            column.type === \"dec\" ||\n            column.type === \"numeric\" ||\n            column.type === \"fixed\"\n        ) {\n            return \"decimal\"\n        } else if (column.type === \"bool\" || column.type === \"boolean\") {\n            return \"tinyint\"\n        } else if (\n            column.type === \"nvarchar\" ||\n            column.type === \"national varchar\"\n        ) {\n            return \"varchar\"\n        } else if (column.type === \"nchar\" || column.type === \"national char\") {\n            return \"char\"\n        } else {\n            return (column.type as string) || \"\"\n        }\n    }\n\n    /**\n     * Normalizes \"default\" value of the column.\n     */\n    normalizeDefault(columnMetadata: ColumnMetadata): string | undefined {\n        const defaultValue = columnMetadata.default\n\n        if (defaultValue === null) {\n            return undefined\n        }\n\n        if (\n            (columnMetadata.type === \"enum\" ||\n                columnMetadata.type === \"simple-enum\") &&\n            defaultValue !== undefined\n        ) {\n            return `'${defaultValue}'`\n        }\n\n        if (columnMetadata.type === \"set\" && defaultValue !== undefined) {\n            return `'${DateUtils.simpleArrayToString(defaultValue)}'`\n        }\n\n        if (typeof defaultValue === \"number\") {\n            return `${defaultValue}`\n        }\n\n        if (typeof defaultValue === \"boolean\") {\n            return defaultValue ? \"1\" : \"0\"\n        }\n\n        if (typeof defaultValue === \"function\") {\n            return defaultValue()\n        }\n\n        if (typeof defaultValue === \"string\") {\n            return `'${defaultValue}'`\n        }\n\n        if (defaultValue === undefined) {\n            return undefined\n        }\n\n        return `${defaultValue}`\n    }\n\n    /**\n     * Normalizes \"isUnique\" value of the column.\n     */\n    normalizeIsUnique(column: ColumnMetadata): boolean {\n        return column.entityMetadata.indices.some(\n            (idx) =>\n                idx.isUnique &&\n                idx.columns.length === 1 &&\n                idx.columns[0] === column,\n        )\n    }\n\n    /**\n     * Returns default column lengths, which is required on column creation.\n     */\n    getColumnLength(column: ColumnMetadata | TableColumn): string {\n        if (column.length) return column.length.toString()\n\n        /**\n         * fix https://github.com/typeorm/typeorm/issues/1139\n         */\n        if (column.generationStrategy === \"uuid\") return \"36\"\n\n        switch (column.type) {\n            case String:\n            case \"varchar\":\n            case \"nvarchar\":\n            case \"national varchar\":\n                return \"255\"\n            case \"varbinary\":\n                return \"255\"\n            default:\n                return \"\"\n        }\n    }\n\n    /**\n     * Creates column type definition including length, precision and scale\n     */\n    createFullType(column: TableColumn): string {\n        let type = column.type\n\n        // used 'getColumnLength()' method, because MySQL requires column length for `varchar`, `nvarchar` and `varbinary` data types\n        if (this.getColumnLength(column)) {\n            type += `(${this.getColumnLength(column)})`\n        } else if (column.width) {\n            type += `(${column.width})`\n        } else if (\n            column.precision !== null &&\n            column.precision !== undefined &&\n            column.scale !== null &&\n            column.scale !== undefined\n        ) {\n            type += `(${column.precision},${column.scale})`\n        } else if (\n            column.precision !== null &&\n            column.precision !== undefined\n        ) {\n            type += `(${column.precision})`\n        }\n\n        if (column.isArray) type += \" array\"\n\n        return type\n    }\n\n    /**\n     * Obtains a new database connection to a master server.\n     * Used for replication.\n     * If replication is not setup then returns default connection's database connection.\n     */\n    obtainMasterConnection(): Promise<any> {\n        return new Promise<any>((ok, fail) => {\n            if (this.poolCluster) {\n                this.poolCluster.getConnection(\n                    \"MASTER\",\n                    (err: any, dbConnection: any) => {\n                        err\n                            ? fail(err)\n                            : ok(this.prepareDbConnection(dbConnection))\n                    },\n                )\n            } else if (this.pool) {\n                this.pool.getConnection((err: any, dbConnection: any) => {\n                    err ? fail(err) : ok(this.prepareDbConnection(dbConnection))\n                })\n            } else {\n                fail(\n                    new TypeORMError(\n                        `Connection is not established with mysql database`,\n                    ),\n                )\n            }\n        })\n    }\n\n    /**\n     * Obtains a new database connection to a slave server.\n     * Used for replication.\n     * If replication is not setup then returns master (default) connection's database connection.\n     */\n    obtainSlaveConnection(): Promise<any> {\n        if (!this.poolCluster) return this.obtainMasterConnection()\n\n        return new Promise<any>((ok, fail) => {\n            this.poolCluster.getConnection(\n                \"SLAVE*\",\n                (err: any, dbConnection: any) => {\n                    err ? fail(err) : ok(this.prepareDbConnection(dbConnection))\n                },\n            )\n        })\n    }\n\n    /**\n     * Creates generated map of values generated or returned by database after INSERT query.\n     */\n    createGeneratedMap(\n        metadata: EntityMetadata,\n        insertResult: any,\n        entityIndex: number,\n    ) {\n        const generatedMap = metadata.generatedColumns.reduce(\n            (map, generatedColumn) => {\n                let value: any\n                if (\n                    generatedColumn.generationStrategy === \"increment\" &&\n                    insertResult.insertId\n                ) {\n                    // NOTE: When multiple rows is inserted by a single INSERT statement,\n                    // `insertId` is the value generated for the first inserted row only.\n                    value = insertResult.insertId + entityIndex\n                    // } else if (generatedColumn.generationStrategy === \"uuid\") {\n                    //     console.log(\"getting db value:\", generatedColumn.databaseName);\n                    //     value = generatedColumn.getEntityValue(uuidMap);\n                }\n\n                return OrmUtils.mergeDeep(\n                    map,\n                    generatedColumn.createValueMap(value),\n                )\n            },\n            {} as ObjectLiteral,\n        )\n\n        return Object.keys(generatedMap).length > 0 ? generatedMap : undefined\n    }\n\n    /**\n     * Differentiate columns of this table and columns from the given column metadatas columns\n     * and returns only changed.\n     */\n    findChangedColumns(\n        tableColumns: TableColumn[],\n        columnMetadatas: ColumnMetadata[],\n    ): ColumnMetadata[] {\n        return columnMetadatas.filter((columnMetadata) => {\n            const tableColumn = tableColumns.find(\n                (c) => c.name === columnMetadata.databaseName,\n            )\n            if (!tableColumn) return false // we don't need new columns, we only need exist and changed\n\n            // console.log(\"table:\", columnMetadata.entityMetadata.tableName);\n            // console.log(\"name:\", tableColumn.name, columnMetadata.databaseName);\n            // console.log(\"type:\", tableColumn.type, this.normalizeType(columnMetadata));\n            // console.log(\"length:\", tableColumn.length, columnMetadata.length);\n            // console.log(\"width:\", tableColumn.width, columnMetadata.width);\n            // console.log(\"precision:\", tableColumn.precision, columnMetadata.precision);\n            // console.log(\"scale:\", tableColumn.scale, columnMetadata.scale);\n            // console.log(\"zerofill:\", tableColumn.zerofill, columnMetadata.zerofill);\n            // console.log(\"unsigned:\", tableColumn.unsigned, columnMetadata.unsigned);\n            // console.log(\"asExpression:\", tableColumn.asExpression, columnMetadata.asExpression);\n            // console.log(\"generatedType:\", tableColumn.generatedType, columnMetadata.generatedType);\n            // console.log(\"comment:\", tableColumn.comment, this.escapeComment(columnMetadata.comment));\n            // console.log(\"default:\", tableColumn.default, columnMetadata.default);\n            // console.log(\"enum:\", tableColumn.enum, columnMetadata.enum);\n            // console.log(\"default changed:\", !this.compareDefaultValues(this.normalizeDefault(columnMetadata), tableColumn.default));\n            // console.log(\"onUpdate:\", tableColumn.onUpdate, columnMetadata.onUpdate);\n            // console.log(\"isPrimary:\", tableColumn.isPrimary, columnMetadata.isPrimary);\n            // console.log(\"isNullable:\", tableColumn.isNullable, columnMetadata.isNullable);\n            // console.log(\"isUnique:\", tableColumn.isUnique, this.normalizeIsUnique(columnMetadata));\n            // console.log(\"isGenerated:\", tableColumn.isGenerated, columnMetadata.isGenerated);\n            // console.log((columnMetadata.generationStrategy !== \"uuid\" && tableColumn.isGenerated !== columnMetadata.isGenerated));\n            // console.log(\"==========================================\");\n\n            let columnMetadataLength = columnMetadata.length\n            if (\n                !columnMetadataLength &&\n                columnMetadata.generationStrategy === \"uuid\"\n            ) {\n                // fixing #3374\n                columnMetadataLength = this.getColumnLength(columnMetadata)\n            }\n\n            return (\n                tableColumn.name !== columnMetadata.databaseName ||\n                tableColumn.type !== this.normalizeType(columnMetadata) ||\n                tableColumn.length !== columnMetadataLength ||\n                tableColumn.width !== columnMetadata.width ||\n                tableColumn.precision !== columnMetadata.precision ||\n                tableColumn.scale !== columnMetadata.scale ||\n                tableColumn.zerofill !== columnMetadata.zerofill ||\n                tableColumn.unsigned !== columnMetadata.unsigned ||\n                tableColumn.asExpression !== columnMetadata.asExpression ||\n                tableColumn.generatedType !== columnMetadata.generatedType ||\n                tableColumn.comment !==\n                    this.escapeComment(columnMetadata.comment) ||\n                !this.compareDefaultValues(\n                    this.normalizeDefault(columnMetadata),\n                    tableColumn.default,\n                ) ||\n                (tableColumn.enum &&\n                    columnMetadata.enum &&\n                    !OrmUtils.isArraysEqual(\n                        tableColumn.enum,\n                        columnMetadata.enum.map((val) => val + \"\"),\n                    )) ||\n                tableColumn.onUpdate !== columnMetadata.onUpdate ||\n                tableColumn.isPrimary !== columnMetadata.isPrimary ||\n                tableColumn.isNullable !== columnMetadata.isNullable ||\n                tableColumn.isUnique !==\n                    this.normalizeIsUnique(columnMetadata) ||\n                (columnMetadata.generationStrategy !== \"uuid\" &&\n                    tableColumn.isGenerated !== columnMetadata.isGenerated)\n            )\n        })\n    }\n\n    /**\n     * Returns true if driver supports RETURNING / OUTPUT statement.\n     */\n    isReturningSqlSupported(): boolean {\n        return false\n    }\n\n    /**\n     * Returns true if driver supports uuid values generation on its own.\n     */\n    isUUIDGenerationSupported(): boolean {\n        return false\n    }\n\n    /**\n     * Returns true if driver supports fulltext indices.\n     */\n    isFullTextColumnTypeSupported(): boolean {\n        return true\n    }\n\n    /**\n     * Creates an escaped parameter.\n     */\n    createParameter(parameterName: string, index: number): string {\n        return \"?\"\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Loads all driver dependencies.\n     */\n    protected loadDependencies(): void {\n        const DataApiDriver =\n            this.options.driver ||\n            PlatformTools.load(\"typeorm-aurora-data-api-driver\")\n        this.DataApiDriver = DataApiDriver\n\n        // Driver uses rollup for publishing, which has issues when using typeorm in combination with webpack\n        // See https://github.com/webpack/webpack/issues/4742#issuecomment-295556787\n        this.DataApiDriver = this.DataApiDriver.default || this.DataApiDriver\n    }\n\n    /**\n     * Creates a new connection pool for a given database credentials.\n     */\n    protected createConnectionOptions(\n        options: AuroraMysqlConnectionOptions,\n        credentials: AuroraMysqlConnectionCredentialsOptions,\n    ): Promise<any> {\n        credentials = Object.assign(\n            {},\n            credentials,\n            DriverUtils.buildDriverOptions(credentials),\n        ) // todo: do it better way\n\n        // build connection options for the driver\n        return Object.assign(\n            {},\n            {\n                resourceArn: options.resourceArn,\n                secretArn: options.secretArn,\n                database: options.database,\n                region: options.region,\n                type: options.type,\n            },\n            {\n                host: credentials.host,\n                user: credentials.username,\n                password: credentials.password,\n                database: credentials.database,\n                port: credentials.port,\n                ssl: options.ssl,\n            },\n\n            options.extra || {},\n        )\n    }\n\n    /**\n     * Creates a new connection pool for a given database credentials.\n     */\n    protected async createPool(connectionOptions: any): Promise<any> {\n        return {}\n    }\n\n    /**\n     * Attaches all required base handlers to a database connection, such as the unhandled error handler.\n     */\n    private prepareDbConnection(connection: any): any {\n        const { logger } = this.connection\n        /**\n         * Attaching an error handler to connection errors is essential, as, otherwise, errors raised will go unhandled and\n         * cause the hosting app to crash.\n         */\n        if (connection.listeners(\"error\").length === 0) {\n            connection.on(\"error\", (error: any) =>\n                logger.log(\n                    \"warn\",\n                    `MySQL connection raised an error. ${error}`,\n                ),\n            )\n        }\n        return connection\n    }\n\n    /**\n     * Checks if \"DEFAULT\" values in the column metadata and in the database are equal.\n     */\n    protected compareDefaultValues(\n        columnMetadataValue: string | undefined,\n        databaseValue: string | undefined,\n    ): boolean {\n        if (\n            typeof columnMetadataValue === \"string\" &&\n            typeof databaseValue === \"string\"\n        ) {\n            // we need to cut out \"'\" because in mysql we can understand returned value is a string or a function\n            // as result compare cannot understand if default is really changed or not\n            columnMetadataValue = columnMetadataValue.replace(/^'+|'+$/g, \"\")\n            databaseValue = databaseValue.replace(/^'+|'+$/g, \"\")\n        }\n\n        return columnMetadataValue === databaseValue\n    }\n\n    /**\n     * Escapes a given comment.\n     */\n    protected escapeComment(comment?: string) {\n        if (!comment) return comment\n\n        comment = comment.replace(/\\u0000/g, \"\") // Null bytes aren't allowed in comments\n\n        return comment\n    }\n}\n"],"mappings":"AACA,SAASA,WAAW,QAAQ,gBAAgB;AAE5C,SAASC,sBAAsB,QAAQ,0BAA0B;AAGjE,SAASC,SAAS,QAAQ,sBAAsB;AAChD,SAASC,aAAa,QAAQ,8BAA8B;AAE5D,SAASC,kBAAkB,QAAQ,yCAAyC;AAQ5E,SAASC,QAAQ,QAAQ,qBAAqB;AAC9C,SAASC,sBAAsB,QAAQ,mCAAmC;AAE1E,SAASC,YAAY,QAAQ,aAAa;AAI1C,SAASC,eAAe,QAAQ,4BAA4B;AAG5D;;;AAGA,OAAM,MAAOC,iBAAiB;EAgS1B;EACA;EACA;EAEAC,YAAYC,UAAsB;IAxPlC;;;IAGA,KAAAC,YAAY,GAAY,KAAK;IAE7B;;;IAGA,KAAAC,WAAW,GAAG,IAAI;IAElB;;;IAGA,KAAAC,kBAAkB,GAAG,QAAiB;IAEtC;;;;;;IAMA,KAAAC,kBAAkB,GAAiB;IAC/B;IACA,KAAK,EACL,KAAK,EACL,SAAS;IAAE;IACX,SAAS,EACT,UAAU,EACV,WAAW,EACX,QAAQ,EACR,OAAO,EACP,QAAQ,EACR,kBAAkB;IAAE;IACpB,MAAM;IAAE;IACR,SAAS,EACT,KAAK;IAAE;IACP,SAAS;IAAE;IACX,OAAO;IAAE;IACT,MAAM;IAAE;IACR,SAAS;IAAE;IACX;IACA,MAAM,EACN,UAAU,EACV,WAAW,EACX,MAAM,EACN,MAAM;IACN;IACA,MAAM,EACN,OAAO;IAAE;IACT,eAAe,EACf,SAAS,EACT,UAAU;IAAE;IACZ,kBAAkB,EAClB,MAAM,EACN,MAAM,EACN,UAAU,EACV,UAAU,EACV,YAAY,EACZ,YAAY,EACZ,UAAU,EACV,UAAU,EACV,MAAM,EACN,KAAK,EACL,QAAQ,EACR,WAAW;IACX;IACA,MAAM;IACN;IACA,UAAU,EACV,OAAO,EACP,YAAY,EACZ,SAAS,EACT,YAAY,EACZ,iBAAiB,EACjB,cAAc,EACd,oBAAoB,CACvB;IAED;;;IAGA,KAAAC,oBAAoB,GAAiB,CAAC,yBAAyB,CAAC;IAEhE;;;IAGA,KAAAC,YAAY,GAAiB,CACzB,UAAU,EACV,OAAO,EACP,YAAY,EACZ,SAAS,EACT,YAAY,EACZ,iBAAiB,EACjB,cAAc,EACd,oBAAoB,CACvB;IAED;;;IAGA,KAAAC,qBAAqB,GAAiB,CAClC,MAAM,EACN,SAAS,EACT,UAAU,EACV,QAAQ,EACR,WAAW,CACd;IAED;;;IAGA,KAAAC,oBAAoB,GAAiB,CACjC,KAAK,EACL,SAAS,EACT,UAAU,EACV,WAAW,EACX,KAAK,EACL,SAAS,EACT,QAAQ,CACX;IAED;;;IAGA,KAAAC,wBAAwB,GAAiB,CACrC,SAAS,EACT,KAAK,EACL,SAAS,EACT,OAAO,EACP,OAAO,EACP,QAAQ,EACR,kBAAkB,EAClB,MAAM,EACN,MAAM,EACN,UAAU,EACV,WAAW,CACd;IAED;;;IAGA,KAAAC,oBAAoB,GAAiB,CACjC,SAAS,EACT,KAAK,EACL,SAAS,EACT,OAAO,EACP,OAAO,EACP,QAAQ,EACR,kBAAkB,EAClB,MAAM,CACT;IAED;;;IAGA,KAAAC,wBAAwB,GAAiB,CACrC,KAAK,EACL,SAAS,EACT,UAAU,EACV,SAAS,EACT,WAAW,EACX,QAAQ,EACR,SAAS,EACT,KAAK,EACL,SAAS,EACT,OAAO,EACP,OAAO,EACP,QAAQ,EACR,kBAAkB,EAClB,MAAM,CACT;IAED;;;;IAIA,KAAAC,eAAe,GAAsB;MACjCC,UAAU,EAAE,UAAU;MACtBC,mBAAmB,EAAE,CAAC;MACtBC,iBAAiB,EAAE,sBAAsB;MACzCC,UAAU,EAAE,UAAU;MACtBC,mBAAmB,EAAE,CAAC;MACtBC,iBAAiB,EAAE,sBAAsB;MACzCC,UAAU,EAAE,UAAU;MACtBC,mBAAmB,EAAE,CAAC;MACtBC,kBAAkB,EAAE,IAAI;MACxBC,OAAO,EAAE,KAAK;MACdC,SAAS,EAAE,KAAK;MAChBC,WAAW,EAAE,KAAK;MAClBC,aAAa,EAAE,SAAS;MACxBC,kBAAkB,EAAE,QAAQ;MAC5BC,OAAO,EAAE,KAAK;MACdC,eAAe,EAAE,SAAS;MAC1BC,SAAS,EAAE,QAAQ;MACnBC,aAAa,EAAE,KAAK;MACpBC,UAAU,EAAE,MAAM;MAClBC,WAAW,EAAE,MAAM;MACnBC,YAAY,EAAE,SAAS;MACvBC,gBAAgB,EAAE,SAAS;MAC3BC,cAAc,EAAE,SAAS;MACzBC,aAAa,EAAE,SAAS;MACxBC,YAAY,EAAE,SAAS;MACvBC,aAAa,EAAE;KAClB;IAED;;;;IAIA,KAAAC,gBAAgB,GAAqB;MACjCC,OAAO,EAAE;QAAEC,MAAM,EAAE;MAAG,CAAE;MACxBC,QAAQ,EAAE;QAAED,MAAM,EAAE;MAAG,CAAE;MACzB,kBAAkB,EAAE;QAAEA,MAAM,EAAE;MAAG,CAAE;MACnCE,IAAI,EAAE;QAAEF,MAAM,EAAE;MAAC,CAAE;MACnBG,MAAM,EAAE;QAAEH,MAAM,EAAE;MAAC,CAAE;MACrBI,SAAS,EAAE;QAAEJ,MAAM,EAAE;MAAG,CAAE;MAC1BK,OAAO,EAAE;QAAEC,SAAS,EAAE,EAAE;QAAEC,KAAK,EAAE;MAAC,CAAE;MACpCC,GAAG,EAAE;QAAEF,SAAS,EAAE,EAAE;QAAEC,KAAK,EAAE;MAAC,CAAE;MAChCE,OAAO,EAAE;QAAEH,SAAS,EAAE,EAAE;QAAEC,KAAK,EAAE;MAAC,CAAE;MACpCG,KAAK,EAAE;QAAEJ,SAAS,EAAE,EAAE;QAAEC,KAAK,EAAE;MAAC,CAAE;MAClCI,KAAK,EAAE;QAAEL,SAAS,EAAE;MAAE,CAAE;MACxBM,MAAM,EAAE;QAAEN,SAAS,EAAE;MAAE,CAAE;MACzBO,IAAI,EAAE;QAAEP,SAAS,EAAE;MAAC,CAAE;MACtBQ,QAAQ,EAAE;QAAER,SAAS,EAAE;MAAC,CAAE;MAC1BS,SAAS,EAAE;QAAET,SAAS,EAAE;MAAC,CAAE;MAC3BU,GAAG,EAAE;QAAEC,KAAK,EAAE;MAAC,CAAE;MACjBC,GAAG,EAAE;QAAED,KAAK,EAAE;MAAE,CAAE;MAClBE,OAAO,EAAE;QAAEF,KAAK,EAAE;MAAE,CAAE;MACtBG,OAAO,EAAE;QAAEH,KAAK,EAAE;MAAC,CAAE;MACrBI,QAAQ,EAAE;QAAEJ,KAAK,EAAE;MAAC,CAAE;MACtBK,SAAS,EAAE;QAAEL,KAAK,EAAE;MAAC,CAAE;MACvBM,MAAM,EAAE;QAAEN,KAAK,EAAE;MAAE;KACtB;IAED;;;;IAIA,KAAAO,cAAc,GAAG,EAAE;IAEnB,KAAAC,eAAe,GAAoB;MAC/BC,OAAO,EAAE;KACZ;IAOG,IAAI,CAACnE,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACoE,OAAO,GAAGpE,UAAU,CAACoE,OAAuC;IAEjE;IACA,IAAI,CAACC,gBAAgB,EAAE;IAEvB,IAAI,CAACC,MAAM,GAAG,IAAI,IAAI,CAACC,aAAa,CAChC,IAAI,CAACH,OAAO,CAACI,MAAM,EACnB,IAAI,CAACJ,OAAO,CAACK,SAAS,EACtB,IAAI,CAACL,OAAO,CAACM,WAAW,EACxB,IAAI,CAACN,OAAO,CAACO,QAAQ,EACrB,CAACC,KAAa,EAAEC,UAAkB,KAC9B,IAAI,CAAC7E,UAAU,CAAC8E,MAAM,CAACC,QAAQ,CAACH,KAAK,EAAEC,UAAU,CAAC,EACtD,IAAI,CAACT,OAAO,CAACY,oBAAoB,EACjC,IAAI,CAACZ,OAAO,CAACa,aAAa,CAC7B;IAED,IAAI,CAACN,QAAQ,GAAGtF,WAAW,CAAC6F,kBAAkB,CAAC,IAAI,CAACd,OAAO,CAAC,CAACO,QAAQ;IAErE;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;EACJ;EAEA;EACA;EACA;EAEA;;;EAGA,MAAMQ,OAAOA,CAAA;IACT,IAAI,CAAC,IAAI,CAACR,QAAQ,EAAE;MAChB,MAAMS,WAAW,GAAG,MAAM,IAAI,CAACC,iBAAiB,CAAC,QAAQ,CAAC;MAE1D,IAAI,CAACV,QAAQ,GAAG,MAAMS,WAAW,CAACE,kBAAkB,EAAE;MAEtD,MAAMF,WAAW,CAACG,OAAO,EAAE;IAC/B;EACJ;EAEA;;;EAGAC,YAAYA,CAAA;IACR,OAAOC,OAAO,CAACC,OAAO,EAAE;EAC5B;EAEA;;;EAGA,MAAMC,UAAUA,CAAA,GAAmB;EAEnC;;;EAGAC,mBAAmBA,CAAA;IACf,OAAO,IAAInG,kBAAkB,CAAC,IAAI,CAACO,UAAU,CAAC;EAClD;EAEA;;;EAGAqF,iBAAiBA,CAACQ,IAAqB;IACnC,OAAO,IAAIvG,sBAAsB,CAC7B,IAAI,EACJ,IAAI,IAAI,CAACiF,aAAa,CAClB,IAAI,CAACH,OAAO,CAACI,MAAM,EACnB,IAAI,CAACJ,OAAO,CAACK,SAAS,EACtB,IAAI,CAACL,OAAO,CAACM,WAAW,EACxB,IAAI,CAACN,OAAO,CAACO,QAAQ,EACrB,CAACC,KAAa,EAAEC,UAAkB,KAC9B,IAAI,CAAC7E,UAAU,CAAC8E,MAAM,CAACC,QAAQ,CAACH,KAAK,EAAEC,UAAU,CAAC,EACtD,IAAI,CAACT,OAAO,CAACY,oBAAoB,EACjC,IAAI,CAACZ,OAAO,CAACa,aAAa,CAC7B,CACJ;EACL;EAEA;;;;EAIAa,yBAAyBA,CACrBC,GAAW,EACXlB,UAAyB,EACzBmB,gBAA+B;IAE/B,MAAMC,iBAAiB,GAAUC,MAAM,CAACC,IAAI,CAACH,gBAAgB,CAAC,CAACI,GAAG,CAC7DC,GAAG,IAAKL,gBAAgB,CAACK,GAAG,CAAC,CACjC;IACD,IAAI,CAACxB,UAAU,IAAI,CAACqB,MAAM,CAACC,IAAI,CAACtB,UAAU,CAAC,CAACpC,MAAM,EAC9C,OAAO,CAACsD,GAAG,EAAEE,iBAAiB,CAAC;IAEnCF,GAAG,GAAGA,GAAG,CAACO,OAAO,CACb,6BAA6B,EAC7B,CAACC,IAAI,EAAEC,OAAe,EAAEH,GAAW,KAAY;MAC3C,IAAI,CAACxB,UAAU,CAAC4B,cAAc,CAACJ,GAAG,CAAC,EAAE;QACjC,OAAOE,IAAI;MACf;MAEA,IAAIG,KAAK,GAAQ7B,UAAU,CAACwB,GAAG,CAAC;MAEhC,IAAIG,OAAO,EAAE;QACT,OAAOE,KAAK,CACPN,GAAG,CAAEO,CAAM,IAAI;UACZV,iBAAiB,CAACW,IAAI,CAACD,CAAC,CAAC;UACzB,OAAO,IAAI,CAACE,eAAe,CACvBR,GAAG,EACHJ,iBAAiB,CAACxD,MAAM,GAAG,CAAC,CAC/B;QACL,CAAC,CAAC,CACDqE,IAAI,CAAC,IAAI,CAAC;MACnB;MAEA,IAAI,OAAOJ,KAAK,KAAK,UAAU,EAAE;QAC7B,OAAOA,KAAK,EAAE;MAClB;MAEAT,iBAAiB,CAACW,IAAI,CAACF,KAAK,CAAC;MAC7B,OAAO,IAAI,CAACG,eAAe,CAACR,GAAG,EAAEJ,iBAAiB,CAACxD,MAAM,GAAG,CAAC,CAAC;IAClE,CAAC,CACJ,EAAC;IACF,OAAO,CAACsD,GAAG,EAAEE,iBAAiB,CAAC;EACnC;EAEA;;;EAGAc,MAAMA,CAACC,UAAkB;IACrB,OAAO,GAAG,GAAGA,UAAU,GAAG,GAAG;EACjC;EAEA;;;;EAIAC,cAAcA,CACVC,SAAiB,EACjBC,MAAe,EACfxC,QAAiB;IAEjB,IAAIyC,SAAS,GAAG,CAACF,SAAS,CAAC;IAE3B,IAAIvC,QAAQ,EAAE;MACVyC,SAAS,CAACC,OAAO,CAAC1C,QAAQ,CAAC;IAC/B;IAEA,OAAOyC,SAAS,CAACN,IAAI,CAAC,GAAG,CAAC;EAC9B;EAEA;;;EAGAQ,cAAcA,CACVC,MAAgE;IAEhE,MAAMC,cAAc,GAAG,IAAI,CAAC7C,QAAQ;IACpC,MAAM8C,YAAY,GAAGC,SAAS;IAE9B,IAAI7H,eAAe,CAAC8H,OAAO,CAACJ,MAAM,CAAC,IAAI1H,eAAe,CAAC+H,MAAM,CAACL,MAAM,CAAC,EAAE;MACnE,MAAMM,MAAM,GAAG,IAAI,CAACP,cAAc,CAACC,MAAM,CAACO,IAAI,CAAC;MAE/C,OAAO;QACHnD,QAAQ,EAAE4C,MAAM,CAAC5C,QAAQ,IAAIkD,MAAM,CAAClD,QAAQ,IAAI6C,cAAc;QAC9DL,MAAM,EAAEI,MAAM,CAACJ,MAAM,IAAIU,MAAM,CAACV,MAAM,IAAIM,YAAY;QACtDP,SAAS,EAAEW,MAAM,CAACX;OACrB;IACL;IAEA,IAAIrH,eAAe,CAACkI,iBAAiB,CAACR,MAAM,CAAC,EAAE;MAC3C,MAAMM,MAAM,GAAG,IAAI,CAACP,cAAc,CAACC,MAAM,CAACS,mBAAmB,CAAC;MAE9D,OAAO;QACHrD,QAAQ,EACJ4C,MAAM,CAACU,kBAAkB,IACzBJ,MAAM,CAAClD,QAAQ,IACf6C,cAAc;QAClBL,MAAM,EACFI,MAAM,CAACW,gBAAgB,IAAIL,MAAM,CAACV,MAAM,IAAIM,YAAY;QAC5DP,SAAS,EAAEW,MAAM,CAACX;OACrB;IACL;IAEA,IAAIrH,eAAe,CAACsI,gBAAgB,CAACZ,MAAM,CAAC,EAAE;MAC1C;MAEA,OAAO;QACH5C,QAAQ,EAAE4C,MAAM,CAAC5C,QAAQ,IAAI6C,cAAc;QAC3CL,MAAM,EAAEI,MAAM,CAACJ,MAAM,IAAIM,YAAY;QACrCP,SAAS,EAAEK,MAAM,CAACL;OACrB;IACL;IAEA,MAAMkB,KAAK,GAAGb,MAAM,CAACc,KAAK,CAAC,GAAG,CAAC;IAE/B,OAAO;MACH1D,QAAQ,EACJ,CAACyD,KAAK,CAAC3F,MAAM,GAAG,CAAC,GAAG2F,KAAK,CAAC,CAAC,CAAC,GAAGV,SAAS,KAAKF,cAAc;MAC/DL,MAAM,EAAEM,YAAY;MACpBP,SAAS,EAAEkB,KAAK,CAAC3F,MAAM,GAAG,CAAC,GAAG2F,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC;KACnD;EACL;EAEA;;;EAGAE,sBAAsBA,CAAC5B,KAAU,EAAE6B,cAA8B;IAC7D,IAAIA,cAAc,CAACC,WAAW,EAC1B9B,KAAK,GAAG/G,sBAAsB,CAAC8I,WAAW,CACtCF,cAAc,CAACC,WAAW,EAC1B9B,KAAK,CACR;IAEL,IACI,CAAC,IAAI,CAACtC,OAAO,CAACa,aAAa,IAC3B,IAAI,CAACb,OAAO,CAACa,aAAa,CAACyD,cAAc,KAAK,KAAK,EACrD;MACE,OAAO,IAAI,CAACpE,MAAM,CAACgE,sBAAsB,CAAC5B,KAAK,EAAE6B,cAAc,CAAC;IACpE;IAEA,IAAI7B,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAKgB,SAAS,EAAE,OAAOhB,KAAK;IAEvD,IAAI6B,cAAc,CAACI,IAAI,KAAKC,OAAO,EAAE;MACjC,OAAOlC,KAAK,KAAK,IAAI,GAAG,CAAC,GAAG,CAAC;IACjC,CAAC,MAAM,IAAI6B,cAAc,CAACI,IAAI,KAAK,MAAM,EAAE;MACvC,OAAOpJ,SAAS,CAACsJ,qBAAqB,CAACnC,KAAK,CAAC;IACjD,CAAC,MAAM,IAAI6B,cAAc,CAACI,IAAI,KAAK,MAAM,EAAE;MACvC,OAAOpJ,SAAS,CAACuJ,qBAAqB,CAACpC,KAAK,CAAC;IACjD,CAAC,MAAM,IAAI6B,cAAc,CAACI,IAAI,KAAK,MAAM,EAAE;MACvC,OAAOI,IAAI,CAACC,SAAS,CAACtC,KAAK,CAAC;IAChC,CAAC,MAAM,IACH6B,cAAc,CAACI,IAAI,KAAK,WAAW,IACnCJ,cAAc,CAACI,IAAI,KAAK,UAAU,IAClCJ,cAAc,CAACI,IAAI,KAAKM,IAAI,EAC9B;MACE,OAAO1J,SAAS,CAAC2J,eAAe,CAACxC,KAAK,CAAC;IAC3C,CAAC,MAAM,IACH6B,cAAc,CAACI,IAAI,KAAK,cAAc,IACtCJ,cAAc,CAACI,IAAI,KAAK,KAAK,EAC/B;MACE,OAAOpJ,SAAS,CAAC4J,mBAAmB,CAACzC,KAAK,CAAC;IAC/C,CAAC,MAAM,IAAI6B,cAAc,CAACI,IAAI,KAAK,aAAa,EAAE;MAC9C,OAAOpJ,SAAS,CAAC6J,kBAAkB,CAAC1C,KAAK,CAAC;IAC9C,CAAC,MAAM,IACH6B,cAAc,CAACI,IAAI,KAAK,MAAM,IAC9BJ,cAAc,CAACI,IAAI,KAAK,aAAa,EACvC;MACE,OAAO,EAAE,GAAGjC,KAAK;IACrB;IAEA,OAAOA,KAAK;EAChB;EAEA;;;EAGA2C,oBAAoBA,CAAC3C,KAAU,EAAE6B,cAA8B;IAC3D,IAAI7B,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAKgB,SAAS,EACrC,OAAOa,cAAc,CAACC,WAAW,GAC3B7I,sBAAsB,CAAC2J,aAAa,CAChCf,cAAc,CAACC,WAAW,EAC1B9B,KAAK,CACR,GACDA,KAAK;IAEf,IACI,CAAC,IAAI,CAACtC,OAAO,CAACa,aAAa,IAC3B,IAAI,CAACb,OAAO,CAACa,aAAa,CAACyD,cAAc,KAAK,KAAK,EACrD;MACE,OAAO,IAAI,CAACpE,MAAM,CAAC+E,oBAAoB,CAAC3C,KAAK,EAAE6B,cAAc,CAAC;IAClE;IAEA,IACIA,cAAc,CAACI,IAAI,KAAKC,OAAO,IAC/BL,cAAc,CAACI,IAAI,KAAK,MAAM,IAC9BJ,cAAc,CAACI,IAAI,KAAK,SAAS,EACnC;MACEjC,KAAK,GAAGA,KAAK,GAAG,IAAI,GAAG,KAAK;IAChC,CAAC,MAAM,IACH6B,cAAc,CAACI,IAAI,KAAK,UAAU,IAClCJ,cAAc,CAACI,IAAI,KAAKM,IAAI,EAC9B;MACEvC,KAAK,GAAGnH,SAAS,CAACgK,qBAAqB,CAAC7C,KAAK,CAAC;IAClD,CAAC,MAAM,IAAI6B,cAAc,CAACI,IAAI,KAAK,MAAM,EAAE;MACvCjC,KAAK,GAAGnH,SAAS,CAACsJ,qBAAqB,CAACnC,KAAK,CAAC;IAClD,CAAC,MAAM,IAAI6B,cAAc,CAACI,IAAI,KAAK,MAAM,EAAE;MACvCjC,KAAK,GAAG,OAAOA,KAAK,KAAK,QAAQ,GAAGqC,IAAI,CAACS,KAAK,CAAC9C,KAAK,CAAC,GAAGA,KAAK;IACjE,CAAC,MAAM,IAAI6B,cAAc,CAACI,IAAI,KAAK,MAAM,EAAE;MACvCjC,KAAK,GAAGnH,SAAS,CAACkK,iBAAiB,CAAC/C,KAAK,CAAC;IAC9C,CAAC,MAAM,IACH6B,cAAc,CAACI,IAAI,KAAK,cAAc,IACtCJ,cAAc,CAACI,IAAI,KAAK,KAAK,EAC/B;MACEjC,KAAK,GAAGnH,SAAS,CAACmK,mBAAmB,CAAChD,KAAK,CAAC;IAChD,CAAC,MAAM,IAAI6B,cAAc,CAACI,IAAI,KAAK,aAAa,EAAE;MAC9CjC,KAAK,GAAGnH,SAAS,CAACoK,kBAAkB,CAACjD,KAAK,CAAC;IAC/C,CAAC,MAAM,IACH,CAAC6B,cAAc,CAACI,IAAI,KAAK,MAAM,IAC3BJ,cAAc,CAACI,IAAI,KAAK,aAAa,KACzCJ,cAAc,CAACqB,IAAI,IACnB,CAACC,KAAK,CAACnD,KAAK,CAAC,IACb6B,cAAc,CAACqB,IAAI,CAACE,OAAO,CAACC,QAAQ,CAACrD,KAAK,CAAC,CAAC,IAAI,CAAC,EACnD;MACE;MACAA,KAAK,GAAGqD,QAAQ,CAACrD,KAAK,CAAC;IAC3B,CAAC,MAAM,IAAI6B,cAAc,CAACI,IAAI,KAAKqB,MAAM,EAAE;MACvC;MACAtD,KAAK,GAAG,CAACmD,KAAK,CAAC,CAACnD,KAAK,CAAC,GAAGqD,QAAQ,CAACrD,KAAK,CAAC,GAAGA,KAAK;IACpD;IAEA,IAAI6B,cAAc,CAACC,WAAW,EAC1B9B,KAAK,GAAG/G,sBAAsB,CAAC2J,aAAa,CACxCf,cAAc,CAACC,WAAW,EAC1B9B,KAAK,CACR;IAEL,OAAOA,KAAK;EAChB;EAEA;;;EAGAuD,aAAaA,CAACC,MAKb;IACG,IAAIA,MAAM,CAACvB,IAAI,KAAKqB,MAAM,IAAIE,MAAM,CAACvB,IAAI,KAAK,SAAS,EAAE;MACrD,OAAO,KAAK;IAChB,CAAC,MAAM,IAAIuB,MAAM,CAACvB,IAAI,KAAKwB,MAAM,EAAE;MAC/B,OAAO,SAAS;IACpB,CAAC,MAAM,IAAID,MAAM,CAACvB,IAAI,KAAKM,IAAI,EAAE;MAC7B,OAAO,UAAU;IACrB,CAAC,MAAM,IAAKiB,MAAM,CAACvB,IAAY,KAAKyB,MAAM,EAAE;MACxC,OAAO,MAAM;IACjB,CAAC,MAAM,IAAIF,MAAM,CAACvB,IAAI,KAAKC,OAAO,EAAE;MAChC,OAAO,SAAS;IACpB,CAAC,MAAM,IAAIsB,MAAM,CAACvB,IAAI,KAAK,MAAM,EAAE;MAC/B,OAAO,SAAS;IACpB,CAAC,MAAM,IACHuB,MAAM,CAACvB,IAAI,KAAK,cAAc,IAC9BuB,MAAM,CAACvB,IAAI,KAAK,aAAa,EAC/B;MACE,OAAO,MAAM;IACjB,CAAC,MAAM,IAAIuB,MAAM,CAACvB,IAAI,KAAK,aAAa,EAAE;MACtC,OAAO,MAAM;IACjB,CAAC,MAAM,IACHuB,MAAM,CAACvB,IAAI,KAAK,kBAAkB,IAClCuB,MAAM,CAACvB,IAAI,KAAK,MAAM,EACxB;MACE,OAAO,QAAQ;IACnB,CAAC,MAAM,IACHuB,MAAM,CAACvB,IAAI,KAAK,KAAK,IACrBuB,MAAM,CAACvB,IAAI,KAAK,SAAS,IACzBuB,MAAM,CAACvB,IAAI,KAAK,OAAO,EACzB;MACE,OAAO,SAAS;IACpB,CAAC,MAAM,IAAIuB,MAAM,CAACvB,IAAI,KAAK,MAAM,IAAIuB,MAAM,CAACvB,IAAI,KAAK,SAAS,EAAE;MAC5D,OAAO,SAAS;IACpB,CAAC,MAAM,IACHuB,MAAM,CAACvB,IAAI,KAAK,UAAU,IAC1BuB,MAAM,CAACvB,IAAI,KAAK,kBAAkB,EACpC;MACE,OAAO,SAAS;IACpB,CAAC,MAAM,IAAIuB,MAAM,CAACvB,IAAI,KAAK,OAAO,IAAIuB,MAAM,CAACvB,IAAI,KAAK,eAAe,EAAE;MACnE,OAAO,MAAM;IACjB,CAAC,MAAM;MACH,OAAQuB,MAAM,CAACvB,IAAe,IAAI,EAAE;IACxC;EACJ;EAEA;;;EAGA0B,gBAAgBA,CAAC9B,cAA8B;IAC3C,MAAM+B,YAAY,GAAG/B,cAAc,CAACgC,OAAO;IAE3C,IAAID,YAAY,KAAK,IAAI,EAAE;MACvB,OAAO5C,SAAS;IACpB;IAEA,IACI,CAACa,cAAc,CAACI,IAAI,KAAK,MAAM,IAC3BJ,cAAc,CAACI,IAAI,KAAK,aAAa,KACzC2B,YAAY,KAAK5C,SAAS,EAC5B;MACE,OAAO,IAAI4C,YAAY,GAAG;IAC9B;IAEA,IAAI/B,cAAc,CAACI,IAAI,KAAK,KAAK,IAAI2B,YAAY,KAAK5C,SAAS,EAAE;MAC7D,OAAO,IAAInI,SAAS,CAAC4J,mBAAmB,CAACmB,YAAY,CAAC,GAAG;IAC7D;IAEA,IAAI,OAAOA,YAAY,KAAK,QAAQ,EAAE;MAClC,OAAO,GAAGA,YAAY,EAAE;IAC5B;IAEA,IAAI,OAAOA,YAAY,KAAK,SAAS,EAAE;MACnC,OAAOA,YAAY,GAAG,GAAG,GAAG,GAAG;IACnC;IAEA,IAAI,OAAOA,YAAY,KAAK,UAAU,EAAE;MACpC,OAAOA,YAAY,EAAE;IACzB;IAEA,IAAI,OAAOA,YAAY,KAAK,QAAQ,EAAE;MAClC,OAAO,IAAIA,YAAY,GAAG;IAC9B;IAEA,IAAIA,YAAY,KAAK5C,SAAS,EAAE;MAC5B,OAAOA,SAAS;IACpB;IAEA,OAAO,GAAG4C,YAAY,EAAE;EAC5B;EAEA;;;EAGAE,iBAAiBA,CAACN,MAAsB;IACpC,OAAOA,MAAM,CAACO,cAAc,CAACC,OAAO,CAACC,IAAI,CACpCC,GAAG,IACAA,GAAG,CAACC,QAAQ,IACZD,GAAG,CAACE,OAAO,CAACrI,MAAM,KAAK,CAAC,IACxBmI,GAAG,CAACE,OAAO,CAAC,CAAC,CAAC,KAAKZ,MAAM,CAChC;EACL;EAEA;;;EAGAa,eAAeA,CAACb,MAAoC;IAChD,IAAIA,MAAM,CAACzH,MAAM,EAAE,OAAOyH,MAAM,CAACzH,MAAM,CAACuI,QAAQ,EAAE;IAElD;;;IAGA,IAAId,MAAM,CAACe,kBAAkB,KAAK,MAAM,EAAE,OAAO,IAAI;IAErD,QAAQf,MAAM,CAACvB,IAAI;MACf,KAAKwB,MAAM;MACX,KAAK,SAAS;MACd,KAAK,UAAU;MACf,KAAK,kBAAkB;QACnB,OAAO,KAAK;MAChB,KAAK,WAAW;QACZ,OAAO,KAAK;MAChB;QACI,OAAO,EAAE;IACjB;EACJ;EAEA;;;EAGAe,cAAcA,CAAChB,MAAmB;IAC9B,IAAIvB,IAAI,GAAGuB,MAAM,CAACvB,IAAI;IAEtB;IACA,IAAI,IAAI,CAACoC,eAAe,CAACb,MAAM,CAAC,EAAE;MAC9BvB,IAAI,IAAI,IAAI,IAAI,CAACoC,eAAe,CAACb,MAAM,CAAC,GAAG;IAC/C,CAAC,MAAM,IAAIA,MAAM,CAACxG,KAAK,EAAE;MACrBiF,IAAI,IAAI,IAAIuB,MAAM,CAACxG,KAAK,GAAG;IAC/B,CAAC,MAAM,IACHwG,MAAM,CAACnH,SAAS,KAAK,IAAI,IACzBmH,MAAM,CAACnH,SAAS,KAAK2E,SAAS,IAC9BwC,MAAM,CAAClH,KAAK,KAAK,IAAI,IACrBkH,MAAM,CAAClH,KAAK,KAAK0E,SAAS,EAC5B;MACEiB,IAAI,IAAI,IAAIuB,MAAM,CAACnH,SAAS,IAAImH,MAAM,CAAClH,KAAK,GAAG;IACnD,CAAC,MAAM,IACHkH,MAAM,CAACnH,SAAS,KAAK,IAAI,IACzBmH,MAAM,CAACnH,SAAS,KAAK2E,SAAS,EAChC;MACEiB,IAAI,IAAI,IAAIuB,MAAM,CAACnH,SAAS,GAAG;IACnC;IAEA,IAAImH,MAAM,CAAC1D,OAAO,EAAEmC,IAAI,IAAI,QAAQ;IAEpC,OAAOA,IAAI;EACf;EAEA;;;;;EAKAwC,sBAAsBA,CAAA;IAClB,OAAO,IAAI1F,OAAO,CAAM,CAAC2F,EAAE,EAAEC,IAAI,KAAI;MACjC,IAAI,IAAI,CAACC,WAAW,EAAE;QAClB,IAAI,CAACA,WAAW,CAACC,aAAa,CAC1B,QAAQ,EACR,CAACC,GAAQ,EAAEC,YAAiB,KAAI;UAC5BD,GAAG,GACGH,IAAI,CAACG,GAAG,CAAC,GACTJ,EAAE,CAAC,IAAI,CAACM,mBAAmB,CAACD,YAAY,CAAC,CAAC;QACpD,CAAC,CACJ;MACL,CAAC,MAAM,IAAI,IAAI,CAACE,IAAI,EAAE;QAClB,IAAI,CAACA,IAAI,CAACJ,aAAa,CAAC,CAACC,GAAQ,EAAEC,YAAiB,KAAI;UACpDD,GAAG,GAAGH,IAAI,CAACG,GAAG,CAAC,GAAGJ,EAAE,CAAC,IAAI,CAACM,mBAAmB,CAACD,YAAY,CAAC,CAAC;QAChE,CAAC,CAAC;MACN,CAAC,MAAM;QACHJ,IAAI,CACA,IAAIzL,YAAY,CACZ,mDAAmD,CACtD,CACJ;MACL;IACJ,CAAC,CAAC;EACN;EAEA;;;;;EAKAgM,qBAAqBA,CAAA;IACjB,IAAI,CAAC,IAAI,CAACN,WAAW,EAAE,OAAO,IAAI,CAACH,sBAAsB,EAAE;IAE3D,OAAO,IAAI1F,OAAO,CAAM,CAAC2F,EAAE,EAAEC,IAAI,KAAI;MACjC,IAAI,CAACC,WAAW,CAACC,aAAa,CAC1B,QAAQ,EACR,CAACC,GAAQ,EAAEC,YAAiB,KAAI;QAC5BD,GAAG,GAAGH,IAAI,CAACG,GAAG,CAAC,GAAGJ,EAAE,CAAC,IAAI,CAACM,mBAAmB,CAACD,YAAY,CAAC,CAAC;MAChE,CAAC,CACJ;IACL,CAAC,CAAC;EACN;EAEA;;;EAGAI,kBAAkBA,CACdC,QAAwB,EACxBC,YAAiB,EACjBC,WAAmB;IAEnB,MAAMC,YAAY,GAAGH,QAAQ,CAACI,gBAAgB,CAACC,MAAM,CACjD,CAAC/F,GAAG,EAAEgG,eAAe,KAAI;MACrB,IAAI1F,KAAU;MACd,IACI0F,eAAe,CAACnB,kBAAkB,KAAK,WAAW,IAClDc,YAAY,CAACM,QAAQ,EACvB;QACE;QACA;QACA3F,KAAK,GAAGqF,YAAY,CAACM,QAAQ,GAAGL,WAAW;QAC3C;QACA;QACA;MACJ;MAEA,OAAOtM,QAAQ,CAAC4M,SAAS,CACrBlG,GAAG,EACHgG,eAAe,CAACG,cAAc,CAAC7F,KAAK,CAAC,CACxC;IACL,CAAC,EACD,EAAmB,CACtB;IAED,OAAOR,MAAM,CAACC,IAAI,CAAC8F,YAAY,CAAC,CAACxJ,MAAM,GAAG,CAAC,GAAGwJ,YAAY,GAAGvE,SAAS;EAC1E;EAEA;;;;EAIA8E,kBAAkBA,CACdC,YAA2B,EAC3BC,eAAiC;IAEjC,OAAOA,eAAe,CAACC,MAAM,CAAEpE,cAAc,IAAI;MAC7C,MAAMqE,WAAW,GAAGH,YAAY,CAACI,IAAI,CAChCC,CAAC,IAAKA,CAAC,CAAChF,IAAI,KAAKS,cAAc,CAACwE,YAAY,CAChD;MACD,IAAI,CAACH,WAAW,EAAE,OAAO,KAAK,EAAC;MAE/B;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA,IAAII,oBAAoB,GAAGzE,cAAc,CAAC9F,MAAM;MAChD,IACI,CAACuK,oBAAoB,IACrBzE,cAAc,CAAC0C,kBAAkB,KAAK,MAAM,EAC9C;QACE;QACA+B,oBAAoB,GAAG,IAAI,CAACjC,eAAe,CAACxC,cAAc,CAAC;MAC/D;MAEA,OACIqE,WAAW,CAAC9E,IAAI,KAAKS,cAAc,CAACwE,YAAY,IAChDH,WAAW,CAACjE,IAAI,KAAK,IAAI,CAACsB,aAAa,CAAC1B,cAAc,CAAC,IACvDqE,WAAW,CAACnK,MAAM,KAAKuK,oBAAoB,IAC3CJ,WAAW,CAAClJ,KAAK,KAAK6E,cAAc,CAAC7E,KAAK,IAC1CkJ,WAAW,CAAC7J,SAAS,KAAKwF,cAAc,CAACxF,SAAS,IAClD6J,WAAW,CAAC5J,KAAK,KAAKuF,cAAc,CAACvF,KAAK,IAC1C4J,WAAW,CAACK,QAAQ,KAAK1E,cAAc,CAAC0E,QAAQ,IAChDL,WAAW,CAACM,QAAQ,KAAK3E,cAAc,CAAC2E,QAAQ,IAChDN,WAAW,CAACO,YAAY,KAAK5E,cAAc,CAAC4E,YAAY,IACxDP,WAAW,CAACQ,aAAa,KAAK7E,cAAc,CAAC6E,aAAa,IAC1DR,WAAW,CAACS,OAAO,KACf,IAAI,CAACC,aAAa,CAAC/E,cAAc,CAAC8E,OAAO,CAAC,IAC9C,CAAC,IAAI,CAACE,oBAAoB,CACtB,IAAI,CAAClD,gBAAgB,CAAC9B,cAAc,CAAC,EACrCqE,WAAW,CAACrC,OAAO,CACtB,IACAqC,WAAW,CAAChD,IAAI,IACbrB,cAAc,CAACqB,IAAI,IACnB,CAAClK,QAAQ,CAAC8N,aAAa,CACnBZ,WAAW,CAAChD,IAAI,EAChBrB,cAAc,CAACqB,IAAI,CAACxD,GAAG,CAAEqH,GAAG,IAAKA,GAAG,GAAG,EAAE,CAAC,CAC5C,IACNb,WAAW,CAACc,QAAQ,KAAKnF,cAAc,CAACmF,QAAQ,IAChDd,WAAW,CAACe,SAAS,KAAKpF,cAAc,CAACoF,SAAS,IAClDf,WAAW,CAACgB,UAAU,KAAKrF,cAAc,CAACqF,UAAU,IACpDhB,WAAW,CAAC/B,QAAQ,KAChB,IAAI,CAACL,iBAAiB,CAACjC,cAAc,CAAC,IACzCA,cAAc,CAAC0C,kBAAkB,KAAK,MAAM,IACzC2B,WAAW,CAACiB,WAAW,KAAKtF,cAAc,CAACsF,WAAY;IAEnE,CAAC,CAAC;EACN;EAEA;;;EAGAC,uBAAuBA,CAAA;IACnB,OAAO,KAAK;EAChB;EAEA;;;EAGAC,yBAAyBA,CAAA;IACrB,OAAO,KAAK;EAChB;EAEA;;;EAGAC,6BAA6BA,CAAA;IACzB,OAAO,IAAI;EACf;EAEA;;;EAGAnH,eAAeA,CAACoH,aAAqB,EAAEC,KAAa;IAChD,OAAO,GAAG;EACd;EAEA;EACA;EACA;EAEA;;;EAGU7J,gBAAgBA,CAAA;IACtB,MAAME,aAAa,GACf,IAAI,CAACH,OAAO,CAAC+J,MAAM,IACnB3O,aAAa,CAAC4O,IAAI,CAAC,gCAAgC,CAAC;IACxD,IAAI,CAAC7J,aAAa,GAAGA,aAAa;IAElC;IACA;IACA,IAAI,CAACA,aAAa,GAAG,IAAI,CAACA,aAAa,CAACgG,OAAO,IAAI,IAAI,CAAChG,aAAa;EACzE;EAEA;;;EAGU8J,uBAAuBA,CAC7BjK,OAAqC,EACrCkK,WAAoD;IAEpDA,WAAW,GAAGpI,MAAM,CAACqI,MAAM,CACvB,EAAE,EACFD,WAAW,EACXjP,WAAW,CAAC6F,kBAAkB,CAACoJ,WAAW,CAAC,CAC9C,EAAC;IAEF;IACA,OAAOpI,MAAM,CAACqI,MAAM,CAChB,EAAE,EACF;MACI7J,WAAW,EAAEN,OAAO,CAACM,WAAW;MAChCD,SAAS,EAAEL,OAAO,CAACK,SAAS;MAC5BE,QAAQ,EAAEP,OAAO,CAACO,QAAQ;MAC1BH,MAAM,EAAEJ,OAAO,CAACI,MAAM;MACtBmE,IAAI,EAAEvE,OAAO,CAACuE;KACjB,EACD;MACI6F,IAAI,EAAEF,WAAW,CAACE,IAAI;MACtBC,IAAI,EAAEH,WAAW,CAACI,QAAQ;MAC1BC,QAAQ,EAAEL,WAAW,CAACK,QAAQ;MAC9BhK,QAAQ,EAAE2J,WAAW,CAAC3J,QAAQ;MAC9BiK,IAAI,EAAEN,WAAW,CAACM,IAAI;MACtBC,GAAG,EAAEzK,OAAO,CAACyK;KAChB,EAEDzK,OAAO,CAAC0K,KAAK,IAAI,EAAE,CACtB;EACL;EAEA;;;EAGU,MAAMC,UAAUA,CAACC,iBAAsB;IAC7C,OAAO,EAAE;EACb;EAEA;;;EAGQtD,mBAAmBA,CAAC1L,UAAe;IACvC,MAAM;MAAE8E;IAAM,CAAE,GAAG,IAAI,CAAC9E,UAAU;IAClC;;;;IAIA,IAAIA,UAAU,CAACiP,SAAS,CAAC,OAAO,CAAC,CAACxM,MAAM,KAAK,CAAC,EAAE;MAC5CzC,UAAU,CAACkP,EAAE,CAAC,OAAO,EAAGC,KAAU,IAC9BrK,MAAM,CAACsK,GAAG,CACN,MAAM,EACN,qCAAqCD,KAAK,EAAE,CAC/C,CACJ;IACL;IACA,OAAOnP,UAAU;EACrB;EAEA;;;EAGUuN,oBAAoBA,CAC1B8B,mBAAuC,EACvCC,aAAiC;IAEjC,IACI,OAAOD,mBAAmB,KAAK,QAAQ,IACvC,OAAOC,aAAa,KAAK,QAAQ,EACnC;MACE;MACA;MACAD,mBAAmB,GAAGA,mBAAmB,CAAC/I,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC;MACjEgJ,aAAa,GAAGA,aAAa,CAAChJ,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC;IACzD;IAEA,OAAO+I,mBAAmB,KAAKC,aAAa;EAChD;EAEA;;;EAGUhC,aAAaA,CAACD,OAAgB;IACpC,IAAI,CAACA,OAAO,EAAE,OAAOA,OAAO;IAE5BA,OAAO,GAAGA,OAAO,CAAC/G,OAAO,CAAC,SAAS,EAAE,EAAE,CAAC,EAAC;IAEzC,OAAO+G,OAAO;EAClB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}