{"ast":null,"code":"import { RelationIdAttribute } from \"./RelationIdAttribute\";\nexport class RelationIdMetadataToAttributeTransformer {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(expressionMap) {\n    this.expressionMap = expressionMap;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  transform() {\n    // by example:\n    // post has relation id:\n    // @RelationId(post => post.categories) categoryIds\n    // category has relation id\n    // @RelationId(category => category.images) imageIds\n    // we load post and join category\n    // we expect post.categoryIds and post.category.imageIds to have relation ids\n    // first create relation id attributes for all relation id metadatas of the main selected object (post from example)\n    if (this.expressionMap.mainAlias) {\n      this.expressionMap.mainAlias.metadata.relationIds.forEach(relationId => {\n        const attribute = this.metadataToAttribute(this.expressionMap.mainAlias.name, relationId);\n        this.expressionMap.relationIdAttributes.push(attribute);\n      });\n    }\n    // second create relation id attributes for all relation id metadatas of all joined objects (category from example)\n    this.expressionMap.joinAttributes.forEach(join => {\n      // ensure this join has a metadata, because relation id can only work for real orm entities\n      if (!join.metadata || join.metadata.isJunction) return;\n      join.metadata.relationIds.forEach(relationId => {\n        const attribute = this.metadataToAttribute(join.alias.name, relationId);\n        this.expressionMap.relationIdAttributes.push(attribute);\n      });\n    });\n  }\n  // -------------------------------------------------------------------------\n  // Private Methods\n  // -------------------------------------------------------------------------\n  metadataToAttribute(parentAliasName, relationId) {\n    return new RelationIdAttribute(this.expressionMap, {\n      relationName: parentAliasName + \".\" + relationId.relation.propertyName,\n      // category.images\n      mapToProperty: parentAliasName + \".\" + relationId.propertyName,\n      // category.imageIds\n      alias: relationId.alias,\n      queryBuilderFactory: relationId.queryBuilderFactory\n    });\n  }\n}","map":{"version":3,"names":["RelationIdAttribute","RelationIdMetadataToAttributeTransformer","constructor","expressionMap","transform","mainAlias","metadata","relationIds","forEach","relationId","attribute","metadataToAttribute","name","relationIdAttributes","push","joinAttributes","join","isJunction","alias","parentAliasName","relationName","relation","propertyName","mapToProperty","queryBuilderFactory"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\query-builder\\relation-id\\RelationIdMetadataToAttributeTransformer.ts"],"sourcesContent":["import { RelationIdAttribute } from \"./RelationIdAttribute\"\nimport { QueryExpressionMap } from \"../QueryExpressionMap\"\nimport { RelationIdMetadata } from \"../../metadata/RelationIdMetadata\"\n\nexport class RelationIdMetadataToAttributeTransformer {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected expressionMap: QueryExpressionMap) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    transform() {\n        // by example:\n        // post has relation id:\n        // @RelationId(post => post.categories) categoryIds\n        // category has relation id\n        // @RelationId(category => category.images) imageIds\n        // we load post and join category\n        // we expect post.categoryIds and post.category.imageIds to have relation ids\n\n        // first create relation id attributes for all relation id metadatas of the main selected object (post from example)\n        if (this.expressionMap.mainAlias) {\n            this.expressionMap.mainAlias.metadata.relationIds.forEach(\n                (relationId) => {\n                    const attribute = this.metadataToAttribute(\n                        this.expressionMap.mainAlias!.name,\n                        relationId,\n                    )\n                    this.expressionMap.relationIdAttributes.push(attribute)\n                },\n            )\n        }\n\n        // second create relation id attributes for all relation id metadatas of all joined objects (category from example)\n        this.expressionMap.joinAttributes.forEach((join) => {\n            // ensure this join has a metadata, because relation id can only work for real orm entities\n            if (!join.metadata || join.metadata.isJunction) return\n\n            join.metadata.relationIds.forEach((relationId) => {\n                const attribute = this.metadataToAttribute(\n                    join.alias.name,\n                    relationId,\n                )\n                this.expressionMap.relationIdAttributes.push(attribute)\n            })\n        })\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    private metadataToAttribute(\n        parentAliasName: string,\n        relationId: RelationIdMetadata,\n    ): RelationIdAttribute {\n        return new RelationIdAttribute(this.expressionMap, {\n            relationName:\n                parentAliasName + \".\" + relationId.relation.propertyName, // category.images\n            mapToProperty: parentAliasName + \".\" + relationId.propertyName, // category.imageIds\n            alias: relationId.alias,\n            queryBuilderFactory: relationId.queryBuilderFactory,\n        })\n    }\n}\n"],"mappings":"AAAA,SAASA,mBAAmB,QAAQ,uBAAuB;AAI3D,OAAM,MAAOC,wCAAwC;EACjD;EACA;EACA;EAEAC,YAAsBC,aAAiC;IAAjC,KAAAA,aAAa,GAAbA,aAAa;EAAuB;EAE1D;EACA;EACA;EAEAC,SAASA,CAAA;IACL;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA,IAAI,IAAI,CAACD,aAAa,CAACE,SAAS,EAAE;MAC9B,IAAI,CAACF,aAAa,CAACE,SAAS,CAACC,QAAQ,CAACC,WAAW,CAACC,OAAO,CACpDC,UAAU,IAAI;QACX,MAAMC,SAAS,GAAG,IAAI,CAACC,mBAAmB,CACtC,IAAI,CAACR,aAAa,CAACE,SAAU,CAACO,IAAI,EAClCH,UAAU,CACb;QACD,IAAI,CAACN,aAAa,CAACU,oBAAoB,CAACC,IAAI,CAACJ,SAAS,CAAC;MAC3D,CAAC,CACJ;IACL;IAEA;IACA,IAAI,CAACP,aAAa,CAACY,cAAc,CAACP,OAAO,CAAEQ,IAAI,IAAI;MAC/C;MACA,IAAI,CAACA,IAAI,CAACV,QAAQ,IAAIU,IAAI,CAACV,QAAQ,CAACW,UAAU,EAAE;MAEhDD,IAAI,CAACV,QAAQ,CAACC,WAAW,CAACC,OAAO,CAAEC,UAAU,IAAI;QAC7C,MAAMC,SAAS,GAAG,IAAI,CAACC,mBAAmB,CACtCK,IAAI,CAACE,KAAK,CAACN,IAAI,EACfH,UAAU,CACb;QACD,IAAI,CAACN,aAAa,CAACU,oBAAoB,CAACC,IAAI,CAACJ,SAAS,CAAC;MAC3D,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EAEA;EACA;EACA;EAEQC,mBAAmBA,CACvBQ,eAAuB,EACvBV,UAA8B;IAE9B,OAAO,IAAIT,mBAAmB,CAAC,IAAI,CAACG,aAAa,EAAE;MAC/CiB,YAAY,EACRD,eAAe,GAAG,GAAG,GAAGV,UAAU,CAACY,QAAQ,CAACC,YAAY;MAAE;MAC9DC,aAAa,EAAEJ,eAAe,GAAG,GAAG,GAAGV,UAAU,CAACa,YAAY;MAAE;MAChEJ,KAAK,EAAET,UAAU,CAACS,KAAK;MACvBM,mBAAmB,EAAEf,UAAU,CAACe;KACnC,CAAC;EACN","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}