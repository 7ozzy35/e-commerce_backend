{"ast":null,"code":"import { ColumnMetadata } from \"../metadata/ColumnMetadata\";\nimport { EntityMetadata } from \"../metadata/EntityMetadata\";\nimport { ForeignKeyMetadata } from \"../metadata/ForeignKeyMetadata\";\nimport { IndexMetadata } from \"../metadata/IndexMetadata\";\nimport { TypeORMError } from \"../error\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Creates EntityMetadata for junction tables.\n * Junction tables are tables generated by many-to-many relations.\n */\nexport class JunctionEntityMetadataBuilder {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    this.connection = connection;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Builds EntityMetadata for the junction of the given many-to-many relation.\n   */\n  build(relation, joinTable) {\n    const referencedColumns = this.collectReferencedColumns(relation, joinTable);\n    const inverseReferencedColumns = this.collectInverseReferencedColumns(relation, joinTable);\n    const joinTableName = joinTable.name || this.connection.namingStrategy.joinTableName(relation.entityMetadata.tableNameWithoutPrefix, relation.inverseEntityMetadata.tableNameWithoutPrefix, relation.propertyPath, relation.inverseRelation ? relation.inverseRelation.propertyName : \"\");\n    const entityMetadata = new EntityMetadata({\n      connection: this.connection,\n      args: {\n        target: \"\",\n        name: joinTableName,\n        type: \"junction\",\n        database: joinTable.database || relation.entityMetadata.database,\n        schema: joinTable.schema || relation.entityMetadata.schema,\n        synchronize: joinTable.synchronize\n      }\n    });\n    entityMetadata.build();\n    // create original side junction columns\n    const junctionColumns = referencedColumns.map(referencedColumn => {\n      const joinColumn = joinTable.joinColumns ? joinTable.joinColumns.find(joinColumnArgs => {\n        return (!joinColumnArgs.referencedColumnName || joinColumnArgs.referencedColumnName === referencedColumn.propertyName) && !!joinColumnArgs.name;\n      }) : undefined;\n      const columnName = joinColumn && joinColumn.name ? joinColumn.name : this.connection.namingStrategy.joinTableColumnName(relation.entityMetadata.tableNameWithoutPrefix, referencedColumn.propertyName, referencedColumn.databaseName);\n      return new ColumnMetadata({\n        connection: this.connection,\n        entityMetadata: entityMetadata,\n        referencedColumn: referencedColumn,\n        args: {\n          target: \"\",\n          mode: \"virtual\",\n          propertyName: columnName,\n          options: {\n            name: columnName,\n            length: !referencedColumn.length && (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\") &&\n            // some versions of mariadb support the column type and should not try to provide the length property\n            this.connection.driver.normalizeType(referencedColumn) !== \"uuid\" && (referencedColumn.generationStrategy === \"uuid\" || referencedColumn.type === \"uuid\") ? \"36\" : referencedColumn.length,\n            // fix https://github.com/typeorm/typeorm/issues/3604\n            width: referencedColumn.width,\n            type: referencedColumn.type,\n            precision: referencedColumn.precision,\n            scale: referencedColumn.scale,\n            charset: referencedColumn.charset,\n            collation: referencedColumn.collation,\n            zerofill: referencedColumn.zerofill,\n            unsigned: referencedColumn.zerofill ? true : referencedColumn.unsigned,\n            enum: referencedColumn.enum,\n            enumName: referencedColumn.enumName,\n            foreignKeyConstraintName: joinColumn?.foreignKeyConstraintName,\n            nullable: false,\n            primary: true\n          }\n        }\n      });\n    });\n    // create inverse side junction columns\n    const inverseJunctionColumns = inverseReferencedColumns.map(inverseReferencedColumn => {\n      const joinColumn = joinTable.inverseJoinColumns ? joinTable.inverseJoinColumns.find(joinColumnArgs => {\n        return (!joinColumnArgs.referencedColumnName || joinColumnArgs.referencedColumnName === inverseReferencedColumn.propertyName) && !!joinColumnArgs.name;\n      }) : undefined;\n      const columnName = joinColumn && joinColumn.name ? joinColumn.name : this.connection.namingStrategy.joinTableInverseColumnName(relation.inverseEntityMetadata.tableNameWithoutPrefix, inverseReferencedColumn.propertyName, inverseReferencedColumn.databaseName);\n      return new ColumnMetadata({\n        connection: this.connection,\n        entityMetadata: entityMetadata,\n        referencedColumn: inverseReferencedColumn,\n        args: {\n          target: \"\",\n          mode: \"virtual\",\n          propertyName: columnName,\n          options: {\n            length: !inverseReferencedColumn.length && (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\") &&\n            // some versions of mariadb support the column type and should not try to provide the length property\n            this.connection.driver.normalizeType(inverseReferencedColumn) !== \"uuid\" && (inverseReferencedColumn.generationStrategy === \"uuid\" || inverseReferencedColumn.type === \"uuid\") ? \"36\" : inverseReferencedColumn.length,\n            // fix https://github.com/typeorm/typeorm/issues/3604\n            width: inverseReferencedColumn.width,\n            // fix https://github.com/typeorm/typeorm/issues/6442\n            type: inverseReferencedColumn.type,\n            precision: inverseReferencedColumn.precision,\n            scale: inverseReferencedColumn.scale,\n            charset: inverseReferencedColumn.charset,\n            collation: inverseReferencedColumn.collation,\n            zerofill: inverseReferencedColumn.zerofill,\n            unsigned: inverseReferencedColumn.zerofill ? true : inverseReferencedColumn.unsigned,\n            enum: inverseReferencedColumn.enum,\n            enumName: inverseReferencedColumn.enumName,\n            foreignKeyConstraintName: joinColumn?.foreignKeyConstraintName,\n            name: columnName,\n            nullable: false,\n            primary: true\n          }\n        }\n      });\n    });\n    this.changeDuplicatedColumnNames(junctionColumns, inverseJunctionColumns);\n    // set junction table columns\n    entityMetadata.ownerColumns = junctionColumns;\n    entityMetadata.inverseColumns = inverseJunctionColumns;\n    entityMetadata.ownColumns = [...junctionColumns, ...inverseJunctionColumns];\n    entityMetadata.ownColumns.forEach(column => column.relationMetadata = relation);\n    // create junction table foreign keys\n    // Note: UPDATE CASCADE clause is not supported in Oracle.\n    // Note: UPDATE/DELETE CASCADE clauses are not supported in Spanner.\n    entityMetadata.foreignKeys = relation.createForeignKeyConstraints ? [new ForeignKeyMetadata({\n      entityMetadata: entityMetadata,\n      referencedEntityMetadata: relation.entityMetadata,\n      columns: junctionColumns,\n      referencedColumns: referencedColumns,\n      name: junctionColumns[0]?.foreignKeyConstraintName,\n      onDelete: this.connection.driver.options.type === \"spanner\" ? \"NO ACTION\" : relation.onDelete || \"CASCADE\",\n      onUpdate: this.connection.driver.options.type === \"oracle\" || this.connection.driver.options.type === \"spanner\" ? \"NO ACTION\" : relation.onUpdate || \"CASCADE\"\n    }), new ForeignKeyMetadata({\n      entityMetadata: entityMetadata,\n      referencedEntityMetadata: relation.inverseEntityMetadata,\n      columns: inverseJunctionColumns,\n      referencedColumns: inverseReferencedColumns,\n      name: inverseJunctionColumns[0]?.foreignKeyConstraintName,\n      onDelete: this.connection.driver.options.type === \"spanner\" ? \"NO ACTION\" : relation.inverseRelation ? relation.inverseRelation.onDelete : \"CASCADE\",\n      onUpdate: this.connection.driver.options.type === \"oracle\" || this.connection.driver.options.type === \"spanner\" ? \"NO ACTION\" : relation.inverseRelation ? relation.inverseRelation.onUpdate : \"CASCADE\"\n    })] : [];\n    // create junction table indices\n    entityMetadata.ownIndices = [new IndexMetadata({\n      entityMetadata: entityMetadata,\n      columns: junctionColumns,\n      args: {\n        target: entityMetadata.target,\n        synchronize: true\n      }\n    }), new IndexMetadata({\n      entityMetadata: entityMetadata,\n      columns: inverseJunctionColumns,\n      args: {\n        target: entityMetadata.target,\n        synchronize: true\n      }\n    })];\n    // finally return entity metadata\n    return entityMetadata;\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Collects referenced columns from the given join column args.\n   */\n  collectReferencedColumns(relation, joinTable) {\n    const hasAnyReferencedColumnName = joinTable.joinColumns ? joinTable.joinColumns.find(joinColumn => !!joinColumn.referencedColumnName) : false;\n    if (!joinTable.joinColumns || joinTable.joinColumns && !hasAnyReferencedColumnName) {\n      return relation.entityMetadata.columns.filter(column => column.isPrimary);\n    } else {\n      return joinTable.joinColumns.map(joinColumn => {\n        const referencedColumn = relation.entityMetadata.columns.find(column => column.propertyName === joinColumn.referencedColumnName);\n        if (!referencedColumn) throw new TypeORMError(`Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.entityMetadata.name}`);\n        return referencedColumn;\n      });\n    }\n  }\n  /**\n   * Collects inverse referenced columns from the given join column args.\n   */\n  collectInverseReferencedColumns(relation, joinTable) {\n    const hasInverseJoinColumns = !!joinTable.inverseJoinColumns;\n    const hasAnyInverseReferencedColumnName = hasInverseJoinColumns ? joinTable.inverseJoinColumns.find(joinColumn => !!joinColumn.referencedColumnName) : false;\n    if (!hasInverseJoinColumns || hasInverseJoinColumns && !hasAnyInverseReferencedColumnName) {\n      return relation.inverseEntityMetadata.primaryColumns;\n    } else {\n      return joinTable.inverseJoinColumns.map(joinColumn => {\n        const referencedColumn = relation.inverseEntityMetadata.ownColumns.find(column => column.propertyName === joinColumn.referencedColumnName);\n        if (!referencedColumn) throw new TypeORMError(`Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.inverseEntityMetadata.name}`);\n        return referencedColumn;\n      });\n    }\n  }\n  changeDuplicatedColumnNames(junctionColumns, inverseJunctionColumns) {\n    junctionColumns.forEach(junctionColumn => {\n      inverseJunctionColumns.forEach(inverseJunctionColumn => {\n        if (junctionColumn.givenDatabaseName === inverseJunctionColumn.givenDatabaseName) {\n          const junctionColumnName = this.connection.namingStrategy.joinTableColumnDuplicationPrefix(junctionColumn.propertyName, 1);\n          junctionColumn.propertyName = junctionColumnName;\n          junctionColumn.givenDatabaseName = junctionColumnName;\n          const inverseJunctionColumnName = this.connection.namingStrategy.joinTableColumnDuplicationPrefix(inverseJunctionColumn.propertyName, 2);\n          inverseJunctionColumn.propertyName = inverseJunctionColumnName;\n          inverseJunctionColumn.givenDatabaseName = inverseJunctionColumnName;\n        }\n      });\n    });\n  }\n}","map":{"version":3,"names":["ColumnMetadata","EntityMetadata","ForeignKeyMetadata","IndexMetadata","TypeORMError","DriverUtils","JunctionEntityMetadataBuilder","constructor","connection","build","relation","joinTable","referencedColumns","collectReferencedColumns","inverseReferencedColumns","collectInverseReferencedColumns","joinTableName","name","namingStrategy","entityMetadata","tableNameWithoutPrefix","inverseEntityMetadata","propertyPath","inverseRelation","propertyName","args","target","type","database","schema","synchronize","junctionColumns","map","referencedColumn","joinColumn","joinColumns","find","joinColumnArgs","referencedColumnName","undefined","columnName","joinTableColumnName","databaseName","mode","options","length","isMySQLFamily","driver","normalizeType","generationStrategy","width","precision","scale","charset","collation","zerofill","unsigned","enum","enumName","foreignKeyConstraintName","nullable","primary","inverseJunctionColumns","inverseReferencedColumn","inverseJoinColumns","joinTableInverseColumnName","changeDuplicatedColumnNames","ownerColumns","inverseColumns","ownColumns","forEach","column","relationMetadata","foreignKeys","createForeignKeyConstraints","referencedEntityMetadata","columns","onDelete","onUpdate","ownIndices","hasAnyReferencedColumnName","filter","isPrimary","hasInverseJoinColumns","hasAnyInverseReferencedColumnName","primaryColumns","junctionColumn","inverseJunctionColumn","givenDatabaseName","junctionColumnName","joinTableColumnDuplicationPrefix","inverseJunctionColumnName"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\metadata-builder\\JunctionEntityMetadataBuilder.ts"],"sourcesContent":["import { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { ForeignKeyMetadata } from \"../metadata/ForeignKeyMetadata\"\nimport { IndexMetadata } from \"../metadata/IndexMetadata\"\nimport { JoinTableMetadataArgs } from \"../metadata-args/JoinTableMetadataArgs\"\nimport { RelationMetadata } from \"../metadata/RelationMetadata\"\nimport { TypeORMError } from \"../error\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\n\n/**\n * Creates EntityMetadata for junction tables.\n * Junction tables are tables generated by many-to-many relations.\n */\nexport class JunctionEntityMetadataBuilder {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private connection: DataSource) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Builds EntityMetadata for the junction of the given many-to-many relation.\n     */\n    build(\n        relation: RelationMetadata,\n        joinTable: JoinTableMetadataArgs,\n    ): EntityMetadata {\n        const referencedColumns = this.collectReferencedColumns(\n            relation,\n            joinTable,\n        )\n        const inverseReferencedColumns = this.collectInverseReferencedColumns(\n            relation,\n            joinTable,\n        )\n\n        const joinTableName =\n            joinTable.name ||\n            this.connection.namingStrategy.joinTableName(\n                relation.entityMetadata.tableNameWithoutPrefix,\n                relation.inverseEntityMetadata.tableNameWithoutPrefix,\n                relation.propertyPath,\n                relation.inverseRelation\n                    ? relation.inverseRelation.propertyName\n                    : \"\",\n            )\n\n        const entityMetadata = new EntityMetadata({\n            connection: this.connection,\n            args: {\n                target: \"\",\n                name: joinTableName,\n                type: \"junction\",\n                database:\n                    joinTable.database || relation.entityMetadata.database,\n                schema: joinTable.schema || relation.entityMetadata.schema,\n                synchronize: joinTable.synchronize,\n            },\n        })\n        entityMetadata.build()\n\n        // create original side junction columns\n        const junctionColumns = referencedColumns.map((referencedColumn) => {\n            const joinColumn = joinTable.joinColumns\n                ? joinTable.joinColumns.find((joinColumnArgs) => {\n                      return (\n                          (!joinColumnArgs.referencedColumnName ||\n                              joinColumnArgs.referencedColumnName ===\n                                  referencedColumn.propertyName) &&\n                          !!joinColumnArgs.name\n                      )\n                  })\n                : undefined\n            const columnName =\n                joinColumn && joinColumn.name\n                    ? joinColumn.name\n                    : this.connection.namingStrategy.joinTableColumnName(\n                          relation.entityMetadata.tableNameWithoutPrefix,\n                          referencedColumn.propertyName,\n                          referencedColumn.databaseName,\n                      )\n\n            return new ColumnMetadata({\n                connection: this.connection,\n                entityMetadata: entityMetadata,\n                referencedColumn: referencedColumn,\n                args: {\n                    target: \"\",\n                    mode: \"virtual\",\n                    propertyName: columnName,\n                    options: {\n                        name: columnName,\n                        length:\n                            !referencedColumn.length &&\n                            (DriverUtils.isMySQLFamily(\n                                this.connection.driver,\n                            ) ||\n                                this.connection.driver.options.type ===\n                                    \"aurora-mysql\") &&\n                            // some versions of mariadb support the column type and should not try to provide the length property\n                            this.connection.driver.normalizeType(\n                                referencedColumn,\n                            ) !== \"uuid\" &&\n                            (referencedColumn.generationStrategy === \"uuid\" ||\n                                referencedColumn.type === \"uuid\")\n                                ? \"36\"\n                                : referencedColumn.length, // fix https://github.com/typeorm/typeorm/issues/3604\n                        width: referencedColumn.width,\n                        type: referencedColumn.type,\n                        precision: referencedColumn.precision,\n                        scale: referencedColumn.scale,\n                        charset: referencedColumn.charset,\n                        collation: referencedColumn.collation,\n                        zerofill: referencedColumn.zerofill,\n                        unsigned: referencedColumn.zerofill\n                            ? true\n                            : referencedColumn.unsigned,\n                        enum: referencedColumn.enum,\n                        enumName: referencedColumn.enumName,\n                        foreignKeyConstraintName:\n                            joinColumn?.foreignKeyConstraintName,\n                        nullable: false,\n                        primary: true,\n                    },\n                },\n            })\n        })\n\n        // create inverse side junction columns\n        const inverseJunctionColumns = inverseReferencedColumns.map(\n            (inverseReferencedColumn) => {\n                const joinColumn = joinTable.inverseJoinColumns\n                    ? joinTable.inverseJoinColumns.find((joinColumnArgs) => {\n                          return (\n                              (!joinColumnArgs.referencedColumnName ||\n                                  joinColumnArgs.referencedColumnName ===\n                                      inverseReferencedColumn.propertyName) &&\n                              !!joinColumnArgs.name\n                          )\n                      })\n                    : undefined\n                const columnName =\n                    joinColumn && joinColumn.name\n                        ? joinColumn.name\n                        : this.connection.namingStrategy.joinTableInverseColumnName(\n                              relation.inverseEntityMetadata\n                                  .tableNameWithoutPrefix,\n                              inverseReferencedColumn.propertyName,\n                              inverseReferencedColumn.databaseName,\n                          )\n\n                return new ColumnMetadata({\n                    connection: this.connection,\n                    entityMetadata: entityMetadata,\n                    referencedColumn: inverseReferencedColumn,\n                    args: {\n                        target: \"\",\n                        mode: \"virtual\",\n                        propertyName: columnName,\n                        options: {\n                            length:\n                                !inverseReferencedColumn.length &&\n                                (DriverUtils.isMySQLFamily(\n                                    this.connection.driver,\n                                ) ||\n                                    this.connection.driver.options.type ===\n                                        \"aurora-mysql\") &&\n                                // some versions of mariadb support the column type and should not try to provide the length property\n                                this.connection.driver.normalizeType(\n                                    inverseReferencedColumn,\n                                ) !== \"uuid\" &&\n                                (inverseReferencedColumn.generationStrategy ===\n                                    \"uuid\" ||\n                                    inverseReferencedColumn.type === \"uuid\")\n                                    ? \"36\"\n                                    : inverseReferencedColumn.length, // fix https://github.com/typeorm/typeorm/issues/3604\n                            width: inverseReferencedColumn.width, // fix https://github.com/typeorm/typeorm/issues/6442\n                            type: inverseReferencedColumn.type,\n                            precision: inverseReferencedColumn.precision,\n                            scale: inverseReferencedColumn.scale,\n                            charset: inverseReferencedColumn.charset,\n                            collation: inverseReferencedColumn.collation,\n                            zerofill: inverseReferencedColumn.zerofill,\n                            unsigned: inverseReferencedColumn.zerofill\n                                ? true\n                                : inverseReferencedColumn.unsigned,\n                            enum: inverseReferencedColumn.enum,\n                            enumName: inverseReferencedColumn.enumName,\n                            foreignKeyConstraintName:\n                                joinColumn?.foreignKeyConstraintName,\n                            name: columnName,\n                            nullable: false,\n                            primary: true,\n                        },\n                    },\n                })\n            },\n        )\n\n        this.changeDuplicatedColumnNames(\n            junctionColumns,\n            inverseJunctionColumns,\n        )\n\n        // set junction table columns\n        entityMetadata.ownerColumns = junctionColumns\n        entityMetadata.inverseColumns = inverseJunctionColumns\n        entityMetadata.ownColumns = [\n            ...junctionColumns,\n            ...inverseJunctionColumns,\n        ]\n        entityMetadata.ownColumns.forEach(\n            (column) => (column.relationMetadata = relation),\n        )\n\n        // create junction table foreign keys\n        // Note: UPDATE CASCADE clause is not supported in Oracle.\n        // Note: UPDATE/DELETE CASCADE clauses are not supported in Spanner.\n        entityMetadata.foreignKeys = relation.createForeignKeyConstraints\n            ? [\n                  new ForeignKeyMetadata({\n                      entityMetadata: entityMetadata,\n                      referencedEntityMetadata: relation.entityMetadata,\n                      columns: junctionColumns,\n                      referencedColumns: referencedColumns,\n                      name: junctionColumns[0]?.foreignKeyConstraintName,\n                      onDelete:\n                          this.connection.driver.options.type === \"spanner\"\n                              ? \"NO ACTION\"\n                              : relation.onDelete || \"CASCADE\",\n                      onUpdate:\n                          this.connection.driver.options.type === \"oracle\" ||\n                          this.connection.driver.options.type === \"spanner\"\n                              ? \"NO ACTION\"\n                              : relation.onUpdate || \"CASCADE\",\n                  }),\n                  new ForeignKeyMetadata({\n                      entityMetadata: entityMetadata,\n                      referencedEntityMetadata: relation.inverseEntityMetadata,\n                      columns: inverseJunctionColumns,\n                      referencedColumns: inverseReferencedColumns,\n                      name: inverseJunctionColumns[0]?.foreignKeyConstraintName,\n                      onDelete:\n                          this.connection.driver.options.type === \"spanner\"\n                              ? \"NO ACTION\"\n                              : relation.inverseRelation\n                              ? relation.inverseRelation.onDelete\n                              : \"CASCADE\",\n                      onUpdate:\n                          this.connection.driver.options.type === \"oracle\" ||\n                          this.connection.driver.options.type === \"spanner\"\n                              ? \"NO ACTION\"\n                              : relation.inverseRelation\n                              ? relation.inverseRelation.onUpdate\n                              : \"CASCADE\",\n                  }),\n              ]\n            : []\n\n        // create junction table indices\n        entityMetadata.ownIndices = [\n            new IndexMetadata({\n                entityMetadata: entityMetadata,\n                columns: junctionColumns,\n                args: {\n                    target: entityMetadata.target,\n                    synchronize: true,\n                },\n            }),\n\n            new IndexMetadata({\n                entityMetadata: entityMetadata,\n                columns: inverseJunctionColumns,\n                args: {\n                    target: entityMetadata.target,\n                    synchronize: true,\n                },\n            }),\n        ]\n\n        // finally return entity metadata\n        return entityMetadata\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Collects referenced columns from the given join column args.\n     */\n    protected collectReferencedColumns(\n        relation: RelationMetadata,\n        joinTable: JoinTableMetadataArgs,\n    ): ColumnMetadata[] {\n        const hasAnyReferencedColumnName = joinTable.joinColumns\n            ? joinTable.joinColumns.find(\n                  (joinColumn) => !!joinColumn.referencedColumnName,\n              )\n            : false\n        if (\n            !joinTable.joinColumns ||\n            (joinTable.joinColumns && !hasAnyReferencedColumnName)\n        ) {\n            return relation.entityMetadata.columns.filter(\n                (column) => column.isPrimary,\n            )\n        } else {\n            return joinTable.joinColumns.map((joinColumn) => {\n                const referencedColumn = relation.entityMetadata.columns.find(\n                    (column) =>\n                        column.propertyName === joinColumn.referencedColumnName,\n                )\n                if (!referencedColumn)\n                    throw new TypeORMError(\n                        `Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.entityMetadata.name}`,\n                    )\n\n                return referencedColumn\n            })\n        }\n    }\n\n    /**\n     * Collects inverse referenced columns from the given join column args.\n     */\n    protected collectInverseReferencedColumns(\n        relation: RelationMetadata,\n        joinTable: JoinTableMetadataArgs,\n    ): ColumnMetadata[] {\n        const hasInverseJoinColumns = !!joinTable.inverseJoinColumns\n        const hasAnyInverseReferencedColumnName = hasInverseJoinColumns\n            ? joinTable.inverseJoinColumns!.find(\n                  (joinColumn) => !!joinColumn.referencedColumnName,\n              )\n            : false\n        if (\n            !hasInverseJoinColumns ||\n            (hasInverseJoinColumns && !hasAnyInverseReferencedColumnName)\n        ) {\n            return relation.inverseEntityMetadata.primaryColumns\n        } else {\n            return joinTable.inverseJoinColumns!.map((joinColumn) => {\n                const referencedColumn =\n                    relation.inverseEntityMetadata.ownColumns.find(\n                        (column) =>\n                            column.propertyName ===\n                            joinColumn.referencedColumnName,\n                    )\n                if (!referencedColumn)\n                    throw new TypeORMError(\n                        `Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.inverseEntityMetadata.name}`,\n                    )\n\n                return referencedColumn\n            })\n        }\n    }\n\n    protected changeDuplicatedColumnNames(\n        junctionColumns: ColumnMetadata[],\n        inverseJunctionColumns: ColumnMetadata[],\n    ) {\n        junctionColumns.forEach((junctionColumn) => {\n            inverseJunctionColumns.forEach((inverseJunctionColumn) => {\n                if (\n                    junctionColumn.givenDatabaseName ===\n                    inverseJunctionColumn.givenDatabaseName\n                ) {\n                    const junctionColumnName =\n                        this.connection.namingStrategy.joinTableColumnDuplicationPrefix(\n                            junctionColumn.propertyName,\n                            1,\n                        )\n                    junctionColumn.propertyName = junctionColumnName\n                    junctionColumn.givenDatabaseName = junctionColumnName\n\n                    const inverseJunctionColumnName =\n                        this.connection.namingStrategy.joinTableColumnDuplicationPrefix(\n                            inverseJunctionColumn.propertyName,\n                            2,\n                        )\n                    inverseJunctionColumn.propertyName =\n                        inverseJunctionColumnName\n                    inverseJunctionColumn.givenDatabaseName =\n                        inverseJunctionColumnName\n                }\n            })\n        })\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}