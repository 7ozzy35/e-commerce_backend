{"ast":null,"code":"import { TypeORMError } from \"../error\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\n/**\n * Allows to work with entity relations and perform specific operations with those relations.\n *\n * todo: add transactions everywhere\n */\nexport class RelationUpdater {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(queryBuilder, expressionMap) {\n    this.queryBuilder = queryBuilder;\n    this.expressionMap = expressionMap;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Performs set or add operation on a relation.\n   */\n  async update(value) {\n    const relation = this.expressionMap.relationMetadata;\n    if (relation.isManyToOne || relation.isOneToOneOwner) {\n      const updateSet = relation.joinColumns.reduce((updateSet, joinColumn) => {\n        const relationValue = ObjectUtils.isObject(value) ? joinColumn.referencedColumn.getEntityValue(value) : value;\n        joinColumn.setEntityValue(updateSet, relationValue);\n        return updateSet;\n      }, {});\n      if (!this.expressionMap.of || Array.isArray(this.expressionMap.of) && !this.expressionMap.of.length) return;\n      await this.queryBuilder.createQueryBuilder().update(relation.entityMetadata.target).set(updateSet).whereInIds(this.expressionMap.of).execute();\n    } else if ((relation.isOneToOneNotOwner || relation.isOneToMany) && value === null) {\n      // we handle null a bit different way\n      const updateSet = {};\n      relation.inverseRelation.joinColumns.forEach(column => {\n        updateSet[column.propertyName] = null;\n      });\n      const ofs = Array.isArray(this.expressionMap.of) ? this.expressionMap.of : [this.expressionMap.of];\n      const parameters = {};\n      const conditions = [];\n      ofs.forEach((of, ofIndex) => {\n        relation.inverseRelation.joinColumns.map((column, columnIndex) => {\n          const parameterName = \"joinColumn_\" + ofIndex + \"_\" + columnIndex;\n          parameters[parameterName] = ObjectUtils.isObject(of) ? column.referencedColumn.getEntityValue(of) : of;\n          conditions.push(`${column.propertyPath} = :${parameterName}`);\n        });\n      });\n      const condition = conditions.map(str => \"(\" + str + \")\").join(\" OR \");\n      if (!condition) return;\n      await this.queryBuilder.createQueryBuilder().update(relation.inverseEntityMetadata.target).set(updateSet).where(condition).setParameters(parameters).execute();\n    } else if (relation.isOneToOneNotOwner || relation.isOneToMany) {\n      if (Array.isArray(this.expressionMap.of)) throw new TypeORMError(`You cannot update relations of multiple entities with the same related object. Provide a single entity into .of method.`);\n      const of = this.expressionMap.of;\n      const updateSet = relation.inverseRelation.joinColumns.reduce((updateSet, joinColumn) => {\n        const relationValue = ObjectUtils.isObject(of) ? joinColumn.referencedColumn.getEntityValue(of) : of;\n        joinColumn.setEntityValue(updateSet, relationValue);\n        return updateSet;\n      }, {});\n      if (!value || Array.isArray(value) && !value.length) return;\n      await this.queryBuilder.createQueryBuilder().update(relation.inverseEntityMetadata.target).set(updateSet).whereInIds(value).execute();\n    } else {\n      // many to many\n      const junctionMetadata = relation.junctionEntityMetadata;\n      const ofs = Array.isArray(this.expressionMap.of) ? this.expressionMap.of : [this.expressionMap.of];\n      const values = Array.isArray(value) ? value : [value];\n      const firstColumnValues = relation.isManyToManyOwner ? ofs : values;\n      const secondColumnValues = relation.isManyToManyOwner ? values : ofs;\n      const bulkInserted = [];\n      firstColumnValues.forEach(firstColumnVal => {\n        secondColumnValues.forEach(secondColumnVal => {\n          const inserted = {};\n          junctionMetadata.ownerColumns.forEach(column => {\n            inserted[column.databaseName] = ObjectUtils.isObject(firstColumnVal) ? column.referencedColumn.getEntityValue(firstColumnVal) : firstColumnVal;\n          });\n          junctionMetadata.inverseColumns.forEach(column => {\n            inserted[column.databaseName] = ObjectUtils.isObject(secondColumnVal) ? column.referencedColumn.getEntityValue(secondColumnVal) : secondColumnVal;\n          });\n          bulkInserted.push(inserted);\n        });\n      });\n      if (!bulkInserted.length) return;\n      if (this.queryBuilder.connection.driver.options.type === \"oracle\" || this.queryBuilder.connection.driver.options.type === \"sap\") {\n        await Promise.all(bulkInserted.map(value => {\n          return this.queryBuilder.createQueryBuilder().insert().into(junctionMetadata.tableName).values(value).execute();\n        }));\n      } else {\n        await this.queryBuilder.createQueryBuilder().insert().into(junctionMetadata.tableName).values(bulkInserted).execute();\n      }\n    }\n  }\n}","map":{"version":3,"names":["TypeORMError","ObjectUtils","RelationUpdater","constructor","queryBuilder","expressionMap","update","value","relation","relationMetadata","isManyToOne","isOneToOneOwner","updateSet","joinColumns","reduce","joinColumn","relationValue","isObject","referencedColumn","getEntityValue","setEntityValue","of","Array","isArray","length","createQueryBuilder","entityMetadata","target","set","whereInIds","execute","isOneToOneNotOwner","isOneToMany","inverseRelation","forEach","column","propertyName","ofs","parameters","conditions","ofIndex","map","columnIndex","parameterName","push","propertyPath","condition","str","join","inverseEntityMetadata","where","setParameters","junctionMetadata","junctionEntityMetadata","values","firstColumnValues","isManyToManyOwner","secondColumnValues","bulkInserted","firstColumnVal","secondColumnVal","inserted","ownerColumns","databaseName","inverseColumns","connection","driver","options","type","Promise","all","insert","into","tableName"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\query-builder\\RelationUpdater.ts"],"sourcesContent":["import { QueryBuilder } from \"./QueryBuilder\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { QueryExpressionMap } from \"./QueryExpressionMap\"\nimport { TypeORMError } from \"../error\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\n\n/**\n * Allows to work with entity relations and perform specific operations with those relations.\n *\n * todo: add transactions everywhere\n */\nexport class RelationUpdater {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        protected queryBuilder: QueryBuilder<any>,\n        protected expressionMap: QueryExpressionMap,\n    ) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs set or add operation on a relation.\n     */\n    async update(value: any | any[]): Promise<void> {\n        const relation = this.expressionMap.relationMetadata\n\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\n            const updateSet = relation.joinColumns.reduce(\n                (updateSet, joinColumn) => {\n                    const relationValue = ObjectUtils.isObject(value)\n                        ? joinColumn.referencedColumn!.getEntityValue(value)\n                        : value\n                    joinColumn.setEntityValue(updateSet, relationValue)\n                    return updateSet\n                },\n                {} as any,\n            )\n\n            if (\n                !this.expressionMap.of ||\n                (Array.isArray(this.expressionMap.of) &&\n                    !this.expressionMap.of.length)\n            )\n                return\n\n            await this.queryBuilder\n                .createQueryBuilder()\n                .update(relation.entityMetadata.target)\n                .set(updateSet)\n                .whereInIds(this.expressionMap.of)\n                .execute()\n        } else if (\n            (relation.isOneToOneNotOwner || relation.isOneToMany) &&\n            value === null\n        ) {\n            // we handle null a bit different way\n\n            const updateSet: ObjectLiteral = {}\n            relation.inverseRelation!.joinColumns.forEach((column) => {\n                updateSet[column.propertyName] = null\n            })\n\n            const ofs = Array.isArray(this.expressionMap.of)\n                ? this.expressionMap.of\n                : [this.expressionMap.of]\n            const parameters: ObjectLiteral = {}\n            const conditions: string[] = []\n            ofs.forEach((of, ofIndex) => {\n                relation.inverseRelation!.joinColumns.map(\n                    (column, columnIndex) => {\n                        const parameterName =\n                            \"joinColumn_\" + ofIndex + \"_\" + columnIndex\n                        parameters[parameterName] = ObjectUtils.isObject(of)\n                            ? column.referencedColumn!.getEntityValue(of)\n                            : of\n                        conditions.push(\n                            `${column.propertyPath} = :${parameterName}`,\n                        )\n                    },\n                )\n            })\n            const condition = conditions\n                .map((str) => \"(\" + str + \")\")\n                .join(\" OR \")\n            if (!condition) return\n\n            await this.queryBuilder\n                .createQueryBuilder()\n                .update(relation.inverseEntityMetadata.target)\n                .set(updateSet)\n                .where(condition)\n                .setParameters(parameters)\n                .execute()\n        } else if (relation.isOneToOneNotOwner || relation.isOneToMany) {\n            if (Array.isArray(this.expressionMap.of))\n                throw new TypeORMError(\n                    `You cannot update relations of multiple entities with the same related object. Provide a single entity into .of method.`,\n                )\n\n            const of = this.expressionMap.of\n            const updateSet = relation.inverseRelation!.joinColumns.reduce(\n                (updateSet, joinColumn) => {\n                    const relationValue = ObjectUtils.isObject(of)\n                        ? joinColumn.referencedColumn!.getEntityValue(of)\n                        : of\n                    joinColumn.setEntityValue(updateSet, relationValue)\n                    return updateSet\n                },\n                {} as any,\n            )\n\n            if (!value || (Array.isArray(value) && !value.length)) return\n\n            await this.queryBuilder\n                .createQueryBuilder()\n                .update(relation.inverseEntityMetadata.target)\n                .set(updateSet)\n                .whereInIds(value)\n                .execute()\n        } else {\n            // many to many\n            const junctionMetadata = relation.junctionEntityMetadata!\n            const ofs = Array.isArray(this.expressionMap.of)\n                ? this.expressionMap.of\n                : [this.expressionMap.of]\n            const values = Array.isArray(value) ? value : [value]\n            const firstColumnValues = relation.isManyToManyOwner ? ofs : values\n            const secondColumnValues = relation.isManyToManyOwner ? values : ofs\n\n            const bulkInserted: ObjectLiteral[] = []\n            firstColumnValues.forEach((firstColumnVal) => {\n                secondColumnValues.forEach((secondColumnVal) => {\n                    const inserted: ObjectLiteral = {}\n                    junctionMetadata.ownerColumns.forEach((column) => {\n                        inserted[column.databaseName] = ObjectUtils.isObject(\n                            firstColumnVal,\n                        )\n                            ? column.referencedColumn!.getEntityValue(\n                                  firstColumnVal,\n                              )\n                            : firstColumnVal\n                    })\n                    junctionMetadata.inverseColumns.forEach((column) => {\n                        inserted[column.databaseName] = ObjectUtils.isObject(\n                            secondColumnVal,\n                        )\n                            ? column.referencedColumn!.getEntityValue(\n                                  secondColumnVal,\n                              )\n                            : secondColumnVal\n                    })\n                    bulkInserted.push(inserted)\n                })\n            })\n\n            if (!bulkInserted.length) return\n\n            if (\n                this.queryBuilder.connection.driver.options.type === \"oracle\" ||\n                this.queryBuilder.connection.driver.options.type === \"sap\"\n            ) {\n                await Promise.all(\n                    bulkInserted.map((value) => {\n                        return this.queryBuilder\n                            .createQueryBuilder()\n                            .insert()\n                            .into(junctionMetadata.tableName)\n                            .values(value)\n                            .execute()\n                    }),\n                )\n            } else {\n                await this.queryBuilder\n                    .createQueryBuilder()\n                    .insert()\n                    .into(junctionMetadata.tableName)\n                    .values(bulkInserted)\n                    .execute()\n            }\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}