{"ast":null,"code":"import { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\";\nimport { QueryFailedError } from \"../../error/QueryFailedError\";\nimport { AbstractSqliteQueryRunner } from \"../sqlite-abstract/AbstractSqliteQueryRunner\";\nimport { Broadcaster } from \"../../subscriber/Broadcaster\";\nimport { TypeORMError } from \"../../error\";\nimport { QueryResult } from \"../../query-runner/QueryResult\";\nimport { BroadcasterResult } from \"../../subscriber/BroadcasterResult\";\n/**\n * Runs queries on a single sqlite database connection.\n */\nexport class CordovaQueryRunner extends AbstractSqliteQueryRunner {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(driver) {\n    super();\n    this.driver = driver;\n    this.connection = driver.connection;\n    this.broadcaster = new Broadcaster(this);\n  }\n  /**\n   * Called before migrations are run.\n   */\n  async beforeMigration() {\n    await this.query(`PRAGMA foreign_keys = OFF`);\n  }\n  /**\n   * Called after migrations are run.\n   */\n  async afterMigration() {\n    await this.query(`PRAGMA foreign_keys = ON`);\n  }\n  /**\n   * Executes a given SQL query.\n   */\n  async query(query, parameters, useStructuredResult = false) {\n    if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();\n    const databaseConnection = await this.connect();\n    const broadcasterResult = new BroadcasterResult();\n    this.driver.connection.logger.logQuery(query, parameters, this);\n    this.broadcaster.broadcastBeforeQueryEvent(broadcasterResult, query, parameters);\n    const queryStartTime = +new Date();\n    try {\n      const raw = await new Promise(async (ok, fail) => {\n        databaseConnection.executeSql(query, parameters, raw => ok(raw), err => fail(err));\n      });\n      // log slow queries if maxQueryExecution time is set\n      const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;\n      const queryEndTime = +new Date();\n      const queryExecutionTime = queryEndTime - queryStartTime;\n      this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, raw, undefined);\n      if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) {\n        this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);\n      }\n      const result = new QueryResult();\n      if (query.substr(0, 11) === \"INSERT INTO\") {\n        result.raw = raw.insertId;\n      } else {\n        let resultSet = [];\n        for (let i = 0; i < raw.rows.length; i++) {\n          resultSet.push(raw.rows.item(i));\n        }\n        result.records = resultSet;\n        result.raw = resultSet;\n      }\n      if (useStructuredResult) {\n        return result;\n      } else {\n        return result.raw;\n      }\n    } catch (err) {\n      this.driver.connection.logger.logQueryError(err, query, parameters, this);\n      this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, undefined, undefined, err);\n      throw new QueryFailedError(query, parameters, err);\n    } finally {\n      await broadcasterResult.wait();\n    }\n  }\n  /**\n   * Insert a new row with given values into the given table.\n   * Returns value of the generated column if given and generate column exist in the table.\n   // todo: implement new syntax\n  async insert(tableName: string, keyValues: ObjectLiteral): Promise<InsertResult> {\n      const keys = Object.keys(keyValues);\n      const columns = keys.map(key => `\"${key}\"`).join(\", \");\n      const values = keys.map(key => \"?\").join(\",\");\n      const generatedColumns = this.connection.hasMetadata(tableName) ? this.connection.getMetadata(tableName).generatedColumns : [];\n      const sql = columns.length > 0 ? (`INSERT INTO \"${tableName}\"(${columns}) VALUES (${values})`) : `INSERT INTO \"${tableName}\" DEFAULT VALUES`;\n      const parameters = keys.map(key => keyValues[key]);\n       return new Promise<InsertResult>(async (ok, fail) => {\n          this.driver.connection.logger.logQuery(sql, parameters, this);\n          const __this = this;\n          const databaseConnection = await this.connect();\n          databaseConnection.executeSql(sql, parameters, (resultSet: any) => {\n              const generatedMap = generatedColumns.reduce((map, generatedColumn) => {\n                  const value = generatedColumn.isPrimary && generatedColumn.generationStrategy === \"increment\" && resultSet.insertId ? resultSet.insertId : keyValues[generatedColumn.databaseName];\n                  if (!value) return map;\n                  return OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));\n              }, {} as ObjectLiteral);\n               ok({\n                  result: undefined,\n                  generatedMap: Object.keys(generatedMap).length > 0 ? generatedMap : undefined\n              });\n          }, (err: any) => {\n              __this.driver.connection.logger.logQueryError(err, sql, parameters, this);\n              fail(err);\n          });\n      });\n  }*/\n  /**\n   * Would start a transaction but this driver does not support transactions.\n   */\n  async startTransaction() {\n    throw new TypeORMError(\"Transactions are not supported by the Cordova driver\");\n  }\n  /**\n   * Would start a transaction but this driver does not support transactions.\n   */\n  async commitTransaction() {\n    throw new TypeORMError(\"Transactions are not supported by the Cordova driver\");\n  }\n  /**\n   * Would start a transaction but this driver does not support transactions.\n   */\n  async rollbackTransaction() {\n    throw new TypeORMError(\"Transactions are not supported by the Cordova driver\");\n  }\n  /**\n   * Removes all tables from the currently connected database.\n   * Be careful with using this method and avoid using it in production or migrations\n   * (because it can clear all your database).\n   */\n  async clearDatabase() {\n    await this.query(`PRAGMA foreign_keys = OFF`);\n    try {\n      const selectViewDropsQuery = `SELECT 'DROP VIEW \"' || name || '\";' as query FROM \"sqlite_master\" WHERE \"type\" = 'view'`;\n      const dropViewQueries = await this.query(selectViewDropsQuery);\n      const selectTableDropsQuery = `SELECT 'DROP TABLE \"' || name || '\";' as query FROM \"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" != 'sqlite_sequence'`;\n      const dropTableQueries = await this.query(selectTableDropsQuery);\n      await Promise.all(dropViewQueries.map(q => this.query(q[\"query\"])));\n      await Promise.all(dropTableQueries.map(q => this.query(q[\"query\"])));\n    } finally {\n      await this.query(`PRAGMA foreign_keys = ON`);\n    }\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Parametrizes given object of values. Used to create column=value queries.\n   */\n  parametrize(objectLiteral, startIndex = 0) {\n    return Object.keys(objectLiteral).map((key, index) => `\"${key}\"` + \"=?\");\n  }\n}","map":{"version":3,"names":["QueryRunnerAlreadyReleasedError","QueryFailedError","AbstractSqliteQueryRunner","Broadcaster","TypeORMError","QueryResult","BroadcasterResult","CordovaQueryRunner","constructor","driver","connection","broadcaster","beforeMigration","query","afterMigration","parameters","useStructuredResult","isReleased","databaseConnection","connect","broadcasterResult","logger","logQuery","broadcastBeforeQueryEvent","queryStartTime","Date","raw","Promise","ok","fail","executeSql","err","maxQueryExecutionTime","options","queryEndTime","queryExecutionTime","broadcastAfterQueryEvent","undefined","logQuerySlow","result","substr","insertId","resultSet","i","rows","length","push","item","records","logQueryError","wait","startTransaction","commitTransaction","rollbackTransaction","clearDatabase","selectViewDropsQuery","dropViewQueries","selectTableDropsQuery","dropTableQueries","all","map","q","parametrize","objectLiteral","startIndex","Object","keys","key","index"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\driver\\cordova\\CordovaQueryRunner.ts"],"sourcesContent":["import { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\"\nimport { QueryFailedError } from \"../../error/QueryFailedError\"\nimport { AbstractSqliteQueryRunner } from \"../sqlite-abstract/AbstractSqliteQueryRunner\"\nimport { CordovaDriver } from \"./CordovaDriver\"\nimport { Broadcaster } from \"../../subscriber/Broadcaster\"\nimport { TypeORMError } from \"../../error\"\nimport { QueryResult } from \"../../query-runner/QueryResult\"\nimport { BroadcasterResult } from \"../../subscriber/BroadcasterResult\"\n\n/**\n * Runs queries on a single sqlite database connection.\n */\nexport class CordovaQueryRunner extends AbstractSqliteQueryRunner {\n    /**\n     * Database driver used by connection.\n     */\n    driver: CordovaDriver\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(driver: CordovaDriver) {\n        super()\n        this.driver = driver\n        this.connection = driver.connection\n        this.broadcaster = new Broadcaster(this)\n    }\n\n    /**\n     * Called before migrations are run.\n     */\n    async beforeMigration(): Promise<void> {\n        await this.query(`PRAGMA foreign_keys = OFF`)\n    }\n\n    /**\n     * Called after migrations are run.\n     */\n    async afterMigration(): Promise<void> {\n        await this.query(`PRAGMA foreign_keys = ON`)\n    }\n\n    /**\n     * Executes a given SQL query.\n     */\n    async query(\n        query: string,\n        parameters?: any[],\n        useStructuredResult = false,\n    ): Promise<any> {\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        const databaseConnection = await this.connect()\n        const broadcasterResult = new BroadcasterResult()\n\n        this.driver.connection.logger.logQuery(query, parameters, this)\n        this.broadcaster.broadcastBeforeQueryEvent(\n            broadcasterResult,\n            query,\n            parameters,\n        )\n\n        const queryStartTime = +new Date()\n\n        try {\n            const raw = await new Promise<any>(async (ok, fail) => {\n                databaseConnection.executeSql(\n                    query,\n                    parameters,\n                    (raw: any) => ok(raw),\n                    (err: any) => fail(err),\n                )\n            })\n\n            // log slow queries if maxQueryExecution time is set\n            const maxQueryExecutionTime =\n                this.driver.options.maxQueryExecutionTime\n            const queryEndTime = +new Date()\n            const queryExecutionTime = queryEndTime - queryStartTime\n\n            this.broadcaster.broadcastAfterQueryEvent(\n                broadcasterResult,\n                query,\n                parameters,\n                true,\n                queryExecutionTime,\n                raw,\n                undefined,\n            )\n\n            if (\n                maxQueryExecutionTime &&\n                queryExecutionTime > maxQueryExecutionTime\n            ) {\n                this.driver.connection.logger.logQuerySlow(\n                    queryExecutionTime,\n                    query,\n                    parameters,\n                    this,\n                )\n            }\n\n            const result = new QueryResult()\n\n            if (query.substr(0, 11) === \"INSERT INTO\") {\n                result.raw = raw.insertId\n            } else {\n                let resultSet = []\n                for (let i = 0; i < raw.rows.length; i++) {\n                    resultSet.push(raw.rows.item(i))\n                }\n\n                result.records = resultSet\n                result.raw = resultSet\n            }\n\n            if (useStructuredResult) {\n                return result\n            } else {\n                return result.raw\n            }\n        } catch (err) {\n            this.driver.connection.logger.logQueryError(\n                err,\n                query,\n                parameters,\n                this,\n            )\n            this.broadcaster.broadcastAfterQueryEvent(\n                broadcasterResult,\n                query,\n                parameters,\n                false,\n                undefined,\n                undefined,\n                err,\n            )\n\n            throw new QueryFailedError(query, parameters, err)\n        } finally {\n            await broadcasterResult.wait()\n        }\n    }\n\n    /**\n     * Insert a new row with given values into the given table.\n     * Returns value of the generated column if given and generate column exist in the table.\n     // todo: implement new syntax\n    async insert(tableName: string, keyValues: ObjectLiteral): Promise<InsertResult> {\n        const keys = Object.keys(keyValues);\n        const columns = keys.map(key => `\"${key}\"`).join(\", \");\n        const values = keys.map(key => \"?\").join(\",\");\n        const generatedColumns = this.connection.hasMetadata(tableName) ? this.connection.getMetadata(tableName).generatedColumns : [];\n        const sql = columns.length > 0 ? (`INSERT INTO \"${tableName}\"(${columns}) VALUES (${values})`) : `INSERT INTO \"${tableName}\" DEFAULT VALUES`;\n        const parameters = keys.map(key => keyValues[key]);\n\n        return new Promise<InsertResult>(async (ok, fail) => {\n            this.driver.connection.logger.logQuery(sql, parameters, this);\n            const __this = this;\n            const databaseConnection = await this.connect();\n            databaseConnection.executeSql(sql, parameters, (resultSet: any) => {\n                const generatedMap = generatedColumns.reduce((map, generatedColumn) => {\n                    const value = generatedColumn.isPrimary && generatedColumn.generationStrategy === \"increment\" && resultSet.insertId ? resultSet.insertId : keyValues[generatedColumn.databaseName];\n                    if (!value) return map;\n                    return OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));\n                }, {} as ObjectLiteral);\n\n                ok({\n                    result: undefined,\n                    generatedMap: Object.keys(generatedMap).length > 0 ? generatedMap : undefined\n                });\n            }, (err: any) => {\n                __this.driver.connection.logger.logQueryError(err, sql, parameters, this);\n                fail(err);\n            });\n        });\n    }*/\n\n    /**\n     * Would start a transaction but this driver does not support transactions.\n     */\n    async startTransaction(): Promise<void> {\n        throw new TypeORMError(\n            \"Transactions are not supported by the Cordova driver\",\n        )\n    }\n\n    /**\n     * Would start a transaction but this driver does not support transactions.\n     */\n    async commitTransaction(): Promise<void> {\n        throw new TypeORMError(\n            \"Transactions are not supported by the Cordova driver\",\n        )\n    }\n\n    /**\n     * Would start a transaction but this driver does not support transactions.\n     */\n    async rollbackTransaction(): Promise<void> {\n        throw new TypeORMError(\n            \"Transactions are not supported by the Cordova driver\",\n        )\n    }\n\n    /**\n     * Removes all tables from the currently connected database.\n     * Be careful with using this method and avoid using it in production or migrations\n     * (because it can clear all your database).\n     */\n    async clearDatabase(): Promise<void> {\n        await this.query(`PRAGMA foreign_keys = OFF`)\n        try {\n            const selectViewDropsQuery = `SELECT 'DROP VIEW \"' || name || '\";' as query FROM \"sqlite_master\" WHERE \"type\" = 'view'`\n            const dropViewQueries: ObjectLiteral[] = await this.query(\n                selectViewDropsQuery,\n            )\n\n            const selectTableDropsQuery = `SELECT 'DROP TABLE \"' || name || '\";' as query FROM \"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" != 'sqlite_sequence'`\n            const dropTableQueries: ObjectLiteral[] = await this.query(\n                selectTableDropsQuery,\n            )\n\n            await Promise.all(\n                dropViewQueries.map((q) => this.query(q[\"query\"])),\n            )\n            await Promise.all(\n                dropTableQueries.map((q) => this.query(q[\"query\"])),\n            )\n        } finally {\n            await this.query(`PRAGMA foreign_keys = ON`)\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Parametrizes given object of values. Used to create column=value queries.\n     */\n    protected parametrize(\n        objectLiteral: ObjectLiteral,\n        startIndex: number = 0,\n    ): string[] {\n        return Object.keys(objectLiteral).map((key, index) => `\"${key}\"` + \"=?\")\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}