{"ast":null,"code":"import { getMetadataArgsStorage } from \"../../globals\";\n/**\n * Marks a entity property as a children of the tree.\n * \"Tree children\" will contain all children (bind) of this entity.\n */\nexport function TreeChildren(options) {\n  return function (object, propertyName) {\n    if (!options) options = {};\n    // now try to determine it its lazy relation\n    const reflectedType = Reflect && Reflect.getMetadata ? Reflect.getMetadata(\"design:type\", object, propertyName) : undefined;\n    const isLazy = reflectedType && typeof reflectedType.name === \"string\" && reflectedType.name.toLowerCase() === \"promise\" || false;\n    // add one-to-many relation for this\n    getMetadataArgsStorage().relations.push({\n      isTreeChildren: true,\n      target: object.constructor,\n      propertyName: propertyName,\n      isLazy: isLazy,\n      relationType: \"one-to-many\",\n      type: () => object.constructor,\n      options: options\n    });\n  };\n}","map":{"version":3,"names":["getMetadataArgsStorage","TreeChildren","options","object","propertyName","reflectedType","Reflect","getMetadata","undefined","isLazy","name","toLowerCase","relations","push","isTreeChildren","target","constructor","relationType","type"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\decorator\\tree\\TreeChildren.ts"],"sourcesContent":["import { getMetadataArgsStorage } from \"../../globals\"\nimport { RelationMetadataArgs } from \"../../metadata-args/RelationMetadataArgs\"\nimport { RelationOptions } from \"../options/RelationOptions\"\n\n/**\n * Marks a entity property as a children of the tree.\n * \"Tree children\" will contain all children (bind) of this entity.\n */\nexport function TreeChildren(options?: {\n    cascade?:\n        | boolean\n        | (\"insert\" | \"update\" | \"remove\" | \"soft-remove\" | \"recover\")[]\n}): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        if (!options) options = {} as RelationOptions\n\n        // now try to determine it its lazy relation\n        const reflectedType =\n            Reflect && (Reflect as any).getMetadata\n                ? Reflect.getMetadata(\"design:type\", object, propertyName)\n                : undefined\n        const isLazy =\n            (reflectedType &&\n                typeof reflectedType.name === \"string\" &&\n                reflectedType.name.toLowerCase() === \"promise\") ||\n            false\n\n        // add one-to-many relation for this\n        getMetadataArgsStorage().relations.push({\n            isTreeChildren: true,\n            target: object.constructor,\n            propertyName: propertyName,\n            isLazy: isLazy,\n            relationType: \"one-to-many\",\n            type: () => object.constructor,\n            options: options,\n        } as RelationMetadataArgs)\n    }\n}\n"],"mappings":"AAAA,SAASA,sBAAsB,QAAQ,eAAe;AAItD;;;;AAIA,OAAM,SAAUC,YAAYA,CAACC,OAI5B;EACG,OAAO,UAAUC,MAAc,EAAEC,YAAoB;IACjD,IAAI,CAACF,OAAO,EAAEA,OAAO,GAAG,EAAqB;IAE7C;IACA,MAAMG,aAAa,GACfC,OAAO,IAAKA,OAAe,CAACC,WAAW,GACjCD,OAAO,CAACC,WAAW,CAAC,aAAa,EAAEJ,MAAM,EAAEC,YAAY,CAAC,GACxDI,SAAS;IACnB,MAAMC,MAAM,GACPJ,aAAa,IACV,OAAOA,aAAa,CAACK,IAAI,KAAK,QAAQ,IACtCL,aAAa,CAACK,IAAI,CAACC,WAAW,EAAE,KAAK,SAAS,IAClD,KAAK;IAET;IACAX,sBAAsB,EAAE,CAACY,SAAS,CAACC,IAAI,CAAC;MACpCC,cAAc,EAAE,IAAI;MACpBC,MAAM,EAAEZ,MAAM,CAACa,WAAW;MAC1BZ,YAAY,EAAEA,YAAY;MAC1BK,MAAM,EAAEA,MAAM;MACdQ,YAAY,EAAE,aAAa;MAC3BC,IAAI,EAAEA,CAAA,KAAMf,MAAM,CAACa,WAAW;MAC9Bd,OAAO,EAAEA;KACY,CAAC;EAC9B,CAAC;AACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}