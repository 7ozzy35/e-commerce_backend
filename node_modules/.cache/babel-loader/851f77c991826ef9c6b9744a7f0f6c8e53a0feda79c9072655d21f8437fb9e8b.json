{"ast":null,"code":"import { Table } from \"../schema-builder/table/Table\";\nimport { Migration } from \"./Migration\";\nimport { MssqlParameter } from \"../driver/sqlserver/MssqlParameter\";\nimport { ForbiddenTransactionModeOverrideError, TypeORMError } from \"../error\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\n/**\n * Executes migrations: runs pending and reverts previously executed migrations.\n */\nexport class MigrationExecutor {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection, queryRunner) {\n    this.connection = connection;\n    this.queryRunner = queryRunner;\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n    /**\n     * Indicates how migrations should be run in transactions.\n     *   all: all migrations are run in a single transaction\n     *   none: all migrations are run without a transaction\n     *   each: each migration is run in a separate transaction\n     */\n    this.transaction = \"all\";\n    const {\n      schema\n    } = this.connection.driver.options;\n    const database = this.connection.driver.database;\n    this.migrationsDatabase = database;\n    this.migrationsSchema = schema;\n    this.migrationsTableName = connection.options.migrationsTableName || \"migrations\";\n    this.migrationsTable = this.connection.driver.buildTableName(this.migrationsTableName, schema, database);\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Tries to execute a single migration given.\n   */\n  async executeMigration(migration) {\n    return this.withQueryRunner(async queryRunner => {\n      await this.createMigrationsTableIfNotExist(queryRunner);\n      // create typeorm_metadata table if it's not created yet\n      const schemaBuilder = this.connection.driver.createSchemaBuilder();\n      if (InstanceChecker.isRdbmsSchemaBuilder(schemaBuilder)) {\n        await schemaBuilder.createMetadataTableIfNecessary(queryRunner);\n      }\n      await queryRunner.beforeMigration();\n      await migration.instance.up(queryRunner);\n      await queryRunner.afterMigration();\n      await this.insertExecutedMigration(queryRunner, migration);\n      return migration;\n    });\n  }\n  /**\n   * Returns an array of all migrations.\n   */\n  async getAllMigrations() {\n    return Promise.resolve(this.getMigrations());\n  }\n  /**\n   * Returns an array of all executed migrations.\n   */\n  async getExecutedMigrations() {\n    return this.withQueryRunner(async queryRunner => {\n      await this.createMigrationsTableIfNotExist(queryRunner);\n      return await this.loadExecutedMigrations(queryRunner);\n    });\n  }\n  /**\n   * Returns an array of all pending migrations.\n   */\n  async getPendingMigrations() {\n    const allMigrations = await this.getAllMigrations();\n    const executedMigrations = await this.getExecutedMigrations();\n    return allMigrations.filter(migration => !executedMigrations.find(executedMigration => executedMigration.name === migration.name));\n  }\n  /**\n   * Inserts an executed migration.\n   */\n  insertMigration(migration) {\n    return this.withQueryRunner(q => this.insertExecutedMigration(q, migration));\n  }\n  /**\n   * Deletes an executed migration.\n   */\n  deleteMigration(migration) {\n    return this.withQueryRunner(q => this.deleteExecutedMigration(q, migration));\n  }\n  /**\n   * Lists all migrations and whether they have been executed or not\n   * returns true if there are unapplied migrations\n   */\n  async showMigrations() {\n    let hasUnappliedMigrations = false;\n    const queryRunner = this.queryRunner || this.connection.createQueryRunner();\n    // create migrations table if its not created yet\n    await this.createMigrationsTableIfNotExist(queryRunner);\n    // get all migrations that are executed and saved in the database\n    const executedMigrations = await this.loadExecutedMigrations(queryRunner);\n    // get all user's migrations in the source code\n    const allMigrations = this.getMigrations();\n    for (const migration of allMigrations) {\n      const executedMigration = executedMigrations.find(executedMigration => executedMigration.name === migration.name);\n      if (executedMigration) {\n        this.connection.logger.logSchemaBuild(`[X] ${executedMigration.id} ${migration.name}`);\n      } else {\n        hasUnappliedMigrations = true;\n        this.connection.logger.logSchemaBuild(`[ ] ${migration.name}`);\n      }\n    }\n    // if query runner was created by us then release it\n    if (!this.queryRunner) {\n      await queryRunner.release();\n    }\n    return hasUnappliedMigrations;\n  }\n  /**\n   * Executes all pending migrations. Pending migrations are migrations that are not yet executed,\n   * thus not saved in the database.\n   */\n  async executePendingMigrations() {\n    const queryRunner = this.queryRunner || this.connection.createQueryRunner();\n    // create migrations table if it's not created yet\n    await this.createMigrationsTableIfNotExist(queryRunner);\n    // create the typeorm_metadata table if it's not created yet\n    const schemaBuilder = this.connection.driver.createSchemaBuilder();\n    if (InstanceChecker.isRdbmsSchemaBuilder(schemaBuilder)) {\n      await schemaBuilder.createMetadataTableIfNecessary(queryRunner);\n    }\n    // get all migrations that are executed and saved in the database\n    const executedMigrations = await this.loadExecutedMigrations(queryRunner);\n    // get the time when last migration was executed\n    let lastTimeExecutedMigration = this.getLatestTimestampMigration(executedMigrations);\n    // get all user's migrations in the source code\n    const allMigrations = this.getMigrations();\n    // variable to store all migrations we did successfully\n    const successMigrations = [];\n    // find all migrations that needs to be executed\n    const pendingMigrations = allMigrations.filter(migration => {\n      // check if we already have executed migration\n      const executedMigration = executedMigrations.find(executedMigration => executedMigration.name === migration.name);\n      if (executedMigration) return false;\n      // migration is new and not executed. now check if its timestamp is correct\n      // if (lastTimeExecutedMigration && migration.timestamp < lastTimeExecutedMigration.timestamp)\n      //     throw new TypeORMError(`New migration found: ${migration.name}, however this migration's timestamp is not valid. Migration's timestamp should not be older then migrations already executed in the database.`);\n      // every check is passed means that migration was not run yet and we need to run it\n      return true;\n    });\n    // if no migrations are pending then nothing to do here\n    if (!pendingMigrations.length) {\n      this.connection.logger.logSchemaBuild(`No migrations are pending`);\n      // if query runner was created by us then release it\n      if (!this.queryRunner) await queryRunner.release();\n      return [];\n    }\n    // log information about migration execution\n    this.connection.logger.logSchemaBuild(`${executedMigrations.length} migrations are already loaded in the database.`);\n    this.connection.logger.logSchemaBuild(`${allMigrations.length} migrations were found in the source code.`);\n    if (lastTimeExecutedMigration) this.connection.logger.logSchemaBuild(`${lastTimeExecutedMigration.name} is the last executed migration. It was executed on ${new Date(lastTimeExecutedMigration.timestamp).toString()}.`);\n    this.connection.logger.logSchemaBuild(`${pendingMigrations.length} migrations are new migrations must be executed.`);\n    if (this.transaction === \"all\") {\n      // If we desire to run all migrations in a single transaction\n      // but there is a migration that explicitly overrides the transaction mode\n      // then we have to fail since we cannot properly resolve that intent\n      // In theory we could support overrides that are set to `true`,\n      // however to keep the interface more rigid, we fail those too\n      const migrationsOverridingTransactionMode = pendingMigrations.filter(migration => !(migration.instance?.transaction === undefined));\n      if (migrationsOverridingTransactionMode.length > 0) {\n        const error = new ForbiddenTransactionModeOverrideError(migrationsOverridingTransactionMode);\n        this.connection.logger.logMigration(`Migrations failed, error: ${error.message}`);\n        throw error;\n      }\n    }\n    // Set the per-migration defaults for the transaction mode\n    // so that we have one centralized place that controls this behavior\n    // When transaction mode is `each` the default is to run in a transaction\n    // When transaction mode is `none` the default is to not run in a transaction\n    // When transaction mode is `all` the default is to not run in a transaction\n    // since all the migrations are already running in one single transaction\n    const txModeDefault = {\n      each: true,\n      none: false,\n      all: false\n    }[this.transaction];\n    for (const migration of pendingMigrations) {\n      if (migration.instance) {\n        const instanceTx = migration.instance.transaction;\n        if (instanceTx === undefined) {\n          migration.transaction = txModeDefault;\n        } else {\n          migration.transaction = instanceTx;\n        }\n      }\n    }\n    // start transaction if its not started yet\n    let transactionStartedByUs = false;\n    if (this.transaction === \"all\" && !queryRunner.isTransactionActive) {\n      await queryRunner.beforeMigration();\n      await queryRunner.startTransaction();\n      transactionStartedByUs = true;\n    }\n    // run all pending migrations in a sequence\n    try {\n      for (const migration of pendingMigrations) {\n        if (this.fake) {\n          // directly insert migration record into the database if it is fake\n          await this.insertExecutedMigration(queryRunner, migration);\n          // nothing else needs to be done, continue to next migration\n          continue;\n        }\n        if (migration.transaction && !queryRunner.isTransactionActive) {\n          await queryRunner.beforeMigration();\n          await queryRunner.startTransaction();\n          transactionStartedByUs = true;\n        }\n        await migration.instance.up(queryRunner).catch(error => {\n          // informative log about migration failure\n          this.connection.logger.logMigration(`Migration \"${migration.name}\" failed, error: ${error?.message}`);\n          throw error;\n        }).then(async () => {\n          // now when migration is executed we need to insert record about it into the database\n          await this.insertExecutedMigration(queryRunner, migration);\n          // commit transaction if we started it\n          if (migration.transaction && transactionStartedByUs) {\n            await queryRunner.commitTransaction();\n            await queryRunner.afterMigration();\n          }\n        }).then(() => {\n          // informative log about migration success\n          successMigrations.push(migration);\n          this.connection.logger.logSchemaBuild(`Migration ${migration.name} has been ${this.fake ? \"(fake)\" : \"\"} executed successfully.`);\n        });\n      }\n      // commit transaction if we started it\n      if (this.transaction === \"all\" && transactionStartedByUs) {\n        await queryRunner.commitTransaction();\n        await queryRunner.afterMigration();\n      }\n    } catch (err) {\n      // rollback transaction if we started it\n      if (transactionStartedByUs) {\n        try {\n          // we throw original error even if rollback thrown an error\n          await queryRunner.rollbackTransaction();\n        } catch (rollbackError) {}\n      }\n      throw err;\n    } finally {\n      // if query runner was created by us then release it\n      if (!this.queryRunner) await queryRunner.release();\n    }\n    return successMigrations;\n  }\n  /**\n   * Reverts last migration that were run.\n   */\n  async undoLastMigration() {\n    const queryRunner = this.queryRunner || this.connection.createQueryRunner();\n    // create migrations table if it's not created yet\n    await this.createMigrationsTableIfNotExist(queryRunner);\n    // create typeorm_metadata table if it's not created yet\n    const schemaBuilder = this.connection.driver.createSchemaBuilder();\n    if (InstanceChecker.isRdbmsSchemaBuilder(schemaBuilder)) {\n      await schemaBuilder.createMetadataTableIfNecessary(queryRunner);\n    }\n    // get all migrations that are executed and saved in the database\n    const executedMigrations = await this.loadExecutedMigrations(queryRunner);\n    // get the time when last migration was executed\n    let lastTimeExecutedMigration = this.getLatestExecutedMigration(executedMigrations);\n    // if no migrations found in the database then nothing to revert\n    if (!lastTimeExecutedMigration) {\n      this.connection.logger.logSchemaBuild(`No migrations were found in the database. Nothing to revert!`);\n      return;\n    }\n    // get all user's migrations in the source code\n    const allMigrations = this.getMigrations();\n    // find the instance of the migration we need to remove\n    const migrationToRevert = allMigrations.find(migration => migration.name === lastTimeExecutedMigration.name);\n    // if no migrations found in the database then nothing to revert\n    if (!migrationToRevert) throw new TypeORMError(`No migration ${lastTimeExecutedMigration.name} was found in the source code. Make sure you have this migration in your codebase and its included in the connection options.`);\n    // log information about migration execution\n    this.connection.logger.logSchemaBuild(`${executedMigrations.length} migrations are already loaded in the database.`);\n    this.connection.logger.logSchemaBuild(`${lastTimeExecutedMigration.name} is the last executed migration. It was executed on ${new Date(lastTimeExecutedMigration.timestamp).toString()}.`);\n    this.connection.logger.logSchemaBuild(`Now reverting it...`);\n    // start transaction if its not started yet\n    let transactionStartedByUs = false;\n    if (this.transaction !== \"none\" && !queryRunner.isTransactionActive) {\n      await queryRunner.startTransaction();\n      transactionStartedByUs = true;\n    }\n    try {\n      if (!this.fake) {\n        await queryRunner.beforeMigration();\n        await migrationToRevert.instance.down(queryRunner);\n        await queryRunner.afterMigration();\n      }\n      await this.deleteExecutedMigration(queryRunner, migrationToRevert);\n      this.connection.logger.logSchemaBuild(`Migration ${migrationToRevert.name} has been ${this.fake ? \"(fake)\" : \"\"} reverted successfully.`);\n      // commit transaction if we started it\n      if (transactionStartedByUs) await queryRunner.commitTransaction();\n    } catch (err) {\n      // rollback transaction if we started it\n      if (transactionStartedByUs) {\n        try {\n          // we throw original error even if rollback thrown an error\n          await queryRunner.rollbackTransaction();\n        } catch (rollbackError) {}\n      }\n      throw err;\n    } finally {\n      // if query runner was created by us then release it\n      if (!this.queryRunner) await queryRunner.release();\n    }\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates table \"migrations\" that will store information about executed migrations.\n   */\n  async createMigrationsTableIfNotExist(queryRunner) {\n    // If driver is mongo no need to create\n    if (this.connection.driver.options.type === \"mongodb\") {\n      return;\n    }\n    const tableExist = await queryRunner.hasTable(this.migrationsTable); // todo: table name should be configurable\n    if (!tableExist) {\n      await queryRunner.createTable(new Table({\n        database: this.migrationsDatabase,\n        schema: this.migrationsSchema,\n        name: this.migrationsTable,\n        columns: [{\n          name: \"id\",\n          type: this.connection.driver.normalizeType({\n            type: this.connection.driver.mappedDataTypes.migrationId\n          }),\n          isGenerated: true,\n          generationStrategy: \"increment\",\n          isPrimary: true,\n          isNullable: false\n        }, {\n          name: \"timestamp\",\n          type: this.connection.driver.normalizeType({\n            type: this.connection.driver.mappedDataTypes.migrationTimestamp\n          }),\n          isPrimary: false,\n          isNullable: false\n        }, {\n          name: \"name\",\n          type: this.connection.driver.normalizeType({\n            type: this.connection.driver.mappedDataTypes.migrationName\n          }),\n          isNullable: false\n        }]\n      }));\n    }\n  }\n  /**\n   * Loads all migrations that were executed and saved into the database (sorts by id).\n   */\n  async loadExecutedMigrations(queryRunner) {\n    if (this.connection.driver.options.type === \"mongodb\") {\n      const mongoRunner = queryRunner;\n      return mongoRunner.cursor(this.migrationsTableName, {}).sort({\n        _id: -1\n      }).toArray();\n    } else {\n      const migrationsRaw = await this.connection.manager.createQueryBuilder(queryRunner).select().orderBy(this.connection.driver.escape(\"id\"), \"DESC\").from(this.migrationsTable, this.migrationsTableName).getRawMany();\n      return migrationsRaw.map(migrationRaw => {\n        return new Migration(parseInt(migrationRaw[\"id\"]), parseInt(migrationRaw[\"timestamp\"]), migrationRaw[\"name\"]);\n      });\n    }\n  }\n  /**\n   * Gets all migrations that setup for this connection.\n   */\n  getMigrations() {\n    const migrations = this.connection.migrations.map(migration => {\n      const migrationClassName = migration.name || migration.constructor.name;\n      const migrationTimestamp = parseInt(migrationClassName.substr(-13), 10);\n      if (!migrationTimestamp || isNaN(migrationTimestamp)) {\n        throw new TypeORMError(`${migrationClassName} migration name is wrong. Migration class name should have a JavaScript timestamp appended.`);\n      }\n      return new Migration(undefined, migrationTimestamp, migrationClassName, migration);\n    });\n    this.checkForDuplicateMigrations(migrations);\n    // sort them by timestamp\n    return migrations.sort((a, b) => a.timestamp - b.timestamp);\n  }\n  checkForDuplicateMigrations(migrations) {\n    const migrationNames = migrations.map(migration => migration.name);\n    const duplicates = Array.from(new Set(migrationNames.filter((migrationName, index) => migrationNames.indexOf(migrationName) < index)));\n    if (duplicates.length > 0) {\n      throw Error(`Duplicate migrations: ${duplicates.join(\", \")}`);\n    }\n  }\n  /**\n   * Finds the latest migration (sorts by timestamp) in the given array of migrations.\n   */\n  getLatestTimestampMigration(migrations) {\n    const sortedMigrations = migrations.map(migration => migration).sort((a, b) => (a.timestamp - b.timestamp) * -1);\n    return sortedMigrations.length > 0 ? sortedMigrations[0] : undefined;\n  }\n  /**\n   * Finds the latest migration in the given array of migrations.\n   * PRE: Migration array must be sorted by descending id.\n   */\n  getLatestExecutedMigration(sortedMigrations) {\n    return sortedMigrations.length > 0 ? sortedMigrations[0] : undefined;\n  }\n  /**\n   * Inserts new executed migration's data into migrations table.\n   */\n  async insertExecutedMigration(queryRunner, migration) {\n    const values = {};\n    if (this.connection.driver.options.type === \"mssql\") {\n      values[\"timestamp\"] = new MssqlParameter(migration.timestamp, this.connection.driver.normalizeType({\n        type: this.connection.driver.mappedDataTypes.migrationTimestamp\n      }));\n      values[\"name\"] = new MssqlParameter(migration.name, this.connection.driver.normalizeType({\n        type: this.connection.driver.mappedDataTypes.migrationName\n      }));\n    } else {\n      values[\"timestamp\"] = migration.timestamp;\n      values[\"name\"] = migration.name;\n    }\n    if (this.connection.driver.options.type === \"mongodb\") {\n      const mongoRunner = queryRunner;\n      await mongoRunner.databaseConnection.db(this.connection.driver.database).collection(this.migrationsTableName).insertOne(values);\n    } else {\n      const qb = queryRunner.manager.createQueryBuilder();\n      await qb.insert().into(this.migrationsTable).values(values).execute();\n    }\n  }\n  /**\n   * Delete previously executed migration's data from the migrations table.\n   */\n  async deleteExecutedMigration(queryRunner, migration) {\n    const conditions = {};\n    if (this.connection.driver.options.type === \"mssql\") {\n      conditions[\"timestamp\"] = new MssqlParameter(migration.timestamp, this.connection.driver.normalizeType({\n        type: this.connection.driver.mappedDataTypes.migrationTimestamp\n      }));\n      conditions[\"name\"] = new MssqlParameter(migration.name, this.connection.driver.normalizeType({\n        type: this.connection.driver.mappedDataTypes.migrationName\n      }));\n    } else {\n      conditions[\"timestamp\"] = migration.timestamp;\n      conditions[\"name\"] = migration.name;\n    }\n    if (this.connection.driver.options.type === \"mongodb\") {\n      const mongoRunner = queryRunner;\n      await mongoRunner.databaseConnection.db(this.connection.driver.database).collection(this.migrationsTableName).deleteOne(conditions);\n    } else {\n      const qb = queryRunner.manager.createQueryBuilder();\n      await qb.delete().from(this.migrationsTable).where(`${qb.escape(\"timestamp\")} = :timestamp`).andWhere(`${qb.escape(\"name\")} = :name`).setParameters(conditions).execute();\n    }\n  }\n  async withQueryRunner(callback) {\n    const queryRunner = this.queryRunner || this.connection.createQueryRunner();\n    try {\n      return await callback(queryRunner);\n    } finally {\n      if (!this.queryRunner) {\n        await queryRunner.release();\n      }\n    }\n  }\n}","map":{"version":3,"names":["Table","Migration","MssqlParameter","ForbiddenTransactionModeOverrideError","TypeORMError","InstanceChecker","MigrationExecutor","constructor","connection","queryRunner","transaction","schema","driver","options","database","migrationsDatabase","migrationsSchema","migrationsTableName","migrationsTable","buildTableName","executeMigration","migration","withQueryRunner","createMigrationsTableIfNotExist","schemaBuilder","createSchemaBuilder","isRdbmsSchemaBuilder","createMetadataTableIfNecessary","beforeMigration","instance","up","afterMigration","insertExecutedMigration","getAllMigrations","Promise","resolve","getMigrations","getExecutedMigrations","loadExecutedMigrations","getPendingMigrations","allMigrations","executedMigrations","filter","find","executedMigration","name","insertMigration","q","deleteMigration","deleteExecutedMigration","showMigrations","hasUnappliedMigrations","createQueryRunner","logger","logSchemaBuild","id","release","executePendingMigrations","lastTimeExecutedMigration","getLatestTimestampMigration","successMigrations","pendingMigrations","length","Date","timestamp","toString","migrationsOverridingTransactionMode","undefined","error","logMigration","message","txModeDefault","each","none","all","instanceTx","transactionStartedByUs","isTransactionActive","startTransaction","fake","catch","then","commitTransaction","push","err","rollbackTransaction","rollbackError","undoLastMigration","getLatestExecutedMigration","migrationToRevert","down","type","tableExist","hasTable","createTable","columns","normalizeType","mappedDataTypes","migrationId","isGenerated","generationStrategy","isPrimary","isNullable","migrationTimestamp","migrationName","mongoRunner","cursor","sort","_id","toArray","migrationsRaw","manager","createQueryBuilder","select","orderBy","escape","from","getRawMany","map","migrationRaw","parseInt","migrations","migrationClassName","substr","isNaN","checkForDuplicateMigrations","a","b","migrationNames","duplicates","Array","Set","index","indexOf","Error","join","sortedMigrations","values","databaseConnection","db","collection","insertOne","qb","insert","into","execute","conditions","deleteOne","delete","where","andWhere","setParameters","callback"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\migration\\MigrationExecutor.ts"],"sourcesContent":["import { Table } from \"../schema-builder/table/Table\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { Migration } from \"./Migration\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { MssqlParameter } from \"../driver/sqlserver/MssqlParameter\"\nimport { MongoQueryRunner } from \"../driver/mongodb/MongoQueryRunner\"\nimport { ForbiddenTransactionModeOverrideError, TypeORMError } from \"../error\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\n\n/**\n * Executes migrations: runs pending and reverts previously executed migrations.\n */\nexport class MigrationExecutor {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Indicates how migrations should be run in transactions.\n     *   all: all migrations are run in a single transaction\n     *   none: all migrations are run without a transaction\n     *   each: each migration is run in a separate transaction\n     */\n    transaction: \"all\" | \"none\" | \"each\" = \"all\"\n\n    /**\n     * Option to fake-run or fake-revert a migration, adding to the\n     * executed migrations table, but not actually running it. This feature is\n     * useful for when migrations are added after the fact or for\n     * interoperability between applications which are desired to each keep\n     * a consistent migration history.\n     */\n    fake: boolean\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    private readonly migrationsDatabase?: string\n    private readonly migrationsSchema?: string\n    private readonly migrationsTable: string\n    private readonly migrationsTableName: string\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        protected connection: DataSource,\n        protected queryRunner?: QueryRunner,\n    ) {\n        const { schema } = this.connection.driver.options as any\n        const database = this.connection.driver.database\n        this.migrationsDatabase = database\n        this.migrationsSchema = schema\n        this.migrationsTableName =\n            connection.options.migrationsTableName || \"migrations\"\n        this.migrationsTable = this.connection.driver.buildTableName(\n            this.migrationsTableName,\n            schema,\n            database,\n        )\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Tries to execute a single migration given.\n     */\n    public async executeMigration(migration: Migration): Promise<Migration> {\n        return this.withQueryRunner(async (queryRunner) => {\n            await this.createMigrationsTableIfNotExist(queryRunner)\n\n            // create typeorm_metadata table if it's not created yet\n            const schemaBuilder = this.connection.driver.createSchemaBuilder()\n            if (InstanceChecker.isRdbmsSchemaBuilder(schemaBuilder)) {\n                await schemaBuilder.createMetadataTableIfNecessary(queryRunner)\n            }\n\n            await queryRunner.beforeMigration()\n            await (migration.instance as any).up(queryRunner)\n            await queryRunner.afterMigration()\n            await this.insertExecutedMigration(queryRunner, migration)\n\n            return migration\n        })\n    }\n\n    /**\n     * Returns an array of all migrations.\n     */\n    public async getAllMigrations(): Promise<Migration[]> {\n        return Promise.resolve(this.getMigrations())\n    }\n\n    /**\n     * Returns an array of all executed migrations.\n     */\n    public async getExecutedMigrations(): Promise<Migration[]> {\n        return this.withQueryRunner(async (queryRunner) => {\n            await this.createMigrationsTableIfNotExist(queryRunner)\n\n            return await this.loadExecutedMigrations(queryRunner)\n        })\n    }\n\n    /**\n     * Returns an array of all pending migrations.\n     */\n    public async getPendingMigrations(): Promise<Migration[]> {\n        const allMigrations = await this.getAllMigrations()\n        const executedMigrations = await this.getExecutedMigrations()\n\n        return allMigrations.filter(\n            (migration) =>\n                !executedMigrations.find(\n                    (executedMigration) =>\n                        executedMigration.name === migration.name,\n                ),\n        )\n    }\n\n    /**\n     * Inserts an executed migration.\n     */\n    public insertMigration(migration: Migration): Promise<void> {\n        return this.withQueryRunner((q) =>\n            this.insertExecutedMigration(q, migration),\n        )\n    }\n\n    /**\n     * Deletes an executed migration.\n     */\n    public deleteMigration(migration: Migration): Promise<void> {\n        return this.withQueryRunner((q) =>\n            this.deleteExecutedMigration(q, migration),\n        )\n    }\n\n    /**\n     * Lists all migrations and whether they have been executed or not\n     * returns true if there are unapplied migrations\n     */\n    async showMigrations(): Promise<boolean> {\n        let hasUnappliedMigrations = false\n        const queryRunner =\n            this.queryRunner || this.connection.createQueryRunner()\n        // create migrations table if its not created yet\n        await this.createMigrationsTableIfNotExist(queryRunner)\n\n        // get all migrations that are executed and saved in the database\n        const executedMigrations = await this.loadExecutedMigrations(\n            queryRunner,\n        )\n\n        // get all user's migrations in the source code\n        const allMigrations = this.getMigrations()\n\n        for (const migration of allMigrations) {\n            const executedMigration = executedMigrations.find(\n                (executedMigration) =>\n                    executedMigration.name === migration.name,\n            )\n\n            if (executedMigration) {\n                this.connection.logger.logSchemaBuild(\n                    `[X] ${executedMigration.id} ${migration.name}`,\n                )\n            } else {\n                hasUnappliedMigrations = true\n                this.connection.logger.logSchemaBuild(`[ ] ${migration.name}`)\n            }\n        }\n\n        // if query runner was created by us then release it\n        if (!this.queryRunner) {\n            await queryRunner.release()\n        }\n\n        return hasUnappliedMigrations\n    }\n\n    /**\n     * Executes all pending migrations. Pending migrations are migrations that are not yet executed,\n     * thus not saved in the database.\n     */\n    async executePendingMigrations(): Promise<Migration[]> {\n        const queryRunner =\n            this.queryRunner || this.connection.createQueryRunner()\n        // create migrations table if it's not created yet\n        await this.createMigrationsTableIfNotExist(queryRunner)\n\n        // create the typeorm_metadata table if it's not created yet\n        const schemaBuilder = this.connection.driver.createSchemaBuilder()\n        if (InstanceChecker.isRdbmsSchemaBuilder(schemaBuilder)) {\n            await schemaBuilder.createMetadataTableIfNecessary(queryRunner)\n        }\n\n        // get all migrations that are executed and saved in the database\n        const executedMigrations = await this.loadExecutedMigrations(\n            queryRunner,\n        )\n\n        // get the time when last migration was executed\n        let lastTimeExecutedMigration =\n            this.getLatestTimestampMigration(executedMigrations)\n\n        // get all user's migrations in the source code\n        const allMigrations = this.getMigrations()\n\n        // variable to store all migrations we did successfully\n        const successMigrations: Migration[] = []\n\n        // find all migrations that needs to be executed\n        const pendingMigrations = allMigrations.filter((migration) => {\n            // check if we already have executed migration\n            const executedMigration = executedMigrations.find(\n                (executedMigration) =>\n                    executedMigration.name === migration.name,\n            )\n            if (executedMigration) return false\n\n            // migration is new and not executed. now check if its timestamp is correct\n            // if (lastTimeExecutedMigration && migration.timestamp < lastTimeExecutedMigration.timestamp)\n            //     throw new TypeORMError(`New migration found: ${migration.name}, however this migration's timestamp is not valid. Migration's timestamp should not be older then migrations already executed in the database.`);\n\n            // every check is passed means that migration was not run yet and we need to run it\n            return true\n        })\n\n        // if no migrations are pending then nothing to do here\n        if (!pendingMigrations.length) {\n            this.connection.logger.logSchemaBuild(`No migrations are pending`)\n            // if query runner was created by us then release it\n            if (!this.queryRunner) await queryRunner.release()\n            return []\n        }\n\n        // log information about migration execution\n        this.connection.logger.logSchemaBuild(\n            `${executedMigrations.length} migrations are already loaded in the database.`,\n        )\n        this.connection.logger.logSchemaBuild(\n            `${allMigrations.length} migrations were found in the source code.`,\n        )\n        if (lastTimeExecutedMigration)\n            this.connection.logger.logSchemaBuild(\n                `${\n                    lastTimeExecutedMigration.name\n                } is the last executed migration. It was executed on ${new Date(\n                    lastTimeExecutedMigration.timestamp,\n                ).toString()}.`,\n            )\n        this.connection.logger.logSchemaBuild(\n            `${pendingMigrations.length} migrations are new migrations must be executed.`,\n        )\n\n        if (this.transaction === \"all\") {\n            // If we desire to run all migrations in a single transaction\n            // but there is a migration that explicitly overrides the transaction mode\n            // then we have to fail since we cannot properly resolve that intent\n            // In theory we could support overrides that are set to `true`,\n            // however to keep the interface more rigid, we fail those too\n            const migrationsOverridingTransactionMode =\n                pendingMigrations.filter(\n                    (migration) =>\n                        !(migration.instance?.transaction === undefined),\n                )\n\n            if (migrationsOverridingTransactionMode.length > 0) {\n                const error = new ForbiddenTransactionModeOverrideError(\n                    migrationsOverridingTransactionMode,\n                )\n                this.connection.logger.logMigration(\n                    `Migrations failed, error: ${error.message}`,\n                )\n                throw error\n            }\n        }\n\n        // Set the per-migration defaults for the transaction mode\n        // so that we have one centralized place that controls this behavior\n\n        // When transaction mode is `each` the default is to run in a transaction\n        // When transaction mode is `none` the default is to not run in a transaction\n        // When transaction mode is `all` the default is to not run in a transaction\n        // since all the migrations are already running in one single transaction\n\n        const txModeDefault = {\n            each: true,\n            none: false,\n            all: false,\n        }[this.transaction]\n\n        for (const migration of pendingMigrations) {\n            if (migration.instance) {\n                const instanceTx = migration.instance.transaction\n\n                if (instanceTx === undefined) {\n                    migration.transaction = txModeDefault\n                } else {\n                    migration.transaction = instanceTx\n                }\n            }\n        }\n\n        // start transaction if its not started yet\n        let transactionStartedByUs = false\n        if (this.transaction === \"all\" && !queryRunner.isTransactionActive) {\n            await queryRunner.beforeMigration()\n            await queryRunner.startTransaction()\n            transactionStartedByUs = true\n        }\n\n        // run all pending migrations in a sequence\n        try {\n            for (const migration of pendingMigrations) {\n                if (this.fake) {\n                    // directly insert migration record into the database if it is fake\n                    await this.insertExecutedMigration(queryRunner, migration)\n\n                    // nothing else needs to be done, continue to next migration\n                    continue\n                }\n\n                if (migration.transaction && !queryRunner.isTransactionActive) {\n                    await queryRunner.beforeMigration()\n                    await queryRunner.startTransaction()\n                    transactionStartedByUs = true\n                }\n\n                await migration\n                    .instance!.up(queryRunner)\n                    .catch((error) => {\n                        // informative log about migration failure\n                        this.connection.logger.logMigration(\n                            `Migration \"${migration.name}\" failed, error: ${error?.message}`,\n                        )\n                        throw error\n                    })\n                    .then(async () => {\n                        // now when migration is executed we need to insert record about it into the database\n                        await this.insertExecutedMigration(\n                            queryRunner,\n                            migration,\n                        )\n                        // commit transaction if we started it\n                        if (migration.transaction && transactionStartedByUs) {\n                            await queryRunner.commitTransaction()\n                            await queryRunner.afterMigration()\n                        }\n                    })\n                    .then(() => {\n                        // informative log about migration success\n                        successMigrations.push(migration)\n                        this.connection.logger.logSchemaBuild(\n                            `Migration ${migration.name} has been ${\n                                this.fake ? \"(fake)\" : \"\"\n                            } executed successfully.`,\n                        )\n                    })\n            }\n\n            // commit transaction if we started it\n            if (this.transaction === \"all\" && transactionStartedByUs) {\n                await queryRunner.commitTransaction()\n                await queryRunner.afterMigration()\n            }\n        } catch (err) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    // we throw original error even if rollback thrown an error\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n\n            throw err\n        } finally {\n            // if query runner was created by us then release it\n            if (!this.queryRunner) await queryRunner.release()\n        }\n        return successMigrations\n    }\n\n    /**\n     * Reverts last migration that were run.\n     */\n    async undoLastMigration(): Promise<void> {\n        const queryRunner =\n            this.queryRunner || this.connection.createQueryRunner()\n\n        // create migrations table if it's not created yet\n        await this.createMigrationsTableIfNotExist(queryRunner)\n\n        // create typeorm_metadata table if it's not created yet\n        const schemaBuilder = this.connection.driver.createSchemaBuilder()\n        if (InstanceChecker.isRdbmsSchemaBuilder(schemaBuilder)) {\n            await schemaBuilder.createMetadataTableIfNecessary(queryRunner)\n        }\n\n        // get all migrations that are executed and saved in the database\n        const executedMigrations = await this.loadExecutedMigrations(\n            queryRunner,\n        )\n\n        // get the time when last migration was executed\n        let lastTimeExecutedMigration =\n            this.getLatestExecutedMigration(executedMigrations)\n\n        // if no migrations found in the database then nothing to revert\n        if (!lastTimeExecutedMigration) {\n            this.connection.logger.logSchemaBuild(\n                `No migrations were found in the database. Nothing to revert!`,\n            )\n            return\n        }\n\n        // get all user's migrations in the source code\n        const allMigrations = this.getMigrations()\n\n        // find the instance of the migration we need to remove\n        const migrationToRevert = allMigrations.find(\n            (migration) => migration.name === lastTimeExecutedMigration!.name,\n        )\n\n        // if no migrations found in the database then nothing to revert\n        if (!migrationToRevert)\n            throw new TypeORMError(\n                `No migration ${lastTimeExecutedMigration.name} was found in the source code. Make sure you have this migration in your codebase and its included in the connection options.`,\n            )\n\n        // log information about migration execution\n        this.connection.logger.logSchemaBuild(\n            `${executedMigrations.length} migrations are already loaded in the database.`,\n        )\n        this.connection.logger.logSchemaBuild(\n            `${\n                lastTimeExecutedMigration.name\n            } is the last executed migration. It was executed on ${new Date(\n                lastTimeExecutedMigration.timestamp,\n            ).toString()}.`,\n        )\n        this.connection.logger.logSchemaBuild(`Now reverting it...`)\n\n        // start transaction if its not started yet\n        let transactionStartedByUs = false\n        if (this.transaction !== \"none\" && !queryRunner.isTransactionActive) {\n            await queryRunner.startTransaction()\n            transactionStartedByUs = true\n        }\n\n        try {\n            if (!this.fake) {\n                await queryRunner.beforeMigration()\n                await migrationToRevert.instance!.down(queryRunner)\n                await queryRunner.afterMigration()\n            }\n\n            await this.deleteExecutedMigration(queryRunner, migrationToRevert)\n            this.connection.logger.logSchemaBuild(\n                `Migration ${migrationToRevert.name} has been ${\n                    this.fake ? \"(fake)\" : \"\"\n                } reverted successfully.`,\n            )\n\n            // commit transaction if we started it\n            if (transactionStartedByUs) await queryRunner.commitTransaction()\n        } catch (err) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    // we throw original error even if rollback thrown an error\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n\n            throw err\n        } finally {\n            // if query runner was created by us then release it\n            if (!this.queryRunner) await queryRunner.release()\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates table \"migrations\" that will store information about executed migrations.\n     */\n    protected async createMigrationsTableIfNotExist(\n        queryRunner: QueryRunner,\n    ): Promise<void> {\n        // If driver is mongo no need to create\n        if (this.connection.driver.options.type === \"mongodb\") {\n            return\n        }\n        const tableExist = await queryRunner.hasTable(this.migrationsTable) // todo: table name should be configurable\n        if (!tableExist) {\n            await queryRunner.createTable(\n                new Table({\n                    database: this.migrationsDatabase,\n                    schema: this.migrationsSchema,\n                    name: this.migrationsTable,\n                    columns: [\n                        {\n                            name: \"id\",\n                            type: this.connection.driver.normalizeType({\n                                type: this.connection.driver.mappedDataTypes\n                                    .migrationId,\n                            }),\n                            isGenerated: true,\n                            generationStrategy: \"increment\",\n                            isPrimary: true,\n                            isNullable: false,\n                        },\n                        {\n                            name: \"timestamp\",\n                            type: this.connection.driver.normalizeType({\n                                type: this.connection.driver.mappedDataTypes\n                                    .migrationTimestamp,\n                            }),\n                            isPrimary: false,\n                            isNullable: false,\n                        },\n                        {\n                            name: \"name\",\n                            type: this.connection.driver.normalizeType({\n                                type: this.connection.driver.mappedDataTypes\n                                    .migrationName,\n                            }),\n                            isNullable: false,\n                        },\n                    ],\n                }),\n            )\n        }\n    }\n\n    /**\n     * Loads all migrations that were executed and saved into the database (sorts by id).\n     */\n    protected async loadExecutedMigrations(\n        queryRunner: QueryRunner,\n    ): Promise<Migration[]> {\n        if (this.connection.driver.options.type === \"mongodb\") {\n            const mongoRunner = queryRunner as MongoQueryRunner\n            return mongoRunner\n                .cursor(this.migrationsTableName, {})\n                .sort({ _id: -1 })\n                .toArray()\n        } else {\n            const migrationsRaw: ObjectLiteral[] = await this.connection.manager\n                .createQueryBuilder(queryRunner)\n                .select()\n                .orderBy(this.connection.driver.escape(\"id\"), \"DESC\")\n                .from(this.migrationsTable, this.migrationsTableName)\n                .getRawMany()\n            return migrationsRaw.map((migrationRaw) => {\n                return new Migration(\n                    parseInt(migrationRaw[\"id\"]),\n                    parseInt(migrationRaw[\"timestamp\"]),\n                    migrationRaw[\"name\"],\n                )\n            })\n        }\n    }\n\n    /**\n     * Gets all migrations that setup for this connection.\n     */\n    protected getMigrations(): Migration[] {\n        const migrations = this.connection.migrations.map((migration) => {\n            const migrationClassName =\n                migration.name || (migration.constructor as any).name\n            const migrationTimestamp = parseInt(\n                migrationClassName.substr(-13),\n                10,\n            )\n            if (!migrationTimestamp || isNaN(migrationTimestamp)) {\n                throw new TypeORMError(\n                    `${migrationClassName} migration name is wrong. Migration class name should have a JavaScript timestamp appended.`,\n                )\n            }\n\n            return new Migration(\n                undefined,\n                migrationTimestamp,\n                migrationClassName,\n                migration,\n            )\n        })\n\n        this.checkForDuplicateMigrations(migrations)\n\n        // sort them by timestamp\n        return migrations.sort((a, b) => a.timestamp - b.timestamp)\n    }\n\n    protected checkForDuplicateMigrations(migrations: Migration[]) {\n        const migrationNames = migrations.map((migration) => migration.name)\n        const duplicates = Array.from(\n            new Set(\n                migrationNames.filter(\n                    (migrationName, index) =>\n                        migrationNames.indexOf(migrationName) < index,\n                ),\n            ),\n        )\n        if (duplicates.length > 0) {\n            throw Error(`Duplicate migrations: ${duplicates.join(\", \")}`)\n        }\n    }\n\n    /**\n     * Finds the latest migration (sorts by timestamp) in the given array of migrations.\n     */\n    protected getLatestTimestampMigration(\n        migrations: Migration[],\n    ): Migration | undefined {\n        const sortedMigrations = migrations\n            .map((migration) => migration)\n            .sort((a, b) => (a.timestamp - b.timestamp) * -1)\n        return sortedMigrations.length > 0 ? sortedMigrations[0] : undefined\n    }\n\n    /**\n     * Finds the latest migration in the given array of migrations.\n     * PRE: Migration array must be sorted by descending id.\n     */\n    protected getLatestExecutedMigration(\n        sortedMigrations: Migration[],\n    ): Migration | undefined {\n        return sortedMigrations.length > 0 ? sortedMigrations[0] : undefined\n    }\n\n    /**\n     * Inserts new executed migration's data into migrations table.\n     */\n    protected async insertExecutedMigration(\n        queryRunner: QueryRunner,\n        migration: Migration,\n    ): Promise<void> {\n        const values: ObjectLiteral = {}\n        if (this.connection.driver.options.type === \"mssql\") {\n            values[\"timestamp\"] = new MssqlParameter(\n                migration.timestamp,\n                this.connection.driver.normalizeType({\n                    type: this.connection.driver.mappedDataTypes\n                        .migrationTimestamp,\n                }) as any,\n            )\n            values[\"name\"] = new MssqlParameter(\n                migration.name,\n                this.connection.driver.normalizeType({\n                    type: this.connection.driver.mappedDataTypes.migrationName,\n                }) as any,\n            )\n        } else {\n            values[\"timestamp\"] = migration.timestamp\n            values[\"name\"] = migration.name\n        }\n        if (this.connection.driver.options.type === \"mongodb\") {\n            const mongoRunner = queryRunner as MongoQueryRunner\n            await mongoRunner.databaseConnection\n                .db(this.connection.driver.database!)\n                .collection(this.migrationsTableName)\n                .insertOne(values)\n        } else {\n            const qb = queryRunner.manager.createQueryBuilder()\n            await qb\n                .insert()\n                .into(this.migrationsTable)\n                .values(values)\n                .execute()\n        }\n    }\n\n    /**\n     * Delete previously executed migration's data from the migrations table.\n     */\n    protected async deleteExecutedMigration(\n        queryRunner: QueryRunner,\n        migration: Migration,\n    ): Promise<void> {\n        const conditions: ObjectLiteral = {}\n        if (this.connection.driver.options.type === \"mssql\") {\n            conditions[\"timestamp\"] = new MssqlParameter(\n                migration.timestamp,\n                this.connection.driver.normalizeType({\n                    type: this.connection.driver.mappedDataTypes\n                        .migrationTimestamp,\n                }) as any,\n            )\n            conditions[\"name\"] = new MssqlParameter(\n                migration.name,\n                this.connection.driver.normalizeType({\n                    type: this.connection.driver.mappedDataTypes.migrationName,\n                }) as any,\n            )\n        } else {\n            conditions[\"timestamp\"] = migration.timestamp\n            conditions[\"name\"] = migration.name\n        }\n\n        if (this.connection.driver.options.type === \"mongodb\") {\n            const mongoRunner = queryRunner as MongoQueryRunner\n            await mongoRunner.databaseConnection\n                .db(this.connection.driver.database!)\n                .collection(this.migrationsTableName)\n                .deleteOne(conditions)\n        } else {\n            const qb = queryRunner.manager.createQueryBuilder()\n            await qb\n                .delete()\n                .from(this.migrationsTable)\n                .where(`${qb.escape(\"timestamp\")} = :timestamp`)\n                .andWhere(`${qb.escape(\"name\")} = :name`)\n                .setParameters(conditions)\n                .execute()\n        }\n    }\n\n    protected async withQueryRunner<T extends any>(\n        callback: (queryRunner: QueryRunner) => T | Promise<T>,\n    ) {\n        const queryRunner =\n            this.queryRunner || this.connection.createQueryRunner()\n\n        try {\n            return await callback(queryRunner)\n        } finally {\n            if (!this.queryRunner) {\n                await queryRunner.release()\n            }\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}