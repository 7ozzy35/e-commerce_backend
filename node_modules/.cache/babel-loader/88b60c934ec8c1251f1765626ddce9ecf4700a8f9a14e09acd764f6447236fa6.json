{"ast":null,"code":"import { BroadcasterResult } from \"./BroadcasterResult\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\n/**\n * Broadcaster provides a helper methods to broadcast events to the subscribers.\n */\nexport class Broadcaster {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(queryRunner) {\n    this.queryRunner = queryRunner;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  async broadcast(event, ...args) {\n    const result = new BroadcasterResult();\n    const broadcastFunction = this[`broadcast${event}Event`];\n    if (typeof broadcastFunction === \"function\") {\n      ;\n      broadcastFunction.call(this, result, ...args);\n    }\n    await result.wait();\n  }\n  /**\n   * Broadcasts \"BEFORE_INSERT\" event.\n   * Before insert event is executed before entity is being inserted to the database for the first time.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n  broadcastBeforeInsertEvent(result, metadata, entity) {\n    if (entity && metadata.beforeInsertListeners.length) {\n      metadata.beforeInsertListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeInsert) {\n          const executionResult = subscriber.beforeInsert({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"BEFORE_UPDATE\" event.\n   * Before update event is executed before entity is being updated in the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n  broadcastBeforeUpdateEvent(result, metadata, entity, databaseEntity, updatedColumns, updatedRelations) {\n    // todo: send relations too?\n    if (entity && metadata.beforeUpdateListeners.length) {\n      metadata.beforeUpdateListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeUpdate) {\n          const executionResult = subscriber.beforeUpdate({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            databaseEntity: databaseEntity,\n            updatedColumns: updatedColumns || [],\n            updatedRelations: updatedRelations || []\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"BEFORE_REMOVE\" event.\n   * Before remove event is executed before entity is being removed from the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n  broadcastBeforeRemoveEvent(result, metadata, entity, databaseEntity, identifier) {\n    if (entity && metadata.beforeRemoveListeners.length) {\n      metadata.beforeRemoveListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeRemove) {\n          const executionResult = subscriber.beforeRemove({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            databaseEntity: databaseEntity,\n            entityId: metadata.getEntityIdMixedMap(databaseEntity ?? identifier)\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"BEFORE_SOFT_REMOVE\" event.\n   * Before soft remove event is executed before entity is being soft removed from the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n  broadcastBeforeSoftRemoveEvent(result, metadata, entity, databaseEntity, identifier) {\n    if (entity && metadata.beforeSoftRemoveListeners.length) {\n      metadata.beforeSoftRemoveListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeSoftRemove) {\n          const executionResult = subscriber.beforeSoftRemove({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            databaseEntity: databaseEntity,\n            entityId: metadata.getEntityIdMixedMap(databaseEntity ?? identifier)\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"BEFORE_RECOVER\" event.\n   * Before recover event is executed before entity is being recovered in the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n  broadcastBeforeRecoverEvent(result, metadata, entity, databaseEntity, identifier) {\n    if (entity && metadata.beforeRecoverListeners.length) {\n      metadata.beforeRecoverListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeRecover) {\n          const executionResult = subscriber.beforeRecover({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            databaseEntity: databaseEntity,\n            entityId: metadata.getEntityIdMixedMap(databaseEntity ?? identifier)\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"AFTER_INSERT\" event.\n   * After insert event is executed after entity is being persisted to the database for the first time.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n  broadcastAfterInsertEvent(result, metadata, entity, identifier) {\n    if (entity && metadata.afterInsertListeners.length) {\n      metadata.afterInsertListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterInsert) {\n          const executionResult = subscriber.afterInsert({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            entityId: metadata.getEntityIdMixedMap(identifier)\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"BEFORE_QUERY\" event.\n   */\n  broadcastBeforeQueryEvent(result, query, parameters) {\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (subscriber.beforeQuery) {\n          const executionResult = subscriber.beforeQuery({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            query: query,\n            parameters: parameters\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"AFTER_QUERY\" event.\n   */\n  broadcastAfterQueryEvent(result, query, parameters, success, executionTime, rawResults, error) {\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (subscriber.afterQuery) {\n          const executionResult = subscriber.afterQuery({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            query: query,\n            parameters: parameters,\n            success: success,\n            executionTime: executionTime,\n            rawResults: rawResults,\n            error: error\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"BEFORE_TRANSACTION_START\" event.\n   */\n  broadcastBeforeTransactionStartEvent(result) {\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (subscriber.beforeTransactionStart) {\n          const executionResult = subscriber.beforeTransactionStart({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"AFTER_TRANSACTION_START\" event.\n   */\n  broadcastAfterTransactionStartEvent(result) {\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (subscriber.afterTransactionStart) {\n          const executionResult = subscriber.afterTransactionStart({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"BEFORE_TRANSACTION_COMMIT\" event.\n   */\n  broadcastBeforeTransactionCommitEvent(result) {\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (subscriber.beforeTransactionCommit) {\n          const executionResult = subscriber.beforeTransactionCommit({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"AFTER_TRANSACTION_COMMIT\" event.\n   */\n  broadcastAfterTransactionCommitEvent(result) {\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (subscriber.afterTransactionCommit) {\n          const executionResult = subscriber.afterTransactionCommit({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"BEFORE_TRANSACTION_ROLLBACK\" event.\n   */\n  broadcastBeforeTransactionRollbackEvent(result) {\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (subscriber.beforeTransactionRollback) {\n          const executionResult = subscriber.beforeTransactionRollback({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"AFTER_TRANSACTION_ROLLBACK\" event.\n   */\n  broadcastAfterTransactionRollbackEvent(result) {\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (subscriber.afterTransactionRollback) {\n          const executionResult = subscriber.afterTransactionRollback({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"AFTER_UPDATE\" event.\n   * After update event is executed after entity is being updated in the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n  broadcastAfterUpdateEvent(result, metadata, entity, databaseEntity, updatedColumns, updatedRelations) {\n    if (entity && metadata.afterUpdateListeners.length) {\n      metadata.afterUpdateListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterUpdate) {\n          const executionResult = subscriber.afterUpdate({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            databaseEntity: databaseEntity,\n            updatedColumns: updatedColumns || [],\n            updatedRelations: updatedRelations || []\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"AFTER_REMOVE\" event.\n   * After remove event is executed after entity is being removed from the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n  broadcastAfterRemoveEvent(result, metadata, entity, databaseEntity, identifier) {\n    if (entity && metadata.afterRemoveListeners.length) {\n      metadata.afterRemoveListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterRemove) {\n          const executionResult = subscriber.afterRemove({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            databaseEntity: databaseEntity,\n            entityId: metadata.getEntityIdMixedMap(databaseEntity ?? identifier)\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"AFTER_SOFT_REMOVE\" event.\n   * After soft remove event is executed after entity is being soft removed from the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n  broadcastAfterSoftRemoveEvent(result, metadata, entity, databaseEntity, identifier) {\n    if (entity && metadata.afterSoftRemoveListeners.length) {\n      metadata.afterSoftRemoveListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterSoftRemove) {\n          const executionResult = subscriber.afterSoftRemove({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            databaseEntity: databaseEntity,\n            entityId: metadata.getEntityIdMixedMap(databaseEntity ?? identifier)\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"AFTER_RECOVER\" event.\n   * After recover event is executed after entity is being recovered in the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n  broadcastAfterRecoverEvent(result, metadata, entity, databaseEntity, identifier) {\n    if (entity && metadata.afterRecoverListeners.length) {\n      metadata.afterRecoverListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterRecover) {\n          const executionResult = subscriber.afterRecover({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            databaseEntity: databaseEntity,\n            entityId: metadata.getEntityIdMixedMap(databaseEntity ?? identifier)\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * @deprecated Use `broadcastLoadForAllEvent`\n   */\n  broadcastLoadEventsForAll(result, metadata, entities) {\n    return this.broadcastLoadEvent(result, metadata, entities);\n  }\n  /**\n   * Broadcasts \"AFTER_LOAD\" event for all given entities, and their sub-entities.\n   * After load event is executed after entity has been loaded from the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n  broadcastLoadEvent(result, metadata, entities) {\n    // Calculate which subscribers are fitting for the given entity type\n    const fittingSubscribers = this.queryRunner.connection.subscribers.filter(subscriber => this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterLoad);\n    if (metadata.relations.length || metadata.afterLoadListeners.length || fittingSubscribers.length) {\n      // todo: check why need this?\n      const nonPromiseEntities = entities.filter(entity => !(entity instanceof Promise));\n      // collect load events for all children entities that were loaded with the main entity\n      if (metadata.relations.length) {\n        metadata.relations.forEach(relation => {\n          nonPromiseEntities.forEach(entity => {\n            // in lazy relations we cannot simply access to entity property because it will cause a getter and a database query\n            if (relation.isLazy && !entity.hasOwnProperty(relation.propertyName)) return;\n            const value = relation.getEntityValue(entity);\n            if (ObjectUtils.isObject(value)) this.broadcastLoadEvent(result, relation.inverseEntityMetadata, Array.isArray(value) ? value : [value]);\n          });\n        });\n      }\n      if (metadata.afterLoadListeners.length) {\n        metadata.afterLoadListeners.forEach(listener => {\n          nonPromiseEntities.forEach(entity => {\n            if (listener.isAllowed(entity)) {\n              const executionResult = listener.execute(entity);\n              if (executionResult instanceof Promise) result.promises.push(executionResult);\n              result.count++;\n            }\n          });\n        });\n      }\n      fittingSubscribers.forEach(subscriber => {\n        nonPromiseEntities.forEach(entity => {\n          const executionResult = subscriber.afterLoad(entity, {\n            entity,\n            metadata,\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        });\n      });\n    }\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Checks if subscriber's methods can be executed by checking if its don't listen to the particular entity,\n   * or listens our entity.\n   */\n  isAllowedSubscriber(subscriber, target) {\n    return !subscriber.listenTo || !subscriber.listenTo() || subscriber.listenTo() === Object || subscriber.listenTo() === target || subscriber.listenTo().isPrototypeOf(target);\n  }\n}","map":{"version":3,"names":["BroadcasterResult","ObjectUtils","Broadcaster","constructor","queryRunner","broadcast","event","args","result","broadcastFunction","call","wait","broadcastBeforeInsertEvent","metadata","entity","beforeInsertListeners","length","forEach","listener","isAllowed","executionResult","execute","Promise","promises","push","count","connection","subscribers","subscriber","isAllowedSubscriber","target","beforeInsert","manager","broadcastBeforeUpdateEvent","databaseEntity","updatedColumns","updatedRelations","beforeUpdateListeners","beforeUpdate","broadcastBeforeRemoveEvent","identifier","beforeRemoveListeners","beforeRemove","entityId","getEntityIdMixedMap","broadcastBeforeSoftRemoveEvent","beforeSoftRemoveListeners","beforeSoftRemove","broadcastBeforeRecoverEvent","beforeRecoverListeners","beforeRecover","broadcastAfterInsertEvent","afterInsertListeners","afterInsert","broadcastBeforeQueryEvent","query","parameters","beforeQuery","broadcastAfterQueryEvent","success","executionTime","rawResults","error","afterQuery","broadcastBeforeTransactionStartEvent","beforeTransactionStart","broadcastAfterTransactionStartEvent","afterTransactionStart","broadcastBeforeTransactionCommitEvent","beforeTransactionCommit","broadcastAfterTransactionCommitEvent","afterTransactionCommit","broadcastBeforeTransactionRollbackEvent","beforeTransactionRollback","broadcastAfterTransactionRollbackEvent","afterTransactionRollback","broadcastAfterUpdateEvent","afterUpdateListeners","afterUpdate","broadcastAfterRemoveEvent","afterRemoveListeners","afterRemove","broadcastAfterSoftRemoveEvent","afterSoftRemoveListeners","afterSoftRemove","broadcastAfterRecoverEvent","afterRecoverListeners","afterRecover","broadcastLoadEventsForAll","entities","broadcastLoadEvent","fittingSubscribers","filter","afterLoad","relations","afterLoadListeners","nonPromiseEntities","relation","isLazy","hasOwnProperty","propertyName","value","getEntityValue","isObject","inverseEntityMetadata","Array","isArray","listenTo","Object","isPrototypeOf"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\subscriber\\Broadcaster.ts"],"sourcesContent":["import { EntitySubscriberInterface } from \"./EntitySubscriberInterface\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { BroadcasterResult } from \"./BroadcasterResult\"\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { RelationMetadata } from \"../metadata/RelationMetadata\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\n\ninterface BroadcasterEvents {\n    BeforeQuery: () => void\n    AfterQuery: () => void\n\n    BeforeTransactionCommit: () => void\n    AfterTransactionCommit: () => void\n    BeforeTransactionStart: () => void\n    AfterTransactionStart: () => void\n    BeforeTransactionRollback: () => void\n    AfterTransactionRollback: () => void\n\n    BeforeUpdate: (\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n        updatedColumns?: ColumnMetadata[],\n        updatedRelations?: RelationMetadata[],\n    ) => void\n    AfterUpdate: (\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n        updatedColumns?: ColumnMetadata[],\n        updatedRelations?: RelationMetadata[],\n    ) => void\n\n    BeforeInsert: (\n        metadata: EntityMetadata,\n        entity: ObjectLiteral | undefined,\n    ) => void\n    AfterInsert: (\n        metadata: EntityMetadata,\n        entity: ObjectLiteral | undefined,\n    ) => void\n\n    BeforeRemove: (\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n    ) => void\n    AfterRemove: (\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n    ) => void\n\n    BeforeSoftRemove: (\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n    ) => void\n    AfterSoftRemove: (\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n    ) => void\n\n    BeforeRecover: (\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n    ) => void\n    AfterRecover: (\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n    ) => void\n\n    Load: (metadata: EntityMetadata, entities: ObjectLiteral[]) => void\n}\n\n/**\n * Broadcaster provides a helper methods to broadcast events to the subscribers.\n */\nexport class Broadcaster {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private queryRunner: QueryRunner) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    async broadcast<U extends keyof BroadcasterEvents>(\n        event: U,\n        ...args: Parameters<BroadcasterEvents[U]>\n    ): Promise<void> {\n        const result = new BroadcasterResult()\n\n        const broadcastFunction = this[`broadcast${event}Event` as keyof this]\n\n        if (typeof broadcastFunction === \"function\") {\n            ;(broadcastFunction as any).call(this, result, ...args)\n        }\n\n        await result.wait()\n    }\n\n    /**\n     * Broadcasts \"BEFORE_INSERT\" event.\n     * Before insert event is executed before entity is being inserted to the database for the first time.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastBeforeInsertEvent(\n        result: BroadcasterResult,\n        metadata: EntityMetadata,\n        entity: undefined | ObjectLiteral,\n    ): void {\n        if (entity && metadata.beforeInsertListeners.length) {\n            metadata.beforeInsertListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity)\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.beforeInsert\n                ) {\n                    const executionResult = subscriber.beforeInsert({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"BEFORE_UPDATE\" event.\n     * Before update event is executed before entity is being updated in the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastBeforeUpdateEvent(\n        result: BroadcasterResult,\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n        updatedColumns?: ColumnMetadata[],\n        updatedRelations?: RelationMetadata[],\n    ): void {\n        // todo: send relations too?\n        if (entity && metadata.beforeUpdateListeners.length) {\n            metadata.beforeUpdateListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity)\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.beforeUpdate\n                ) {\n                    const executionResult = subscriber.beforeUpdate({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        updatedColumns: updatedColumns || [],\n                        updatedRelations: updatedRelations || [],\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"BEFORE_REMOVE\" event.\n     * Before remove event is executed before entity is being removed from the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastBeforeRemoveEvent(\n        result: BroadcasterResult,\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n        identifier?: ObjectLiteral,\n    ): void {\n        if (entity && metadata.beforeRemoveListeners.length) {\n            metadata.beforeRemoveListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity)\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.beforeRemove\n                ) {\n                    const executionResult = subscriber.beforeRemove({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        entityId: metadata.getEntityIdMixedMap(\n                            databaseEntity ?? identifier,\n                        ),\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"BEFORE_SOFT_REMOVE\" event.\n     * Before soft remove event is executed before entity is being soft removed from the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastBeforeSoftRemoveEvent(\n        result: BroadcasterResult,\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n        identifier?: ObjectLiteral,\n    ): void {\n        if (entity && metadata.beforeSoftRemoveListeners.length) {\n            metadata.beforeSoftRemoveListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity)\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.beforeSoftRemove\n                ) {\n                    const executionResult = subscriber.beforeSoftRemove({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        entityId: metadata.getEntityIdMixedMap(\n                            databaseEntity ?? identifier,\n                        ),\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"BEFORE_RECOVER\" event.\n     * Before recover event is executed before entity is being recovered in the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastBeforeRecoverEvent(\n        result: BroadcasterResult,\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n        identifier?: ObjectLiteral,\n    ): void {\n        if (entity && metadata.beforeRecoverListeners.length) {\n            metadata.beforeRecoverListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity)\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.beforeRecover\n                ) {\n                    const executionResult = subscriber.beforeRecover({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        entityId: metadata.getEntityIdMixedMap(\n                            databaseEntity ?? identifier,\n                        ),\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_INSERT\" event.\n     * After insert event is executed after entity is being persisted to the database for the first time.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastAfterInsertEvent(\n        result: BroadcasterResult,\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        identifier?: ObjectLiteral,\n    ): void {\n        if (entity && metadata.afterInsertListeners.length) {\n            metadata.afterInsertListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity)\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.afterInsert\n                ) {\n                    const executionResult = subscriber.afterInsert({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        entityId: metadata.getEntityIdMixedMap(identifier),\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"BEFORE_QUERY\" event.\n     */\n    broadcastBeforeQueryEvent(\n        result: BroadcasterResult,\n        query: string,\n        parameters: undefined | any[],\n    ): void {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (subscriber.beforeQuery) {\n                    const executionResult = subscriber.beforeQuery({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        query: query,\n                        parameters: parameters,\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_QUERY\" event.\n     */\n    broadcastAfterQueryEvent(\n        result: BroadcasterResult,\n        query: string,\n        parameters: undefined | any[],\n        success: boolean,\n        executionTime: undefined | number,\n        rawResults: undefined | any,\n        error: undefined | any,\n    ): void {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (subscriber.afterQuery) {\n                    const executionResult = subscriber.afterQuery({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        query: query,\n                        parameters: parameters,\n                        success: success,\n                        executionTime: executionTime,\n                        rawResults: rawResults,\n                        error: error,\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"BEFORE_TRANSACTION_START\" event.\n     */\n    broadcastBeforeTransactionStartEvent(result: BroadcasterResult): void {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (subscriber.beforeTransactionStart) {\n                    const executionResult = subscriber.beforeTransactionStart({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_TRANSACTION_START\" event.\n     */\n    broadcastAfterTransactionStartEvent(result: BroadcasterResult): void {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (subscriber.afterTransactionStart) {\n                    const executionResult = subscriber.afterTransactionStart({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"BEFORE_TRANSACTION_COMMIT\" event.\n     */\n    broadcastBeforeTransactionCommitEvent(result: BroadcasterResult): void {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (subscriber.beforeTransactionCommit) {\n                    const executionResult = subscriber.beforeTransactionCommit({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_TRANSACTION_COMMIT\" event.\n     */\n    broadcastAfterTransactionCommitEvent(result: BroadcasterResult): void {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (subscriber.afterTransactionCommit) {\n                    const executionResult = subscriber.afterTransactionCommit({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"BEFORE_TRANSACTION_ROLLBACK\" event.\n     */\n    broadcastBeforeTransactionRollbackEvent(result: BroadcasterResult): void {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (subscriber.beforeTransactionRollback) {\n                    const executionResult =\n                        subscriber.beforeTransactionRollback({\n                            connection: this.queryRunner.connection,\n                            queryRunner: this.queryRunner,\n                            manager: this.queryRunner.manager,\n                        })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_TRANSACTION_ROLLBACK\" event.\n     */\n    broadcastAfterTransactionRollbackEvent(result: BroadcasterResult): void {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (subscriber.afterTransactionRollback) {\n                    const executionResult = subscriber.afterTransactionRollback(\n                        {\n                            connection: this.queryRunner.connection,\n                            queryRunner: this.queryRunner,\n                            manager: this.queryRunner.manager,\n                        },\n                    )\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_UPDATE\" event.\n     * After update event is executed after entity is being updated in the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastAfterUpdateEvent(\n        result: BroadcasterResult,\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n        updatedColumns?: ColumnMetadata[],\n        updatedRelations?: RelationMetadata[],\n    ): void {\n        if (entity && metadata.afterUpdateListeners.length) {\n            metadata.afterUpdateListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity)\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.afterUpdate\n                ) {\n                    const executionResult = subscriber.afterUpdate({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        updatedColumns: updatedColumns || [],\n                        updatedRelations: updatedRelations || [],\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_REMOVE\" event.\n     * After remove event is executed after entity is being removed from the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastAfterRemoveEvent(\n        result: BroadcasterResult,\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n        identifier?: ObjectLiteral,\n    ): void {\n        if (entity && metadata.afterRemoveListeners.length) {\n            metadata.afterRemoveListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity)\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.afterRemove\n                ) {\n                    const executionResult = subscriber.afterRemove({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        entityId: metadata.getEntityIdMixedMap(\n                            databaseEntity ?? identifier,\n                        ),\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_SOFT_REMOVE\" event.\n     * After soft remove event is executed after entity is being soft removed from the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastAfterSoftRemoveEvent(\n        result: BroadcasterResult,\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n        identifier?: ObjectLiteral,\n    ): void {\n        if (entity && metadata.afterSoftRemoveListeners.length) {\n            metadata.afterSoftRemoveListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity)\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.afterSoftRemove\n                ) {\n                    const executionResult = subscriber.afterSoftRemove({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        entityId: metadata.getEntityIdMixedMap(\n                            databaseEntity ?? identifier,\n                        ),\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * Broadcasts \"AFTER_RECOVER\" event.\n     * After recover event is executed after entity is being recovered in the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastAfterRecoverEvent(\n        result: BroadcasterResult,\n        metadata: EntityMetadata,\n        entity?: ObjectLiteral,\n        databaseEntity?: ObjectLiteral,\n        identifier?: ObjectLiteral,\n    ): void {\n        if (entity && metadata.afterRecoverListeners.length) {\n            metadata.afterRecoverListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity)\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.afterRecover\n                ) {\n                    const executionResult = subscriber.afterRecover({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        entityId: metadata.getEntityIdMixedMap(\n                            databaseEntity ?? identifier,\n                        ),\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                }\n            })\n        }\n    }\n\n    /**\n     * @deprecated Use `broadcastLoadForAllEvent`\n     */\n    broadcastLoadEventsForAll(\n        result: BroadcasterResult,\n        metadata: EntityMetadata,\n        entities: ObjectLiteral[],\n    ): void {\n        return this.broadcastLoadEvent(result, metadata, entities)\n    }\n\n    /**\n     * Broadcasts \"AFTER_LOAD\" event for all given entities, and their sub-entities.\n     * After load event is executed after entity has been loaded from the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastLoadEvent(\n        result: BroadcasterResult,\n        metadata: EntityMetadata,\n        entities: ObjectLiteral[],\n    ): void {\n        // Calculate which subscribers are fitting for the given entity type\n        const fittingSubscribers =\n            this.queryRunner.connection.subscribers.filter(\n                (subscriber) =>\n                    this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.afterLoad,\n            )\n\n        if (\n            metadata.relations.length ||\n            metadata.afterLoadListeners.length ||\n            fittingSubscribers.length\n        ) {\n            // todo: check why need this?\n            const nonPromiseEntities = entities.filter(\n                (entity) => !(entity instanceof Promise),\n            )\n\n            // collect load events for all children entities that were loaded with the main entity\n            if (metadata.relations.length) {\n                metadata.relations.forEach((relation) => {\n                    nonPromiseEntities.forEach((entity) => {\n                        // in lazy relations we cannot simply access to entity property because it will cause a getter and a database query\n                        if (\n                            relation.isLazy &&\n                            !entity.hasOwnProperty(relation.propertyName)\n                        )\n                            return\n\n                        const value = relation.getEntityValue(entity)\n                        if (ObjectUtils.isObject(value))\n                            this.broadcastLoadEvent(\n                                result,\n                                relation.inverseEntityMetadata,\n                                Array.isArray(value) ? value : [value],\n                            )\n                    })\n                })\n            }\n\n            if (metadata.afterLoadListeners.length) {\n                metadata.afterLoadListeners.forEach((listener) => {\n                    nonPromiseEntities.forEach((entity) => {\n                        if (listener.isAllowed(entity)) {\n                            const executionResult = listener.execute(entity)\n                            if (executionResult instanceof Promise)\n                                result.promises.push(executionResult)\n                            result.count++\n                        }\n                    })\n                })\n            }\n\n            fittingSubscribers.forEach((subscriber) => {\n                nonPromiseEntities.forEach((entity) => {\n                    const executionResult = subscriber.afterLoad!(entity, {\n                        entity,\n                        metadata,\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    })\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult)\n                    result.count++\n                })\n            })\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Checks if subscriber's methods can be executed by checking if its don't listen to the particular entity,\n     * or listens our entity.\n     */\n    protected isAllowedSubscriber(\n        subscriber: EntitySubscriberInterface<any>,\n        target: Function | string,\n    ): boolean {\n        return (\n            !subscriber.listenTo ||\n            !subscriber.listenTo() ||\n            subscriber.listenTo() === Object ||\n            subscriber.listenTo() === target ||\n            subscriber.listenTo().isPrototypeOf(target)\n        )\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}