{"ast":null,"code":"import { FindOptionsUtils } from \"../find-options/FindOptionsUtils\";\n/**\n * Wraps entities and creates getters/setters for their relations\n * to be able to lazily load relations when accessing these relations.\n */\nexport class RelationLoader {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    this.connection = connection;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Loads relation data for the given entity and its relation.\n   */\n  load(relation, entityOrEntities, queryRunner, queryBuilder) {\n    // todo: check all places where it uses non array\n    if (queryRunner && queryRunner.isReleased) queryRunner = undefined; // get new one if already closed\n    if (relation.isManyToOne || relation.isOneToOneOwner) {\n      return this.loadManyToOneOrOneToOneOwner(relation, entityOrEntities, queryRunner, queryBuilder);\n    } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n      return this.loadOneToManyOrOneToOneNotOwner(relation, entityOrEntities, queryRunner, queryBuilder);\n    } else if (relation.isManyToManyOwner) {\n      return this.loadManyToManyOwner(relation, entityOrEntities, queryRunner, queryBuilder);\n    } else {\n      // many-to-many non owner\n      return this.loadManyToManyNotOwner(relation, entityOrEntities, queryRunner, queryBuilder);\n    }\n  }\n  /**\n   * Loads data for many-to-one and one-to-one owner relations.\n   *\n   * (ow) post.category<=>category.post\n   * loaded: category from post\n   * example: SELECT category.id AS category_id, category.name AS category_name FROM category category\n   *              INNER JOIN post Post ON Post.category=category.id WHERE Post.id=1\n   */\n  loadManyToOneOrOneToOneOwner(relation, entityOrEntities, queryRunner, queryBuilder) {\n    const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];\n    const joinAliasName = relation.entityMetadata.name;\n    const qb = queryBuilder ? queryBuilder : this.connection.createQueryBuilder(queryRunner).select(relation.propertyName) // category\n    .from(relation.type, relation.propertyName);\n    const mainAlias = qb.expressionMap.mainAlias.name;\n    const columns = relation.entityMetadata.primaryColumns;\n    const joinColumns = relation.isOwning ? relation.joinColumns : relation.inverseRelation.joinColumns;\n    const conditions = joinColumns.map(joinColumn => {\n      return `${relation.entityMetadata.name}.${joinColumn.propertyName} = ${mainAlias}.${joinColumn.referencedColumn.propertyName}`;\n    }).join(\" AND \");\n    qb.innerJoin(relation.entityMetadata.target, joinAliasName, conditions);\n    if (columns.length === 1) {\n      qb.where(`${joinAliasName}.${columns[0].propertyPath} IN (:...${joinAliasName + \"_\" + columns[0].propertyName})`);\n      qb.setParameter(joinAliasName + \"_\" + columns[0].propertyName, entities.map(entity => columns[0].getEntityValue(entity, true)));\n    } else {\n      const condition = entities.map((entity, entityIndex) => {\n        return columns.map((column, columnIndex) => {\n          const paramName = joinAliasName + \"_entity_\" + entityIndex + \"_\" + columnIndex;\n          qb.setParameter(paramName, column.getEntityValue(entity, true));\n          return joinAliasName + \".\" + column.propertyPath + \" = :\" + paramName;\n        }).join(\" AND \");\n      }).map(condition => \"(\" + condition + \")\").join(\" OR \");\n      qb.where(condition);\n    }\n    FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);\n    return qb.getMany();\n    // return qb.getOne(); todo: fix all usages\n  }\n  /**\n   * Loads data for one-to-many and one-to-one not owner relations.\n   *\n   * SELECT post\n   * FROM post post\n   * WHERE post.[joinColumn.name] = entity[joinColumn.referencedColumn]\n   */\n  loadOneToManyOrOneToOneNotOwner(relation, entityOrEntities, queryRunner, queryBuilder) {\n    const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];\n    const columns = relation.inverseRelation.joinColumns;\n    const qb = queryBuilder ? queryBuilder : this.connection.createQueryBuilder(queryRunner).select(relation.propertyName).from(relation.inverseRelation.entityMetadata.target, relation.propertyName);\n    const aliasName = qb.expressionMap.mainAlias.name;\n    if (columns.length === 1) {\n      qb.where(`${aliasName}.${columns[0].propertyPath} IN (:...${aliasName + \"_\" + columns[0].propertyName})`);\n      qb.setParameter(aliasName + \"_\" + columns[0].propertyName, entities.map(entity => columns[0].referencedColumn.getEntityValue(entity, true)));\n    } else {\n      const condition = entities.map((entity, entityIndex) => {\n        return columns.map((column, columnIndex) => {\n          const paramName = aliasName + \"_entity_\" + entityIndex + \"_\" + columnIndex;\n          qb.setParameter(paramName, column.referencedColumn.getEntityValue(entity, true));\n          return aliasName + \".\" + column.propertyPath + \" = :\" + paramName;\n        }).join(\" AND \");\n      }).map(condition => \"(\" + condition + \")\").join(\" OR \");\n      qb.where(condition);\n    }\n    FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);\n    return qb.getMany();\n    // return relation.isOneToMany ? qb.getMany() : qb.getOne(); todo: fix all usages\n  }\n  /**\n   * Loads data for many-to-many owner relations.\n   *\n   * SELECT category\n   * FROM category category\n   * INNER JOIN post_categories post_categories\n   * ON post_categories.postId = :postId\n   * AND post_categories.categoryId = category.id\n   */\n  loadManyToManyOwner(relation, entityOrEntities, queryRunner, queryBuilder) {\n    const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];\n    const parameters = relation.joinColumns.reduce((parameters, joinColumn) => {\n      parameters[joinColumn.propertyName] = entities.map(entity => joinColumn.referencedColumn.getEntityValue(entity, true));\n      return parameters;\n    }, {});\n    const qb = queryBuilder ? queryBuilder : this.connection.createQueryBuilder(queryRunner).select(relation.propertyName).from(relation.type, relation.propertyName);\n    const mainAlias = qb.expressionMap.mainAlias.name;\n    const joinAlias = relation.junctionEntityMetadata.tableName;\n    const joinColumnConditions = relation.joinColumns.map(joinColumn => {\n      return `${joinAlias}.${joinColumn.propertyName} IN (:...${joinColumn.propertyName})`;\n    });\n    const inverseJoinColumnConditions = relation.inverseJoinColumns.map(inverseJoinColumn => {\n      return `${joinAlias}.${inverseJoinColumn.propertyName}=${mainAlias}.${inverseJoinColumn.referencedColumn.propertyName}`;\n    });\n    qb.innerJoin(joinAlias, joinAlias, [...joinColumnConditions, ...inverseJoinColumnConditions].join(\" AND \")).setParameters(parameters);\n    FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);\n    return qb.getMany();\n  }\n  /**\n   * Loads data for many-to-many not owner relations.\n   *\n   * SELECT post\n   * FROM post post\n   * INNER JOIN post_categories post_categories\n   * ON post_categories.postId = post.id\n   * AND post_categories.categoryId = post_categories.categoryId\n   */\n  loadManyToManyNotOwner(relation, entityOrEntities, queryRunner, queryBuilder) {\n    const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];\n    const qb = queryBuilder ? queryBuilder : this.connection.createQueryBuilder(queryRunner).select(relation.propertyName).from(relation.type, relation.propertyName);\n    const mainAlias = qb.expressionMap.mainAlias.name;\n    const joinAlias = relation.junctionEntityMetadata.tableName;\n    const joinColumnConditions = relation.inverseRelation.joinColumns.map(joinColumn => {\n      return `${joinAlias}.${joinColumn.propertyName} = ${mainAlias}.${joinColumn.referencedColumn.propertyName}`;\n    });\n    const inverseJoinColumnConditions = relation.inverseRelation.inverseJoinColumns.map(inverseJoinColumn => {\n      return `${joinAlias}.${inverseJoinColumn.propertyName} IN (:...${inverseJoinColumn.propertyName})`;\n    });\n    const parameters = relation.inverseRelation.inverseJoinColumns.reduce((parameters, joinColumn) => {\n      parameters[joinColumn.propertyName] = entities.map(entity => joinColumn.referencedColumn.getEntityValue(entity, true));\n      return parameters;\n    }, {});\n    qb.innerJoin(joinAlias, joinAlias, [...joinColumnConditions, ...inverseJoinColumnConditions].join(\" AND \")).setParameters(parameters);\n    FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);\n    return qb.getMany();\n  }\n  /**\n   * Wraps given entity and creates getters/setters for its given relation\n   * to be able to lazily load data when accessing this relation.\n   */\n  enableLazyLoad(relation, entity, queryRunner) {\n    const relationLoader = this;\n    const dataIndex = \"__\" + relation.propertyName + \"__\"; // in what property of the entity loaded data will be stored\n    const promiseIndex = \"__promise_\" + relation.propertyName + \"__\"; // in what property of the entity loading promise will be stored\n    const resolveIndex = \"__has_\" + relation.propertyName + \"__\"; // indicates if relation data already was loaded or not, we need this flag if loaded data is empty\n    const setData = (entity, value) => {\n      entity[dataIndex] = value;\n      entity[resolveIndex] = true;\n      delete entity[promiseIndex];\n      return value;\n    };\n    const setPromise = (entity, value) => {\n      delete entity[resolveIndex];\n      delete entity[dataIndex];\n      entity[promiseIndex] = value;\n      value.then(\n      // ensure different value is not assigned yet\n      result => entity[promiseIndex] === value ? setData(entity, result) : result);\n      return value;\n    };\n    Object.defineProperty(entity, relation.propertyName, {\n      get: function () {\n        if (this[resolveIndex] === true || this[dataIndex] !== undefined)\n          // if related data already was loaded then simply return it\n          return Promise.resolve(this[dataIndex]);\n        if (this[promiseIndex])\n          // if related data is loading then return a promise relationLoader loads it\n          return this[promiseIndex];\n        // nothing is loaded yet, load relation data and save it in the model once they are loaded\n        const loader = relationLoader.load(relation, this, queryRunner).then(result => relation.isOneToOne || relation.isManyToOne ? result.length === 0 ? null : result[0] : result);\n        return setPromise(this, loader);\n      },\n      set: function (value) {\n        if (value instanceof Promise) {\n          // if set data is a promise then wait for its resolve and save in the object\n          setPromise(this, value);\n        } else {\n          // if its direct data set (non promise, probably not safe-typed)\n          setData(this, value);\n        }\n      },\n      configurable: true,\n      enumerable: false\n    });\n  }\n}","map":{"version":3,"names":["FindOptionsUtils","RelationLoader","constructor","connection","load","relation","entityOrEntities","queryRunner","queryBuilder","isReleased","undefined","isManyToOne","isOneToOneOwner","loadManyToOneOrOneToOneOwner","isOneToMany","isOneToOneNotOwner","loadOneToManyOrOneToOneNotOwner","isManyToManyOwner","loadManyToManyOwner","loadManyToManyNotOwner","entities","Array","isArray","joinAliasName","entityMetadata","name","qb","createQueryBuilder","select","propertyName","from","type","mainAlias","expressionMap","columns","primaryColumns","joinColumns","isOwning","inverseRelation","conditions","map","joinColumn","referencedColumn","join","innerJoin","target","length","where","propertyPath","setParameter","entity","getEntityValue","condition","entityIndex","column","columnIndex","paramName","joinEagerRelations","alias","metadata","getMany","aliasName","parameters","reduce","joinAlias","junctionEntityMetadata","tableName","joinColumnConditions","inverseJoinColumnConditions","inverseJoinColumns","inverseJoinColumn","setParameters","enableLazyLoad","relationLoader","dataIndex","promiseIndex","resolveIndex","setData","value","setPromise","then","result","Object","defineProperty","get","Promise","resolve","loader","isOneToOne","set","configurable","enumerable"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\query-builder\\RelationLoader.ts"],"sourcesContent":["import { DataSource } from \"../data-source/DataSource\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { RelationMetadata } from \"../metadata/RelationMetadata\"\nimport { FindOptionsUtils } from \"../find-options/FindOptionsUtils\"\nimport { SelectQueryBuilder } from \"./SelectQueryBuilder\"\n\n/**\n * Wraps entities and creates getters/setters for their relations\n * to be able to lazily load relations when accessing these relations.\n */\nexport class RelationLoader {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private connection: DataSource) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Loads relation data for the given entity and its relation.\n     */\n    load(\n        relation: RelationMetadata,\n        entityOrEntities: ObjectLiteral | ObjectLiteral[],\n        queryRunner?: QueryRunner,\n        queryBuilder?: SelectQueryBuilder<any>,\n    ): Promise<any[]> {\n        // todo: check all places where it uses non array\n        if (queryRunner && queryRunner.isReleased) queryRunner = undefined // get new one if already closed\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\n            return this.loadManyToOneOrOneToOneOwner(\n                relation,\n                entityOrEntities,\n                queryRunner,\n                queryBuilder,\n            )\n        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            return this.loadOneToManyOrOneToOneNotOwner(\n                relation,\n                entityOrEntities,\n                queryRunner,\n                queryBuilder,\n            )\n        } else if (relation.isManyToManyOwner) {\n            return this.loadManyToManyOwner(\n                relation,\n                entityOrEntities,\n                queryRunner,\n                queryBuilder,\n            )\n        } else {\n            // many-to-many non owner\n            return this.loadManyToManyNotOwner(\n                relation,\n                entityOrEntities,\n                queryRunner,\n                queryBuilder,\n            )\n        }\n    }\n\n    /**\n     * Loads data for many-to-one and one-to-one owner relations.\n     *\n     * (ow) post.category<=>category.post\n     * loaded: category from post\n     * example: SELECT category.id AS category_id, category.name AS category_name FROM category category\n     *              INNER JOIN post Post ON Post.category=category.id WHERE Post.id=1\n     */\n    loadManyToOneOrOneToOneOwner(\n        relation: RelationMetadata,\n        entityOrEntities: ObjectLiteral | ObjectLiteral[],\n        queryRunner?: QueryRunner,\n        queryBuilder?: SelectQueryBuilder<any>,\n    ): Promise<any> {\n        const entities = Array.isArray(entityOrEntities)\n            ? entityOrEntities\n            : [entityOrEntities]\n\n        const joinAliasName = relation.entityMetadata.name\n        const qb = queryBuilder\n            ? queryBuilder\n            : this.connection\n                  .createQueryBuilder(queryRunner)\n                  .select(relation.propertyName) // category\n                  .from(relation.type, relation.propertyName)\n\n        const mainAlias = qb.expressionMap.mainAlias!.name\n        const columns = relation.entityMetadata.primaryColumns\n        const joinColumns = relation.isOwning\n            ? relation.joinColumns\n            : relation.inverseRelation!.joinColumns\n        const conditions = joinColumns\n            .map((joinColumn) => {\n                return `${relation.entityMetadata.name}.${\n                    joinColumn.propertyName\n                } = ${mainAlias}.${joinColumn.referencedColumn!.propertyName}`\n            })\n            .join(\" AND \")\n\n        qb.innerJoin(\n            relation.entityMetadata.target as Function,\n            joinAliasName,\n            conditions,\n        )\n\n        if (columns.length === 1) {\n            qb.where(\n                `${joinAliasName}.${columns[0].propertyPath} IN (:...${\n                    joinAliasName + \"_\" + columns[0].propertyName\n                })`,\n            )\n            qb.setParameter(\n                joinAliasName + \"_\" + columns[0].propertyName,\n                entities.map((entity) =>\n                    columns[0].getEntityValue(entity, true),\n                ),\n            )\n        } else {\n            const condition = entities\n                .map((entity, entityIndex) => {\n                    return columns\n                        .map((column, columnIndex) => {\n                            const paramName =\n                                joinAliasName +\n                                \"_entity_\" +\n                                entityIndex +\n                                \"_\" +\n                                columnIndex\n                            qb.setParameter(\n                                paramName,\n                                column.getEntityValue(entity, true),\n                            )\n                            return (\n                                joinAliasName +\n                                \".\" +\n                                column.propertyPath +\n                                \" = :\" +\n                                paramName\n                            )\n                        })\n                        .join(\" AND \")\n                })\n                .map((condition) => \"(\" + condition + \")\")\n                .join(\" OR \")\n            qb.where(condition)\n        }\n\n        FindOptionsUtils.joinEagerRelations(\n            qb,\n            qb.alias,\n            qb.expressionMap.mainAlias!.metadata,\n        )\n\n        return qb.getMany()\n        // return qb.getOne(); todo: fix all usages\n    }\n\n    /**\n     * Loads data for one-to-many and one-to-one not owner relations.\n     *\n     * SELECT post\n     * FROM post post\n     * WHERE post.[joinColumn.name] = entity[joinColumn.referencedColumn]\n     */\n    loadOneToManyOrOneToOneNotOwner(\n        relation: RelationMetadata,\n        entityOrEntities: ObjectLiteral | ObjectLiteral[],\n        queryRunner?: QueryRunner,\n        queryBuilder?: SelectQueryBuilder<any>,\n    ): Promise<any> {\n        const entities = Array.isArray(entityOrEntities)\n            ? entityOrEntities\n            : [entityOrEntities]\n        const columns = relation.inverseRelation!.joinColumns\n        const qb = queryBuilder\n            ? queryBuilder\n            : this.connection\n                  .createQueryBuilder(queryRunner)\n                  .select(relation.propertyName)\n                  .from(\n                      relation.inverseRelation!.entityMetadata.target,\n                      relation.propertyName,\n                  )\n\n        const aliasName = qb.expressionMap.mainAlias!.name\n\n        if (columns.length === 1) {\n            qb.where(\n                `${aliasName}.${columns[0].propertyPath} IN (:...${\n                    aliasName + \"_\" + columns[0].propertyName\n                })`,\n            )\n            qb.setParameter(\n                aliasName + \"_\" + columns[0].propertyName,\n                entities.map((entity) =>\n                    columns[0].referencedColumn!.getEntityValue(entity, true),\n                ),\n            )\n        } else {\n            const condition = entities\n                .map((entity, entityIndex) => {\n                    return columns\n                        .map((column, columnIndex) => {\n                            const paramName =\n                                aliasName +\n                                \"_entity_\" +\n                                entityIndex +\n                                \"_\" +\n                                columnIndex\n                            qb.setParameter(\n                                paramName,\n                                column.referencedColumn!.getEntityValue(\n                                    entity,\n                                    true,\n                                ),\n                            )\n                            return (\n                                aliasName +\n                                \".\" +\n                                column.propertyPath +\n                                \" = :\" +\n                                paramName\n                            )\n                        })\n                        .join(\" AND \")\n                })\n                .map((condition) => \"(\" + condition + \")\")\n                .join(\" OR \")\n            qb.where(condition)\n        }\n\n        FindOptionsUtils.joinEagerRelations(\n            qb,\n            qb.alias,\n            qb.expressionMap.mainAlias!.metadata,\n        )\n\n        return qb.getMany()\n        // return relation.isOneToMany ? qb.getMany() : qb.getOne(); todo: fix all usages\n    }\n\n    /**\n     * Loads data for many-to-many owner relations.\n     *\n     * SELECT category\n     * FROM category category\n     * INNER JOIN post_categories post_categories\n     * ON post_categories.postId = :postId\n     * AND post_categories.categoryId = category.id\n     */\n    loadManyToManyOwner(\n        relation: RelationMetadata,\n        entityOrEntities: ObjectLiteral | ObjectLiteral[],\n        queryRunner?: QueryRunner,\n        queryBuilder?: SelectQueryBuilder<any>,\n    ): Promise<any> {\n        const entities = Array.isArray(entityOrEntities)\n            ? entityOrEntities\n            : [entityOrEntities]\n        const parameters = relation.joinColumns.reduce(\n            (parameters, joinColumn) => {\n                parameters[joinColumn.propertyName] = entities.map((entity) =>\n                    joinColumn.referencedColumn!.getEntityValue(entity, true),\n                )\n                return parameters\n            },\n            {} as ObjectLiteral,\n        )\n\n        const qb = queryBuilder\n            ? queryBuilder\n            : this.connection\n                  .createQueryBuilder(queryRunner)\n                  .select(relation.propertyName)\n                  .from(relation.type, relation.propertyName)\n\n        const mainAlias = qb.expressionMap.mainAlias!.name\n        const joinAlias = relation.junctionEntityMetadata!.tableName\n        const joinColumnConditions = relation.joinColumns.map((joinColumn) => {\n            return `${joinAlias}.${joinColumn.propertyName} IN (:...${joinColumn.propertyName})`\n        })\n        const inverseJoinColumnConditions = relation.inverseJoinColumns.map(\n            (inverseJoinColumn) => {\n                return `${joinAlias}.${\n                    inverseJoinColumn.propertyName\n                }=${mainAlias}.${\n                    inverseJoinColumn.referencedColumn!.propertyName\n                }`\n            },\n        )\n\n        qb.innerJoin(\n            joinAlias,\n            joinAlias,\n            [...joinColumnConditions, ...inverseJoinColumnConditions].join(\n                \" AND \",\n            ),\n        ).setParameters(parameters)\n\n        FindOptionsUtils.joinEagerRelations(\n            qb,\n            qb.alias,\n            qb.expressionMap.mainAlias!.metadata,\n        )\n\n        return qb.getMany()\n    }\n\n    /**\n     * Loads data for many-to-many not owner relations.\n     *\n     * SELECT post\n     * FROM post post\n     * INNER JOIN post_categories post_categories\n     * ON post_categories.postId = post.id\n     * AND post_categories.categoryId = post_categories.categoryId\n     */\n    loadManyToManyNotOwner(\n        relation: RelationMetadata,\n        entityOrEntities: ObjectLiteral | ObjectLiteral[],\n        queryRunner?: QueryRunner,\n        queryBuilder?: SelectQueryBuilder<any>,\n    ): Promise<any> {\n        const entities = Array.isArray(entityOrEntities)\n            ? entityOrEntities\n            : [entityOrEntities]\n\n        const qb = queryBuilder\n            ? queryBuilder\n            : this.connection\n                  .createQueryBuilder(queryRunner)\n                  .select(relation.propertyName)\n                  .from(relation.type, relation.propertyName)\n\n        const mainAlias = qb.expressionMap.mainAlias!.name\n        const joinAlias = relation.junctionEntityMetadata!.tableName\n        const joinColumnConditions = relation.inverseRelation!.joinColumns.map(\n            (joinColumn) => {\n                return `${joinAlias}.${\n                    joinColumn.propertyName\n                } = ${mainAlias}.${joinColumn.referencedColumn!.propertyName}`\n            },\n        )\n        const inverseJoinColumnConditions =\n            relation.inverseRelation!.inverseJoinColumns.map(\n                (inverseJoinColumn) => {\n                    return `${joinAlias}.${inverseJoinColumn.propertyName} IN (:...${inverseJoinColumn.propertyName})`\n                },\n            )\n        const parameters = relation.inverseRelation!.inverseJoinColumns.reduce(\n            (parameters, joinColumn) => {\n                parameters[joinColumn.propertyName] = entities.map((entity) =>\n                    joinColumn.referencedColumn!.getEntityValue(entity, true),\n                )\n                return parameters\n            },\n            {} as ObjectLiteral,\n        )\n\n        qb.innerJoin(\n            joinAlias,\n            joinAlias,\n            [...joinColumnConditions, ...inverseJoinColumnConditions].join(\n                \" AND \",\n            ),\n        ).setParameters(parameters)\n\n        FindOptionsUtils.joinEagerRelations(\n            qb,\n            qb.alias,\n            qb.expressionMap.mainAlias!.metadata,\n        )\n\n        return qb.getMany()\n    }\n\n    /**\n     * Wraps given entity and creates getters/setters for its given relation\n     * to be able to lazily load data when accessing this relation.\n     */\n    enableLazyLoad(\n        relation: RelationMetadata,\n        entity: ObjectLiteral,\n        queryRunner?: QueryRunner,\n    ) {\n        const relationLoader = this\n        const dataIndex = \"__\" + relation.propertyName + \"__\" // in what property of the entity loaded data will be stored\n        const promiseIndex = \"__promise_\" + relation.propertyName + \"__\" // in what property of the entity loading promise will be stored\n        const resolveIndex = \"__has_\" + relation.propertyName + \"__\" // indicates if relation data already was loaded or not, we need this flag if loaded data is empty\n\n        const setData = (entity: ObjectLiteral, value: any) => {\n            entity[dataIndex] = value\n            entity[resolveIndex] = true\n            delete entity[promiseIndex]\n            return value\n        }\n        const setPromise = (entity: ObjectLiteral, value: Promise<any>) => {\n            delete entity[resolveIndex]\n            delete entity[dataIndex]\n            entity[promiseIndex] = value\n            value.then(\n                // ensure different value is not assigned yet\n                (result) =>\n                    entity[promiseIndex] === value\n                        ? setData(entity, result)\n                        : result,\n            )\n            return value\n        }\n\n        Object.defineProperty(entity, relation.propertyName, {\n            get: function () {\n                if (\n                    this[resolveIndex] === true ||\n                    this[dataIndex] !== undefined\n                )\n                    // if related data already was loaded then simply return it\n                    return Promise.resolve(this[dataIndex])\n\n                if (this[promiseIndex])\n                    // if related data is loading then return a promise relationLoader loads it\n                    return this[promiseIndex]\n\n                // nothing is loaded yet, load relation data and save it in the model once they are loaded\n                const loader = relationLoader\n                    .load(relation, this, queryRunner)\n                    .then((result) =>\n                        relation.isOneToOne || relation.isManyToOne\n                            ? result.length === 0\n                                ? null\n                                : result[0]\n                            : result,\n                    )\n                return setPromise(this, loader)\n            },\n            set: function (value: any | Promise<any>) {\n                if (value instanceof Promise) {\n                    // if set data is a promise then wait for its resolve and save in the object\n                    setPromise(this, value)\n                } else {\n                    // if its direct data set (non promise, probably not safe-typed)\n                    setData(this, value)\n                }\n            },\n            configurable: true,\n            enumerable: false,\n        })\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}