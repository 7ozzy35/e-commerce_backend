{"ast":null,"code":"import { Table } from \"./table/Table\";\nimport { TableColumn } from \"./table/TableColumn\";\nimport { TableForeignKey } from \"./table/TableForeignKey\";\nimport { TableIndex } from \"./table/TableIndex\";\nimport { TableUtils } from \"./util/TableUtils\";\nimport { TableUnique } from \"./table/TableUnique\";\nimport { TableCheck } from \"./table/TableCheck\";\nimport { TableExclusion } from \"./table/TableExclusion\";\nimport { View } from \"./view/View\";\nimport { ViewUtils } from \"./util/ViewUtils\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Creates complete tables schemas in the database based on the entity metadatas.\n *\n * Steps how schema is being built:\n * 1. load list of all tables with complete column and keys information from the db\n * 2. drop all (old) foreign keys that exist in the table, but does not exist in the metadata\n * 3. create new tables that does not exist in the db, but exist in the metadata\n * 4. drop all columns exist (left old) in the db table, but does not exist in the metadata\n * 5. add columns from metadata which does not exist in the table\n * 6. update all exist columns which metadata has changed\n * 7. update primary keys - update old and create new primary key from changed columns\n * 8. create foreign keys which does not exist in the table yet\n * 9. create indices which are missing in db yet, and drops indices which exist in the db, but does not exist in the metadata anymore\n */\nexport class RdbmsSchemaBuilder {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    this.connection = connection;\n    this[\"@instanceof\"] = Symbol.for(\"RdbmsSchemaBuilder\");\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates complete schemas for the given entity metadatas.\n   */\n  async build() {\n    this.queryRunner = this.connection.createQueryRunner();\n    // this.connection.driver.database || this.currentDatabase;\n    this.currentDatabase = this.connection.driver.database;\n    this.currentSchema = this.connection.driver.schema;\n    // CockroachDB implements asynchronous schema sync operations which can not been executed in transaction.\n    // E.g. if you try to DROP column and ADD it again in the same transaction, crdb throws error.\n    // In Spanner queries against the INFORMATION_SCHEMA can be used in a read-only transaction,\n    // but not in a read-write transaction.\n    const isUsingTransactions = !(this.connection.driver.options.type === \"cockroachdb\") && !(this.connection.driver.options.type === \"spanner\") && this.connection.options.migrationsTransactionMode !== \"none\";\n    await this.queryRunner.beforeMigration();\n    if (isUsingTransactions) {\n      await this.queryRunner.startTransaction();\n    }\n    try {\n      await this.createMetadataTableIfNecessary(this.queryRunner);\n      // Flush the queryrunner table & view cache\n      const tablePaths = this.entityToSyncMetadatas.map(metadata => this.getTablePath(metadata));\n      const viewPaths = this.viewEntityToSyncMetadatas.map(metadata => this.getTablePath(metadata));\n      await this.queryRunner.getTables(tablePaths);\n      await this.queryRunner.getViews(viewPaths);\n      await this.executeSchemaSyncOperationsInProperOrder();\n      // if cache is enabled then perform cache-synchronization as well\n      if (this.connection.queryResultCache) await this.connection.queryResultCache.synchronize(this.queryRunner);\n      if (isUsingTransactions) {\n        await this.queryRunner.commitTransaction();\n      }\n    } catch (error) {\n      try {\n        // we throw original error even if rollback thrown an error\n        if (isUsingTransactions) {\n          await this.queryRunner.rollbackTransaction();\n        }\n      } catch (rollbackError) {}\n      throw error;\n    } finally {\n      await this.queryRunner.afterMigration();\n      await this.queryRunner.release();\n    }\n  }\n  /**\n   * Create the typeorm_metadata table if necessary.\n   */\n  async createMetadataTableIfNecessary(queryRunner) {\n    if (this.viewEntityToSyncMetadatas.length > 0 || this.hasGeneratedColumns()) {\n      await this.createTypeormMetadataTable(queryRunner);\n    }\n  }\n  /**\n   * Returns sql queries to be executed by schema builder.\n   */\n  async log() {\n    this.queryRunner = this.connection.createQueryRunner();\n    try {\n      // Flush the queryrunner table & view cache\n      const tablePaths = this.entityToSyncMetadatas.map(metadata => this.getTablePath(metadata));\n      const viewPaths = this.viewEntityToSyncMetadatas.map(metadata => this.getTablePath(metadata));\n      await this.queryRunner.getTables(tablePaths);\n      await this.queryRunner.getViews(viewPaths);\n      this.queryRunner.enableSqlMemory();\n      await this.executeSchemaSyncOperationsInProperOrder();\n      // if cache is enabled then perform cache-synchronization as well\n      if (this.connection.queryResultCache)\n        // todo: check this functionality\n        await this.connection.queryResultCache.synchronize(this.queryRunner);\n      return this.queryRunner.getMemorySql();\n    } finally {\n      // its important to disable this mode despite the fact we are release query builder\n      // because there exist drivers which reuse same query runner. Also its important to disable\n      // sql memory after call of getMemorySql() method because last one flushes sql memory.\n      this.queryRunner.disableSqlMemory();\n      await this.queryRunner.release();\n    }\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Returns only entities that should be synced in the database.\n   */\n  get entityToSyncMetadatas() {\n    return this.connection.entityMetadatas.filter(metadata => metadata.synchronize && metadata.tableType !== \"entity-child\" && metadata.tableType !== \"view\");\n  }\n  /**\n   * Returns only entities that should be synced in the database.\n   */\n  get viewEntityToSyncMetadatas() {\n    return this.connection.entityMetadatas.filter(metadata => metadata.tableType === \"view\" && metadata.synchronize)\n    // sort views in creation order by dependencies\n    .sort(ViewUtils.viewMetadataCmp);\n  }\n  /**\n   * Checks if there are at least one generated column.\n   */\n  hasGeneratedColumns() {\n    return this.connection.entityMetadatas.some(entityMetadata => {\n      return entityMetadata.columns.some(column => column.generatedType);\n    });\n  }\n  /**\n   * Executes schema sync operations in a proper order.\n   * Order of operations matter here.\n   */\n  async executeSchemaSyncOperationsInProperOrder() {\n    await this.dropOldViews();\n    await this.dropOldForeignKeys();\n    await this.dropOldIndices();\n    await this.dropOldChecks();\n    await this.dropOldExclusions();\n    await this.dropCompositeUniqueConstraints();\n    // await this.renameTables();\n    await this.renameColumns();\n    await this.changeTableComment();\n    await this.createNewTables();\n    await this.dropRemovedColumns();\n    await this.addNewColumns();\n    await this.updatePrimaryKeys();\n    await this.updateExistColumns();\n    await this.createNewIndices();\n    await this.createNewChecks();\n    await this.createNewExclusions();\n    await this.createCompositeUniqueConstraints();\n    await this.createForeignKeys();\n    await this.createViews();\n    await this.createNewViewIndices();\n  }\n  getTablePath(target) {\n    const parsed = this.connection.driver.parseTableName(target);\n    return this.connection.driver.buildTableName(parsed.tableName, parsed.schema || this.currentSchema, parsed.database || this.currentDatabase);\n  }\n  /**\n   * Drops all (old) foreign keys that exist in the tables, but do not exist in the entity metadata.\n   */\n  async dropOldForeignKeys() {\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue;\n      // find foreign keys that exist in the schemas but does not exist in the entity metadata\n      const tableForeignKeysToDrop = table.foreignKeys.filter(tableForeignKey => {\n        const metadataFK = metadata.foreignKeys.find(metadataForeignKey => tableForeignKey.name === metadataForeignKey.name && this.getTablePath(tableForeignKey) === this.getTablePath(metadataForeignKey.referencedEntityMetadata));\n        return !metadataFK || metadataFK.onDelete && metadataFK.onDelete !== tableForeignKey.onDelete || metadataFK.onUpdate && metadataFK.onUpdate !== tableForeignKey.onUpdate;\n      });\n      if (tableForeignKeysToDrop.length === 0) continue;\n      this.connection.logger.logSchemaBuild(`dropping old foreign keys of ${table.name}: ${tableForeignKeysToDrop.map(dbForeignKey => dbForeignKey.name).join(\", \")}`);\n      // drop foreign keys from the database\n      await this.queryRunner.dropForeignKeys(table, tableForeignKeysToDrop);\n    }\n  }\n  /**\n   * Rename tables\n   */\n  async renameTables() {\n    // for (const metadata of this.entityToSyncMetadatas) {\n    //     const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n    // }\n  }\n  /**\n   * Renames columns.\n   * Works if only one column per table was changed.\n   * Changes only column name. If something besides name was changed, these changes will be ignored.\n   */\n  async renameColumns() {\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue;\n      if (metadata.columns.length !== table.columns.length) continue;\n      const renamedMetadataColumns = metadata.columns.filter(c => !c.isVirtualProperty).filter(column => {\n        return !table.columns.find(tableColumn => {\n          return tableColumn.name === column.databaseName && tableColumn.type === this.connection.driver.normalizeType(column) && tableColumn.isNullable === column.isNullable && tableColumn.isUnique === this.connection.driver.normalizeIsUnique(column);\n        });\n      });\n      if (renamedMetadataColumns.length === 0 || renamedMetadataColumns.length > 1) continue;\n      const renamedTableColumns = table.columns.filter(tableColumn => {\n        return !metadata.columns.find(column => {\n          return !column.isVirtualProperty && column.databaseName === tableColumn.name && this.connection.driver.normalizeType(column) === tableColumn.type && column.isNullable === tableColumn.isNullable && this.connection.driver.normalizeIsUnique(column) === tableColumn.isUnique;\n        });\n      });\n      if (renamedTableColumns.length === 0 || renamedTableColumns.length > 1) continue;\n      const renamedColumn = renamedTableColumns[0].clone();\n      renamedColumn.name = renamedMetadataColumns[0].databaseName;\n      this.connection.logger.logSchemaBuild(`renaming column \"${renamedTableColumns[0].name}\" in \"${table.name}\" to \"${renamedColumn.name}\"`);\n      await this.queryRunner.renameColumn(table, renamedTableColumns[0], renamedColumn);\n    }\n  }\n  async dropOldIndices() {\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue;\n      const dropQueries = table.indices.filter(tableIndex => {\n        const indexMetadata = metadata.indices.find(index => index.name === tableIndex.name);\n        if (indexMetadata) {\n          if (indexMetadata.synchronize === false) return false;\n          if (indexMetadata.isUnique !== tableIndex.isUnique) return true;\n          if (indexMetadata.isSpatial !== tableIndex.isSpatial) return true;\n          if (this.connection.driver.isFullTextColumnTypeSupported() && indexMetadata.isFulltext !== tableIndex.isFulltext) return true;\n          if (indexMetadata.columns.length !== tableIndex.columnNames.length) return true;\n          return !indexMetadata.columns.every(column => tableIndex.columnNames.indexOf(column.databaseName) !== -1);\n        }\n        return true;\n      }).map(async tableIndex => {\n        this.connection.logger.logSchemaBuild(`dropping an index: \"${tableIndex.name}\" from table ${table.name}`);\n        await this.queryRunner.dropIndex(table, tableIndex);\n      });\n      await Promise.all(dropQueries);\n    }\n    if (this.connection.options.type === \"postgres\") {\n      const postgresQueryRunner = this.queryRunner;\n      for (const metadata of this.viewEntityToSyncMetadatas) {\n        const view = this.queryRunner.loadedViews.find(view => this.getTablePath(view) === this.getTablePath(metadata));\n        if (!view) continue;\n        const dropQueries = view.indices.filter(tableIndex => {\n          const indexMetadata = metadata.indices.find(index => index.name === tableIndex.name);\n          if (indexMetadata) {\n            if (indexMetadata.synchronize === false) return false;\n            if (indexMetadata.isUnique !== tableIndex.isUnique) return true;\n            if (indexMetadata.isSpatial !== tableIndex.isSpatial) return true;\n            if (this.connection.driver.isFullTextColumnTypeSupported() && indexMetadata.isFulltext !== tableIndex.isFulltext) return true;\n            if (indexMetadata.columns.length !== tableIndex.columnNames.length) return true;\n            return !indexMetadata.columns.every(column => tableIndex.columnNames.indexOf(column.databaseName) !== -1);\n          }\n          return true;\n        }).map(async tableIndex => {\n          this.connection.logger.logSchemaBuild(`dropping an index: \"${tableIndex.name}\" from view ${view.name}`);\n          await postgresQueryRunner.dropViewIndex(view, tableIndex);\n        });\n        await Promise.all(dropQueries);\n      }\n    }\n  }\n  async dropOldChecks() {\n    // Mysql does not support check constraints\n    if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\") return;\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue;\n      const oldChecks = table.checks.filter(tableCheck => {\n        return !metadata.checks.find(checkMetadata => checkMetadata.name === tableCheck.name);\n      });\n      if (oldChecks.length === 0) continue;\n      this.connection.logger.logSchemaBuild(`dropping old check constraint: ${oldChecks.map(check => `\"${check.name}\"`).join(\", \")} from table \"${table.name}\"`);\n      await this.queryRunner.dropCheckConstraints(table, oldChecks);\n    }\n  }\n  async dropCompositeUniqueConstraints() {\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue;\n      const compositeUniques = table.uniques.filter(tableUnique => {\n        return tableUnique.columnNames.length > 1 && !metadata.uniques.find(uniqueMetadata => uniqueMetadata.name === tableUnique.name);\n      });\n      if (compositeUniques.length === 0) continue;\n      this.connection.logger.logSchemaBuild(`dropping old unique constraint: ${compositeUniques.map(unique => `\"${unique.name}\"`).join(\", \")} from table \"${table.name}\"`);\n      await this.queryRunner.dropUniqueConstraints(table, compositeUniques);\n    }\n  }\n  async dropOldExclusions() {\n    // Only PostgreSQL supports exclusion constraints\n    if (!(this.connection.driver.options.type === \"postgres\")) return;\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue;\n      const oldExclusions = table.exclusions.filter(tableExclusion => {\n        return !metadata.exclusions.find(exclusionMetadata => exclusionMetadata.name === tableExclusion.name);\n      });\n      if (oldExclusions.length === 0) continue;\n      this.connection.logger.logSchemaBuild(`dropping old exclusion constraint: ${oldExclusions.map(exclusion => `\"${exclusion.name}\"`).join(\", \")} from table \"${table.name}\"`);\n      await this.queryRunner.dropExclusionConstraints(table, oldExclusions);\n    }\n  }\n  /**\n   * change table comment\n   */\n  async changeTableComment() {\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue;\n      if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === 'postgres') {\n        const newComment = metadata.comment;\n        await this.queryRunner.changeTableComment(table, newComment);\n      }\n    }\n  }\n  /**\n   * Creates tables that do not exist in the database yet.\n   * New tables are created without foreign and primary keys.\n   * Primary key only can be created in conclusion with auto generated column.\n   */\n  async createNewTables() {\n    for (const metadata of this.entityToSyncMetadatas) {\n      // check if table does not exist yet\n      const existTable = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (existTable) continue;\n      this.connection.logger.logSchemaBuild(`creating a new table: ${this.getTablePath(metadata)}`);\n      // create a new table and sync it in the database\n      const table = Table.create(metadata, this.connection.driver);\n      await this.queryRunner.createTable(table, false, false);\n      this.queryRunner.loadedTables.push(table);\n    }\n  }\n  async createViews() {\n    for (const metadata of this.viewEntityToSyncMetadatas) {\n      // check if view does not exist yet\n      const existView = this.queryRunner.loadedViews.find(view => {\n        const viewExpression = typeof view.expression === \"string\" ? view.expression.trim() : view.expression(this.connection).getQuery();\n        const metadataExpression = typeof metadata.expression === \"string\" ? metadata.expression.trim() : metadata.expression(this.connection).getQuery();\n        return this.getTablePath(view) === this.getTablePath(metadata) && viewExpression === metadataExpression;\n      });\n      if (existView) continue;\n      this.connection.logger.logSchemaBuild(`creating a new view: ${this.getTablePath(metadata)}`);\n      // create a new view and sync it in the database\n      const view = View.create(metadata, this.connection.driver);\n      await this.queryRunner.createView(view, true);\n      this.queryRunner.loadedViews.push(view);\n    }\n  }\n  async dropOldViews() {\n    const droppedViews = [];\n    const viewEntityToSyncMetadatas = this.viewEntityToSyncMetadatas;\n    // BuIld lookup cache for finding views metadata\n    const viewToMetadata = new Map();\n    for (const view of this.queryRunner.loadedViews) {\n      const viewMetadata = viewEntityToSyncMetadatas.find(metadata => {\n        return this.getTablePath(view) === this.getTablePath(metadata);\n      });\n      if (viewMetadata) {\n        viewToMetadata.set(view, viewMetadata);\n      }\n    }\n    // Gather all changed view, that need a drop\n    for (const view of this.queryRunner.loadedViews) {\n      const viewMetadata = viewToMetadata.get(view);\n      if (!viewMetadata) {\n        continue;\n      }\n      const viewExpression = typeof view.expression === \"string\" ? view.expression.trim() : view.expression(this.connection).getQuery();\n      const metadataExpression = typeof viewMetadata.expression === \"string\" ? viewMetadata.expression.trim() : viewMetadata.expression(this.connection).getQuery();\n      if (viewExpression === metadataExpression) continue;\n      this.connection.logger.logSchemaBuild(`dropping an old view: ${view.name}`);\n      // Collect view to be dropped\n      droppedViews.push(view);\n    }\n    // Helper function that for a given view, will recursively return list of the view and all views that depend on it\n    const viewDependencyChain = view => {\n      // Get the view metadata\n      const viewMetadata = viewToMetadata.get(view);\n      let viewWithDependencies = [view];\n      // If no metadata is known for the view, simply return the view itself\n      if (!viewMetadata) {\n        return viewWithDependencies;\n      }\n      // Iterate over all known views\n      for (const [currentView, currentMetadata] of viewToMetadata.entries()) {\n        // Ignore self reference\n        if (currentView === view) {\n          continue;\n        }\n        // If the currently iterated view depends on the passed in view\n        if (currentMetadata.dependsOn && (currentMetadata.dependsOn.has(viewMetadata.target) || currentMetadata.dependsOn.has(viewMetadata.name))) {\n          // Recursively add currently iterate view and its dependents\n          viewWithDependencies = viewWithDependencies.concat(viewDependencyChain(currentView));\n        }\n      }\n      // Return all collected views\n      return viewWithDependencies;\n    };\n    // Collect final list of views to be dropped in a Set so there are no duplicates\n    const droppedViewsWithDependencies = new Set(\n    // Collect all dropped views, and their dependencies\n    droppedViews.map(view => viewDependencyChain(view))\n    // Flattened to single Array ( can be replaced with flatMap, once supported)\n    .reduce((all, segment) => {\n      return all.concat(segment);\n    }, [])\n    // Sort the views to be dropped in creation order\n    .sort((a, b) => {\n      return ViewUtils.viewMetadataCmp(viewToMetadata.get(a), viewToMetadata.get(b));\n    })\n    // reverse order to get drop order\n    .reverse());\n    // Finally emit all drop views\n    for (const view of droppedViewsWithDependencies) {\n      await this.queryRunner.dropView(view);\n    }\n    this.queryRunner.loadedViews = this.queryRunner.loadedViews.filter(view => !droppedViewsWithDependencies.has(view));\n  }\n  /**\n   * Drops all columns that exist in the table, but does not exist in the metadata (left old).\n   * We drop their keys too, since it should be safe.\n   */\n  async dropRemovedColumns() {\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue;\n      // find columns that exist in the database but does not exist in the metadata\n      const droppedTableColumns = table.columns.filter(tableColumn => {\n        return !metadata.columns.find(columnMetadata => columnMetadata.isVirtualProperty || columnMetadata.databaseName === tableColumn.name);\n      });\n      if (droppedTableColumns.length === 0) continue;\n      this.connection.logger.logSchemaBuild(`columns dropped in ${table.name}: ` + droppedTableColumns.map(column => column.name).join(\", \"));\n      // drop columns from the database\n      await this.queryRunner.dropColumns(table, droppedTableColumns);\n    }\n  }\n  /**\n   * Adds columns from metadata which does not exist in the table.\n   * Columns are created without keys.\n   */\n  async addNewColumns() {\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue;\n      // find which columns are new\n      const newColumnMetadatas = metadata.columns.filter(columnMetadata => {\n        return !columnMetadata.isVirtualProperty && !table.columns.find(tableColumn => tableColumn.name === columnMetadata.databaseName);\n      });\n      if (newColumnMetadatas.length === 0) continue;\n      // create columns in the database\n      const newTableColumnOptions = this.metadataColumnsToTableColumnOptions(newColumnMetadatas);\n      const newTableColumns = newTableColumnOptions.map(option => new TableColumn(option));\n      if (newTableColumns.length === 0) continue;\n      this.connection.logger.logSchemaBuild(`new columns added: ` + newColumnMetadatas.map(column => column.databaseName).join(\", \"));\n      await this.queryRunner.addColumns(table, newTableColumns);\n    }\n  }\n  /**\n   * Updates composite primary keys.\n   */\n  async updatePrimaryKeys() {\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue;\n      const primaryMetadataColumns = metadata.columns.filter(column => column.isPrimary);\n      const primaryTableColumns = table.columns.filter(column => column.isPrimary);\n      if (primaryTableColumns.length !== primaryMetadataColumns.length && primaryMetadataColumns.length > 1) {\n        const changedPrimaryColumns = primaryMetadataColumns.map(primaryMetadataColumn => {\n          return new TableColumn(TableUtils.createTableColumnOptions(primaryMetadataColumn, this.connection.driver));\n        });\n        await this.queryRunner.updatePrimaryKeys(table, changedPrimaryColumns);\n      }\n    }\n  }\n  /**\n   * Update all exist columns which metadata has changed.\n   * Still don't create keys. Also we don't touch foreign keys of the changed columns.\n   */\n  async updateExistColumns() {\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue;\n      const changedColumns = this.connection.driver.findChangedColumns(table.columns, metadata.columns);\n      if (changedColumns.length === 0) continue;\n      // drop all foreign keys that point to this column\n      for (const changedColumn of changedColumns) {\n        await this.dropColumnReferencedForeignKeys(this.getTablePath(metadata), changedColumn.databaseName);\n      }\n      // drop all composite indices related to this column\n      for (const changedColumn of changedColumns) {\n        await this.dropColumnCompositeIndices(this.getTablePath(metadata), changedColumn.databaseName);\n      }\n      // drop all composite uniques related to this column\n      // Mysql does not support unique constraints.\n      if (!(DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\" || this.connection.driver.options.type === \"spanner\")) {\n        for (const changedColumn of changedColumns) {\n          await this.dropColumnCompositeUniques(this.getTablePath(metadata), changedColumn.databaseName);\n        }\n      }\n      // generate a map of new/old columns\n      const newAndOldTableColumns = changedColumns.map(changedColumn => {\n        const oldTableColumn = table.columns.find(column => column.name === changedColumn.databaseName);\n        const newTableColumnOptions = TableUtils.createTableColumnOptions(changedColumn, this.connection.driver);\n        const newTableColumn = new TableColumn(newTableColumnOptions);\n        return {\n          oldColumn: oldTableColumn,\n          newColumn: newTableColumn\n        };\n      });\n      if (newAndOldTableColumns.length === 0) continue;\n      this.connection.logger.logSchemaBuild(`columns changed in \"${table.name}\". updating: ` + changedColumns.map(column => column.databaseName).join(\", \"));\n      await this.queryRunner.changeColumns(table, newAndOldTableColumns);\n    }\n  }\n  /**\n   * Creates composite indices which are missing in db yet.\n   */\n  async createNewIndices() {\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue;\n      const newIndices = metadata.indices.filter(indexMetadata => !table.indices.find(tableIndex => tableIndex.name === indexMetadata.name) && indexMetadata.synchronize === true).map(indexMetadata => TableIndex.create(indexMetadata));\n      if (newIndices.length === 0) continue;\n      this.connection.logger.logSchemaBuild(`adding new indices ${newIndices.map(index => `\"${index.name}\"`).join(\", \")} in table \"${table.name}\"`);\n      await this.queryRunner.createIndices(table, newIndices);\n    }\n  }\n  /**\n   * Creates indices for materialized views.\n   */\n  async createNewViewIndices() {\n    // Only PostgreSQL supports indices for materialized views.\n    if (this.connection.options.type !== \"postgres\" || !DriverUtils.isPostgresFamily(this.connection.driver)) {\n      return;\n    }\n    const postgresQueryRunner = this.queryRunner;\n    for (const metadata of this.viewEntityToSyncMetadatas) {\n      // check if view does not exist yet\n      const view = this.queryRunner.loadedViews.find(view => {\n        const viewExpression = typeof view.expression === \"string\" ? view.expression.trim() : view.expression(this.connection).getQuery();\n        const metadataExpression = typeof metadata.expression === \"string\" ? metadata.expression.trim() : metadata.expression(this.connection).getQuery();\n        return this.getTablePath(view) === this.getTablePath(metadata) && viewExpression === metadataExpression;\n      });\n      if (!view || !view.materialized) continue;\n      const newIndices = metadata.indices.filter(indexMetadata => !view.indices.find(tableIndex => tableIndex.name === indexMetadata.name) && indexMetadata.synchronize === true).map(indexMetadata => TableIndex.create(indexMetadata));\n      if (newIndices.length === 0) continue;\n      this.connection.logger.logSchemaBuild(`adding new indices ${newIndices.map(index => `\"${index.name}\"`).join(\", \")} in view \"${view.name}\"`);\n      await postgresQueryRunner.createViewIndices(view, newIndices);\n    }\n  }\n  async createNewChecks() {\n    // Mysql does not support check constraints\n    if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\") return;\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue;\n      const newChecks = metadata.checks.filter(checkMetadata => !table.checks.find(tableCheck => tableCheck.name === checkMetadata.name)).map(checkMetadata => TableCheck.create(checkMetadata));\n      if (newChecks.length === 0) continue;\n      this.connection.logger.logSchemaBuild(`adding new check constraints: ${newChecks.map(index => `\"${index.name}\"`).join(\", \")} in table \"${table.name}\"`);\n      await this.queryRunner.createCheckConstraints(table, newChecks);\n    }\n  }\n  /**\n   * Creates composite uniques which are missing in db yet.\n   */\n  async createCompositeUniqueConstraints() {\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue;\n      const compositeUniques = metadata.uniques.filter(uniqueMetadata => uniqueMetadata.columns.length > 1 && !table.uniques.find(tableUnique => tableUnique.name === uniqueMetadata.name)).map(uniqueMetadata => TableUnique.create(uniqueMetadata));\n      if (compositeUniques.length === 0) continue;\n      this.connection.logger.logSchemaBuild(`adding new unique constraints: ${compositeUniques.map(unique => `\"${unique.name}\"`).join(\", \")} in table \"${table.name}\"`);\n      await this.queryRunner.createUniqueConstraints(table, compositeUniques);\n    }\n  }\n  /**\n   * Creates exclusions which are missing in db yet.\n   */\n  async createNewExclusions() {\n    // Only PostgreSQL supports exclusion constraints\n    if (!(this.connection.driver.options.type === \"postgres\")) return;\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue;\n      const newExclusions = metadata.exclusions.filter(exclusionMetadata => !table.exclusions.find(tableExclusion => tableExclusion.name === exclusionMetadata.name)).map(exclusionMetadata => TableExclusion.create(exclusionMetadata));\n      if (newExclusions.length === 0) continue;\n      this.connection.logger.logSchemaBuild(`adding new exclusion constraints: ${newExclusions.map(exclusion => `\"${exclusion.name}\"`).join(\", \")} in table \"${table.name}\"`);\n      await this.queryRunner.createExclusionConstraints(table, newExclusions);\n    }\n  }\n  /**\n   * Creates foreign keys which does not exist in the table yet.\n   */\n  async createForeignKeys() {\n    for (const metadata of this.entityToSyncMetadatas) {\n      const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n      if (!table) continue;\n      const newKeys = metadata.foreignKeys.filter(foreignKey => {\n        return !table.foreignKeys.find(dbForeignKey => dbForeignKey.name === foreignKey.name && this.getTablePath(dbForeignKey) === this.getTablePath(foreignKey.referencedEntityMetadata));\n      });\n      if (newKeys.length === 0) continue;\n      const dbForeignKeys = newKeys.map(foreignKeyMetadata => TableForeignKey.create(foreignKeyMetadata, this.connection.driver));\n      this.connection.logger.logSchemaBuild(`creating a foreign keys: ${newKeys.map(key => key.name).join(\", \")} on table \"${table.name}\"`);\n      await this.queryRunner.createForeignKeys(table, dbForeignKeys);\n    }\n  }\n  /**\n   * Drops all foreign keys where given column of the given table is being used.\n   */\n  async dropColumnReferencedForeignKeys(tablePath, columnName) {\n    const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === tablePath);\n    if (!table) return;\n    const tablesWithFK = [];\n    const columnForeignKey = table.foreignKeys.find(foreignKey => foreignKey.columnNames.indexOf(columnName) !== -1);\n    if (columnForeignKey) {\n      const clonedTable = table.clone();\n      clonedTable.foreignKeys = [columnForeignKey];\n      tablesWithFK.push(clonedTable);\n      table.removeForeignKey(columnForeignKey);\n    }\n    for (const loadedTable of this.queryRunner.loadedTables) {\n      const dependForeignKeys = loadedTable.foreignKeys.filter(foreignKey => {\n        return this.getTablePath(foreignKey) === tablePath && foreignKey.referencedColumnNames.indexOf(columnName) !== -1;\n      });\n      if (dependForeignKeys.length > 0) {\n        const clonedTable = loadedTable.clone();\n        clonedTable.foreignKeys = dependForeignKeys;\n        tablesWithFK.push(clonedTable);\n        dependForeignKeys.forEach(dependForeignKey => loadedTable.removeForeignKey(dependForeignKey));\n      }\n    }\n    if (tablesWithFK.length > 0) {\n      for (const tableWithFK of tablesWithFK) {\n        this.connection.logger.logSchemaBuild(`dropping related foreign keys of ${tableWithFK.name}: ${tableWithFK.foreignKeys.map(foreignKey => foreignKey.name).join(\", \")}`);\n        await this.queryRunner.dropForeignKeys(tableWithFK, tableWithFK.foreignKeys);\n      }\n    }\n  }\n  /**\n   * Drops all composite indices, related to given column.\n   */\n  async dropColumnCompositeIndices(tablePath, columnName) {\n    const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === tablePath);\n    if (!table) return;\n    const relatedIndices = table.indices.filter(index => index.columnNames.length > 1 && index.columnNames.indexOf(columnName) !== -1);\n    if (relatedIndices.length === 0) return;\n    this.connection.logger.logSchemaBuild(`dropping related indices of \"${tablePath}\".\"${columnName}\": ${relatedIndices.map(index => index.name).join(\", \")}`);\n    await this.queryRunner.dropIndices(table, relatedIndices);\n  }\n  /**\n   * Drops all composite uniques, related to given column.\n   */\n  async dropColumnCompositeUniques(tablePath, columnName) {\n    const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === tablePath);\n    if (!table) return;\n    const relatedUniques = table.uniques.filter(unique => unique.columnNames.length > 1 && unique.columnNames.indexOf(columnName) !== -1);\n    if (relatedUniques.length === 0) return;\n    this.connection.logger.logSchemaBuild(`dropping related unique constraints of \"${tablePath}\".\"${columnName}\": ${relatedUniques.map(unique => unique.name).join(\", \")}`);\n    await this.queryRunner.dropUniqueConstraints(table, relatedUniques);\n  }\n  /**\n   * Creates new columns from the given column metadatas.\n   */\n  metadataColumnsToTableColumnOptions(columns) {\n    return columns.map(columnMetadata => TableUtils.createTableColumnOptions(columnMetadata, this.connection.driver));\n  }\n  /**\n   * Creates typeorm service table for storing user defined Views and generate columns.\n   */\n  async createTypeormMetadataTable(queryRunner) {\n    const schema = this.currentSchema;\n    const database = this.currentDatabase;\n    const typeormMetadataTable = this.connection.driver.buildTableName(this.connection.metadataTableName, schema, database);\n    // Spanner requires at least one primary key in a table.\n    // Since we don't have unique column in \"typeorm_metadata\" table\n    // and we should avoid breaking changes, we mark all columns as primary for Spanner driver.\n    const isPrimary = this.connection.driver.options.type === \"spanner\";\n    await queryRunner.createTable(new Table({\n      database: database,\n      schema: schema,\n      name: typeormMetadataTable,\n      columns: [{\n        name: \"type\",\n        type: this.connection.driver.normalizeType({\n          type: this.connection.driver.mappedDataTypes.metadataType\n        }),\n        isNullable: false,\n        isPrimary\n      }, {\n        name: \"database\",\n        type: this.connection.driver.normalizeType({\n          type: this.connection.driver.mappedDataTypes.metadataDatabase\n        }),\n        isNullable: true,\n        isPrimary\n      }, {\n        name: \"schema\",\n        type: this.connection.driver.normalizeType({\n          type: this.connection.driver.mappedDataTypes.metadataSchema\n        }),\n        isNullable: true,\n        isPrimary\n      }, {\n        name: \"table\",\n        type: this.connection.driver.normalizeType({\n          type: this.connection.driver.mappedDataTypes.metadataTable\n        }),\n        isNullable: true,\n        isPrimary\n      }, {\n        name: \"name\",\n        type: this.connection.driver.normalizeType({\n          type: this.connection.driver.mappedDataTypes.metadataName\n        }),\n        isNullable: true,\n        isPrimary\n      }, {\n        name: \"value\",\n        type: this.connection.driver.normalizeType({\n          type: this.connection.driver.mappedDataTypes.metadataValue\n        }),\n        isNullable: true,\n        isPrimary\n      }]\n    }), true);\n  }\n}","map":{"version":3,"names":["Table","TableColumn","TableForeignKey","TableIndex","TableUtils","TableUnique","TableCheck","TableExclusion","View","ViewUtils","DriverUtils","RdbmsSchemaBuilder","constructor","connection","Symbol","for","build","queryRunner","createQueryRunner","currentDatabase","driver","database","currentSchema","schema","isUsingTransactions","options","type","migrationsTransactionMode","beforeMigration","startTransaction","createMetadataTableIfNecessary","tablePaths","entityToSyncMetadatas","map","metadata","getTablePath","viewPaths","viewEntityToSyncMetadatas","getTables","getViews","executeSchemaSyncOperationsInProperOrder","queryResultCache","synchronize","commitTransaction","error","rollbackTransaction","rollbackError","afterMigration","release","length","hasGeneratedColumns","createTypeormMetadataTable","log","enableSqlMemory","getMemorySql","disableSqlMemory","entityMetadatas","filter","tableType","sort","viewMetadataCmp","some","entityMetadata","columns","column","generatedType","dropOldViews","dropOldForeignKeys","dropOldIndices","dropOldChecks","dropOldExclusions","dropCompositeUniqueConstraints","renameColumns","changeTableComment","createNewTables","dropRemovedColumns","addNewColumns","updatePrimaryKeys","updateExistColumns","createNewIndices","createNewChecks","createNewExclusions","createCompositeUniqueConstraints","createForeignKeys","createViews","createNewViewIndices","target","parsed","parseTableName","buildTableName","tableName","table","loadedTables","find","tableForeignKeysToDrop","foreignKeys","tableForeignKey","metadataFK","metadataForeignKey","name","referencedEntityMetadata","onDelete","onUpdate","logger","logSchemaBuild","dbForeignKey","join","dropForeignKeys","renameTables","renamedMetadataColumns","c","isVirtualProperty","tableColumn","databaseName","normalizeType","isNullable","isUnique","normalizeIsUnique","renamedTableColumns","renamedColumn","clone","renameColumn","dropQueries","indices","tableIndex","indexMetadata","index","isSpatial","isFullTextColumnTypeSupported","isFulltext","columnNames","every","indexOf","dropIndex","Promise","all","postgresQueryRunner","view","loadedViews","dropViewIndex","isMySQLFamily","oldChecks","checks","tableCheck","checkMetadata","check","dropCheckConstraints","compositeUniques","uniques","tableUnique","uniqueMetadata","unique","dropUniqueConstraints","oldExclusions","exclusions","tableExclusion","exclusionMetadata","exclusion","dropExclusionConstraints","newComment","comment","existTable","create","createTable","push","existView","viewExpression","expression","trim","getQuery","metadataExpression","createView","droppedViews","viewToMetadata","Map","viewMetadata","set","get","viewDependencyChain","viewWithDependencies","currentView","currentMetadata","entries","dependsOn","has","concat","droppedViewsWithDependencies","Set","reduce","segment","a","b","reverse","dropView","droppedTableColumns","columnMetadata","dropColumns","newColumnMetadatas","newTableColumnOptions","metadataColumnsToTableColumnOptions","newTableColumns","option","addColumns","primaryMetadataColumns","isPrimary","primaryTableColumns","changedPrimaryColumns","primaryMetadataColumn","createTableColumnOptions","changedColumns","findChangedColumns","changedColumn","dropColumnReferencedForeignKeys","dropColumnCompositeIndices","dropColumnCompositeUniques","newAndOldTableColumns","oldTableColumn","newTableColumn","oldColumn","newColumn","changeColumns","newIndices","createIndices","isPostgresFamily","materialized","createViewIndices","newChecks","createCheckConstraints","createUniqueConstraints","newExclusions","createExclusionConstraints","newKeys","foreignKey","dbForeignKeys","foreignKeyMetadata","key","tablePath","columnName","tablesWithFK","columnForeignKey","clonedTable","removeForeignKey","loadedTable","dependForeignKeys","referencedColumnNames","forEach","dependForeignKey","tableWithFK","relatedIndices","dropIndices","relatedUniques","typeormMetadataTable","metadataTableName","mappedDataTypes","metadataType","metadataDatabase","metadataSchema","metadataTable","metadataName","metadataValue"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\schema-builder\\RdbmsSchemaBuilder.ts"],"sourcesContent":["import { Table } from \"./table/Table\"\nimport { TableColumn } from \"./table/TableColumn\"\nimport { TableForeignKey } from \"./table/TableForeignKey\"\nimport { TableIndex } from \"./table/TableIndex\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { SchemaBuilder } from \"./SchemaBuilder\"\nimport { SqlInMemory } from \"../driver/SqlInMemory\"\nimport { TableUtils } from \"./util/TableUtils\"\nimport { TableColumnOptions } from \"./options/TableColumnOptions\"\nimport { TableUnique } from \"./table/TableUnique\"\nimport { TableCheck } from \"./table/TableCheck\"\nimport { TableExclusion } from \"./table/TableExclusion\"\nimport { View } from \"./view/View\"\nimport { ViewUtils } from \"./util/ViewUtils\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\nimport { PostgresQueryRunner } from \"../driver/postgres/PostgresQueryRunner\"\n\n/**\n * Creates complete tables schemas in the database based on the entity metadatas.\n *\n * Steps how schema is being built:\n * 1. load list of all tables with complete column and keys information from the db\n * 2. drop all (old) foreign keys that exist in the table, but does not exist in the metadata\n * 3. create new tables that does not exist in the db, but exist in the metadata\n * 4. drop all columns exist (left old) in the db table, but does not exist in the metadata\n * 5. add columns from metadata which does not exist in the table\n * 6. update all exist columns which metadata has changed\n * 7. update primary keys - update old and create new primary key from changed columns\n * 8. create foreign keys which does not exist in the table yet\n * 9. create indices which are missing in db yet, and drops indices which exist in the db, but does not exist in the metadata anymore\n */\nexport class RdbmsSchemaBuilder implements SchemaBuilder {\n    readonly \"@instanceof\" = Symbol.for(\"RdbmsSchemaBuilder\")\n\n    /**\n     * Used to execute schema creation queries in a single connection.\n     */\n    protected queryRunner: QueryRunner\n\n    private currentDatabase?: string\n\n    private currentSchema?: string\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected connection: DataSource) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates complete schemas for the given entity metadatas.\n     */\n    async build(): Promise<void> {\n        this.queryRunner = this.connection.createQueryRunner()\n\n        // this.connection.driver.database || this.currentDatabase;\n        this.currentDatabase = this.connection.driver.database\n        this.currentSchema = this.connection.driver.schema\n\n        // CockroachDB implements asynchronous schema sync operations which can not been executed in transaction.\n        // E.g. if you try to DROP column and ADD it again in the same transaction, crdb throws error.\n        // In Spanner queries against the INFORMATION_SCHEMA can be used in a read-only transaction,\n        // but not in a read-write transaction.\n        const isUsingTransactions =\n            !(this.connection.driver.options.type === \"cockroachdb\") &&\n            !(this.connection.driver.options.type === \"spanner\") &&\n            this.connection.options.migrationsTransactionMode !== \"none\"\n\n        await this.queryRunner.beforeMigration()\n\n        if (isUsingTransactions) {\n            await this.queryRunner.startTransaction()\n        }\n\n        try {\n            await this.createMetadataTableIfNecessary(this.queryRunner)\n            // Flush the queryrunner table & view cache\n            const tablePaths = this.entityToSyncMetadatas.map((metadata) =>\n                this.getTablePath(metadata),\n            )\n            const viewPaths = this.viewEntityToSyncMetadatas.map((metadata) =>\n                this.getTablePath(metadata),\n            )\n\n            await this.queryRunner.getTables(tablePaths)\n            await this.queryRunner.getViews(viewPaths)\n\n            await this.executeSchemaSyncOperationsInProperOrder()\n\n            // if cache is enabled then perform cache-synchronization as well\n            if (this.connection.queryResultCache)\n                await this.connection.queryResultCache.synchronize(\n                    this.queryRunner,\n                )\n\n            if (isUsingTransactions) {\n                await this.queryRunner.commitTransaction()\n            }\n        } catch (error) {\n            try {\n                // we throw original error even if rollback thrown an error\n                if (isUsingTransactions) {\n                    await this.queryRunner.rollbackTransaction()\n                }\n            } catch (rollbackError) {}\n            throw error\n        } finally {\n            await this.queryRunner.afterMigration()\n\n            await this.queryRunner.release()\n        }\n    }\n\n    /**\n     * Create the typeorm_metadata table if necessary.\n     */\n    async createMetadataTableIfNecessary(\n        queryRunner: QueryRunner,\n    ): Promise<void> {\n        if (\n            this.viewEntityToSyncMetadatas.length > 0 ||\n            this.hasGeneratedColumns()\n        ) {\n            await this.createTypeormMetadataTable(queryRunner)\n        }\n    }\n\n    /**\n     * Returns sql queries to be executed by schema builder.\n     */\n    async log(): Promise<SqlInMemory> {\n        this.queryRunner = this.connection.createQueryRunner()\n        try {\n            // Flush the queryrunner table & view cache\n            const tablePaths = this.entityToSyncMetadatas.map((metadata) =>\n                this.getTablePath(metadata),\n            )\n            const viewPaths = this.viewEntityToSyncMetadatas.map((metadata) =>\n                this.getTablePath(metadata),\n            )\n            await this.queryRunner.getTables(tablePaths)\n            await this.queryRunner.getViews(viewPaths)\n\n            this.queryRunner.enableSqlMemory()\n            await this.executeSchemaSyncOperationsInProperOrder()\n\n            // if cache is enabled then perform cache-synchronization as well\n            if (this.connection.queryResultCache)\n                // todo: check this functionality\n                await this.connection.queryResultCache.synchronize(\n                    this.queryRunner,\n                )\n\n            return this.queryRunner.getMemorySql()\n        } finally {\n            // its important to disable this mode despite the fact we are release query builder\n            // because there exist drivers which reuse same query runner. Also its important to disable\n            // sql memory after call of getMemorySql() method because last one flushes sql memory.\n            this.queryRunner.disableSqlMemory()\n            await this.queryRunner.release()\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Returns only entities that should be synced in the database.\n     */\n    protected get entityToSyncMetadatas(): EntityMetadata[] {\n        return this.connection.entityMetadatas.filter(\n            (metadata) =>\n                metadata.synchronize &&\n                metadata.tableType !== \"entity-child\" &&\n                metadata.tableType !== \"view\",\n        )\n    }\n\n    /**\n     * Returns only entities that should be synced in the database.\n     */\n    protected get viewEntityToSyncMetadatas(): EntityMetadata[] {\n        return (\n            this.connection.entityMetadatas\n                .filter(\n                    (metadata) =>\n                        metadata.tableType === \"view\" && metadata.synchronize,\n                )\n                // sort views in creation order by dependencies\n                .sort(ViewUtils.viewMetadataCmp)\n        )\n    }\n\n    /**\n     * Checks if there are at least one generated column.\n     */\n    protected hasGeneratedColumns(): boolean {\n        return this.connection.entityMetadatas.some((entityMetadata) => {\n            return entityMetadata.columns.some((column) => column.generatedType)\n        })\n    }\n\n    /**\n     * Executes schema sync operations in a proper order.\n     * Order of operations matter here.\n     */\n    protected async executeSchemaSyncOperationsInProperOrder(): Promise<void> {\n        await this.dropOldViews()\n        await this.dropOldForeignKeys()\n        await this.dropOldIndices()\n        await this.dropOldChecks()\n        await this.dropOldExclusions()\n        await this.dropCompositeUniqueConstraints()\n        // await this.renameTables();\n        await this.renameColumns()\n        await this.changeTableComment()\n        await this.createNewTables()\n        await this.dropRemovedColumns()\n        await this.addNewColumns()\n        await this.updatePrimaryKeys()\n        await this.updateExistColumns()\n        await this.createNewIndices()\n        await this.createNewChecks()\n        await this.createNewExclusions()\n        await this.createCompositeUniqueConstraints()\n        await this.createForeignKeys()\n        await this.createViews()\n        await this.createNewViewIndices()\n    }\n\n    private getTablePath(\n        target: EntityMetadata | Table | View | TableForeignKey | string,\n    ): string {\n        const parsed = this.connection.driver.parseTableName(target)\n\n        return this.connection.driver.buildTableName(\n            parsed.tableName,\n            parsed.schema || this.currentSchema,\n            parsed.database || this.currentDatabase,\n        )\n    }\n\n    /**\n     * Drops all (old) foreign keys that exist in the tables, but do not exist in the entity metadata.\n     */\n    protected async dropOldForeignKeys(): Promise<void> {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            // find foreign keys that exist in the schemas but does not exist in the entity metadata\n            const tableForeignKeysToDrop = table.foreignKeys.filter(\n                (tableForeignKey) => {\n                    const metadataFK = metadata.foreignKeys.find(\n                        (metadataForeignKey) =>\n                            tableForeignKey.name === metadataForeignKey.name &&\n                            this.getTablePath(tableForeignKey) ===\n                                this.getTablePath(\n                                    metadataForeignKey.referencedEntityMetadata,\n                                ),\n                    )\n                    return (\n                        !metadataFK ||\n                        (metadataFK.onDelete &&\n                            metadataFK.onDelete !== tableForeignKey.onDelete) ||\n                        (metadataFK.onUpdate &&\n                            metadataFK.onUpdate !== tableForeignKey.onUpdate)\n                    )\n                },\n            )\n            if (tableForeignKeysToDrop.length === 0) continue\n\n            this.connection.logger.logSchemaBuild(\n                `dropping old foreign keys of ${\n                    table.name\n                }: ${tableForeignKeysToDrop\n                    .map((dbForeignKey) => dbForeignKey.name)\n                    .join(\", \")}`,\n            )\n\n            // drop foreign keys from the database\n            await this.queryRunner.dropForeignKeys(\n                table,\n                tableForeignKeysToDrop,\n            )\n        }\n    }\n\n    /**\n     * Rename tables\n     */\n    protected async renameTables(): Promise<void> {\n        // for (const metadata of this.entityToSyncMetadatas) {\n        //     const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n        // }\n    }\n\n    /**\n     * Renames columns.\n     * Works if only one column per table was changed.\n     * Changes only column name. If something besides name was changed, these changes will be ignored.\n     */\n    protected async renameColumns(): Promise<void> {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            if (metadata.columns.length !== table.columns.length) continue\n\n            const renamedMetadataColumns = metadata.columns\n                .filter((c) => !c.isVirtualProperty)\n                .filter((column) => {\n                    return !table.columns.find((tableColumn) => {\n                        return (\n                            tableColumn.name === column.databaseName &&\n                            tableColumn.type ===\n                                this.connection.driver.normalizeType(column) &&\n                            tableColumn.isNullable === column.isNullable &&\n                            tableColumn.isUnique ===\n                                this.connection.driver.normalizeIsUnique(column)\n                        )\n                    })\n                })\n\n            if (\n                renamedMetadataColumns.length === 0 ||\n                renamedMetadataColumns.length > 1\n            )\n                continue\n\n            const renamedTableColumns = table.columns.filter((tableColumn) => {\n                return !metadata.columns.find((column) => {\n                    return (\n                        !column.isVirtualProperty &&\n                        column.databaseName === tableColumn.name &&\n                        this.connection.driver.normalizeType(column) ===\n                            tableColumn.type &&\n                        column.isNullable === tableColumn.isNullable &&\n                        this.connection.driver.normalizeIsUnique(column) ===\n                            tableColumn.isUnique\n                    )\n                })\n            })\n\n            if (\n                renamedTableColumns.length === 0 ||\n                renamedTableColumns.length > 1\n            )\n                continue\n\n            const renamedColumn = renamedTableColumns[0].clone()\n            renamedColumn.name = renamedMetadataColumns[0].databaseName\n\n            this.connection.logger.logSchemaBuild(\n                `renaming column \"${renamedTableColumns[0].name}\" in \"${table.name}\" to \"${renamedColumn.name}\"`,\n            )\n            await this.queryRunner.renameColumn(\n                table,\n                renamedTableColumns[0],\n                renamedColumn,\n            )\n        }\n    }\n\n    protected async dropOldIndices(): Promise<void> {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            const dropQueries = table.indices\n                .filter((tableIndex) => {\n                    const indexMetadata = metadata.indices.find(\n                        (index) => index.name === tableIndex.name,\n                    )\n                    if (indexMetadata) {\n                        if (indexMetadata.synchronize === false) return false\n\n                        if (indexMetadata.isUnique !== tableIndex.isUnique)\n                            return true\n\n                        if (indexMetadata.isSpatial !== tableIndex.isSpatial)\n                            return true\n\n                        if (\n                            this.connection.driver.isFullTextColumnTypeSupported() &&\n                            indexMetadata.isFulltext !== tableIndex.isFulltext\n                        )\n                            return true\n\n                        if (\n                            indexMetadata.columns.length !==\n                            tableIndex.columnNames.length\n                        )\n                            return true\n\n                        return !indexMetadata.columns.every(\n                            (column) =>\n                                tableIndex.columnNames.indexOf(\n                                    column.databaseName,\n                                ) !== -1,\n                        )\n                    }\n\n                    return true\n                })\n                .map(async (tableIndex) => {\n                    this.connection.logger.logSchemaBuild(\n                        `dropping an index: \"${tableIndex.name}\" from table ${table.name}`,\n                    )\n                    await this.queryRunner.dropIndex(table, tableIndex)\n                })\n\n            await Promise.all(dropQueries)\n        }\n        if (this.connection.options.type === \"postgres\") {\n            const postgresQueryRunner: PostgresQueryRunner = <\n                PostgresQueryRunner\n            >this.queryRunner\n            for (const metadata of this.viewEntityToSyncMetadatas) {\n                const view = this.queryRunner.loadedViews.find(\n                    (view) =>\n                        this.getTablePath(view) === this.getTablePath(metadata),\n                )\n                if (!view) continue\n\n                const dropQueries = view.indices\n                    .filter((tableIndex) => {\n                        const indexMetadata = metadata.indices.find(\n                            (index) => index.name === tableIndex.name,\n                        )\n                        if (indexMetadata) {\n                            if (indexMetadata.synchronize === false)\n                                return false\n\n                            if (indexMetadata.isUnique !== tableIndex.isUnique)\n                                return true\n\n                            if (\n                                indexMetadata.isSpatial !== tableIndex.isSpatial\n                            )\n                                return true\n\n                            if (\n                                this.connection.driver.isFullTextColumnTypeSupported() &&\n                                indexMetadata.isFulltext !==\n                                    tableIndex.isFulltext\n                            )\n                                return true\n\n                            if (\n                                indexMetadata.columns.length !==\n                                tableIndex.columnNames.length\n                            )\n                                return true\n\n                            return !indexMetadata.columns.every(\n                                (column) =>\n                                    tableIndex.columnNames.indexOf(\n                                        column.databaseName,\n                                    ) !== -1,\n                            )\n                        }\n\n                        return true\n                    })\n                    .map(async (tableIndex) => {\n                        this.connection.logger.logSchemaBuild(\n                            `dropping an index: \"${tableIndex.name}\" from view ${view.name}`,\n                        )\n                        await postgresQueryRunner.dropViewIndex(\n                            view,\n                            tableIndex,\n                        )\n                    })\n\n                await Promise.all(dropQueries)\n            }\n        }\n    }\n\n    protected async dropOldChecks(): Promise<void> {\n        // Mysql does not support check constraints\n        if (\n            DriverUtils.isMySQLFamily(this.connection.driver) ||\n            this.connection.driver.options.type === \"aurora-mysql\"\n        )\n            return\n\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            const oldChecks = table.checks.filter((tableCheck) => {\n                return !metadata.checks.find(\n                    (checkMetadata) => checkMetadata.name === tableCheck.name,\n                )\n            })\n\n            if (oldChecks.length === 0) continue\n\n            this.connection.logger.logSchemaBuild(\n                `dropping old check constraint: ${oldChecks\n                    .map((check) => `\"${check.name}\"`)\n                    .join(\", \")} from table \"${table.name}\"`,\n            )\n            await this.queryRunner.dropCheckConstraints(table, oldChecks)\n        }\n    }\n\n    protected async dropCompositeUniqueConstraints(): Promise<void> {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            const compositeUniques = table.uniques.filter((tableUnique) => {\n                return (\n                    tableUnique.columnNames.length > 1 &&\n                    !metadata.uniques.find(\n                        (uniqueMetadata) =>\n                            uniqueMetadata.name === tableUnique.name,\n                    )\n                )\n            })\n\n            if (compositeUniques.length === 0) continue\n\n            this.connection.logger.logSchemaBuild(\n                `dropping old unique constraint: ${compositeUniques\n                    .map((unique) => `\"${unique.name}\"`)\n                    .join(\", \")} from table \"${table.name}\"`,\n            )\n            await this.queryRunner.dropUniqueConstraints(\n                table,\n                compositeUniques,\n            )\n        }\n    }\n\n    protected async dropOldExclusions(): Promise<void> {\n        // Only PostgreSQL supports exclusion constraints\n        if (!(this.connection.driver.options.type === \"postgres\")) return\n\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            const oldExclusions = table.exclusions.filter((tableExclusion) => {\n                return !metadata.exclusions.find(\n                    (exclusionMetadata) =>\n                        exclusionMetadata.name === tableExclusion.name,\n                )\n            })\n\n            if (oldExclusions.length === 0) continue\n\n            this.connection.logger.logSchemaBuild(\n                `dropping old exclusion constraint: ${oldExclusions\n                    .map((exclusion) => `\"${exclusion.name}\"`)\n                    .join(\", \")} from table \"${table.name}\"`,\n            )\n            await this.queryRunner.dropExclusionConstraints(\n                table,\n                oldExclusions,\n            )\n        }\n    }\n\n    /**\n     * change table comment\n     */\n    protected async changeTableComment(): Promise<void> {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            if (\n                DriverUtils.isMySQLFamily(this.connection.driver) ||\n                this.connection.driver.options.type === 'postgres'\n            ) {\n                const newComment = metadata.comment\n                await this.queryRunner.changeTableComment(table, newComment)\n            }\n        }\n    }\n\n    /**\n     * Creates tables that do not exist in the database yet.\n     * New tables are created without foreign and primary keys.\n     * Primary key only can be created in conclusion with auto generated column.\n     */\n    protected async createNewTables(): Promise<void> {\n        for (const metadata of this.entityToSyncMetadatas) {\n            // check if table does not exist yet\n            const existTable = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (existTable) continue\n\n            this.connection.logger.logSchemaBuild(\n                `creating a new table: ${this.getTablePath(metadata)}`,\n            )\n\n            // create a new table and sync it in the database\n            const table = Table.create(metadata, this.connection.driver)\n            await this.queryRunner.createTable(table, false, false)\n            this.queryRunner.loadedTables.push(table)\n        }\n    }\n\n    protected async createViews(): Promise<void> {\n        for (const metadata of this.viewEntityToSyncMetadatas) {\n            // check if view does not exist yet\n            const existView = this.queryRunner.loadedViews.find((view) => {\n                const viewExpression =\n                    typeof view.expression === \"string\"\n                        ? view.expression.trim()\n                        : view.expression(this.connection).getQuery()\n                const metadataExpression =\n                    typeof metadata.expression === \"string\"\n                        ? metadata.expression.trim()\n                        : metadata.expression!(this.connection).getQuery()\n                return (\n                    this.getTablePath(view) === this.getTablePath(metadata) &&\n                    viewExpression === metadataExpression\n                )\n            })\n            if (existView) continue\n\n            this.connection.logger.logSchemaBuild(\n                `creating a new view: ${this.getTablePath(metadata)}`,\n            )\n\n            // create a new view and sync it in the database\n            const view = View.create(metadata, this.connection.driver)\n            await this.queryRunner.createView(view, true)\n            this.queryRunner.loadedViews.push(view)\n        }\n    }\n\n    protected async dropOldViews(): Promise<void> {\n        const droppedViews: Array<View> = []\n        const viewEntityToSyncMetadatas = this.viewEntityToSyncMetadatas\n        // BuIld lookup cache for finding views metadata\n        const viewToMetadata = new Map<View, EntityMetadata>()\n        for (const view of this.queryRunner.loadedViews) {\n            const viewMetadata = viewEntityToSyncMetadatas.find((metadata) => {\n                return this.getTablePath(view) === this.getTablePath(metadata)\n            })\n            if (viewMetadata) {\n                viewToMetadata.set(view, viewMetadata)\n            }\n        }\n        // Gather all changed view, that need a drop\n        for (const view of this.queryRunner.loadedViews) {\n            const viewMetadata = viewToMetadata.get(view)\n            if (!viewMetadata) {\n                continue\n            }\n            const viewExpression =\n                typeof view.expression === \"string\"\n                    ? view.expression.trim()\n                    : view.expression(this.connection).getQuery()\n            const metadataExpression =\n                typeof viewMetadata.expression === \"string\"\n                    ? viewMetadata.expression.trim()\n                    : viewMetadata.expression!(this.connection).getQuery()\n\n            if (viewExpression === metadataExpression) continue\n\n            this.connection.logger.logSchemaBuild(\n                `dropping an old view: ${view.name}`,\n            )\n\n            // Collect view to be dropped\n            droppedViews.push(view)\n        }\n\n        // Helper function that for a given view, will recursively return list of the view and all views that depend on it\n        const viewDependencyChain = (view: View): View[] => {\n            // Get the view metadata\n            const viewMetadata = viewToMetadata.get(view)\n            let viewWithDependencies = [view]\n            // If no metadata is known for the view, simply return the view itself\n            if (!viewMetadata) {\n                return viewWithDependencies\n            }\n            // Iterate over all known views\n            for (const [\n                currentView,\n                currentMetadata,\n            ] of viewToMetadata.entries()) {\n                // Ignore self reference\n                if (currentView === view) {\n                    continue\n                }\n                // If the currently iterated view depends on the passed in view\n                if (\n                    currentMetadata.dependsOn &&\n                    (currentMetadata.dependsOn.has(viewMetadata.target) ||\n                        currentMetadata.dependsOn.has(viewMetadata.name))\n                ) {\n                    // Recursively add currently iterate view and its dependents\n                    viewWithDependencies = viewWithDependencies.concat(\n                        viewDependencyChain(currentView),\n                    )\n                }\n            }\n            // Return all collected views\n            return viewWithDependencies\n        }\n\n        // Collect final list of views to be dropped in a Set so there are no duplicates\n        const droppedViewsWithDependencies: Set<View> = new Set(\n            // Collect all dropped views, and their dependencies\n            droppedViews\n                .map((view) => viewDependencyChain(view))\n                // Flattened to single Array ( can be replaced with flatMap, once supported)\n                .reduce((all, segment) => {\n                    return all.concat(segment)\n                }, [])\n                // Sort the views to be dropped in creation order\n                .sort((a, b) => {\n                    return ViewUtils.viewMetadataCmp(\n                        viewToMetadata.get(a),\n                        viewToMetadata.get(b),\n                    )\n                })\n                // reverse order to get drop order\n                .reverse(),\n        )\n\n        // Finally emit all drop views\n        for (const view of droppedViewsWithDependencies) {\n            await this.queryRunner.dropView(view)\n        }\n        this.queryRunner.loadedViews = this.queryRunner.loadedViews.filter(\n            (view) => !droppedViewsWithDependencies.has(view),\n        )\n    }\n\n    /**\n     * Drops all columns that exist in the table, but does not exist in the metadata (left old).\n     * We drop their keys too, since it should be safe.\n     */\n    protected async dropRemovedColumns(): Promise<void> {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            // find columns that exist in the database but does not exist in the metadata\n            const droppedTableColumns = table.columns.filter((tableColumn) => {\n                return !metadata.columns.find(\n                    (columnMetadata) =>\n                        columnMetadata.isVirtualProperty ||\n                        columnMetadata.databaseName === tableColumn.name,\n                )\n            })\n            if (droppedTableColumns.length === 0) continue\n\n            this.connection.logger.logSchemaBuild(\n                `columns dropped in ${table.name}: ` +\n                    droppedTableColumns.map((column) => column.name).join(\", \"),\n            )\n\n            // drop columns from the database\n            await this.queryRunner.dropColumns(table, droppedTableColumns)\n        }\n    }\n\n    /**\n     * Adds columns from metadata which does not exist in the table.\n     * Columns are created without keys.\n     */\n    protected async addNewColumns(): Promise<void> {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            // find which columns are new\n            const newColumnMetadatas = metadata.columns.filter(\n                (columnMetadata) => {\n                    return (\n                        !columnMetadata.isVirtualProperty &&\n                        !table.columns.find(\n                            (tableColumn) =>\n                                tableColumn.name ===\n                                columnMetadata.databaseName,\n                        )\n                    )\n                },\n            )\n            if (newColumnMetadatas.length === 0) continue\n\n            // create columns in the database\n            const newTableColumnOptions =\n                this.metadataColumnsToTableColumnOptions(newColumnMetadatas)\n            const newTableColumns = newTableColumnOptions.map(\n                (option) => new TableColumn(option),\n            )\n\n            if (newTableColumns.length === 0) continue\n\n            this.connection.logger.logSchemaBuild(\n                `new columns added: ` +\n                    newColumnMetadatas\n                        .map((column) => column.databaseName)\n                        .join(\", \"),\n            )\n            await this.queryRunner.addColumns(table, newTableColumns)\n        }\n    }\n\n    /**\n     * Updates composite primary keys.\n     */\n    protected async updatePrimaryKeys(): Promise<void> {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            const primaryMetadataColumns = metadata.columns.filter(\n                (column) => column.isPrimary,\n            )\n            const primaryTableColumns = table.columns.filter(\n                (column) => column.isPrimary,\n            )\n            if (\n                primaryTableColumns.length !== primaryMetadataColumns.length &&\n                primaryMetadataColumns.length > 1\n            ) {\n                const changedPrimaryColumns = primaryMetadataColumns.map(\n                    (primaryMetadataColumn) => {\n                        return new TableColumn(\n                            TableUtils.createTableColumnOptions(\n                                primaryMetadataColumn,\n                                this.connection.driver,\n                            ),\n                        )\n                    },\n                )\n                await this.queryRunner.updatePrimaryKeys(\n                    table,\n                    changedPrimaryColumns,\n                )\n            }\n        }\n    }\n\n    /**\n     * Update all exist columns which metadata has changed.\n     * Still don't create keys. Also we don't touch foreign keys of the changed columns.\n     */\n    protected async updateExistColumns(): Promise<void> {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            const changedColumns = this.connection.driver.findChangedColumns(\n                table.columns,\n                metadata.columns,\n            )\n            if (changedColumns.length === 0) continue\n\n            // drop all foreign keys that point to this column\n            for (const changedColumn of changedColumns) {\n                await this.dropColumnReferencedForeignKeys(\n                    this.getTablePath(metadata),\n                    changedColumn.databaseName,\n                )\n            }\n\n            // drop all composite indices related to this column\n            for (const changedColumn of changedColumns) {\n                await this.dropColumnCompositeIndices(\n                    this.getTablePath(metadata),\n                    changedColumn.databaseName,\n                )\n            }\n\n            // drop all composite uniques related to this column\n            // Mysql does not support unique constraints.\n            if (\n                !(\n                    DriverUtils.isMySQLFamily(this.connection.driver) ||\n                    this.connection.driver.options.type === \"aurora-mysql\" ||\n                    this.connection.driver.options.type === \"spanner\"\n                )\n            ) {\n                for (const changedColumn of changedColumns) {\n                    await this.dropColumnCompositeUniques(\n                        this.getTablePath(metadata),\n                        changedColumn.databaseName,\n                    )\n                }\n            }\n\n            // generate a map of new/old columns\n            const newAndOldTableColumns = changedColumns.map(\n                (changedColumn) => {\n                    const oldTableColumn = table.columns.find(\n                        (column) => column.name === changedColumn.databaseName,\n                    )!\n                    const newTableColumnOptions =\n                        TableUtils.createTableColumnOptions(\n                            changedColumn,\n                            this.connection.driver,\n                        )\n                    const newTableColumn = new TableColumn(\n                        newTableColumnOptions,\n                    )\n\n                    return {\n                        oldColumn: oldTableColumn,\n                        newColumn: newTableColumn,\n                    }\n                },\n            )\n\n            if (newAndOldTableColumns.length === 0) continue\n\n            this.connection.logger.logSchemaBuild(\n                `columns changed in \"${table.name}\". updating: ` +\n                    changedColumns\n                        .map((column) => column.databaseName)\n                        .join(\", \"),\n            )\n            await this.queryRunner.changeColumns(table, newAndOldTableColumns)\n        }\n    }\n\n    /**\n     * Creates composite indices which are missing in db yet.\n     */\n    protected async createNewIndices(): Promise<void> {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            const newIndices = metadata.indices\n                .filter(\n                    (indexMetadata) =>\n                        !table.indices.find(\n                            (tableIndex) =>\n                                tableIndex.name === indexMetadata.name,\n                        ) && indexMetadata.synchronize === true,\n                )\n                .map((indexMetadata) => TableIndex.create(indexMetadata))\n\n            if (newIndices.length === 0) continue\n\n            this.connection.logger.logSchemaBuild(\n                `adding new indices ${newIndices\n                    .map((index) => `\"${index.name}\"`)\n                    .join(\", \")} in table \"${table.name}\"`,\n            )\n            await this.queryRunner.createIndices(table, newIndices)\n        }\n    }\n\n    /**\n     * Creates indices for materialized views.\n     */\n    protected async createNewViewIndices(): Promise<void> {\n        // Only PostgreSQL supports indices for materialized views.\n        if (\n            this.connection.options.type !== \"postgres\" ||\n            !DriverUtils.isPostgresFamily(this.connection.driver)\n        ) {\n            return\n        }\n        const postgresQueryRunner: PostgresQueryRunner = <PostgresQueryRunner>(\n            this.queryRunner\n        )\n        for (const metadata of this.viewEntityToSyncMetadatas) {\n            // check if view does not exist yet\n            const view = this.queryRunner.loadedViews.find((view) => {\n                const viewExpression =\n                    typeof view.expression === \"string\"\n                        ? view.expression.trim()\n                        : view.expression(this.connection).getQuery()\n                const metadataExpression =\n                    typeof metadata.expression === \"string\"\n                        ? metadata.expression.trim()\n                        : metadata.expression!(this.connection).getQuery()\n                return (\n                    this.getTablePath(view) === this.getTablePath(metadata) &&\n                    viewExpression === metadataExpression\n                )\n            })\n            if (!view || !view.materialized) continue\n\n            const newIndices = metadata.indices\n                .filter(\n                    (indexMetadata) =>\n                        !view.indices.find(\n                            (tableIndex) =>\n                                tableIndex.name === indexMetadata.name,\n                        ) && indexMetadata.synchronize === true,\n                )\n                .map((indexMetadata) => TableIndex.create(indexMetadata))\n\n            if (newIndices.length === 0) continue\n\n            this.connection.logger.logSchemaBuild(\n                `adding new indices ${newIndices\n                    .map((index) => `\"${index.name}\"`)\n                    .join(\", \")} in view \"${view.name}\"`,\n            )\n            await postgresQueryRunner.createViewIndices(view, newIndices)\n        }\n    }\n\n    protected async createNewChecks(): Promise<void> {\n        // Mysql does not support check constraints\n        if (\n            DriverUtils.isMySQLFamily(this.connection.driver) ||\n            this.connection.driver.options.type === \"aurora-mysql\"\n        )\n            return\n\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            const newChecks = metadata.checks\n                .filter(\n                    (checkMetadata) =>\n                        !table.checks.find(\n                            (tableCheck) =>\n                                tableCheck.name === checkMetadata.name,\n                        ),\n                )\n                .map((checkMetadata) => TableCheck.create(checkMetadata))\n\n            if (newChecks.length === 0) continue\n\n            this.connection.logger.logSchemaBuild(\n                `adding new check constraints: ${newChecks\n                    .map((index) => `\"${index.name}\"`)\n                    .join(\", \")} in table \"${table.name}\"`,\n            )\n            await this.queryRunner.createCheckConstraints(table, newChecks)\n        }\n    }\n\n    /**\n     * Creates composite uniques which are missing in db yet.\n     */\n    protected async createCompositeUniqueConstraints(): Promise<void> {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            const compositeUniques = metadata.uniques\n                .filter(\n                    (uniqueMetadata) =>\n                        uniqueMetadata.columns.length > 1 &&\n                        !table.uniques.find(\n                            (tableUnique) =>\n                                tableUnique.name === uniqueMetadata.name,\n                        ),\n                )\n                .map((uniqueMetadata) => TableUnique.create(uniqueMetadata))\n\n            if (compositeUniques.length === 0) continue\n\n            this.connection.logger.logSchemaBuild(\n                `adding new unique constraints: ${compositeUniques\n                    .map((unique) => `\"${unique.name}\"`)\n                    .join(\", \")} in table \"${table.name}\"`,\n            )\n            await this.queryRunner.createUniqueConstraints(\n                table,\n                compositeUniques,\n            )\n        }\n    }\n\n    /**\n     * Creates exclusions which are missing in db yet.\n     */\n    protected async createNewExclusions(): Promise<void> {\n        // Only PostgreSQL supports exclusion constraints\n        if (!(this.connection.driver.options.type === \"postgres\")) return\n\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            const newExclusions = metadata.exclusions\n                .filter(\n                    (exclusionMetadata) =>\n                        !table.exclusions.find(\n                            (tableExclusion) =>\n                                tableExclusion.name === exclusionMetadata.name,\n                        ),\n                )\n                .map((exclusionMetadata) =>\n                    TableExclusion.create(exclusionMetadata),\n                )\n\n            if (newExclusions.length === 0) continue\n\n            this.connection.logger.logSchemaBuild(\n                `adding new exclusion constraints: ${newExclusions\n                    .map((exclusion) => `\"${exclusion.name}\"`)\n                    .join(\", \")} in table \"${table.name}\"`,\n            )\n            await this.queryRunner.createExclusionConstraints(\n                table,\n                newExclusions,\n            )\n        }\n    }\n\n    /**\n     * Creates foreign keys which does not exist in the table yet.\n     */\n    protected async createForeignKeys(): Promise<void> {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find(\n                (table) =>\n                    this.getTablePath(table) === this.getTablePath(metadata),\n            )\n            if (!table) continue\n\n            const newKeys = metadata.foreignKeys.filter((foreignKey) => {\n                return !table.foreignKeys.find(\n                    (dbForeignKey) =>\n                        dbForeignKey.name === foreignKey.name &&\n                        this.getTablePath(dbForeignKey) ===\n                            this.getTablePath(\n                                foreignKey.referencedEntityMetadata,\n                            ),\n                )\n            })\n            if (newKeys.length === 0) continue\n\n            const dbForeignKeys = newKeys.map((foreignKeyMetadata) =>\n                TableForeignKey.create(\n                    foreignKeyMetadata,\n                    this.connection.driver,\n                ),\n            )\n            this.connection.logger.logSchemaBuild(\n                `creating a foreign keys: ${newKeys\n                    .map((key) => key.name)\n                    .join(\", \")} on table \"${table.name}\"`,\n            )\n            await this.queryRunner.createForeignKeys(table, dbForeignKeys)\n        }\n    }\n\n    /**\n     * Drops all foreign keys where given column of the given table is being used.\n     */\n    protected async dropColumnReferencedForeignKeys(\n        tablePath: string,\n        columnName: string,\n    ): Promise<void> {\n        const table = this.queryRunner.loadedTables.find(\n            (table) => this.getTablePath(table) === tablePath,\n        )\n        if (!table) return\n\n        const tablesWithFK: Table[] = []\n        const columnForeignKey = table.foreignKeys.find(\n            (foreignKey) => foreignKey.columnNames.indexOf(columnName) !== -1,\n        )\n        if (columnForeignKey) {\n            const clonedTable = table.clone()\n            clonedTable.foreignKeys = [columnForeignKey]\n            tablesWithFK.push(clonedTable)\n            table.removeForeignKey(columnForeignKey)\n        }\n\n        for (const loadedTable of this.queryRunner.loadedTables) {\n            const dependForeignKeys = loadedTable.foreignKeys.filter(\n                (foreignKey) => {\n                    return (\n                        this.getTablePath(foreignKey) === tablePath &&\n                        foreignKey.referencedColumnNames.indexOf(columnName) !==\n                            -1\n                    )\n                },\n            )\n\n            if (dependForeignKeys.length > 0) {\n                const clonedTable = loadedTable.clone()\n                clonedTable.foreignKeys = dependForeignKeys\n                tablesWithFK.push(clonedTable)\n                dependForeignKeys.forEach((dependForeignKey) =>\n                    loadedTable.removeForeignKey(dependForeignKey),\n                )\n            }\n        }\n\n        if (tablesWithFK.length > 0) {\n            for (const tableWithFK of tablesWithFK) {\n                this.connection.logger.logSchemaBuild(\n                    `dropping related foreign keys of ${\n                        tableWithFK.name\n                    }: ${tableWithFK.foreignKeys\n                        .map((foreignKey) => foreignKey.name)\n                        .join(\", \")}`,\n                )\n                await this.queryRunner.dropForeignKeys(\n                    tableWithFK,\n                    tableWithFK.foreignKeys,\n                )\n            }\n        }\n    }\n\n    /**\n     * Drops all composite indices, related to given column.\n     */\n    protected async dropColumnCompositeIndices(\n        tablePath: string,\n        columnName: string,\n    ): Promise<void> {\n        const table = this.queryRunner.loadedTables.find(\n            (table) => this.getTablePath(table) === tablePath,\n        )\n        if (!table) return\n\n        const relatedIndices = table.indices.filter(\n            (index) =>\n                index.columnNames.length > 1 &&\n                index.columnNames.indexOf(columnName) !== -1,\n        )\n        if (relatedIndices.length === 0) return\n\n        this.connection.logger.logSchemaBuild(\n            `dropping related indices of \"${tablePath}\".\"${columnName}\": ${relatedIndices\n                .map((index) => index.name)\n                .join(\", \")}`,\n        )\n        await this.queryRunner.dropIndices(table, relatedIndices)\n    }\n\n    /**\n     * Drops all composite uniques, related to given column.\n     */\n    protected async dropColumnCompositeUniques(\n        tablePath: string,\n        columnName: string,\n    ): Promise<void> {\n        const table = this.queryRunner.loadedTables.find(\n            (table) => this.getTablePath(table) === tablePath,\n        )\n        if (!table) return\n\n        const relatedUniques = table.uniques.filter(\n            (unique) =>\n                unique.columnNames.length > 1 &&\n                unique.columnNames.indexOf(columnName) !== -1,\n        )\n        if (relatedUniques.length === 0) return\n\n        this.connection.logger.logSchemaBuild(\n            `dropping related unique constraints of \"${tablePath}\".\"${columnName}\": ${relatedUniques\n                .map((unique) => unique.name)\n                .join(\", \")}`,\n        )\n        await this.queryRunner.dropUniqueConstraints(table, relatedUniques)\n    }\n\n    /**\n     * Creates new columns from the given column metadatas.\n     */\n    protected metadataColumnsToTableColumnOptions(\n        columns: ColumnMetadata[],\n    ): TableColumnOptions[] {\n        return columns.map((columnMetadata) =>\n            TableUtils.createTableColumnOptions(\n                columnMetadata,\n                this.connection.driver,\n            ),\n        )\n    }\n\n    /**\n     * Creates typeorm service table for storing user defined Views and generate columns.\n     */\n    protected async createTypeormMetadataTable(queryRunner: QueryRunner) {\n        const schema = this.currentSchema\n        const database = this.currentDatabase\n        const typeormMetadataTable = this.connection.driver.buildTableName(\n            this.connection.metadataTableName,\n            schema,\n            database,\n        )\n\n        // Spanner requires at least one primary key in a table.\n        // Since we don't have unique column in \"typeorm_metadata\" table\n        // and we should avoid breaking changes, we mark all columns as primary for Spanner driver.\n        const isPrimary = this.connection.driver.options.type === \"spanner\"\n        await queryRunner.createTable(\n            new Table({\n                database: database,\n                schema: schema,\n                name: typeormMetadataTable,\n                columns: [\n                    {\n                        name: \"type\",\n                        type: this.connection.driver.normalizeType({\n                            type: this.connection.driver.mappedDataTypes\n                                .metadataType,\n                        }),\n                        isNullable: false,\n                        isPrimary,\n                    },\n                    {\n                        name: \"database\",\n                        type: this.connection.driver.normalizeType({\n                            type: this.connection.driver.mappedDataTypes\n                                .metadataDatabase,\n                        }),\n                        isNullable: true,\n                        isPrimary,\n                    },\n                    {\n                        name: \"schema\",\n                        type: this.connection.driver.normalizeType({\n                            type: this.connection.driver.mappedDataTypes\n                                .metadataSchema,\n                        }),\n                        isNullable: true,\n                        isPrimary,\n                    },\n                    {\n                        name: \"table\",\n                        type: this.connection.driver.normalizeType({\n                            type: this.connection.driver.mappedDataTypes\n                                .metadataTable,\n                        }),\n                        isNullable: true,\n                        isPrimary,\n                    },\n                    {\n                        name: \"name\",\n                        type: this.connection.driver.normalizeType({\n                            type: this.connection.driver.mappedDataTypes\n                                .metadataName,\n                        }),\n                        isNullable: true,\n                        isPrimary,\n                    },\n                    {\n                        name: \"value\",\n                        type: this.connection.driver.normalizeType({\n                            type: this.connection.driver.mappedDataTypes\n                                .metadataValue,\n                        }),\n                        isNullable: true,\n                        isPrimary,\n                    },\n                ],\n            }),\n            true,\n        )\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}