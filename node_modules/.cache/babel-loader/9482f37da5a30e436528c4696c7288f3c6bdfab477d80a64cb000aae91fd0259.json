{"ast":null,"code":"import { getMetadataArgsStorage } from \"../../globals\";\nimport { ColumnTypeUndefinedError } from \"../../error/ColumnTypeUndefinedError\";\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(typeOrOptions, options) {\n  return function (object, propertyName) {\n    // normalize parameters\n    let type;\n    if (typeof typeOrOptions === \"string\" || typeof typeOrOptions === \"function\") {\n      type = typeOrOptions;\n    } else if (typeOrOptions) {\n      options = typeOrOptions;\n      type = typeOrOptions.type;\n    }\n    if (!options) options = {};\n    // if type is not given explicitly then try to guess it\n    const reflectMetadataType = Reflect && Reflect.getMetadata ? Reflect.getMetadata(\"design:type\", object, propertyName) : undefined;\n    if (!type && reflectMetadataType)\n      // if type is not given explicitly then try to guess it\n      type = reflectMetadataType;\n    // check if there is no type in column options then set type from first function argument, or guessed one\n    if (!options.type && type) options.type = type;\n    // specify HSTORE type if column is HSTORE\n    if (options.type === \"hstore\" && !options.hstoreType) options.hstoreType = reflectMetadataType === Object ? \"object\" : \"string\";\n    if (typeof typeOrOptions === \"function\") {\n      // register an embedded\n      getMetadataArgsStorage().embeddeds.push({\n        target: object.constructor,\n        propertyName: propertyName,\n        isArray: reflectMetadataType === Array || options.array === true,\n        prefix: options.prefix !== undefined ? options.prefix : undefined,\n        type: typeOrOptions\n      });\n    } else {\n      // register a regular column\n      // if we still don't have a type then we need to give error to user that type is required\n      if (!options.type) throw new ColumnTypeUndefinedError(object, propertyName);\n      // create unique\n      if (options.unique === true) getMetadataArgsStorage().uniques.push({\n        target: object.constructor,\n        columns: [propertyName]\n      });\n      getMetadataArgsStorage().columns.push({\n        target: object.constructor,\n        propertyName: propertyName,\n        mode: \"regular\",\n        options: options\n      });\n      if (options.generated) {\n        getMetadataArgsStorage().generations.push({\n          target: object.constructor,\n          propertyName: propertyName,\n          strategy: typeof options.generated === \"string\" ? options.generated : \"increment\"\n        });\n      }\n    }\n  };\n}","map":{"version":3,"names":["getMetadataArgsStorage","ColumnTypeUndefinedError","Column","typeOrOptions","options","object","propertyName","type","reflectMetadataType","Reflect","getMetadata","undefined","hstoreType","Object","embeddeds","push","target","constructor","isArray","Array","array","prefix","unique","uniques","columns","mode","generated","generations","strategy"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\decorator\\columns\\Column.ts"],"sourcesContent":["import { getMetadataArgsStorage } from \"../../globals\"\nimport {\n    ColumnType,\n    SimpleColumnType,\n    SpatialColumnType,\n    WithLengthColumnType,\n    WithPrecisionColumnType,\n    WithWidthColumnType,\n} from \"../../driver/types/ColumnTypes\"\nimport { ColumnMetadataArgs } from \"../../metadata-args/ColumnMetadataArgs\"\nimport { ColumnCommonOptions } from \"../options/ColumnCommonOptions\"\nimport { SpatialColumnOptions } from \"../options/SpatialColumnOptions\"\nimport { ColumnWithLengthOptions } from \"../options/ColumnWithLengthOptions\"\nimport { ColumnNumericOptions } from \"../options/ColumnNumericOptions\"\nimport { ColumnEnumOptions } from \"../options/ColumnEnumOptions\"\nimport { ColumnEmbeddedOptions } from \"../options/ColumnEmbeddedOptions\"\nimport { EmbeddedMetadataArgs } from \"../../metadata-args/EmbeddedMetadataArgs\"\nimport { ColumnTypeUndefinedError } from \"../../error/ColumnTypeUndefinedError\"\nimport { ColumnHstoreOptions } from \"../options/ColumnHstoreOptions\"\nimport { ColumnWithWidthOptions } from \"../options/ColumnWithWidthOptions\"\nimport { GeneratedMetadataArgs } from \"../../metadata-args/GeneratedMetadataArgs\"\nimport { ColumnOptions } from \"../options/ColumnOptions\"\n\n/**\n * Column decorator is used to mark a specific class property as a table column. Only properties decorated with this\n * decorator will be persisted to the database when entity be saved.\n */\nexport function Column(): PropertyDecorator\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(options: ColumnOptions): PropertyDecorator\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(\n    type: SimpleColumnType,\n    options?: ColumnCommonOptions,\n): PropertyDecorator\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(\n    type: SpatialColumnType,\n    options?: ColumnCommonOptions & SpatialColumnOptions,\n): PropertyDecorator\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(\n    type: WithLengthColumnType,\n    options?: ColumnCommonOptions & ColumnWithLengthOptions,\n): PropertyDecorator\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(\n    type: WithWidthColumnType,\n    options?: ColumnCommonOptions & ColumnWithWidthOptions,\n): PropertyDecorator\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(\n    type: WithPrecisionColumnType,\n    options?: ColumnCommonOptions & ColumnNumericOptions,\n): PropertyDecorator\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(\n    type: \"enum\",\n    options?: ColumnCommonOptions & ColumnEnumOptions,\n): PropertyDecorator\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(\n    type: \"simple-enum\",\n    options?: ColumnCommonOptions & ColumnEnumOptions,\n): PropertyDecorator\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(\n    type: \"set\",\n    options?: ColumnCommonOptions & ColumnEnumOptions,\n): PropertyDecorator\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(\n    type: \"hstore\",\n    options?: ColumnCommonOptions & ColumnHstoreOptions,\n): PropertyDecorator\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n *\n * Property in entity can be marked as Embedded, and on persist all columns from the embedded are mapped to the\n * single table of the entity where Embedded is used. And on hydration all columns which supposed to be in the\n * embedded will be mapped to it from the single table.\n */\nexport function Column(\n    type: (type?: any) => Function,\n    options?: ColumnEmbeddedOptions,\n): PropertyDecorator\n\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(\n    typeOrOptions?:\n        | ((type?: any) => Function)\n        | ColumnType\n        | (ColumnOptions & ColumnEmbeddedOptions),\n    options?: ColumnOptions & ColumnEmbeddedOptions,\n): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        // normalize parameters\n        let type: ColumnType | undefined\n        if (\n            typeof typeOrOptions === \"string\" ||\n            typeof typeOrOptions === \"function\"\n        ) {\n            type = <ColumnType>typeOrOptions\n        } else if (typeOrOptions) {\n            options = <ColumnOptions>typeOrOptions\n            type = typeOrOptions.type\n        }\n        if (!options) options = {} as ColumnOptions\n\n        // if type is not given explicitly then try to guess it\n        const reflectMetadataType =\n            Reflect && (Reflect as any).getMetadata\n                ? (Reflect as any).getMetadata(\n                      \"design:type\",\n                      object,\n                      propertyName,\n                  )\n                : undefined\n        if (!type && reflectMetadataType)\n            // if type is not given explicitly then try to guess it\n            type = reflectMetadataType\n\n        // check if there is no type in column options then set type from first function argument, or guessed one\n        if (!options.type && type) options.type = type\n\n        // specify HSTORE type if column is HSTORE\n        if (options.type === \"hstore\" && !options.hstoreType)\n            options.hstoreType =\n                reflectMetadataType === Object ? \"object\" : \"string\"\n\n        if (typeof typeOrOptions === \"function\") {\n            // register an embedded\n            getMetadataArgsStorage().embeddeds.push({\n                target: object.constructor,\n                propertyName: propertyName,\n                isArray:\n                    reflectMetadataType === Array || options.array === true,\n                prefix:\n                    options.prefix !== undefined ? options.prefix : undefined,\n                type: typeOrOptions as (type?: any) => Function,\n            } as EmbeddedMetadataArgs)\n        } else {\n            // register a regular column\n\n            // if we still don't have a type then we need to give error to user that type is required\n            if (!options.type)\n                throw new ColumnTypeUndefinedError(object, propertyName)\n\n            // create unique\n            if (options.unique === true)\n                getMetadataArgsStorage().uniques.push({\n                    target: object.constructor,\n                    columns: [propertyName],\n                })\n\n            getMetadataArgsStorage().columns.push({\n                target: object.constructor,\n                propertyName: propertyName,\n                mode: \"regular\",\n                options: options,\n            } as ColumnMetadataArgs)\n\n            if (options.generated) {\n                getMetadataArgsStorage().generations.push({\n                    target: object.constructor,\n                    propertyName: propertyName,\n                    strategy:\n                        typeof options.generated === \"string\"\n                            ? options.generated\n                            : \"increment\",\n                } as GeneratedMetadataArgs)\n            }\n        }\n    }\n}\n"],"mappings":"AAAA,SAASA,sBAAsB,QAAQ,eAAe;AAiBtD,SAASC,wBAAwB,QAAQ,sCAAsC;AAgH/E;;;;AAIA,OAAM,SAAUC,MAAMA,CAClBC,aAG6C,EAC7CC,OAA+C;EAE/C,OAAO,UAAUC,MAAc,EAAEC,YAAoB;IACjD;IACA,IAAIC,IAA4B;IAChC,IACI,OAAOJ,aAAa,KAAK,QAAQ,IACjC,OAAOA,aAAa,KAAK,UAAU,EACrC;MACEI,IAAI,GAAeJ,aAAa;IACpC,CAAC,MAAM,IAAIA,aAAa,EAAE;MACtBC,OAAO,GAAkBD,aAAa;MACtCI,IAAI,GAAGJ,aAAa,CAACI,IAAI;IAC7B;IACA,IAAI,CAACH,OAAO,EAAEA,OAAO,GAAG,EAAmB;IAE3C;IACA,MAAMI,mBAAmB,GACrBC,OAAO,IAAKA,OAAe,CAACC,WAAW,GAChCD,OAAe,CAACC,WAAW,CACxB,aAAa,EACbL,MAAM,EACNC,YAAY,CACf,GACDK,SAAS;IACnB,IAAI,CAACJ,IAAI,IAAIC,mBAAmB;MAC5B;MACAD,IAAI,GAAGC,mBAAmB;IAE9B;IACA,IAAI,CAACJ,OAAO,CAACG,IAAI,IAAIA,IAAI,EAAEH,OAAO,CAACG,IAAI,GAAGA,IAAI;IAE9C;IACA,IAAIH,OAAO,CAACG,IAAI,KAAK,QAAQ,IAAI,CAACH,OAAO,CAACQ,UAAU,EAChDR,OAAO,CAACQ,UAAU,GACdJ,mBAAmB,KAAKK,MAAM,GAAG,QAAQ,GAAG,QAAQ;IAE5D,IAAI,OAAOV,aAAa,KAAK,UAAU,EAAE;MACrC;MACAH,sBAAsB,EAAE,CAACc,SAAS,CAACC,IAAI,CAAC;QACpCC,MAAM,EAAEX,MAAM,CAACY,WAAW;QAC1BX,YAAY,EAAEA,YAAY;QAC1BY,OAAO,EACHV,mBAAmB,KAAKW,KAAK,IAAIf,OAAO,CAACgB,KAAK,KAAK,IAAI;QAC3DC,MAAM,EACFjB,OAAO,CAACiB,MAAM,KAAKV,SAAS,GAAGP,OAAO,CAACiB,MAAM,GAAGV,SAAS;QAC7DJ,IAAI,EAAEJ;OACe,CAAC;IAC9B,CAAC,MAAM;MACH;MAEA;MACA,IAAI,CAACC,OAAO,CAACG,IAAI,EACb,MAAM,IAAIN,wBAAwB,CAACI,MAAM,EAAEC,YAAY,CAAC;MAE5D;MACA,IAAIF,OAAO,CAACkB,MAAM,KAAK,IAAI,EACvBtB,sBAAsB,EAAE,CAACuB,OAAO,CAACR,IAAI,CAAC;QAClCC,MAAM,EAAEX,MAAM,CAACY,WAAW;QAC1BO,OAAO,EAAE,CAAClB,YAAY;OACzB,CAAC;MAENN,sBAAsB,EAAE,CAACwB,OAAO,CAACT,IAAI,CAAC;QAClCC,MAAM,EAAEX,MAAM,CAACY,WAAW;QAC1BX,YAAY,EAAEA,YAAY;QAC1BmB,IAAI,EAAE,SAAS;QACfrB,OAAO,EAAEA;OACU,CAAC;MAExB,IAAIA,OAAO,CAACsB,SAAS,EAAE;QACnB1B,sBAAsB,EAAE,CAAC2B,WAAW,CAACZ,IAAI,CAAC;UACtCC,MAAM,EAAEX,MAAM,CAACY,WAAW;UAC1BX,YAAY,EAAEA,YAAY;UAC1BsB,QAAQ,EACJ,OAAOxB,OAAO,CAACsB,SAAS,KAAK,QAAQ,GAC/BtB,OAAO,CAACsB,SAAS,GACjB;SACY,CAAC;MAC/B;IACJ;EACJ,CAAC;AACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}