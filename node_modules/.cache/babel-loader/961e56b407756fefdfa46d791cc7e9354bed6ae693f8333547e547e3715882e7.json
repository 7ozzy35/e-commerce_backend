{"ast":null,"code":"import { ObjectUtils } from \"../../util/ObjectUtils\";\n/**\n * Transforms plain old javascript object\n * Entity is constructed based on its entity metadata.\n */\nexport class PlainObjectToNewEntityTransformer {\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  transform(newEntity, object, metadata, getLazyRelationsPromiseValue = false) {\n    // console.log(\"groupAndTransform entity:\", newEntity);\n    // console.log(\"groupAndTransform object:\", object);\n    this.groupAndTransform(newEntity, object, metadata, getLazyRelationsPromiseValue);\n    // console.log(\"result:\", newEntity);\n    return newEntity;\n  }\n  // -------------------------------------------------------------------------\n  // Private Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated\n   * we need to group our result and we must have some unique id (primary key in our case)\n   */\n  groupAndTransform(entity, object, metadata, getLazyRelationsPromiseValue = false) {\n    // console.log(\"groupAndTransform entity:\", entity);\n    // console.log(\"groupAndTransform object:\", object);\n    // copy regular column properties from the given object\n    metadata.nonVirtualColumns.forEach(column => {\n      const objectColumnValue = column.getEntityValue(object);\n      if (objectColumnValue !== undefined) column.setEntityValue(entity, objectColumnValue);\n    });\n    // // copy relation properties from the given object\n    if (metadata.relations.length) {\n      metadata.relations.forEach(relation => {\n        let entityRelatedValue = relation.getEntityValue(entity);\n        const objectRelatedValue = relation.getEntityValue(object, getLazyRelationsPromiseValue);\n        if (objectRelatedValue === undefined) return;\n        if (relation.isOneToMany || relation.isManyToMany) {\n          if (!Array.isArray(objectRelatedValue)) return;\n          if (!entityRelatedValue) {\n            entityRelatedValue = [];\n            relation.setEntityValue(entity, entityRelatedValue);\n          }\n          objectRelatedValue.forEach(objectRelatedValueItem => {\n            // check if we have this item from the merging object in the original entity we merge into\n            let objectRelatedValueEntity = entityRelatedValue.find(entityRelatedValueItem => {\n              return relation.inverseEntityMetadata.compareEntities(objectRelatedValueItem, entityRelatedValueItem);\n            });\n            const inverseEntityMetadata = relation.inverseEntityMetadata.findInheritanceMetadata(objectRelatedValueItem);\n            // if such item already exist then merge new data into it, if its not we create a new entity and merge it into the array\n            if (!objectRelatedValueEntity) {\n              objectRelatedValueEntity = inverseEntityMetadata.create(undefined, {\n                fromDeserializer: true\n              });\n              entityRelatedValue.push(objectRelatedValueEntity);\n            }\n            this.groupAndTransform(objectRelatedValueEntity, objectRelatedValueItem, inverseEntityMetadata, getLazyRelationsPromiseValue);\n          });\n        } else {\n          // if related object isn't an object (direct relation id for example)\n          // we just set it to the entity relation, we don't need anything more from it\n          // however we do it only if original entity does not have this relation set to object\n          // to prevent full overriding of objects\n          if (!ObjectUtils.isObject(objectRelatedValue)) {\n            if (!ObjectUtils.isObject(entityRelatedValue)) relation.setEntityValue(entity, objectRelatedValue);\n            return;\n          }\n          const inverseEntityMetadata = relation.inverseEntityMetadata.findInheritanceMetadata(objectRelatedValue);\n          if (!entityRelatedValue) {\n            entityRelatedValue = inverseEntityMetadata.create(undefined, {\n              fromDeserializer: true\n            });\n            relation.setEntityValue(entity, entityRelatedValue);\n          }\n          this.groupAndTransform(entityRelatedValue, objectRelatedValue, inverseEntityMetadata, getLazyRelationsPromiseValue);\n        }\n      });\n    }\n  }\n}","map":{"version":3,"names":["ObjectUtils","PlainObjectToNewEntityTransformer","transform","newEntity","object","metadata","getLazyRelationsPromiseValue","groupAndTransform","entity","nonVirtualColumns","forEach","column","objectColumnValue","getEntityValue","undefined","setEntityValue","relations","length","relation","entityRelatedValue","objectRelatedValue","isOneToMany","isManyToMany","Array","isArray","objectRelatedValueItem","objectRelatedValueEntity","find","entityRelatedValueItem","inverseEntityMetadata","compareEntities","findInheritanceMetadata","create","fromDeserializer","push","isObject"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\query-builder\\transformer\\PlainObjectToNewEntityTransformer.ts"],"sourcesContent":["import { EntityMetadata } from \"../../metadata/EntityMetadata\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { ObjectUtils } from \"../../util/ObjectUtils\"\n\n/**\n * Transforms plain old javascript object\n * Entity is constructed based on its entity metadata.\n */\nexport class PlainObjectToNewEntityTransformer {\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    transform<T extends ObjectLiteral>(\n        newEntity: T,\n        object: ObjectLiteral,\n        metadata: EntityMetadata,\n        getLazyRelationsPromiseValue: boolean = false,\n    ): T {\n        // console.log(\"groupAndTransform entity:\", newEntity);\n        // console.log(\"groupAndTransform object:\", object);\n        this.groupAndTransform(\n            newEntity,\n            object,\n            metadata,\n            getLazyRelationsPromiseValue,\n        )\n        // console.log(\"result:\", newEntity);\n        return newEntity\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated\n     * we need to group our result and we must have some unique id (primary key in our case)\n     */\n    private groupAndTransform(\n        entity: ObjectLiteral,\n        object: ObjectLiteral,\n        metadata: EntityMetadata,\n        getLazyRelationsPromiseValue: boolean = false,\n    ): void {\n        // console.log(\"groupAndTransform entity:\", entity);\n        // console.log(\"groupAndTransform object:\", object);\n\n        // copy regular column properties from the given object\n        metadata.nonVirtualColumns.forEach((column) => {\n            const objectColumnValue = column.getEntityValue(object)\n            if (objectColumnValue !== undefined)\n                column.setEntityValue(entity, objectColumnValue)\n        })\n\n        // // copy relation properties from the given object\n        if (metadata.relations.length) {\n            metadata.relations.forEach((relation) => {\n                let entityRelatedValue = relation.getEntityValue(entity)\n                const objectRelatedValue = relation.getEntityValue(\n                    object,\n                    getLazyRelationsPromiseValue,\n                )\n                if (objectRelatedValue === undefined) return\n\n                if (relation.isOneToMany || relation.isManyToMany) {\n                    if (!Array.isArray(objectRelatedValue)) return\n\n                    if (!entityRelatedValue) {\n                        entityRelatedValue = []\n                        relation.setEntityValue(entity, entityRelatedValue)\n                    }\n\n                    objectRelatedValue.forEach((objectRelatedValueItem) => {\n                        // check if we have this item from the merging object in the original entity we merge into\n                        let objectRelatedValueEntity = (\n                            entityRelatedValue as any[]\n                        ).find((entityRelatedValueItem) => {\n                            return relation.inverseEntityMetadata.compareEntities(\n                                objectRelatedValueItem,\n                                entityRelatedValueItem,\n                            )\n                        })\n\n                        const inverseEntityMetadata =\n                            relation.inverseEntityMetadata.findInheritanceMetadata(\n                                objectRelatedValueItem,\n                            )\n\n                        // if such item already exist then merge new data into it, if its not we create a new entity and merge it into the array\n                        if (!objectRelatedValueEntity) {\n                            objectRelatedValueEntity =\n                                inverseEntityMetadata.create(undefined, {\n                                    fromDeserializer: true,\n                                })\n                            entityRelatedValue.push(objectRelatedValueEntity)\n                        }\n\n                        this.groupAndTransform(\n                            objectRelatedValueEntity,\n                            objectRelatedValueItem,\n                            inverseEntityMetadata,\n                            getLazyRelationsPromiseValue,\n                        )\n                    })\n                } else {\n                    // if related object isn't an object (direct relation id for example)\n                    // we just set it to the entity relation, we don't need anything more from it\n                    // however we do it only if original entity does not have this relation set to object\n                    // to prevent full overriding of objects\n                    if (!ObjectUtils.isObject(objectRelatedValue)) {\n                        if (!ObjectUtils.isObject(entityRelatedValue))\n                            relation.setEntityValue(entity, objectRelatedValue)\n                        return\n                    }\n\n                    const inverseEntityMetadata =\n                        relation.inverseEntityMetadata.findInheritanceMetadata(\n                            objectRelatedValue,\n                        )\n\n                    if (!entityRelatedValue) {\n                        entityRelatedValue = inverseEntityMetadata.create(\n                            undefined,\n                            {\n                                fromDeserializer: true,\n                            },\n                        )\n                        relation.setEntityValue(entity, entityRelatedValue)\n                    }\n\n                    this.groupAndTransform(\n                        entityRelatedValue,\n                        objectRelatedValue,\n                        inverseEntityMetadata,\n                        getLazyRelationsPromiseValue,\n                    )\n                }\n            })\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}