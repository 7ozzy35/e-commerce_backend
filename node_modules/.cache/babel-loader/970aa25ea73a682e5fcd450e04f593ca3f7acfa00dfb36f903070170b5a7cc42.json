{"ast":null,"code":"import { TypeORMError } from \"../error\";\n/**\n * Orders insert or remove subjects in proper order (using topological sorting)\n * to make sure insert or remove operations are executed in a proper order.\n */\nexport class SubjectTopoligicalSorter {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(subjects) {\n    this.subjects = [...subjects]; // copy subjects to prevent changing of sent array\n    this.metadatas = this.getUniqueMetadatas(this.subjects);\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Sorts (orders) subjects in their topological order.\n   */\n  sort(direction) {\n    // if there are no metadatas it probably mean there is no subjects... we don't have to do anything here\n    if (!this.metadatas.length) return this.subjects;\n    const sortedSubjects = [];\n    // first if we sort for deletion all junction subjects\n    // junction subjects are subjects without entity and database entity set\n    if (direction === \"delete\") {\n      const junctionSubjects = this.subjects.filter(subject => !subject.entity && !subject.databaseEntity);\n      sortedSubjects.push(...junctionSubjects);\n      this.removeAlreadySorted(junctionSubjects);\n    }\n    // next we always insert entities with non-nullable relations, sort them first\n    const nonNullableDependencies = this.getNonNullableDependencies();\n    let sortedNonNullableEntityTargets = this.toposort(nonNullableDependencies);\n    if (direction === \"insert\") sortedNonNullableEntityTargets = sortedNonNullableEntityTargets.reverse();\n    // so we have a sorted entity targets\n    // go thought each of them and find all subjects with sorted entity target\n    // add those sorted targets and remove them from original array of targets\n    sortedNonNullableEntityTargets.forEach(sortedEntityTarget => {\n      const entityTargetSubjects = this.subjects.filter(subject => subject.metadata.targetName === sortedEntityTarget || subject.metadata.inheritanceTree.some(s => s.name === sortedEntityTarget));\n      sortedSubjects.push(...entityTargetSubjects);\n      this.removeAlreadySorted(entityTargetSubjects);\n    });\n    // next sort all other entities\n    // same process as in above but with other entities\n    const otherDependencies = this.getDependencies();\n    let sortedOtherEntityTargets = this.toposort(otherDependencies);\n    if (direction === \"insert\") sortedOtherEntityTargets = sortedOtherEntityTargets.reverse();\n    sortedOtherEntityTargets.forEach(sortedEntityTarget => {\n      const entityTargetSubjects = this.subjects.filter(subject => subject.metadata.targetName === sortedEntityTarget);\n      sortedSubjects.push(...entityTargetSubjects);\n      this.removeAlreadySorted(entityTargetSubjects);\n    });\n    // if we have something left in the subjects add them as well\n    sortedSubjects.push(...this.subjects);\n    return sortedSubjects;\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Removes already sorted subjects from this.subjects list of subjects.\n   */\n  removeAlreadySorted(subjects) {\n    subjects.forEach(subject => {\n      this.subjects.splice(this.subjects.indexOf(subject), 1);\n    });\n  }\n  /**\n   * Extracts all unique metadatas from the given subjects.\n   */\n  getUniqueMetadatas(subjects) {\n    const metadatas = [];\n    subjects.forEach(subject => {\n      if (metadatas.indexOf(subject.metadata) === -1) metadatas.push(subject.metadata);\n    });\n    return metadatas;\n  }\n  /**\n   * Gets dependency tree for all entity metadatas with non-nullable relations.\n   * We need to execute insertions first for entities which non-nullable relations.\n   */\n  getNonNullableDependencies() {\n    return this.metadatas.reduce((dependencies, metadata) => {\n      metadata.relationsWithJoinColumns.forEach(relation => {\n        if (relation.isNullable) return;\n        dependencies.push([metadata.targetName, relation.inverseEntityMetadata.targetName]);\n      });\n      return dependencies;\n    }, []);\n  }\n  /**\n   * Gets dependency tree for all entity metadatas with non-nullable relations.\n   * We need to execute insertions first for entities which non-nullable relations.\n   */\n  getDependencies() {\n    return this.metadatas.reduce((dependencies, metadata) => {\n      metadata.relationsWithJoinColumns.forEach(relation => {\n        // if relation is self-referenced we skip it\n        if (relation.inverseEntityMetadata === metadata) return;\n        dependencies.push([metadata.targetName, relation.inverseEntityMetadata.targetName]);\n      });\n      return dependencies;\n    }, []);\n  }\n  /**\n   * Sorts given graph using topological sorting algorithm.\n   *\n   * Algorithm is kindly taken from https://github.com/marcelklehr/toposort repository.\n   */\n  toposort(edges) {\n    function uniqueNodes(arr) {\n      let res = [];\n      for (let i = 0, len = arr.length; i < len; i++) {\n        let edge = arr[i];\n        if (res.indexOf(edge[0]) < 0) res.push(edge[0]);\n        if (res.indexOf(edge[1]) < 0) res.push(edge[1]);\n      }\n      return res;\n    }\n    const nodes = uniqueNodes(edges);\n    let cursor = nodes.length,\n      sorted = new Array(cursor),\n      visited = {},\n      i = cursor;\n    while (i--) {\n      if (!visited[i]) visit(nodes[i], i, []);\n    }\n    function visit(node, i, predecessors) {\n      if (predecessors.indexOf(node) >= 0) {\n        throw new TypeORMError(\"Cyclic dependency: \" + JSON.stringify(node)); // todo: better error\n      }\n      if (!~nodes.indexOf(node)) {\n        throw new TypeORMError(\"Found unknown node. Make sure to provided all involved nodes. Unknown node: \" + JSON.stringify(node));\n      }\n      if (visited[i]) return;\n      visited[i] = true;\n      // outgoing edges\n      let outgoing = edges.filter(function (edge) {\n        return edge[0] === node;\n      });\n      if (i = outgoing.length) {\n        let preds = predecessors.concat(node);\n        do {\n          let child = outgoing[--i][1];\n          visit(child, nodes.indexOf(child), preds);\n        } while (i);\n      }\n      sorted[--cursor] = node;\n    }\n    return sorted;\n  }\n}","map":{"version":3,"names":["TypeORMError","SubjectTopoligicalSorter","constructor","subjects","metadatas","getUniqueMetadatas","sort","direction","length","sortedSubjects","junctionSubjects","filter","subject","entity","databaseEntity","push","removeAlreadySorted","nonNullableDependencies","getNonNullableDependencies","sortedNonNullableEntityTargets","toposort","reverse","forEach","sortedEntityTarget","entityTargetSubjects","metadata","targetName","inheritanceTree","some","s","name","otherDependencies","getDependencies","sortedOtherEntityTargets","splice","indexOf","reduce","dependencies","relationsWithJoinColumns","relation","isNullable","inverseEntityMetadata","edges","uniqueNodes","arr","res","i","len","edge","nodes","cursor","sorted","Array","visited","visit","node","predecessors","JSON","stringify","outgoing","preds","concat","child"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\persistence\\SubjectTopoligicalSorter.ts"],"sourcesContent":["import { Subject } from \"./Subject\"\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { TypeORMError } from \"../error\"\n\n/**\n * Orders insert or remove subjects in proper order (using topological sorting)\n * to make sure insert or remove operations are executed in a proper order.\n */\nexport class SubjectTopoligicalSorter {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Insert subjects needs to be sorted.\n     */\n    subjects: Subject[]\n\n    /**\n     * Unique list of entity metadatas of this subject.\n     */\n    metadatas: EntityMetadata[]\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(subjects: Subject[]) {\n        this.subjects = [...subjects] // copy subjects to prevent changing of sent array\n        this.metadatas = this.getUniqueMetadatas(this.subjects)\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Sorts (orders) subjects in their topological order.\n     */\n    sort(direction: \"insert\" | \"delete\"): Subject[] {\n        // if there are no metadatas it probably mean there is no subjects... we don't have to do anything here\n        if (!this.metadatas.length) return this.subjects\n\n        const sortedSubjects: Subject[] = []\n\n        // first if we sort for deletion all junction subjects\n        // junction subjects are subjects without entity and database entity set\n        if (direction === \"delete\") {\n            const junctionSubjects = this.subjects.filter(\n                (subject) => !subject.entity && !subject.databaseEntity,\n            )\n            sortedSubjects.push(...junctionSubjects)\n            this.removeAlreadySorted(junctionSubjects)\n        }\n\n        // next we always insert entities with non-nullable relations, sort them first\n        const nonNullableDependencies = this.getNonNullableDependencies()\n        let sortedNonNullableEntityTargets = this.toposort(\n            nonNullableDependencies,\n        )\n        if (direction === \"insert\")\n            sortedNonNullableEntityTargets =\n                sortedNonNullableEntityTargets.reverse()\n\n        // so we have a sorted entity targets\n        // go thought each of them and find all subjects with sorted entity target\n        // add those sorted targets and remove them from original array of targets\n        sortedNonNullableEntityTargets.forEach((sortedEntityTarget) => {\n            const entityTargetSubjects = this.subjects.filter(\n                (subject) =>\n                    subject.metadata.targetName === sortedEntityTarget ||\n                    subject.metadata.inheritanceTree.some(\n                        (s) => s.name === sortedEntityTarget,\n                    ),\n            )\n            sortedSubjects.push(...entityTargetSubjects)\n            this.removeAlreadySorted(entityTargetSubjects)\n        })\n\n        // next sort all other entities\n        // same process as in above but with other entities\n        const otherDependencies: string[][] = this.getDependencies()\n        let sortedOtherEntityTargets = this.toposort(otherDependencies)\n        if (direction === \"insert\")\n            sortedOtherEntityTargets = sortedOtherEntityTargets.reverse()\n\n        sortedOtherEntityTargets.forEach((sortedEntityTarget) => {\n            const entityTargetSubjects = this.subjects.filter(\n                (subject) => subject.metadata.targetName === sortedEntityTarget,\n            )\n            sortedSubjects.push(...entityTargetSubjects)\n            this.removeAlreadySorted(entityTargetSubjects)\n        })\n\n        // if we have something left in the subjects add them as well\n        sortedSubjects.push(...this.subjects)\n        return sortedSubjects\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Removes already sorted subjects from this.subjects list of subjects.\n     */\n    protected removeAlreadySorted(subjects: Subject[]) {\n        subjects.forEach((subject) => {\n            this.subjects.splice(this.subjects.indexOf(subject), 1)\n        })\n    }\n\n    /**\n     * Extracts all unique metadatas from the given subjects.\n     */\n    protected getUniqueMetadatas(subjects: Subject[]) {\n        const metadatas: EntityMetadata[] = []\n        subjects.forEach((subject) => {\n            if (metadatas.indexOf(subject.metadata) === -1)\n                metadatas.push(subject.metadata)\n        })\n        return metadatas\n    }\n\n    /**\n     * Gets dependency tree for all entity metadatas with non-nullable relations.\n     * We need to execute insertions first for entities which non-nullable relations.\n     */\n    protected getNonNullableDependencies(): string[][] {\n        return this.metadatas.reduce((dependencies, metadata) => {\n            metadata.relationsWithJoinColumns.forEach((relation) => {\n                if (relation.isNullable) return\n\n                dependencies.push([\n                    metadata.targetName,\n                    relation.inverseEntityMetadata.targetName,\n                ])\n            })\n            return dependencies\n        }, [] as string[][])\n    }\n\n    /**\n     * Gets dependency tree for all entity metadatas with non-nullable relations.\n     * We need to execute insertions first for entities which non-nullable relations.\n     */\n    protected getDependencies(): string[][] {\n        return this.metadatas.reduce((dependencies, metadata) => {\n            metadata.relationsWithJoinColumns.forEach((relation) => {\n                // if relation is self-referenced we skip it\n                if (relation.inverseEntityMetadata === metadata) return\n\n                dependencies.push([\n                    metadata.targetName,\n                    relation.inverseEntityMetadata.targetName,\n                ])\n            })\n            return dependencies\n        }, [] as string[][])\n    }\n\n    /**\n     * Sorts given graph using topological sorting algorithm.\n     *\n     * Algorithm is kindly taken from https://github.com/marcelklehr/toposort repository.\n     */\n    protected toposort(edges: any[][]) {\n        function uniqueNodes(arr: any[]) {\n            let res = []\n            for (let i = 0, len = arr.length; i < len; i++) {\n                let edge: any = arr[i]\n                if (res.indexOf(edge[0]) < 0) res.push(edge[0])\n                if (res.indexOf(edge[1]) < 0) res.push(edge[1])\n            }\n            return res\n        }\n\n        const nodes = uniqueNodes(edges)\n        let cursor = nodes.length,\n            sorted = new Array(cursor),\n            visited: any = {},\n            i = cursor\n\n        while (i--) {\n            if (!visited[i]) visit(nodes[i], i, [])\n        }\n\n        function visit(node: any, i: number, predecessors: any[]) {\n            if (predecessors.indexOf(node) >= 0) {\n                throw new TypeORMError(\n                    \"Cyclic dependency: \" + JSON.stringify(node),\n                ) // todo: better error\n            }\n\n            if (!~nodes.indexOf(node)) {\n                throw new TypeORMError(\n                    \"Found unknown node. Make sure to provided all involved nodes. Unknown node: \" +\n                        JSON.stringify(node),\n                )\n            }\n\n            if (visited[i]) return\n            visited[i] = true\n\n            // outgoing edges\n            let outgoing = edges.filter(function (edge) {\n                return edge[0] === node\n            })\n            if ((i = outgoing.length)) {\n                let preds = predecessors.concat(node)\n                do {\n                    let child = outgoing[--i][1]\n                    visit(child, nodes.indexOf(child), preds)\n                } while (i)\n            }\n\n            sorted[--cursor] = node\n        }\n\n        return sorted\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}