{"ast":null,"code":"import { Query } from \"../driver/Query\";\nimport { SqlInMemory } from \"../driver/SqlInMemory\";\nimport { TypeORMError } from \"../error/TypeORMError\";\nimport { OrmUtils } from \"../util/OrmUtils\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\nexport class BaseQueryRunner {\n  constructor() {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n    /**\n     * Indicates if connection for this query runner is released.\n     * Once its released, query runner cannot run queries anymore.\n     */\n    this.isReleased = false;\n    /**\n     * Indicates if transaction is in progress.\n     */\n    this.isTransactionActive = false;\n    /**\n     * Stores temporarily user data.\n     * Useful for sharing data with subscribers.\n     */\n    this.data = {};\n    /**\n     * All synchronized tables in the database.\n     */\n    this.loadedTables = [];\n    /**\n     * All synchronized views in the database.\n     */\n    this.loadedViews = [];\n    /**\n     * Indicates if special query runner mode in which sql queries won't be executed is enabled.\n     */\n    this.sqlMemoryMode = false;\n    /**\n     * Sql-s stored if \"sql in memory\" mode is enabled.\n     */\n    this.sqlInMemory = new SqlInMemory();\n    /**\n     * current depth of transaction.\n     * for transactionDepth > 0 will use SAVEPOINT to start and commit/rollback transaction blocks\n     */\n    this.transactionDepth = 0;\n    this.cachedTablePaths = {};\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Called before migrations are run.\n   */\n  async beforeMigration() {\n    // Do nothing\n  }\n  /**\n   * Called after migrations are run.\n   */\n  async afterMigration() {\n    // Do nothing\n  }\n  /**\n   * Loads given table's data from the database.\n   */\n  async getTable(tablePath) {\n    this.loadedTables = await this.loadTables([tablePath]);\n    return this.loadedTables.length > 0 ? this.loadedTables[0] : undefined;\n  }\n  /**\n   * Loads all tables (with given names) from the database.\n   */\n  async getTables(tableNames) {\n    if (!tableNames) {\n      // Don't cache in this case.\n      // This is the new case & isn't used anywhere else anyway.\n      return await this.loadTables(tableNames);\n    }\n    this.loadedTables = await this.loadTables(tableNames);\n    return this.loadedTables;\n  }\n  /**\n   * Loads given view's data from the database.\n   */\n  async getView(viewPath) {\n    this.loadedViews = await this.loadViews([viewPath]);\n    return this.loadedViews.length > 0 ? this.loadedViews[0] : undefined;\n  }\n  /**\n   * Loads given view's data from the database.\n   */\n  async getViews(viewPaths) {\n    this.loadedViews = await this.loadViews(viewPaths);\n    return this.loadedViews;\n  }\n  /**\n   * Enables special query runner mode in which sql queries won't be executed,\n   * instead they will be memorized into a special variable inside query runner.\n   * You can get memorized sql using getMemorySql() method.\n   */\n  enableSqlMemory() {\n    this.sqlInMemory = new SqlInMemory();\n    this.sqlMemoryMode = true;\n  }\n  /**\n   * Disables special query runner mode in which sql queries won't be executed\n   * started by calling enableSqlMemory() method.\n   *\n   * Previously memorized sql will be flushed.\n   */\n  disableSqlMemory() {\n    this.sqlInMemory = new SqlInMemory();\n    this.sqlMemoryMode = false;\n  }\n  /**\n   * Flushes all memorized sqls.\n   */\n  clearSqlMemory() {\n    this.sqlInMemory = new SqlInMemory();\n  }\n  /**\n   * Gets sql stored in the memory. Parameters in the sql are already replaced.\n   */\n  getMemorySql() {\n    return this.sqlInMemory;\n  }\n  /**\n   * Executes up sql queries.\n   */\n  async executeMemoryUpSql() {\n    for (const {\n      query,\n      parameters\n    } of this.sqlInMemory.upQueries) {\n      await this.query(query, parameters);\n    }\n  }\n  /**\n   * Executes down sql queries.\n   */\n  async executeMemoryDownSql() {\n    for (const {\n      query,\n      parameters\n    } of this.sqlInMemory.downQueries.reverse()) {\n      await this.query(query, parameters);\n    }\n  }\n  getReplicationMode() {\n    return this.mode;\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Gets view from previously loaded views, otherwise loads it from database.\n   */\n  async getCachedView(viewName) {\n    const view = this.loadedViews.find(view => view.name === viewName);\n    if (view) return view;\n    const foundViews = await this.loadViews([viewName]);\n    if (foundViews.length > 0) {\n      this.loadedViews.push(foundViews[0]);\n      return foundViews[0];\n    } else {\n      throw new TypeORMError(`View \"${viewName}\" does not exist.`);\n    }\n  }\n  /**\n   * Gets table from previously loaded tables, otherwise loads it from database.\n   */\n  async getCachedTable(tableName) {\n    if (tableName in this.cachedTablePaths) {\n      const tablePath = this.cachedTablePaths[tableName];\n      const table = this.loadedTables.find(table => this.getTablePath(table) === tablePath);\n      if (table) {\n        return table;\n      }\n    }\n    const foundTables = await this.loadTables([tableName]);\n    if (foundTables.length > 0) {\n      const foundTablePath = this.getTablePath(foundTables[0]);\n      const cachedTable = this.loadedTables.find(table => this.getTablePath(table) === foundTablePath);\n      if (!cachedTable) {\n        this.cachedTablePaths[tableName] = this.getTablePath(foundTables[0]);\n        this.loadedTables.push(foundTables[0]);\n        return foundTables[0];\n      } else {\n        return cachedTable;\n      }\n    } else {\n      throw new TypeORMError(`Table \"${tableName}\" does not exist.`);\n    }\n  }\n  /**\n   * Replaces loaded table with given changed table.\n   */\n  replaceCachedTable(table, changedTable) {\n    const oldTablePath = this.getTablePath(table);\n    const foundTable = this.loadedTables.find(loadedTable => this.getTablePath(loadedTable) === oldTablePath);\n    // Clean up the lookup cache..\n    for (const [key, cachedPath] of Object.entries(this.cachedTablePaths)) {\n      if (cachedPath === oldTablePath) {\n        this.cachedTablePaths[key] = this.getTablePath(changedTable);\n      }\n    }\n    if (foundTable) {\n      foundTable.database = changedTable.database;\n      foundTable.schema = changedTable.schema;\n      foundTable.name = changedTable.name;\n      foundTable.columns = changedTable.columns;\n      foundTable.indices = changedTable.indices;\n      foundTable.foreignKeys = changedTable.foreignKeys;\n      foundTable.uniques = changedTable.uniques;\n      foundTable.checks = changedTable.checks;\n      foundTable.justCreated = changedTable.justCreated;\n      foundTable.engine = changedTable.engine;\n      foundTable.comment = changedTable.comment;\n    }\n  }\n  getTablePath(target) {\n    const parsed = this.connection.driver.parseTableName(target);\n    return this.connection.driver.buildTableName(parsed.tableName, parsed.schema, parsed.database);\n  }\n  getTypeormMetadataTableName() {\n    const options = this.connection.driver.options;\n    return this.connection.driver.buildTableName(this.connection.metadataTableName, options.schema, options.database);\n  }\n  /**\n   * Generates SQL query to select record from typeorm metadata table.\n   */\n  selectTypeormMetadataSql({\n    database,\n    schema,\n    table,\n    type,\n    name\n  }) {\n    const qb = this.connection.createQueryBuilder();\n    const selectQb = qb.select().from(this.getTypeormMetadataTableName(), \"t\").where(`${qb.escape(\"type\")} = :type`, {\n      type\n    }).andWhere(`${qb.escape(\"name\")} = :name`, {\n      name\n    });\n    if (database) {\n      selectQb.andWhere(`${qb.escape(\"database\")} = :database`, {\n        database\n      });\n    }\n    if (schema) {\n      selectQb.andWhere(`${qb.escape(\"schema\")} = :schema`, {\n        schema\n      });\n    }\n    if (table) {\n      selectQb.andWhere(`${qb.escape(\"table\")} = :table`, {\n        table\n      });\n    }\n    const [query, parameters] = selectQb.getQueryAndParameters();\n    return new Query(query, parameters);\n  }\n  /**\n   * Generates SQL query to insert a record into typeorm metadata table.\n   */\n  insertTypeormMetadataSql({\n    database,\n    schema,\n    table,\n    type,\n    name,\n    value\n  }) {\n    const [query, parameters] = this.connection.createQueryBuilder().insert().into(this.getTypeormMetadataTableName()).values({\n      database: database,\n      schema: schema,\n      table: table,\n      type: type,\n      name: name,\n      value: value\n    }).getQueryAndParameters();\n    return new Query(query, parameters);\n  }\n  /**\n   * Generates SQL query to delete a record from typeorm metadata table.\n   */\n  deleteTypeormMetadataSql({\n    database,\n    schema,\n    table,\n    type,\n    name\n  }) {\n    const qb = this.connection.createQueryBuilder();\n    const deleteQb = qb.delete().from(this.getTypeormMetadataTableName()).where(`${qb.escape(\"type\")} = :type`, {\n      type\n    }).andWhere(`${qb.escape(\"name\")} = :name`, {\n      name\n    });\n    if (database) {\n      deleteQb.andWhere(`${qb.escape(\"database\")} = :database`, {\n        database\n      });\n    }\n    if (schema) {\n      deleteQb.andWhere(`${qb.escape(\"schema\")} = :schema`, {\n        schema\n      });\n    }\n    if (table) {\n      deleteQb.andWhere(`${qb.escape(\"table\")} = :table`, {\n        table\n      });\n    }\n    const [query, parameters] = deleteQb.getQueryAndParameters();\n    return new Query(query, parameters);\n  }\n  /**\n   * Checks if at least one of column properties was changed.\n   * Does not checks column type, length and autoincrement, because these properties changes separately.\n   */\n  isColumnChanged(oldColumn, newColumn, checkDefault, checkComment, checkEnum = true) {\n    // this logs need to debug issues in column change detection. Do not delete it!\n    // console.log(\"charset ---------------\");\n    // console.log(oldColumn.charset !== newColumn.charset);\n    // console.log(oldColumn.charset, newColumn.charset);\n    // console.log(\"collation ---------------\");\n    // console.log(oldColumn.collation !== newColumn.collation);\n    // console.log(oldColumn.collation, newColumn.collation);\n    // console.log(\"precision ---------------\");\n    // console.log(oldColumn.precision !== newColumn.precision);\n    // console.log(oldColumn.precision, newColumn.precision);\n    // console.log(\"scale ---------------\");\n    // console.log(oldColumn.scale !== newColumn.scale);\n    // console.log(oldColumn.scale, newColumn.scale);\n    // console.log(\"default ---------------\");\n    // console.log((checkDefault && oldColumn.default !== newColumn.default));\n    // console.log(oldColumn.default, newColumn.default);\n    // console.log(\"isNullable ---------------\");\n    // console.log(oldColumn.isNullable !== newColumn.isNullable);\n    // console.log(oldColumn.isNullable, newColumn.isNullable);\n    // console.log(\"comment ---------------\");\n    // console.log((checkComment && oldColumn.comment !== newColumn.comment));\n    // console.log(oldColumn.comment, newColumn.comment);\n    // console.log(\"enum ---------------\");\n    // console.log(!OrmUtils.isArraysEqual(oldColumn.enum || [], newColumn.enum || []));\n    // console.log(oldColumn.enum, newColumn.enum);\n    return oldColumn.charset !== newColumn.charset || oldColumn.collation !== newColumn.collation || oldColumn.precision !== newColumn.precision || oldColumn.scale !== newColumn.scale || oldColumn.width !== newColumn.width ||\n    // MySQL only\n    oldColumn.zerofill !== newColumn.zerofill ||\n    // MySQL only\n    oldColumn.unsigned !== newColumn.unsigned ||\n    // MySQL only\n    oldColumn.asExpression !== newColumn.asExpression || checkDefault && oldColumn.default !== newColumn.default || oldColumn.onUpdate !== newColumn.onUpdate ||\n    // MySQL only\n    oldColumn.isNullable !== newColumn.isNullable || checkComment && oldColumn.comment !== newColumn.comment || checkEnum && this.isEnumChanged(oldColumn, newColumn);\n  }\n  isEnumChanged(oldColumn, newColumn) {\n    return !OrmUtils.isArraysEqual(oldColumn.enum || [], newColumn.enum || []);\n  }\n  /**\n   * Checks if column length is by default.\n   */\n  isDefaultColumnLength(table, column, length) {\n    // if table have metadata, we check if length is specified in column metadata\n    if (this.connection.hasMetadata(table.name)) {\n      const metadata = this.connection.getMetadata(table.name);\n      const columnMetadata = metadata.findColumnWithDatabaseName(column.name);\n      if (columnMetadata) {\n        const columnMetadataLength = this.connection.driver.getColumnLength(columnMetadata);\n        if (columnMetadataLength) return false;\n      }\n    }\n    if (this.connection.driver.dataTypeDefaults && this.connection.driver.dataTypeDefaults[column.type] && this.connection.driver.dataTypeDefaults[column.type].length) {\n      return this.connection.driver.dataTypeDefaults[column.type].length.toString() === length.toString();\n    }\n    return false;\n  }\n  /**\n   * Checks if column precision is by default.\n   */\n  isDefaultColumnPrecision(table, column, precision) {\n    // if table have metadata, we check if length is specified in column metadata\n    if (this.connection.hasMetadata(table.name)) {\n      const metadata = this.connection.getMetadata(table.name);\n      const columnMetadata = metadata.findColumnWithDatabaseName(column.name);\n      if (columnMetadata && columnMetadata.precision !== null && columnMetadata.precision !== undefined) return false;\n    }\n    if (this.connection.driver.dataTypeDefaults && this.connection.driver.dataTypeDefaults[column.type] && this.connection.driver.dataTypeDefaults[column.type].precision !== null && this.connection.driver.dataTypeDefaults[column.type].precision !== undefined) return this.connection.driver.dataTypeDefaults[column.type].precision === precision;\n    return false;\n  }\n  /**\n   * Checks if column scale is by default.\n   */\n  isDefaultColumnScale(table, column, scale) {\n    // if table have metadata, we check if length is specified in column metadata\n    if (this.connection.hasMetadata(table.name)) {\n      const metadata = this.connection.getMetadata(table.name);\n      const columnMetadata = metadata.findColumnWithDatabaseName(column.name);\n      if (columnMetadata && columnMetadata.scale !== null && columnMetadata.scale !== undefined) return false;\n    }\n    if (this.connection.driver.dataTypeDefaults && this.connection.driver.dataTypeDefaults[column.type] && this.connection.driver.dataTypeDefaults[column.type].scale !== null && this.connection.driver.dataTypeDefaults[column.type].scale !== undefined) return this.connection.driver.dataTypeDefaults[column.type].scale === scale;\n    return false;\n  }\n  /**\n   * Executes sql used special for schema build.\n   */\n  async executeQueries(upQueries, downQueries) {\n    if (InstanceChecker.isQuery(upQueries)) upQueries = [upQueries];\n    if (InstanceChecker.isQuery(downQueries)) downQueries = [downQueries];\n    this.sqlInMemory.upQueries.push(...upQueries);\n    this.sqlInMemory.downQueries.push(...downQueries);\n    // if sql-in-memory mode is enabled then simply store sql in memory and return\n    if (this.sqlMemoryMode === true) return Promise.resolve();\n    for (const {\n      query,\n      parameters\n    } of upQueries) {\n      await this.query(query, parameters);\n    }\n  }\n  /**\n   * Generated an index name for a table and index\n   */\n  generateIndexName(table, index) {\n    // new index may be passed without name. In this case we generate index name manually.\n    return this.connection.namingStrategy.indexName(table, index.columnNames, index.where);\n  }\n}","map":{"version":3,"names":["Query","SqlInMemory","TypeORMError","OrmUtils","InstanceChecker","BaseQueryRunner","constructor","isReleased","isTransactionActive","data","loadedTables","loadedViews","sqlMemoryMode","sqlInMemory","transactionDepth","cachedTablePaths","beforeMigration","afterMigration","getTable","tablePath","loadTables","length","undefined","getTables","tableNames","getView","viewPath","loadViews","getViews","viewPaths","enableSqlMemory","disableSqlMemory","clearSqlMemory","getMemorySql","executeMemoryUpSql","query","parameters","upQueries","executeMemoryDownSql","downQueries","reverse","getReplicationMode","mode","getCachedView","viewName","view","find","name","foundViews","push","getCachedTable","tableName","table","getTablePath","foundTables","foundTablePath","cachedTable","replaceCachedTable","changedTable","oldTablePath","foundTable","loadedTable","key","cachedPath","Object","entries","database","schema","columns","indices","foreignKeys","uniques","checks","justCreated","engine","comment","target","parsed","connection","driver","parseTableName","buildTableName","getTypeormMetadataTableName","options","metadataTableName","selectTypeormMetadataSql","type","qb","createQueryBuilder","selectQb","select","from","where","escape","andWhere","getQueryAndParameters","insertTypeormMetadataSql","value","insert","into","values","deleteTypeormMetadataSql","deleteQb","delete","isColumnChanged","oldColumn","newColumn","checkDefault","checkComment","checkEnum","charset","collation","precision","scale","width","zerofill","unsigned","asExpression","default","onUpdate","isNullable","isEnumChanged","isArraysEqual","enum","isDefaultColumnLength","column","hasMetadata","metadata","getMetadata","columnMetadata","findColumnWithDatabaseName","columnMetadataLength","getColumnLength","dataTypeDefaults","toString","isDefaultColumnPrecision","isDefaultColumnScale","executeQueries","isQuery","Promise","resolve","generateIndexName","index","namingStrategy","indexName","columnNames"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\query-runner\\BaseQueryRunner.ts"],"sourcesContent":["import { PostgresConnectionOptions } from \"../driver/postgres/PostgresConnectionOptions\"\nimport { Query } from \"../driver/Query\"\nimport { SqlInMemory } from \"../driver/SqlInMemory\"\nimport { SqlServerConnectionOptions } from \"../driver/sqlserver/SqlServerConnectionOptions\"\nimport { TableIndex } from \"../schema-builder/table/TableIndex\"\nimport { View } from \"../schema-builder/view/View\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { Table } from \"../schema-builder/table/Table\"\nimport { EntityManager } from \"../entity-manager/EntityManager\"\nimport { TableColumn } from \"../schema-builder/table/TableColumn\"\nimport { Broadcaster } from \"../subscriber/Broadcaster\"\nimport { ReplicationMode } from \"../driver/types/ReplicationMode\"\nimport { TypeORMError } from \"../error/TypeORMError\"\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { TableForeignKey } from \"../schema-builder/table/TableForeignKey\"\nimport { OrmUtils } from \"../util/OrmUtils\"\nimport { MetadataTableType } from \"../driver/types/MetadataTableType\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\n\nexport abstract class BaseQueryRunner {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection used by this query runner.\n     */\n    connection: DataSource\n\n    /**\n     * Entity manager working only with current query runner.\n     */\n    manager: EntityManager\n\n    /**\n     * Indicates if connection for this query runner is released.\n     * Once its released, query runner cannot run queries anymore.\n     */\n    isReleased = false\n\n    /**\n     * Indicates if transaction is in progress.\n     */\n    isTransactionActive = false\n\n    /**\n     * Stores temporarily user data.\n     * Useful for sharing data with subscribers.\n     */\n    data = {}\n\n    /**\n     * All synchronized tables in the database.\n     */\n    loadedTables: Table[] = []\n\n    /**\n     * All synchronized views in the database.\n     */\n    loadedViews: View[] = []\n\n    /**\n     * Broadcaster used on this query runner to broadcast entity events.\n     */\n    broadcaster: Broadcaster\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Real database connection from a connection pool used to perform queries.\n     */\n    protected databaseConnection: any\n\n    /**\n     * Indicates if special query runner mode in which sql queries won't be executed is enabled.\n     */\n    protected sqlMemoryMode: boolean = false\n\n    /**\n     * Sql-s stored if \"sql in memory\" mode is enabled.\n     */\n    protected sqlInMemory: SqlInMemory = new SqlInMemory()\n\n    /**\n     * Mode in which query runner executes.\n     * Used for replication.\n     * If replication is not setup its value is ignored.\n     */\n    protected mode: ReplicationMode\n\n    /**\n     * current depth of transaction.\n     * for transactionDepth > 0 will use SAVEPOINT to start and commit/rollback transaction blocks\n     */\n    protected transactionDepth = 0\n\n    private cachedTablePaths: Record<string, string> = {}\n\n    // -------------------------------------------------------------------------\n    // Public Abstract Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes a given SQL query.\n     */\n    abstract query(\n        query: string,\n        parameters?: any[],\n        useStructuredResult?: boolean,\n    ): Promise<any>\n\n    // -------------------------------------------------------------------------\n    // Protected Abstract Methods\n    // -------------------------------------------------------------------------\n\n    protected abstract loadTables(tablePaths?: string[]): Promise<Table[]>\n\n    protected abstract loadViews(tablePaths?: string[]): Promise<View[]>\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Called before migrations are run.\n     */\n    async beforeMigration(): Promise<void> {\n        // Do nothing\n    }\n\n    /**\n     * Called after migrations are run.\n     */\n    async afterMigration(): Promise<void> {\n        // Do nothing\n    }\n\n    /**\n     * Loads given table's data from the database.\n     */\n    async getTable(tablePath: string): Promise<Table | undefined> {\n        this.loadedTables = await this.loadTables([tablePath])\n        return this.loadedTables.length > 0 ? this.loadedTables[0] : undefined\n    }\n\n    /**\n     * Loads all tables (with given names) from the database.\n     */\n    async getTables(tableNames?: string[]): Promise<Table[]> {\n        if (!tableNames) {\n            // Don't cache in this case.\n            // This is the new case & isn't used anywhere else anyway.\n            return await this.loadTables(tableNames)\n        }\n\n        this.loadedTables = await this.loadTables(tableNames)\n        return this.loadedTables\n    }\n\n    /**\n     * Loads given view's data from the database.\n     */\n    async getView(viewPath: string): Promise<View | undefined> {\n        this.loadedViews = await this.loadViews([viewPath])\n        return this.loadedViews.length > 0 ? this.loadedViews[0] : undefined\n    }\n\n    /**\n     * Loads given view's data from the database.\n     */\n    async getViews(viewPaths?: string[]): Promise<View[]> {\n        this.loadedViews = await this.loadViews(viewPaths)\n        return this.loadedViews\n    }\n\n    /**\n     * Enables special query runner mode in which sql queries won't be executed,\n     * instead they will be memorized into a special variable inside query runner.\n     * You can get memorized sql using getMemorySql() method.\n     */\n    enableSqlMemory(): void {\n        this.sqlInMemory = new SqlInMemory()\n        this.sqlMemoryMode = true\n    }\n\n    /**\n     * Disables special query runner mode in which sql queries won't be executed\n     * started by calling enableSqlMemory() method.\n     *\n     * Previously memorized sql will be flushed.\n     */\n    disableSqlMemory(): void {\n        this.sqlInMemory = new SqlInMemory()\n        this.sqlMemoryMode = false\n    }\n\n    /**\n     * Flushes all memorized sqls.\n     */\n    clearSqlMemory(): void {\n        this.sqlInMemory = new SqlInMemory()\n    }\n\n    /**\n     * Gets sql stored in the memory. Parameters in the sql are already replaced.\n     */\n    getMemorySql(): SqlInMemory {\n        return this.sqlInMemory\n    }\n\n    /**\n     * Executes up sql queries.\n     */\n    async executeMemoryUpSql(): Promise<void> {\n        for (const { query, parameters } of this.sqlInMemory.upQueries) {\n            await this.query(query, parameters)\n        }\n    }\n\n    /**\n     * Executes down sql queries.\n     */\n    async executeMemoryDownSql(): Promise<void> {\n        for (const {\n            query,\n            parameters,\n        } of this.sqlInMemory.downQueries.reverse()) {\n            await this.query(query, parameters)\n        }\n    }\n\n    getReplicationMode(): ReplicationMode {\n        return this.mode\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets view from previously loaded views, otherwise loads it from database.\n     */\n    protected async getCachedView(viewName: string): Promise<View> {\n        const view = this.loadedViews.find((view) => view.name === viewName)\n        if (view) return view\n\n        const foundViews = await this.loadViews([viewName])\n        if (foundViews.length > 0) {\n            this.loadedViews.push(foundViews[0])\n            return foundViews[0]\n        } else {\n            throw new TypeORMError(`View \"${viewName}\" does not exist.`)\n        }\n    }\n\n    /**\n     * Gets table from previously loaded tables, otherwise loads it from database.\n     */\n    protected async getCachedTable(tableName: string): Promise<Table> {\n        if (tableName in this.cachedTablePaths) {\n            const tablePath = this.cachedTablePaths[tableName]\n            const table = this.loadedTables.find(\n                (table) => this.getTablePath(table) === tablePath,\n            )\n\n            if (table) {\n                return table\n            }\n        }\n\n        const foundTables = await this.loadTables([tableName])\n\n        if (foundTables.length > 0) {\n            const foundTablePath = this.getTablePath(foundTables[0])\n\n            const cachedTable = this.loadedTables.find(\n                (table) => this.getTablePath(table) === foundTablePath,\n            )\n\n            if (!cachedTable) {\n                this.cachedTablePaths[tableName] = this.getTablePath(\n                    foundTables[0],\n                )\n                this.loadedTables.push(foundTables[0])\n                return foundTables[0]\n            } else {\n                return cachedTable\n            }\n        } else {\n            throw new TypeORMError(`Table \"${tableName}\" does not exist.`)\n        }\n    }\n\n    /**\n     * Replaces loaded table with given changed table.\n     */\n    protected replaceCachedTable(table: Table, changedTable: Table): void {\n        const oldTablePath = this.getTablePath(table)\n        const foundTable = this.loadedTables.find(\n            (loadedTable) => this.getTablePath(loadedTable) === oldTablePath,\n        )\n\n        // Clean up the lookup cache..\n        for (const [key, cachedPath] of Object.entries(this.cachedTablePaths)) {\n            if (cachedPath === oldTablePath) {\n                this.cachedTablePaths[key] = this.getTablePath(changedTable)\n            }\n        }\n\n        if (foundTable) {\n            foundTable.database = changedTable.database\n            foundTable.schema = changedTable.schema\n            foundTable.name = changedTable.name\n            foundTable.columns = changedTable.columns\n            foundTable.indices = changedTable.indices\n            foundTable.foreignKeys = changedTable.foreignKeys\n            foundTable.uniques = changedTable.uniques\n            foundTable.checks = changedTable.checks\n            foundTable.justCreated = changedTable.justCreated\n            foundTable.engine = changedTable.engine\n            foundTable.comment = changedTable.comment\n        }\n    }\n\n    protected getTablePath(\n        target: EntityMetadata | Table | View | TableForeignKey | string,\n    ): string {\n        const parsed = this.connection.driver.parseTableName(target)\n\n        return this.connection.driver.buildTableName(\n            parsed.tableName,\n            parsed.schema,\n            parsed.database,\n        )\n    }\n\n    protected getTypeormMetadataTableName(): string {\n        const options = <\n            SqlServerConnectionOptions | PostgresConnectionOptions\n        >this.connection.driver.options\n        return this.connection.driver.buildTableName(\n            this.connection.metadataTableName,\n            options.schema,\n            options.database,\n        )\n    }\n\n    /**\n     * Generates SQL query to select record from typeorm metadata table.\n     */\n    protected selectTypeormMetadataSql({\n        database,\n        schema,\n        table,\n        type,\n        name,\n    }: {\n        database?: string\n        schema?: string\n        table?: string\n        type: MetadataTableType\n        name: string\n    }): Query {\n        const qb = this.connection.createQueryBuilder()\n        const selectQb = qb\n            .select()\n            .from(this.getTypeormMetadataTableName(), \"t\")\n            .where(`${qb.escape(\"type\")} = :type`, { type })\n            .andWhere(`${qb.escape(\"name\")} = :name`, { name })\n\n        if (database) {\n            selectQb.andWhere(`${qb.escape(\"database\")} = :database`, {\n                database,\n            })\n        }\n\n        if (schema) {\n            selectQb.andWhere(`${qb.escape(\"schema\")} = :schema`, { schema })\n        }\n\n        if (table) {\n            selectQb.andWhere(`${qb.escape(\"table\")} = :table`, { table })\n        }\n\n        const [query, parameters] = selectQb.getQueryAndParameters()\n        return new Query(query, parameters)\n    }\n\n    /**\n     * Generates SQL query to insert a record into typeorm metadata table.\n     */\n    protected insertTypeormMetadataSql({\n        database,\n        schema,\n        table,\n        type,\n        name,\n        value,\n    }: {\n        database?: string\n        schema?: string\n        table?: string\n        type: MetadataTableType\n        name: string\n        value?: string\n    }): Query {\n        const [query, parameters] = this.connection\n            .createQueryBuilder()\n            .insert()\n            .into(this.getTypeormMetadataTableName())\n            .values({\n                database: database,\n                schema: schema,\n                table: table,\n                type: type,\n                name: name,\n                value: value,\n            })\n            .getQueryAndParameters()\n\n        return new Query(query, parameters)\n    }\n\n    /**\n     * Generates SQL query to delete a record from typeorm metadata table.\n     */\n    protected deleteTypeormMetadataSql({\n        database,\n        schema,\n        table,\n        type,\n        name,\n    }: {\n        database?: string\n        schema?: string\n        table?: string\n        type: MetadataTableType\n        name: string\n    }): Query {\n        const qb = this.connection.createQueryBuilder()\n        const deleteQb = qb\n            .delete()\n            .from(this.getTypeormMetadataTableName())\n            .where(`${qb.escape(\"type\")} = :type`, { type })\n            .andWhere(`${qb.escape(\"name\")} = :name`, { name })\n\n        if (database) {\n            deleteQb.andWhere(`${qb.escape(\"database\")} = :database`, {\n                database,\n            })\n        }\n\n        if (schema) {\n            deleteQb.andWhere(`${qb.escape(\"schema\")} = :schema`, { schema })\n        }\n\n        if (table) {\n            deleteQb.andWhere(`${qb.escape(\"table\")} = :table`, { table })\n        }\n\n        const [query, parameters] = deleteQb.getQueryAndParameters()\n        return new Query(query, parameters)\n    }\n\n    /**\n     * Checks if at least one of column properties was changed.\n     * Does not checks column type, length and autoincrement, because these properties changes separately.\n     */\n    protected isColumnChanged(\n        oldColumn: TableColumn,\n        newColumn: TableColumn,\n        checkDefault?: boolean,\n        checkComment?: boolean,\n        checkEnum = true,\n    ): boolean {\n        // this logs need to debug issues in column change detection. Do not delete it!\n\n        // console.log(\"charset ---------------\");\n        // console.log(oldColumn.charset !== newColumn.charset);\n        // console.log(oldColumn.charset, newColumn.charset);\n        // console.log(\"collation ---------------\");\n        // console.log(oldColumn.collation !== newColumn.collation);\n        // console.log(oldColumn.collation, newColumn.collation);\n        // console.log(\"precision ---------------\");\n        // console.log(oldColumn.precision !== newColumn.precision);\n        // console.log(oldColumn.precision, newColumn.precision);\n        // console.log(\"scale ---------------\");\n        // console.log(oldColumn.scale !== newColumn.scale);\n        // console.log(oldColumn.scale, newColumn.scale);\n        // console.log(\"default ---------------\");\n        // console.log((checkDefault && oldColumn.default !== newColumn.default));\n        // console.log(oldColumn.default, newColumn.default);\n        // console.log(\"isNullable ---------------\");\n        // console.log(oldColumn.isNullable !== newColumn.isNullable);\n        // console.log(oldColumn.isNullable, newColumn.isNullable);\n        // console.log(\"comment ---------------\");\n        // console.log((checkComment && oldColumn.comment !== newColumn.comment));\n        // console.log(oldColumn.comment, newColumn.comment);\n        // console.log(\"enum ---------------\");\n        // console.log(!OrmUtils.isArraysEqual(oldColumn.enum || [], newColumn.enum || []));\n        // console.log(oldColumn.enum, newColumn.enum);\n\n        return (\n            oldColumn.charset !== newColumn.charset ||\n            oldColumn.collation !== newColumn.collation ||\n            oldColumn.precision !== newColumn.precision ||\n            oldColumn.scale !== newColumn.scale ||\n            oldColumn.width !== newColumn.width || // MySQL only\n            oldColumn.zerofill !== newColumn.zerofill || // MySQL only\n            oldColumn.unsigned !== newColumn.unsigned || // MySQL only\n            oldColumn.asExpression !== newColumn.asExpression ||\n            (checkDefault && oldColumn.default !== newColumn.default) ||\n            oldColumn.onUpdate !== newColumn.onUpdate || // MySQL only\n            oldColumn.isNullable !== newColumn.isNullable ||\n            (checkComment && oldColumn.comment !== newColumn.comment) ||\n            (checkEnum && this.isEnumChanged(oldColumn, newColumn))\n        )\n    }\n\n    protected isEnumChanged(oldColumn: TableColumn, newColumn: TableColumn) {\n        return !OrmUtils.isArraysEqual(\n            oldColumn.enum || [],\n            newColumn.enum || [],\n        )\n    }\n\n    /**\n     * Checks if column length is by default.\n     */\n    protected isDefaultColumnLength(\n        table: Table,\n        column: TableColumn,\n        length: string,\n    ): boolean {\n        // if table have metadata, we check if length is specified in column metadata\n        if (this.connection.hasMetadata(table.name)) {\n            const metadata = this.connection.getMetadata(table.name)\n            const columnMetadata = metadata.findColumnWithDatabaseName(\n                column.name,\n            )\n\n            if (columnMetadata) {\n                const columnMetadataLength =\n                    this.connection.driver.getColumnLength(columnMetadata)\n                if (columnMetadataLength) return false\n            }\n        }\n\n        if (\n            this.connection.driver.dataTypeDefaults &&\n            this.connection.driver.dataTypeDefaults[column.type] &&\n            this.connection.driver.dataTypeDefaults[column.type].length\n        ) {\n            return (\n                this.connection.driver.dataTypeDefaults[\n                    column.type\n                ].length!.toString() === length.toString()\n            )\n        }\n\n        return false\n    }\n\n    /**\n     * Checks if column precision is by default.\n     */\n    protected isDefaultColumnPrecision(\n        table: Table,\n        column: TableColumn,\n        precision: number,\n    ): boolean {\n        // if table have metadata, we check if length is specified in column metadata\n        if (this.connection.hasMetadata(table.name)) {\n            const metadata = this.connection.getMetadata(table.name)\n            const columnMetadata = metadata.findColumnWithDatabaseName(\n                column.name,\n            )\n            if (\n                columnMetadata &&\n                columnMetadata.precision !== null &&\n                columnMetadata.precision !== undefined\n            )\n                return false\n        }\n\n        if (\n            this.connection.driver.dataTypeDefaults &&\n            this.connection.driver.dataTypeDefaults[column.type] &&\n            this.connection.driver.dataTypeDefaults[column.type].precision !==\n                null &&\n            this.connection.driver.dataTypeDefaults[column.type].precision !==\n                undefined\n        )\n            return (\n                this.connection.driver.dataTypeDefaults[column.type]\n                    .precision === precision\n            )\n\n        return false\n    }\n\n    /**\n     * Checks if column scale is by default.\n     */\n    protected isDefaultColumnScale(\n        table: Table,\n        column: TableColumn,\n        scale: number,\n    ): boolean {\n        // if table have metadata, we check if length is specified in column metadata\n        if (this.connection.hasMetadata(table.name)) {\n            const metadata = this.connection.getMetadata(table.name)\n            const columnMetadata = metadata.findColumnWithDatabaseName(\n                column.name,\n            )\n            if (\n                columnMetadata &&\n                columnMetadata.scale !== null &&\n                columnMetadata.scale !== undefined\n            )\n                return false\n        }\n\n        if (\n            this.connection.driver.dataTypeDefaults &&\n            this.connection.driver.dataTypeDefaults[column.type] &&\n            this.connection.driver.dataTypeDefaults[column.type].scale !==\n                null &&\n            this.connection.driver.dataTypeDefaults[column.type].scale !==\n                undefined\n        )\n            return (\n                this.connection.driver.dataTypeDefaults[column.type].scale ===\n                scale\n            )\n\n        return false\n    }\n\n    /**\n     * Executes sql used special for schema build.\n     */\n    protected async executeQueries(\n        upQueries: Query | Query[],\n        downQueries: Query | Query[],\n    ): Promise<void> {\n        if (InstanceChecker.isQuery(upQueries)) upQueries = [upQueries]\n        if (InstanceChecker.isQuery(downQueries)) downQueries = [downQueries]\n\n        this.sqlInMemory.upQueries.push(...upQueries)\n        this.sqlInMemory.downQueries.push(...downQueries)\n\n        // if sql-in-memory mode is enabled then simply store sql in memory and return\n        if (this.sqlMemoryMode === true)\n            return Promise.resolve() as Promise<any>\n\n        for (const { query, parameters } of upQueries) {\n            await this.query(query, parameters)\n        }\n    }\n\n    /**\n     * Generated an index name for a table and index\n     */\n    protected generateIndexName(\n        table: Table | View,\n        index: TableIndex,\n    ): string {\n        // new index may be passed without name. In this case we generate index name manually.\n        return this.connection.namingStrategy.indexName(\n            table,\n            index.columnNames,\n            index.where,\n        )\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}