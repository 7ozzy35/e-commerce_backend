{"ast":null,"code":"import { Subject } from \"../Subject\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\n/**\n * Builds operations needs to be executed for many-to-many relations of the given subjects.\n *\n * by example: post contains owner many-to-many relation with categories in the property called \"categories\", e.g.\n *             @ManyToMany(type => Category, category => category.posts) categories: Category[]\n *             If user adds categories into the post and saves post we need to bind them.\n *             This operation requires updation of junction table.\n */\nexport class ManyToManySubjectBuilder {\n  // ---------------------------------------------------------------------\n  // Constructor\n  // ---------------------------------------------------------------------\n  constructor(subjects) {\n    this.subjects = subjects;\n  }\n  // ---------------------------------------------------------------------\n  // Public Methods\n  // ---------------------------------------------------------------------\n  /**\n   * Builds operations for any changes in the many-to-many relations of the subjects.\n   */\n  build() {\n    this.subjects.forEach(subject => {\n      // if subject doesn't have entity then no need to find something that should be inserted or removed\n      if (!subject.entity) return;\n      // go through all persistence enabled many-to-many relations and build subject operations for them\n      subject.metadata.manyToManyRelations.forEach(relation => {\n        // skip relations for which persistence is disabled\n        if (relation.persistenceEnabled === false) return;\n        this.buildForSubjectRelation(subject, relation);\n      });\n    });\n  }\n  /**\n   * Builds operations for removal of all many-to-many records of all many-to-many relations of the given subject.\n   */\n  buildForAllRemoval(subject) {\n    // if subject does not have a database entity then it means it does not exist in the database\n    // if it does not exist in the database then we don't have anything for deletion\n    if (!subject.databaseEntity) return;\n    // go through all persistence enabled many-to-many relations and build subject operations for them\n    subject.metadata.manyToManyRelations.forEach(relation => {\n      // skip relations for which persistence is disabled\n      if (relation.persistenceEnabled === false) return;\n      // get all related entities (actually related entity relation ids) bind to this subject entity\n      // by example: returns category ids of the post we are currently working with (subject.entity is post)\n      const relatedEntityRelationIdsInDatabase = relation.getEntityValue(subject.databaseEntity);\n      // go through all related entities and create a new junction subject for each row in junction table\n      relatedEntityRelationIdsInDatabase.forEach(relationId => {\n        const junctionSubject = new Subject({\n          metadata: relation.junctionEntityMetadata,\n          parentSubject: subject,\n          mustBeRemoved: true,\n          identifier: this.buildJunctionIdentifier(subject, relation, relationId)\n        });\n        // we use unshift because we need to perform those operations before post deletion is performed\n        // but post deletion was already added as an subject\n        // this is temporary solution, later we need to implement proper sorting of subjects before their removal\n        this.subjects.push(junctionSubject);\n      });\n    });\n  }\n  // ---------------------------------------------------------------------\n  // Protected Methods\n  // ---------------------------------------------------------------------\n  /**\n   * Builds operations for a given subject and relation.\n   *\n   * by example: subject is \"post\" entity we are saving here and relation is \"categories\" inside it here.\n   */\n  buildForSubjectRelation(subject, relation) {\n    // load from db all relation ids of inverse entities that are \"bind\" to the subject's entity\n    // this way we gonna check which relation ids are missing and which are new (e.g. inserted or removed)\n    let databaseRelatedEntityIds = [];\n    // if subject don't have database entity it means all related entities in persisted subject are new and must be bind\n    // and we don't need to remove something that is not exist\n    if (subject.databaseEntity) {\n      const databaseRelatedEntityValue = relation.getEntityValue(subject.databaseEntity);\n      if (databaseRelatedEntityValue) {\n        databaseRelatedEntityIds = databaseRelatedEntityValue.map(e => relation.inverseEntityMetadata.getEntityIdMap(e));\n      }\n    }\n    // extract entity's relation value\n    // by example: categories inside our post (subject.entity is post)\n    let relatedEntities = relation.getEntityValue(subject.entity);\n    if (relatedEntities === null)\n      // if value set to null its equal if we set it to empty array - all items must be removed from the database\n      relatedEntities = [];\n    if (!Array.isArray(relatedEntities)) return;\n    // from all related entities find only those which aren't found in the db - for them we will create operation subjects\n    relatedEntities.forEach(relatedEntity => {\n      // by example: relatedEntity is category from categories saved with post\n      // todo: check how it will work for entities which are saved by cascades, but aren't saved in the database yet\n      // extract only relation id from the related entities, since we only need it for comparison\n      // by example: extract from category only relation id (category id, or let's say category title, depend on join column options)\n      let relatedEntityRelationIdMap = relation.inverseEntityMetadata.getEntityIdMap(relatedEntity);\n      // try to find a subject of this related entity, maybe it was loaded or was marked for persistence\n      const relatedEntitySubject = this.subjects.find(subject => {\n        return subject.entity === relatedEntity;\n      });\n      // if subject with entity was found take subject identifier as relation id map since it may contain extra properties resolved\n      if (relatedEntitySubject) relatedEntityRelationIdMap = relatedEntitySubject.identifier;\n      // if related entity relation id map is empty it means related entity is newly persisted\n      if (!relatedEntityRelationIdMap) {\n        // we decided to remove this error because it brings complications when saving object with non-saved entities\n        // if related entity does not have a subject then it means user tries to bind entity which wasn't saved\n        // in this persistence because he didn't pass this entity for save or he did not set cascades\n        // but without entity being inserted we cannot bind it in the relation operation, so we throw an exception here\n        // we decided to remove this error because it brings complications when saving object with non-saved entities\n        // if (!relatedEntitySubject)\n        //     throw new TypeORMError(`Many-to-many relation \"${relation.entityMetadata.name}.${relation.propertyPath}\" contains ` +\n        //         `entities which do not exist in the database yet, thus they cannot be bind in the database. ` +\n        //         `Please setup cascade insertion or save entities before binding it.`);\n        if (!relatedEntitySubject) return;\n      }\n      // try to find related entity in the database\n      // by example: find post's category in the database post's categories\n      const relatedEntityExistInDatabase = databaseRelatedEntityIds.find(databaseRelatedEntityRelationId => {\n        return OrmUtils.compareIds(databaseRelatedEntityRelationId, relatedEntityRelationIdMap);\n      });\n      // if entity is found then don't do anything - it means binding in junction table already exist, we don't need to add anything\n      if (relatedEntityExistInDatabase) return;\n      const ownerValue = relation.isOwning ? subject : relatedEntitySubject || relatedEntity; // by example: ownerEntityMap is post from subject here\n      const inverseValue = relation.isOwning ? relatedEntitySubject || relatedEntity : subject; // by example: inverseEntityMap is category from categories array here\n      // create a new subject for insert operation of junction rows\n      const junctionSubject = new Subject({\n        metadata: relation.junctionEntityMetadata,\n        parentSubject: subject,\n        canBeInserted: true\n      });\n      this.subjects.push(junctionSubject);\n      relation.junctionEntityMetadata.ownerColumns.forEach(column => {\n        junctionSubject.changeMaps.push({\n          column: column,\n          value: ownerValue\n          // valueFactory: (value) => column.referencedColumn!.getEntityValue(value) // column.referencedColumn!.getEntityValue(ownerEntityMap),\n        });\n      });\n      relation.junctionEntityMetadata.inverseColumns.forEach(column => {\n        junctionSubject.changeMaps.push({\n          column: column,\n          value: inverseValue\n          // valueFactory: (value) => column.referencedColumn!.getEntityValue(value) // column.referencedColumn!.getEntityValue(inverseEntityMap),\n        });\n      });\n    });\n    // get all inverse entities relation ids that are \"bind\" to the currently persisted entity\n    const changedInverseEntityRelationIds = [];\n    relatedEntities.forEach(relatedEntity => {\n      // relation.inverseEntityMetadata!.getEntityIdMap(relatedEntity)\n      let relatedEntityRelationIdMap = relation.inverseEntityMetadata.getEntityIdMap(relatedEntity);\n      // try to find a subject of this related entity, maybe it was loaded or was marked for persistence\n      const relatedEntitySubject = this.subjects.find(subject => {\n        return subject.entity === relatedEntity;\n      });\n      // if subject with entity was found take subject identifier as relation id map since it may contain extra properties resolved\n      if (relatedEntitySubject) relatedEntityRelationIdMap = relatedEntitySubject.identifier;\n      if (relatedEntityRelationIdMap !== undefined && relatedEntityRelationIdMap !== null) changedInverseEntityRelationIds.push(relatedEntityRelationIdMap);\n    });\n    // now from all entities in the persisted entity find only those which aren't found in the db\n    const removedJunctionEntityIds = databaseRelatedEntityIds.filter(existRelationId => {\n      return !changedInverseEntityRelationIds.find(changedRelationId => {\n        return OrmUtils.compareIds(changedRelationId, existRelationId);\n      });\n    });\n    // finally create a new junction remove operations for missing related entities\n    removedJunctionEntityIds.forEach(removedEntityRelationId => {\n      const junctionSubject = new Subject({\n        metadata: relation.junctionEntityMetadata,\n        parentSubject: subject,\n        mustBeRemoved: true,\n        identifier: this.buildJunctionIdentifier(subject, relation, removedEntityRelationId)\n      });\n      this.subjects.push(junctionSubject);\n    });\n  }\n  /**\n   * Creates identifiers for junction table.\n   * Example: { postId: 1, categoryId: 2 }\n   */\n  buildJunctionIdentifier(subject, relation, relationId) {\n    const ownerEntityMap = relation.isOwning ? subject.entity : relationId;\n    const inverseEntityMap = relation.isOwning ? relationId : subject.entity;\n    const identifier = {};\n    relation.junctionEntityMetadata.ownerColumns.forEach(column => {\n      OrmUtils.mergeDeep(identifier, column.createValueMap(column.referencedColumn.getEntityValue(ownerEntityMap)));\n    });\n    relation.junctionEntityMetadata.inverseColumns.forEach(column => {\n      OrmUtils.mergeDeep(identifier, column.createValueMap(column.referencedColumn.getEntityValue(inverseEntityMap)));\n    });\n    return identifier;\n  }\n}","map":{"version":3,"names":["Subject","OrmUtils","ManyToManySubjectBuilder","constructor","subjects","build","forEach","subject","entity","metadata","manyToManyRelations","relation","persistenceEnabled","buildForSubjectRelation","buildForAllRemoval","databaseEntity","relatedEntityRelationIdsInDatabase","getEntityValue","relationId","junctionSubject","junctionEntityMetadata","parentSubject","mustBeRemoved","identifier","buildJunctionIdentifier","push","databaseRelatedEntityIds","databaseRelatedEntityValue","map","e","inverseEntityMetadata","getEntityIdMap","relatedEntities","Array","isArray","relatedEntity","relatedEntityRelationIdMap","relatedEntitySubject","find","relatedEntityExistInDatabase","databaseRelatedEntityRelationId","compareIds","ownerValue","isOwning","inverseValue","canBeInserted","ownerColumns","column","changeMaps","value","inverseColumns","changedInverseEntityRelationIds","undefined","removedJunctionEntityIds","filter","existRelationId","changedRelationId","removedEntityRelationId","ownerEntityMap","inverseEntityMap","mergeDeep","createValueMap","referencedColumn"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\persistence\\subject-builder\\ManyToManySubjectBuilder.ts"],"sourcesContent":["import { Subject } from \"../Subject\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { RelationMetadata } from \"../../metadata/RelationMetadata\"\n\n/**\n * Builds operations needs to be executed for many-to-many relations of the given subjects.\n *\n * by example: post contains owner many-to-many relation with categories in the property called \"categories\", e.g.\n *             @ManyToMany(type => Category, category => category.posts) categories: Category[]\n *             If user adds categories into the post and saves post we need to bind them.\n *             This operation requires updation of junction table.\n */\nexport class ManyToManySubjectBuilder {\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(protected subjects: Subject[]) {}\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds operations for any changes in the many-to-many relations of the subjects.\n     */\n    build(): void {\n        this.subjects.forEach((subject) => {\n            // if subject doesn't have entity then no need to find something that should be inserted or removed\n            if (!subject.entity) return\n\n            // go through all persistence enabled many-to-many relations and build subject operations for them\n            subject.metadata.manyToManyRelations.forEach((relation) => {\n                // skip relations for which persistence is disabled\n                if (relation.persistenceEnabled === false) return\n\n                this.buildForSubjectRelation(subject, relation)\n            })\n        })\n    }\n\n    /**\n     * Builds operations for removal of all many-to-many records of all many-to-many relations of the given subject.\n     */\n    buildForAllRemoval(subject: Subject) {\n        // if subject does not have a database entity then it means it does not exist in the database\n        // if it does not exist in the database then we don't have anything for deletion\n        if (!subject.databaseEntity) return\n\n        // go through all persistence enabled many-to-many relations and build subject operations for them\n        subject.metadata.manyToManyRelations.forEach((relation) => {\n            // skip relations for which persistence is disabled\n            if (relation.persistenceEnabled === false) return\n\n            // get all related entities (actually related entity relation ids) bind to this subject entity\n            // by example: returns category ids of the post we are currently working with (subject.entity is post)\n            const relatedEntityRelationIdsInDatabase: ObjectLiteral[] =\n                relation.getEntityValue(subject.databaseEntity!)\n\n            // go through all related entities and create a new junction subject for each row in junction table\n            relatedEntityRelationIdsInDatabase.forEach((relationId) => {\n                const junctionSubject = new Subject({\n                    metadata: relation.junctionEntityMetadata!,\n                    parentSubject: subject,\n                    mustBeRemoved: true,\n                    identifier: this.buildJunctionIdentifier(\n                        subject,\n                        relation,\n                        relationId,\n                    ),\n                })\n\n                // we use unshift because we need to perform those operations before post deletion is performed\n                // but post deletion was already added as an subject\n                // this is temporary solution, later we need to implement proper sorting of subjects before their removal\n                this.subjects.push(junctionSubject)\n            })\n        })\n    }\n\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds operations for a given subject and relation.\n     *\n     * by example: subject is \"post\" entity we are saving here and relation is \"categories\" inside it here.\n     */\n    protected buildForSubjectRelation(\n        subject: Subject,\n        relation: RelationMetadata,\n    ) {\n        // load from db all relation ids of inverse entities that are \"bind\" to the subject's entity\n        // this way we gonna check which relation ids are missing and which are new (e.g. inserted or removed)\n        let databaseRelatedEntityIds: ObjectLiteral[] = []\n\n        // if subject don't have database entity it means all related entities in persisted subject are new and must be bind\n        // and we don't need to remove something that is not exist\n        if (subject.databaseEntity) {\n            const databaseRelatedEntityValue = relation.getEntityValue(\n                subject.databaseEntity,\n            )\n            if (databaseRelatedEntityValue) {\n                databaseRelatedEntityIds = databaseRelatedEntityValue.map(\n                    (e: any) =>\n                        relation.inverseEntityMetadata.getEntityIdMap(e),\n                )\n            }\n        }\n\n        // extract entity's relation value\n        // by example: categories inside our post (subject.entity is post)\n        let relatedEntities: ObjectLiteral[] = relation.getEntityValue(\n            subject.entity!,\n        )\n        if (relatedEntities === null)\n            // if value set to null its equal if we set it to empty array - all items must be removed from the database\n            relatedEntities = []\n        if (!Array.isArray(relatedEntities)) return\n\n        // from all related entities find only those which aren't found in the db - for them we will create operation subjects\n        relatedEntities.forEach((relatedEntity) => {\n            // by example: relatedEntity is category from categories saved with post\n\n            // todo: check how it will work for entities which are saved by cascades, but aren't saved in the database yet\n\n            // extract only relation id from the related entities, since we only need it for comparison\n            // by example: extract from category only relation id (category id, or let's say category title, depend on join column options)\n            let relatedEntityRelationIdMap =\n                relation.inverseEntityMetadata!.getEntityIdMap(relatedEntity)\n\n            // try to find a subject of this related entity, maybe it was loaded or was marked for persistence\n            const relatedEntitySubject = this.subjects.find((subject) => {\n                return subject.entity === relatedEntity\n            })\n\n            // if subject with entity was found take subject identifier as relation id map since it may contain extra properties resolved\n            if (relatedEntitySubject)\n                relatedEntityRelationIdMap = relatedEntitySubject.identifier\n\n            // if related entity relation id map is empty it means related entity is newly persisted\n            if (!relatedEntityRelationIdMap) {\n                // we decided to remove this error because it brings complications when saving object with non-saved entities\n                // if related entity does not have a subject then it means user tries to bind entity which wasn't saved\n                // in this persistence because he didn't pass this entity for save or he did not set cascades\n                // but without entity being inserted we cannot bind it in the relation operation, so we throw an exception here\n                // we decided to remove this error because it brings complications when saving object with non-saved entities\n                // if (!relatedEntitySubject)\n                //     throw new TypeORMError(`Many-to-many relation \"${relation.entityMetadata.name}.${relation.propertyPath}\" contains ` +\n                //         `entities which do not exist in the database yet, thus they cannot be bind in the database. ` +\n                //         `Please setup cascade insertion or save entities before binding it.`);\n                if (!relatedEntitySubject) return\n            }\n\n            // try to find related entity in the database\n            // by example: find post's category in the database post's categories\n            const relatedEntityExistInDatabase = databaseRelatedEntityIds.find(\n                (databaseRelatedEntityRelationId) => {\n                    return OrmUtils.compareIds(\n                        databaseRelatedEntityRelationId,\n                        relatedEntityRelationIdMap,\n                    )\n                },\n            )\n\n            // if entity is found then don't do anything - it means binding in junction table already exist, we don't need to add anything\n            if (relatedEntityExistInDatabase) return\n\n            const ownerValue = relation.isOwning\n                ? subject\n                : relatedEntitySubject || relatedEntity // by example: ownerEntityMap is post from subject here\n            const inverseValue = relation.isOwning\n                ? relatedEntitySubject || relatedEntity\n                : subject // by example: inverseEntityMap is category from categories array here\n\n            // create a new subject for insert operation of junction rows\n            const junctionSubject = new Subject({\n                metadata: relation.junctionEntityMetadata!,\n                parentSubject: subject,\n                canBeInserted: true,\n            })\n            this.subjects.push(junctionSubject)\n\n            relation.junctionEntityMetadata!.ownerColumns.forEach((column) => {\n                junctionSubject.changeMaps.push({\n                    column: column,\n                    value: ownerValue,\n                    // valueFactory: (value) => column.referencedColumn!.getEntityValue(value) // column.referencedColumn!.getEntityValue(ownerEntityMap),\n                })\n            })\n\n            relation.junctionEntityMetadata!.inverseColumns.forEach(\n                (column) => {\n                    junctionSubject.changeMaps.push({\n                        column: column,\n                        value: inverseValue,\n                        // valueFactory: (value) => column.referencedColumn!.getEntityValue(value) // column.referencedColumn!.getEntityValue(inverseEntityMap),\n                    })\n                },\n            )\n        })\n\n        // get all inverse entities relation ids that are \"bind\" to the currently persisted entity\n        const changedInverseEntityRelationIds: ObjectLiteral[] = []\n        relatedEntities.forEach((relatedEntity) => {\n            // relation.inverseEntityMetadata!.getEntityIdMap(relatedEntity)\n            let relatedEntityRelationIdMap =\n                relation.inverseEntityMetadata!.getEntityIdMap(relatedEntity)\n\n            // try to find a subject of this related entity, maybe it was loaded or was marked for persistence\n            const relatedEntitySubject = this.subjects.find((subject) => {\n                return subject.entity === relatedEntity\n            })\n\n            // if subject with entity was found take subject identifier as relation id map since it may contain extra properties resolved\n            if (relatedEntitySubject)\n                relatedEntityRelationIdMap = relatedEntitySubject.identifier\n\n            if (\n                relatedEntityRelationIdMap !== undefined &&\n                relatedEntityRelationIdMap !== null\n            )\n                changedInverseEntityRelationIds.push(relatedEntityRelationIdMap)\n        })\n\n        // now from all entities in the persisted entity find only those which aren't found in the db\n        const removedJunctionEntityIds = databaseRelatedEntityIds.filter(\n            (existRelationId) => {\n                return !changedInverseEntityRelationIds.find(\n                    (changedRelationId) => {\n                        return OrmUtils.compareIds(\n                            changedRelationId,\n                            existRelationId,\n                        )\n                    },\n                )\n            },\n        )\n\n        // finally create a new junction remove operations for missing related entities\n        removedJunctionEntityIds.forEach((removedEntityRelationId) => {\n            const junctionSubject = new Subject({\n                metadata: relation.junctionEntityMetadata!,\n                parentSubject: subject,\n                mustBeRemoved: true,\n                identifier: this.buildJunctionIdentifier(\n                    subject,\n                    relation,\n                    removedEntityRelationId,\n                ),\n            })\n            this.subjects.push(junctionSubject)\n        })\n    }\n\n    /**\n     * Creates identifiers for junction table.\n     * Example: { postId: 1, categoryId: 2 }\n     */\n    protected buildJunctionIdentifier(\n        subject: Subject,\n        relation: RelationMetadata,\n        relationId: ObjectLiteral,\n    ) {\n        const ownerEntityMap = relation.isOwning ? subject.entity! : relationId\n        const inverseEntityMap = relation.isOwning\n            ? relationId\n            : subject.entity!\n\n        const identifier: ObjectLiteral = {}\n        relation.junctionEntityMetadata!.ownerColumns.forEach((column) => {\n            OrmUtils.mergeDeep(\n                identifier,\n                column.createValueMap(\n                    column.referencedColumn!.getEntityValue(ownerEntityMap),\n                ),\n            )\n        })\n        relation.junctionEntityMetadata!.inverseColumns.forEach((column) => {\n            OrmUtils.mergeDeep(\n                identifier,\n                column.createValueMap(\n                    column.referencedColumn!.getEntityValue(inverseEntityMap),\n                ),\n            )\n        })\n        return identifier\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}