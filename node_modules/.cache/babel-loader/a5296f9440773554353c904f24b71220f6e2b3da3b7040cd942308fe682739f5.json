{"ast":null,"code":"import { TypeORMError } from \"../../error\";\nimport { QueryFailedError } from \"../../error/QueryFailedError\";\nimport { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\";\nimport { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\";\nimport { BaseQueryRunner } from \"../../query-runner/BaseQueryRunner\";\nimport { QueryResult } from \"../../query-runner/QueryResult\";\nimport { Table } from \"../../schema-builder/table/Table\";\nimport { TableCheck } from \"../../schema-builder/table/TableCheck\";\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\";\nimport { TableExclusion } from \"../../schema-builder/table/TableExclusion\";\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\";\nimport { TableIndex } from \"../../schema-builder/table/TableIndex\";\nimport { TableUnique } from \"../../schema-builder/table/TableUnique\";\nimport { View } from \"../../schema-builder/view/View\";\nimport { Broadcaster } from \"../../subscriber/Broadcaster\";\nimport { InstanceChecker } from \"../../util/InstanceChecker\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { VersionUtils } from \"../../util/VersionUtils\";\nimport { Query } from \"../Query\";\nimport { MetadataTableType } from \"../types/MetadataTableType\";\nimport { BroadcasterResult } from \"../../subscriber/BroadcasterResult\";\n/**\n * Runs queries on a single postgres database connection.\n */\nexport class PostgresQueryRunner extends BaseQueryRunner {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(driver, mode) {\n    super();\n    this.driver = driver;\n    this.connection = driver.connection;\n    this.mode = mode;\n    this.broadcaster = new Broadcaster(this);\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates/uses database connection from the connection pool to perform further operations.\n   * Returns obtained database connection.\n   */\n  connect() {\n    if (this.databaseConnection) return Promise.resolve(this.databaseConnection);\n    if (this.databaseConnectionPromise) return this.databaseConnectionPromise;\n    if (this.mode === \"slave\" && this.driver.isReplicated) {\n      this.databaseConnectionPromise = this.driver.obtainSlaveConnection().then(([connection, release]) => {\n        this.driver.connectedQueryRunners.push(this);\n        this.databaseConnection = connection;\n        const onErrorCallback = err => this.releasePostgresConnection(err);\n        this.releaseCallback = err => {\n          this.databaseConnection.removeListener(\"error\", onErrorCallback);\n          release(err);\n        };\n        this.databaseConnection.on(\"error\", onErrorCallback);\n        return this.databaseConnection;\n      });\n    } else {\n      // master\n      this.databaseConnectionPromise = this.driver.obtainMasterConnection().then(([connection, release]) => {\n        this.driver.connectedQueryRunners.push(this);\n        this.databaseConnection = connection;\n        const onErrorCallback = err => this.releasePostgresConnection(err);\n        this.releaseCallback = err => {\n          this.databaseConnection.removeListener(\"error\", onErrorCallback);\n          release(err);\n        };\n        this.databaseConnection.on(\"error\", onErrorCallback);\n        return this.databaseConnection;\n      });\n    }\n    return this.databaseConnectionPromise;\n  }\n  /**\n   * Release a connection back to the pool, optionally specifying an Error to release with.\n   * Per pg-pool documentation this will prevent the pool from re-using the broken connection.\n   */\n  async releasePostgresConnection(err) {\n    if (this.isReleased) {\n      return;\n    }\n    this.isReleased = true;\n    if (this.releaseCallback) {\n      this.releaseCallback(err);\n      this.releaseCallback = undefined;\n    }\n    const index = this.driver.connectedQueryRunners.indexOf(this);\n    if (index !== -1) {\n      this.driver.connectedQueryRunners.splice(index, 1);\n    }\n  }\n  /**\n   * Releases used database connection.\n   * You cannot use query runner methods once its released.\n   */\n  release() {\n    return this.releasePostgresConnection();\n  }\n  /**\n   * Starts transaction.\n   */\n  async startTransaction(isolationLevel) {\n    this.isTransactionActive = true;\n    try {\n      await this.broadcaster.broadcast(\"BeforeTransactionStart\");\n    } catch (err) {\n      this.isTransactionActive = false;\n      throw err;\n    }\n    if (this.transactionDepth === 0) {\n      this.transactionDepth += 1;\n      await this.query(\"START TRANSACTION\");\n      if (isolationLevel) {\n        await this.query(\"SET TRANSACTION ISOLATION LEVEL \" + isolationLevel);\n      }\n    } else {\n      this.transactionDepth += 1;\n      await this.query(`SAVEPOINT typeorm_${this.transactionDepth - 1}`);\n    }\n    await this.broadcaster.broadcast(\"AfterTransactionStart\");\n  }\n  /**\n   * Commits transaction.\n   * Error will be thrown if transaction was not started.\n   */\n  async commitTransaction() {\n    if (!this.isTransactionActive) throw new TransactionNotStartedError();\n    await this.broadcaster.broadcast(\"BeforeTransactionCommit\");\n    if (this.transactionDepth > 1) {\n      this.transactionDepth -= 1;\n      await this.query(`RELEASE SAVEPOINT typeorm_${this.transactionDepth}`);\n    } else {\n      this.transactionDepth -= 1;\n      await this.query(\"COMMIT\");\n      this.isTransactionActive = false;\n    }\n    await this.broadcaster.broadcast(\"AfterTransactionCommit\");\n  }\n  /**\n   * Rollbacks transaction.\n   * Error will be thrown if transaction was not started.\n   */\n  async rollbackTransaction() {\n    if (!this.isTransactionActive) throw new TransactionNotStartedError();\n    await this.broadcaster.broadcast(\"BeforeTransactionRollback\");\n    if (this.transactionDepth > 1) {\n      this.transactionDepth -= 1;\n      await this.query(`ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth}`);\n    } else {\n      this.transactionDepth -= 1;\n      await this.query(\"ROLLBACK\");\n      this.isTransactionActive = false;\n    }\n    await this.broadcaster.broadcast(\"AfterTransactionRollback\");\n  }\n  /**\n   * Executes a given SQL query.\n   */\n  async query(query, parameters, useStructuredResult = false) {\n    if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();\n    const databaseConnection = await this.connect();\n    const broadcasterResult = new BroadcasterResult();\n    this.driver.connection.logger.logQuery(query, parameters, this);\n    this.broadcaster.broadcastBeforeQueryEvent(broadcasterResult, query, parameters);\n    try {\n      const queryStartTime = +new Date();\n      const raw = await databaseConnection.query(query, parameters);\n      // log slow queries if maxQueryExecution time is set\n      const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;\n      const queryEndTime = +new Date();\n      const queryExecutionTime = queryEndTime - queryStartTime;\n      this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, raw, undefined);\n      if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);\n      const result = new QueryResult();\n      if (raw) {\n        if (raw.hasOwnProperty(\"rows\")) {\n          result.records = raw.rows;\n        }\n        if (raw.hasOwnProperty(\"rowCount\")) {\n          result.affected = raw.rowCount;\n        }\n        switch (raw.command) {\n          case \"DELETE\":\n          case \"UPDATE\":\n            // for UPDATE and DELETE query additionally return number of affected rows\n            result.raw = [raw.rows, raw.rowCount];\n            break;\n          default:\n            result.raw = raw.rows;\n        }\n        if (!useStructuredResult) {\n          return result.raw;\n        }\n      }\n      return result;\n    } catch (err) {\n      this.driver.connection.logger.logQueryError(err, query, parameters, this);\n      this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, undefined, undefined, err);\n      throw new QueryFailedError(query, parameters, err);\n    } finally {\n      await broadcasterResult.wait();\n    }\n  }\n  /**\n   * Returns raw data stream.\n   */\n  async stream(query, parameters, onEnd, onError) {\n    const QueryStream = this.driver.loadStreamDependency();\n    if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();\n    const databaseConnection = await this.connect();\n    this.driver.connection.logger.logQuery(query, parameters, this);\n    const stream = databaseConnection.query(new QueryStream(query, parameters));\n    if (onEnd) stream.on(\"end\", onEnd);\n    if (onError) stream.on(\"error\", onError);\n    return stream;\n  }\n  /**\n   * Returns all available database names including system databases.\n   */\n  async getDatabases() {\n    return Promise.resolve([]);\n  }\n  /**\n   * Returns all available schema names including system schemas.\n   * If database parameter specified, returns schemas of that database.\n   */\n  async getSchemas(database) {\n    return Promise.resolve([]);\n  }\n  /**\n   * Checks if database with the given name exist.\n   */\n  async hasDatabase(database) {\n    const result = await this.query(`SELECT * FROM pg_database WHERE datname='${database}';`);\n    return result.length ? true : false;\n  }\n  /**\n   * Loads currently using database\n   */\n  async getCurrentDatabase() {\n    const query = await this.query(`SELECT * FROM current_database()`);\n    return query[0][\"current_database\"];\n  }\n  /**\n   * Checks if schema with the given name exist.\n   */\n  async hasSchema(schema) {\n    const result = await this.query(`SELECT * FROM \"information_schema\".\"schemata\" WHERE \"schema_name\" = '${schema}'`);\n    return result.length ? true : false;\n  }\n  /**\n   * Loads currently using database schema\n   */\n  async getCurrentSchema() {\n    const query = await this.query(`SELECT * FROM current_schema()`);\n    return query[0][\"current_schema\"];\n  }\n  /**\n   * Checks if table with the given name exist in the database.\n   */\n  async hasTable(tableOrName) {\n    const parsedTableName = this.driver.parseTableName(tableOrName);\n    if (!parsedTableName.schema) {\n      parsedTableName.schema = await this.getCurrentSchema();\n    }\n    const sql = `SELECT * FROM \"information_schema\".\"tables\" WHERE \"table_schema\" = '${parsedTableName.schema}' AND \"table_name\" = '${parsedTableName.tableName}'`;\n    const result = await this.query(sql);\n    return result.length ? true : false;\n  }\n  /**\n   * Checks if column with the given name exist in the given table.\n   */\n  async hasColumn(tableOrName, columnName) {\n    const parsedTableName = this.driver.parseTableName(tableOrName);\n    if (!parsedTableName.schema) {\n      parsedTableName.schema = await this.getCurrentSchema();\n    }\n    const sql = `SELECT * FROM \"information_schema\".\"columns\" WHERE \"table_schema\" = '${parsedTableName.schema}' AND \"table_name\" = '${parsedTableName.tableName}' AND \"column_name\" = '${columnName}'`;\n    const result = await this.query(sql);\n    return result.length ? true : false;\n  }\n  /**\n   * Creates a new database.\n   * Note: Postgres does not support database creation inside a transaction block.\n   */\n  async createDatabase(database, ifNotExist) {\n    if (ifNotExist) {\n      const databaseAlreadyExists = await this.hasDatabase(database);\n      if (databaseAlreadyExists) return Promise.resolve();\n    }\n    const up = `CREATE DATABASE \"${database}\"`;\n    const down = `DROP DATABASE \"${database}\"`;\n    await this.executeQueries(new Query(up), new Query(down));\n  }\n  /**\n   * Drops database.\n   * Note: Postgres does not support database dropping inside a transaction block.\n   */\n  async dropDatabase(database, ifExist) {\n    const up = ifExist ? `DROP DATABASE IF EXISTS \"${database}\"` : `DROP DATABASE \"${database}\"`;\n    const down = `CREATE DATABASE \"${database}\"`;\n    await this.executeQueries(new Query(up), new Query(down));\n  }\n  /**\n   * Creates a new table schema.\n   */\n  async createSchema(schemaPath, ifNotExist) {\n    const schema = schemaPath.indexOf(\".\") === -1 ? schemaPath : schemaPath.split(\".\")[1];\n    const up = ifNotExist ? `CREATE SCHEMA IF NOT EXISTS \"${schema}\"` : `CREATE SCHEMA \"${schema}\"`;\n    const down = `DROP SCHEMA \"${schema}\" CASCADE`;\n    await this.executeQueries(new Query(up), new Query(down));\n  }\n  /**\n   * Drops table schema.\n   */\n  async dropSchema(schemaPath, ifExist, isCascade) {\n    const schema = schemaPath.indexOf(\".\") === -1 ? schemaPath : schemaPath.split(\".\")[1];\n    const up = ifExist ? `DROP SCHEMA IF EXISTS \"${schema}\" ${isCascade ? \"CASCADE\" : \"\"}` : `DROP SCHEMA \"${schema}\" ${isCascade ? \"CASCADE\" : \"\"}`;\n    const down = `CREATE SCHEMA \"${schema}\"`;\n    await this.executeQueries(new Query(up), new Query(down));\n  }\n  /**\n   * Creates a new table.\n   */\n  async createTable(table, ifNotExist = false, createForeignKeys = true, createIndices = true) {\n    if (ifNotExist) {\n      const isTableExist = await this.hasTable(table);\n      if (isTableExist) return Promise.resolve();\n    }\n    const upQueries = [];\n    const downQueries = [];\n    // if table have column with ENUM type, we must create this type in postgres.\n    const enumColumns = table.columns.filter(column => column.type === \"enum\" || column.type === \"simple-enum\");\n    const createdEnumTypes = [];\n    for (const column of enumColumns) {\n      // TODO: Should also check if values of existing type matches expected ones\n      const hasEnum = await this.hasEnumType(table, column);\n      const enumName = this.buildEnumName(table, column);\n      // if enum with the same \"enumName\" is defined more then once, me must prevent double creation\n      if (!hasEnum && createdEnumTypes.indexOf(enumName) === -1) {\n        createdEnumTypes.push(enumName);\n        upQueries.push(this.createEnumTypeSql(table, column, enumName));\n        downQueries.push(this.dropEnumTypeSql(table, column, enumName));\n      }\n    }\n    // if table have column with generated type, we must add the expression to the metadata table\n    const generatedColumns = table.columns.filter(column => column.generatedType === \"STORED\" && column.asExpression);\n    for (const column of generatedColumns) {\n      const tableNameWithSchema = (await this.getTableNameWithSchema(table.name)).split(\".\");\n      const tableName = tableNameWithSchema[1];\n      const schema = tableNameWithSchema[0];\n      const insertQuery = this.insertTypeormMetadataSql({\n        database: this.driver.database,\n        schema,\n        table: tableName,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name,\n        value: column.asExpression\n      });\n      const deleteQuery = this.deleteTypeormMetadataSql({\n        database: this.driver.database,\n        schema,\n        table: tableName,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name\n      });\n      upQueries.push(insertQuery);\n      downQueries.push(deleteQuery);\n    }\n    upQueries.push(this.createTableSql(table, createForeignKeys));\n    downQueries.push(this.dropTableSql(table));\n    // if createForeignKeys is true, we must drop created foreign keys in down query.\n    // createTable does not need separate method to create foreign keys, because it create fk's in the same query with table creation.\n    if (createForeignKeys) table.foreignKeys.forEach(foreignKey => downQueries.push(this.dropForeignKeySql(table, foreignKey)));\n    if (createIndices) {\n      table.indices.forEach(index => {\n        // new index may be passed without name. In this case we generate index name manually.\n        if (!index.name) index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);\n        upQueries.push(this.createIndexSql(table, index));\n        downQueries.push(this.dropIndexSql(table, index));\n      });\n    }\n    if (table.comment) {\n      upQueries.push(new Query(\"COMMENT ON TABLE \" + this.escapePath(table) + \" IS '\" + table.comment + \"'\"));\n      downQueries.push(new Query(\"COMMENT ON TABLE \" + this.escapePath(table) + \" IS NULL\"));\n    }\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Drops the table.\n   */\n  async dropTable(target, ifExist, dropForeignKeys = true, dropIndices = true) {\n    // It needs because if table does not exist and dropForeignKeys or dropIndices is true, we don't need\n    // to perform drop queries for foreign keys and indices.\n    if (ifExist) {\n      const isTableExist = await this.hasTable(target);\n      if (!isTableExist) return Promise.resolve();\n    }\n    // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.\n    const createForeignKeys = dropForeignKeys;\n    const tablePath = this.getTablePath(target);\n    const table = await this.getCachedTable(tablePath);\n    const upQueries = [];\n    const downQueries = [];\n    if (dropIndices) {\n      table.indices.forEach(index => {\n        upQueries.push(this.dropIndexSql(table, index));\n        downQueries.push(this.createIndexSql(table, index));\n      });\n    }\n    if (dropForeignKeys) table.foreignKeys.forEach(foreignKey => upQueries.push(this.dropForeignKeySql(table, foreignKey)));\n    upQueries.push(this.dropTableSql(table));\n    downQueries.push(this.createTableSql(table, createForeignKeys));\n    // if table had columns with generated type, we must remove the expression from the metadata table\n    const generatedColumns = table.columns.filter(column => column.generatedType && column.asExpression);\n    for (const column of generatedColumns) {\n      const tableNameWithSchema = (await this.getTableNameWithSchema(table.name)).split(\".\");\n      const tableName = tableNameWithSchema[1];\n      const schema = tableNameWithSchema[0];\n      const deleteQuery = this.deleteTypeormMetadataSql({\n        database: this.driver.database,\n        schema,\n        table: tableName,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name\n      });\n      const insertQuery = this.insertTypeormMetadataSql({\n        database: this.driver.database,\n        schema,\n        table: tableName,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name,\n        value: column.asExpression\n      });\n      upQueries.push(deleteQuery);\n      downQueries.push(insertQuery);\n    }\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Creates a new view.\n   */\n  async createView(view, syncWithMetadata = false) {\n    const upQueries = [];\n    const downQueries = [];\n    upQueries.push(this.createViewSql(view));\n    if (syncWithMetadata) upQueries.push(await this.insertViewDefinitionSql(view));\n    downQueries.push(this.dropViewSql(view));\n    if (syncWithMetadata) downQueries.push(await this.deleteViewDefinitionSql(view));\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Drops the view.\n   */\n  async dropView(target) {\n    const viewName = InstanceChecker.isView(target) ? target.name : target;\n    const view = await this.getCachedView(viewName);\n    const upQueries = [];\n    const downQueries = [];\n    upQueries.push(await this.deleteViewDefinitionSql(view));\n    upQueries.push(this.dropViewSql(view));\n    downQueries.push(await this.insertViewDefinitionSql(view));\n    downQueries.push(this.createViewSql(view));\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Renames the given table.\n   */\n  async renameTable(oldTableOrName, newTableName) {\n    const upQueries = [];\n    const downQueries = [];\n    const oldTable = InstanceChecker.isTable(oldTableOrName) ? oldTableOrName : await this.getCachedTable(oldTableOrName);\n    const newTable = oldTable.clone();\n    const {\n      schema: schemaName,\n      tableName: oldTableName\n    } = this.driver.parseTableName(oldTable);\n    newTable.name = schemaName ? `${schemaName}.${newTableName}` : newTableName;\n    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(oldTable)} RENAME TO \"${newTableName}\"`));\n    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME TO \"${oldTableName}\"`));\n    // rename column primary key constraint if it has default constraint name\n    if (newTable.primaryColumns.length > 0 && !newTable.primaryColumns[0].primaryKeyConstraintName) {\n      const columnNames = newTable.primaryColumns.map(column => column.name);\n      const oldPkName = this.connection.namingStrategy.primaryKeyName(oldTable, columnNames);\n      const newPkName = this.connection.namingStrategy.primaryKeyName(newTable, columnNames);\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT \"${oldPkName}\" TO \"${newPkName}\"`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT \"${newPkName}\" TO \"${oldPkName}\"`));\n    }\n    // rename sequences\n    newTable.columns.map(col => {\n      if (col.isGenerated && col.generationStrategy === \"increment\") {\n        const sequencePath = this.buildSequencePath(oldTable, col.name);\n        const sequenceName = this.buildSequenceName(oldTable, col.name);\n        const newSequencePath = this.buildSequencePath(newTable, col.name);\n        const newSequenceName = this.buildSequenceName(newTable, col.name);\n        const up = `ALTER SEQUENCE ${this.escapePath(sequencePath)} RENAME TO \"${newSequenceName}\"`;\n        const down = `ALTER SEQUENCE ${this.escapePath(newSequencePath)} RENAME TO \"${sequenceName}\"`;\n        upQueries.push(new Query(up));\n        downQueries.push(new Query(down));\n      }\n    });\n    // rename unique constraints\n    newTable.uniques.forEach(unique => {\n      const oldUniqueName = this.connection.namingStrategy.uniqueConstraintName(oldTable, unique.columnNames);\n      // Skip renaming if Unique has user defined constraint name\n      if (unique.name !== oldUniqueName) return;\n      // build new constraint name\n      const newUniqueName = this.connection.namingStrategy.uniqueConstraintName(newTable, unique.columnNames);\n      // build queries\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT \"${unique.name}\" TO \"${newUniqueName}\"`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT \"${newUniqueName}\" TO \"${unique.name}\"`));\n      // replace constraint name\n      unique.name = newUniqueName;\n    });\n    // rename index constraints\n    newTable.indices.forEach(index => {\n      const oldIndexName = this.connection.namingStrategy.indexName(oldTable, index.columnNames, index.where);\n      // Skip renaming if Index has user defined constraint name\n      if (index.name !== oldIndexName) return;\n      // build new constraint name\n      const {\n        schema\n      } = this.driver.parseTableName(newTable);\n      const newIndexName = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);\n      // build queries\n      const up = schema ? `ALTER INDEX \"${schema}\".\"${index.name}\" RENAME TO \"${newIndexName}\"` : `ALTER INDEX \"${index.name}\" RENAME TO \"${newIndexName}\"`;\n      const down = schema ? `ALTER INDEX \"${schema}\".\"${newIndexName}\" RENAME TO \"${index.name}\"` : `ALTER INDEX \"${newIndexName}\" RENAME TO \"${index.name}\"`;\n      upQueries.push(new Query(up));\n      downQueries.push(new Query(down));\n      // replace constraint name\n      index.name = newIndexName;\n    });\n    // rename foreign key constraints\n    newTable.foreignKeys.forEach(foreignKey => {\n      const oldForeignKeyName = this.connection.namingStrategy.foreignKeyName(oldTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n      // Skip renaming if foreign key has user defined constraint name\n      if (foreignKey.name !== oldForeignKeyName) return;\n      // build new constraint name\n      const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n      // build queries\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT \"${foreignKey.name}\" TO \"${newForeignKeyName}\"`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT \"${newForeignKeyName}\" TO \"${foreignKey.name}\"`));\n      // replace constraint name\n      foreignKey.name = newForeignKeyName;\n    });\n    // rename ENUM types\n    const enumColumns = newTable.columns.filter(column => column.type === \"enum\" || column.type === \"simple-enum\");\n    for (let column of enumColumns) {\n      // skip renaming for user-defined enum name\n      if (column.enumName) continue;\n      const oldEnumType = await this.getUserDefinedTypeName(oldTable, column);\n      upQueries.push(new Query(`ALTER TYPE \"${oldEnumType.schema}\".\"${oldEnumType.name}\" RENAME TO ${this.buildEnumName(newTable, column, false)}`));\n      downQueries.push(new Query(`ALTER TYPE ${this.buildEnumName(newTable, column)} RENAME TO \"${oldEnumType.name}\"`));\n    }\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Creates a new column from the column in the table.\n   */\n  async addColumn(tableOrName, column) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const clonedTable = table.clone();\n    const upQueries = [];\n    const downQueries = [];\n    if (column.type === \"enum\" || column.type === \"simple-enum\") {\n      const hasEnum = await this.hasEnumType(table, column);\n      if (!hasEnum) {\n        upQueries.push(this.createEnumTypeSql(table, column));\n        downQueries.push(this.dropEnumTypeSql(table, column));\n      }\n    }\n    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, column)}`));\n    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN \"${column.name}\"`));\n    // create or update primary key constraint\n    if (column.isPrimary) {\n      const primaryColumns = clonedTable.primaryColumns;\n      // if table already have primary key, me must drop it and recreate again\n      if (primaryColumns.length > 0) {\n        const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map(column => column.name));\n        const columnNames = primaryColumns.map(column => `\"${column.name}\"`).join(\", \");\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${pkName}\"`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`));\n      }\n      primaryColumns.push(column);\n      const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map(column => column.name));\n      const columnNames = primaryColumns.map(column => `\"${column.name}\"`).join(\", \");\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${pkName}\"`));\n    }\n    // create column index\n    const columnIndex = clonedTable.indices.find(index => index.columnNames.length === 1 && index.columnNames[0] === column.name);\n    if (columnIndex) {\n      upQueries.push(this.createIndexSql(table, columnIndex));\n      downQueries.push(this.dropIndexSql(table, columnIndex));\n    }\n    // create unique constraint\n    if (column.isUnique) {\n      const uniqueConstraint = new TableUnique({\n        name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),\n        columnNames: [column.name]\n      });\n      clonedTable.uniques.push(uniqueConstraint);\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${uniqueConstraint.name}\" UNIQUE (\"${column.name}\")`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${uniqueConstraint.name}\"`));\n    }\n    if (column.generatedType === \"STORED\" && column.asExpression) {\n      const tableNameWithSchema = (await this.getTableNameWithSchema(table.name)).split(\".\");\n      const tableName = tableNameWithSchema[1];\n      const schema = tableNameWithSchema[0];\n      const insertQuery = this.insertTypeormMetadataSql({\n        database: this.driver.database,\n        schema,\n        table: tableName,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name,\n        value: column.asExpression\n      });\n      const deleteQuery = this.deleteTypeormMetadataSql({\n        database: this.driver.database,\n        schema,\n        table: tableName,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name\n      });\n      upQueries.push(insertQuery);\n      downQueries.push(deleteQuery);\n    }\n    // create column's comment\n    if (column.comment) {\n      upQueries.push(new Query(`COMMENT ON COLUMN ${this.escapePath(table)}.\"${column.name}\" IS ${this.escapeComment(column.comment)}`));\n      downQueries.push(new Query(`COMMENT ON COLUMN ${this.escapePath(table)}.\"${column.name}\" IS ${this.escapeComment(column.comment)}`));\n    }\n    await this.executeQueries(upQueries, downQueries);\n    clonedTable.addColumn(column);\n    this.replaceCachedTable(table, clonedTable);\n  }\n  /**\n   * Creates a new columns from the column in the table.\n   */\n  async addColumns(tableOrName, columns) {\n    for (const column of columns) {\n      await this.addColumn(tableOrName, column);\n    }\n  }\n  /**\n   * Renames column in the given table.\n   */\n  async renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find(c => c.name === oldTableColumnOrName);\n    if (!oldColumn) throw new TypeORMError(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n    let newColumn;\n    if (InstanceChecker.isTableColumn(newTableColumnOrName)) {\n      newColumn = newTableColumnOrName;\n    } else {\n      newColumn = oldColumn.clone();\n      newColumn.name = newTableColumnOrName;\n    }\n    return this.changeColumn(table, oldColumn, newColumn);\n  }\n  /**\n   * Changes a column in the table.\n   */\n  async changeColumn(tableOrName, oldTableColumnOrName, newColumn) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    let clonedTable = table.clone();\n    const upQueries = [];\n    const downQueries = [];\n    let defaultValueChanged = false;\n    const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find(column => column.name === oldTableColumnOrName);\n    if (!oldColumn) throw new TypeORMError(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n    if (oldColumn.type !== newColumn.type || oldColumn.length !== newColumn.length || newColumn.isArray !== oldColumn.isArray || !oldColumn.generatedType && newColumn.generatedType === \"STORED\" || oldColumn.asExpression !== newColumn.asExpression && newColumn.generatedType === \"STORED\") {\n      // To avoid data conversion, we just recreate column\n      await this.dropColumn(table, oldColumn);\n      await this.addColumn(table, newColumn);\n      // update cloned table\n      clonedTable = table.clone();\n    } else {\n      if (oldColumn.name !== newColumn.name) {\n        // rename column\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME COLUMN \"${oldColumn.name}\" TO \"${newColumn.name}\"`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME COLUMN \"${newColumn.name}\" TO \"${oldColumn.name}\"`));\n        // rename ENUM type\n        if (oldColumn.type === \"enum\" || oldColumn.type === \"simple-enum\") {\n          const oldEnumType = await this.getUserDefinedTypeName(table, oldColumn);\n          upQueries.push(new Query(`ALTER TYPE \"${oldEnumType.schema}\".\"${oldEnumType.name}\" RENAME TO ${this.buildEnumName(table, newColumn, false)}`));\n          downQueries.push(new Query(`ALTER TYPE ${this.buildEnumName(table, newColumn)} RENAME TO \"${oldEnumType.name}\"`));\n        }\n        // rename column primary key constraint\n        if (oldColumn.isPrimary === true && !oldColumn.primaryKeyConstraintName) {\n          const primaryColumns = clonedTable.primaryColumns;\n          // build old primary constraint name\n          const columnNames = primaryColumns.map(column => column.name);\n          const oldPkName = this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);\n          // replace old column name with new column name\n          columnNames.splice(columnNames.indexOf(oldColumn.name), 1);\n          columnNames.push(newColumn.name);\n          // build new primary constraint name\n          const newPkName = this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT \"${oldPkName}\" TO \"${newPkName}\"`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT \"${newPkName}\" TO \"${oldPkName}\"`));\n        }\n        // rename column sequence\n        if (oldColumn.isGenerated === true && newColumn.generationStrategy === \"increment\") {\n          const sequencePath = this.buildSequencePath(table, oldColumn.name);\n          const sequenceName = this.buildSequenceName(table, oldColumn.name);\n          const newSequencePath = this.buildSequencePath(table, newColumn.name);\n          const newSequenceName = this.buildSequenceName(table, newColumn.name);\n          const up = `ALTER SEQUENCE ${this.escapePath(sequencePath)} RENAME TO \"${newSequenceName}\"`;\n          const down = `ALTER SEQUENCE ${this.escapePath(newSequencePath)} RENAME TO \"${sequenceName}\"`;\n          upQueries.push(new Query(up));\n          downQueries.push(new Query(down));\n        }\n        // rename unique constraints\n        clonedTable.findColumnUniques(oldColumn).forEach(unique => {\n          const oldUniqueName = this.connection.namingStrategy.uniqueConstraintName(clonedTable, unique.columnNames);\n          // Skip renaming if Unique has user defined constraint name\n          if (unique.name !== oldUniqueName) return;\n          // build new constraint name\n          unique.columnNames.splice(unique.columnNames.indexOf(oldColumn.name), 1);\n          unique.columnNames.push(newColumn.name);\n          const newUniqueName = this.connection.namingStrategy.uniqueConstraintName(clonedTable, unique.columnNames);\n          // build queries\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT \"${unique.name}\" TO \"${newUniqueName}\"`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT \"${newUniqueName}\" TO \"${unique.name}\"`));\n          // replace constraint name\n          unique.name = newUniqueName;\n        });\n        // rename index constraints\n        clonedTable.findColumnIndices(oldColumn).forEach(index => {\n          const oldIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);\n          // Skip renaming if Index has user defined constraint name\n          if (index.name !== oldIndexName) return;\n          // build new constraint name\n          index.columnNames.splice(index.columnNames.indexOf(oldColumn.name), 1);\n          index.columnNames.push(newColumn.name);\n          const {\n            schema\n          } = this.driver.parseTableName(table);\n          const newIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);\n          // build queries\n          const up = schema ? `ALTER INDEX \"${schema}\".\"${index.name}\" RENAME TO \"${newIndexName}\"` : `ALTER INDEX \"${index.name}\" RENAME TO \"${newIndexName}\"`;\n          const down = schema ? `ALTER INDEX \"${schema}\".\"${newIndexName}\" RENAME TO \"${index.name}\"` : `ALTER INDEX \"${newIndexName}\" RENAME TO \"${index.name}\"`;\n          upQueries.push(new Query(up));\n          downQueries.push(new Query(down));\n          // replace constraint name\n          index.name = newIndexName;\n        });\n        // rename foreign key constraints\n        clonedTable.findColumnForeignKeys(oldColumn).forEach(foreignKey => {\n          const foreignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n          // Skip renaming if foreign key has user defined constraint name\n          if (foreignKey.name !== foreignKeyName) return;\n          // build new constraint name\n          foreignKey.columnNames.splice(foreignKey.columnNames.indexOf(oldColumn.name), 1);\n          foreignKey.columnNames.push(newColumn.name);\n          const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n          // build queries\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT \"${foreignKey.name}\" TO \"${newForeignKeyName}\"`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT \"${newForeignKeyName}\" TO \"${foreignKey.name}\"`));\n          // replace constraint name\n          foreignKey.name = newForeignKeyName;\n        });\n        // rename old column in the Table object\n        const oldTableColumn = clonedTable.columns.find(column => column.name === oldColumn.name);\n        clonedTable.columns[clonedTable.columns.indexOf(oldTableColumn)].name = newColumn.name;\n        oldColumn.name = newColumn.name;\n      }\n      if (newColumn.precision !== oldColumn.precision || newColumn.scale !== oldColumn.scale) {\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${this.driver.createFullType(newColumn)}`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${this.driver.createFullType(oldColumn)}`));\n      }\n      if ((newColumn.type === \"enum\" || newColumn.type === \"simple-enum\") && (oldColumn.type === \"enum\" || oldColumn.type === \"simple-enum\") && (!OrmUtils.isArraysEqual(newColumn.enum, oldColumn.enum) || newColumn.enumName !== oldColumn.enumName)) {\n        const arraySuffix = newColumn.isArray ? \"[]\" : \"\";\n        // \"public\".\"new_enum\"\n        const newEnumName = this.buildEnumName(table, newColumn);\n        // \"public\".\"old_enum\"\n        const oldEnumName = this.buildEnumName(table, oldColumn);\n        // \"old_enum\"\n        const oldEnumNameWithoutSchema = this.buildEnumName(table, oldColumn, false);\n        //\"public\".\"old_enum_old\"\n        const oldEnumNameWithSchema_old = this.buildEnumName(table, oldColumn, true, false, true);\n        //\"old_enum_old\"\n        const oldEnumNameWithoutSchema_old = this.buildEnumName(table, oldColumn, false, false, true);\n        // rename old ENUM\n        upQueries.push(new Query(`ALTER TYPE ${oldEnumName} RENAME TO ${oldEnumNameWithoutSchema_old}`));\n        downQueries.push(new Query(`ALTER TYPE ${oldEnumNameWithSchema_old} RENAME TO ${oldEnumNameWithoutSchema}`));\n        // create new ENUM\n        upQueries.push(this.createEnumTypeSql(table, newColumn, newEnumName));\n        downQueries.push(this.dropEnumTypeSql(table, newColumn, newEnumName));\n        // if column have default value, we must drop it to avoid issues with type casting\n        if (oldColumn.default !== null && oldColumn.default !== undefined) {\n          // mark default as changed to prevent double update\n          defaultValueChanged = true;\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" DROP DEFAULT`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" SET DEFAULT ${oldColumn.default}`));\n        }\n        // build column types\n        const upType = `${newEnumName}${arraySuffix} USING \"${newColumn.name}\"::\"text\"::${newEnumName}${arraySuffix}`;\n        const downType = `${oldEnumNameWithSchema_old}${arraySuffix} USING \"${newColumn.name}\"::\"text\"::${oldEnumNameWithSchema_old}${arraySuffix}`;\n        // update column to use new type\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${upType}`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${downType}`));\n        // restore column default or create new one\n        if (newColumn.default !== null && newColumn.default !== undefined) {\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${newColumn.default}`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n        }\n        // remove old ENUM\n        upQueries.push(this.dropEnumTypeSql(table, oldColumn, oldEnumNameWithSchema_old));\n        downQueries.push(this.createEnumTypeSql(table, oldColumn, oldEnumNameWithSchema_old));\n      }\n      if (oldColumn.isNullable !== newColumn.isNullable) {\n        if (newColumn.isNullable) {\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" DROP NOT NULL`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" SET NOT NULL`));\n        } else {\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" SET NOT NULL`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" DROP NOT NULL`));\n        }\n      }\n      if (oldColumn.comment !== newColumn.comment) {\n        upQueries.push(new Query(`COMMENT ON COLUMN ${this.escapePath(table)}.\"${oldColumn.name}\" IS ${this.escapeComment(newColumn.comment)}`));\n        downQueries.push(new Query(`COMMENT ON COLUMN ${this.escapePath(table)}.\"${newColumn.name}\" IS ${this.escapeComment(oldColumn.comment)}`));\n      }\n      if (newColumn.isPrimary !== oldColumn.isPrimary) {\n        const primaryColumns = clonedTable.primaryColumns;\n        // if primary column state changed, we must always drop existed constraint.\n        if (primaryColumns.length > 0) {\n          const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map(column => column.name));\n          const columnNames = primaryColumns.map(column => `\"${column.name}\"`).join(\", \");\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${pkName}\"`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`));\n        }\n        if (newColumn.isPrimary === true) {\n          primaryColumns.push(newColumn);\n          // update column in table\n          const column = clonedTable.columns.find(column => column.name === newColumn.name);\n          column.isPrimary = true;\n          const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map(column => column.name));\n          const columnNames = primaryColumns.map(column => `\"${column.name}\"`).join(\", \");\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${pkName}\"`));\n        } else {\n          const primaryColumn = primaryColumns.find(c => c.name === newColumn.name);\n          primaryColumns.splice(primaryColumns.indexOf(primaryColumn), 1);\n          // update column in table\n          const column = clonedTable.columns.find(column => column.name === newColumn.name);\n          column.isPrimary = false;\n          // if we have another primary keys, we must recreate constraint.\n          if (primaryColumns.length > 0) {\n            const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map(column => column.name));\n            const columnNames = primaryColumns.map(column => `\"${column.name}\"`).join(\", \");\n            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`));\n            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${pkName}\"`));\n          }\n        }\n      }\n      if (newColumn.isUnique !== oldColumn.isUnique) {\n        if (newColumn.isUnique === true) {\n          const uniqueConstraint = new TableUnique({\n            name: this.connection.namingStrategy.uniqueConstraintName(table, [newColumn.name]),\n            columnNames: [newColumn.name]\n          });\n          clonedTable.uniques.push(uniqueConstraint);\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${uniqueConstraint.name}\" UNIQUE (\"${newColumn.name}\")`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${uniqueConstraint.name}\"`));\n        } else {\n          const uniqueConstraint = clonedTable.uniques.find(unique => {\n            return unique.columnNames.length === 1 && !!unique.columnNames.find(columnName => columnName === newColumn.name);\n          });\n          clonedTable.uniques.splice(clonedTable.uniques.indexOf(uniqueConstraint), 1);\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${uniqueConstraint.name}\"`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${uniqueConstraint.name}\" UNIQUE (\"${newColumn.name}\")`));\n        }\n      }\n      if (oldColumn.isGenerated !== newColumn.isGenerated) {\n        // if old column was \"generated\", we should clear defaults\n        if (oldColumn.isGenerated) {\n          if (oldColumn.generationStrategy === \"uuid\") {\n            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" DROP DEFAULT`));\n            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" SET DEFAULT ${this.driver.uuidGenerator}`));\n          } else if (oldColumn.generationStrategy === \"increment\") {\n            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT nextval('${this.escapePath(this.buildSequencePath(table, newColumn))}')`));\n            upQueries.push(new Query(`DROP SEQUENCE ${this.escapePath(this.buildSequencePath(table, newColumn))}`));\n            downQueries.push(new Query(`CREATE SEQUENCE IF NOT EXISTS ${this.escapePath(this.buildSequencePath(table, newColumn))} OWNED BY ${this.escapePath(table)}.\"${newColumn.name}\"`));\n          }\n        }\n        if (newColumn.generationStrategy === \"uuid\") {\n          if (newColumn.isGenerated === true) {\n            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${this.driver.uuidGenerator}`));\n            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n          } else {\n            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${this.driver.uuidGenerator}`));\n          }\n        } else if (newColumn.generationStrategy === \"increment\") {\n          if (newColumn.isGenerated === true) {\n            upQueries.push(new Query(`CREATE SEQUENCE IF NOT EXISTS ${this.escapePath(this.buildSequencePath(table, newColumn))} OWNED BY ${this.escapePath(table)}.\"${newColumn.name}\"`));\n            downQueries.push(new Query(`DROP SEQUENCE ${this.escapePath(this.buildSequencePath(table, newColumn))}`));\n            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT nextval('${this.escapePath(this.buildSequencePath(table, newColumn))}')`));\n            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n          } else {\n            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT nextval('${this.escapePath(this.buildSequencePath(table, newColumn))}')`));\n            upQueries.push(new Query(`DROP SEQUENCE ${this.escapePath(this.buildSequencePath(table, newColumn))}`));\n            downQueries.push(new Query(`CREATE SEQUENCE IF NOT EXISTS ${this.escapePath(this.buildSequencePath(table, newColumn))} OWNED BY ${this.escapePath(table)}.\"${newColumn.name}\"`));\n          }\n        }\n      }\n      // the default might have changed when the enum changed\n      if (newColumn.default !== oldColumn.default && !defaultValueChanged) {\n        if (newColumn.default !== null && newColumn.default !== undefined) {\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${newColumn.default}`));\n          if (oldColumn.default !== null && oldColumn.default !== undefined) {\n            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${oldColumn.default}`));\n          } else {\n            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n          }\n        } else if (oldColumn.default !== null && oldColumn.default !== undefined) {\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${oldColumn.default}`));\n        }\n      }\n      if ((newColumn.spatialFeatureType || \"\").toLowerCase() !== (oldColumn.spatialFeatureType || \"\").toLowerCase() || newColumn.srid !== oldColumn.srid) {\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${this.driver.createFullType(newColumn)}`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${this.driver.createFullType(oldColumn)}`));\n      }\n      if (newColumn.generatedType !== oldColumn.generatedType) {\n        // Convert generated column data to normal column\n        if (!newColumn.generatedType || newColumn.generatedType === \"VIRTUAL\") {\n          // We can copy the generated data to the new column\n          const tableNameWithSchema = (await this.getTableNameWithSchema(table.name)).split(\".\");\n          const tableName = tableNameWithSchema[1];\n          const schema = tableNameWithSchema[0];\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME COLUMN \"${oldColumn.name}\" TO \"TEMP_OLD_${oldColumn.name}\"`));\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, newColumn)}`));\n          upQueries.push(new Query(`UPDATE ${this.escapePath(table)} SET \"${newColumn.name}\" = \"TEMP_OLD_${oldColumn.name}\"`));\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN \"TEMP_OLD_${oldColumn.name}\"`));\n          upQueries.push(this.deleteTypeormMetadataSql({\n            database: this.driver.database,\n            schema,\n            table: tableName,\n            type: MetadataTableType.GENERATED_COLUMN,\n            name: oldColumn.name\n          }));\n          // However, we can't copy it back on downgrade. It needs to regenerate.\n          downQueries.push(this.insertTypeormMetadataSql({\n            database: this.driver.database,\n            schema,\n            table: tableName,\n            type: MetadataTableType.GENERATED_COLUMN,\n            name: oldColumn.name,\n            value: oldColumn.asExpression\n          }));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, oldColumn)}`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN \"${newColumn.name}\"`));\n          // downQueries.push(\n          //     this.deleteTypeormMetadataSql({\n          //         database: this.driver.database,\n          //         schema,\n          //         table: tableName,\n          //         type: MetadataTableType.GENERATED_COLUMN,\n          //         name: newColumn.name,\n          //     }),\n          // )\n        }\n      }\n    }\n    await this.executeQueries(upQueries, downQueries);\n    this.replaceCachedTable(table, clonedTable);\n  }\n  /**\n   * Changes a column in the table.\n   */\n  async changeColumns(tableOrName, changedColumns) {\n    for (const {\n      oldColumn,\n      newColumn\n    } of changedColumns) {\n      await this.changeColumn(tableOrName, oldColumn, newColumn);\n    }\n  }\n  /**\n   * Drops column in the table.\n   */\n  async dropColumn(tableOrName, columnOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const column = InstanceChecker.isTableColumn(columnOrName) ? columnOrName : table.findColumnByName(columnOrName);\n    if (!column) throw new TypeORMError(`Column \"${columnOrName}\" was not found in table \"${table.name}\"`);\n    const clonedTable = table.clone();\n    const upQueries = [];\n    const downQueries = [];\n    // drop primary key constraint\n    if (column.isPrimary) {\n      const pkName = column.primaryKeyConstraintName ? column.primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, clonedTable.primaryColumns.map(column => column.name));\n      const columnNames = clonedTable.primaryColumns.map(primaryColumn => `\"${primaryColumn.name}\"`).join(\", \");\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP CONSTRAINT \"${pkName}\"`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`));\n      // update column in table\n      const tableColumn = clonedTable.findColumnByName(column.name);\n      tableColumn.isPrimary = false;\n      // if primary key have multiple columns, we must recreate it without dropped column\n      if (clonedTable.primaryColumns.length > 0) {\n        const pkName = clonedTable.primaryColumns[0].primaryKeyConstraintName ? clonedTable.primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, clonedTable.primaryColumns.map(column => column.name));\n        const columnNames = clonedTable.primaryColumns.map(primaryColumn => `\"${primaryColumn.name}\"`).join(\", \");\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP CONSTRAINT \"${pkName}\"`));\n      }\n    }\n    // drop column index\n    const columnIndex = clonedTable.indices.find(index => index.columnNames.length === 1 && index.columnNames[0] === column.name);\n    if (columnIndex) {\n      clonedTable.indices.splice(clonedTable.indices.indexOf(columnIndex), 1);\n      upQueries.push(this.dropIndexSql(table, columnIndex));\n      downQueries.push(this.createIndexSql(table, columnIndex));\n    }\n    // drop column check\n    const columnCheck = clonedTable.checks.find(check => !!check.columnNames && check.columnNames.length === 1 && check.columnNames[0] === column.name);\n    if (columnCheck) {\n      clonedTable.checks.splice(clonedTable.checks.indexOf(columnCheck), 1);\n      upQueries.push(this.dropCheckConstraintSql(table, columnCheck));\n      downQueries.push(this.createCheckConstraintSql(table, columnCheck));\n    }\n    // drop column unique\n    const columnUnique = clonedTable.uniques.find(unique => unique.columnNames.length === 1 && unique.columnNames[0] === column.name);\n    if (columnUnique) {\n      clonedTable.uniques.splice(clonedTable.uniques.indexOf(columnUnique), 1);\n      upQueries.push(this.dropUniqueConstraintSql(table, columnUnique));\n      downQueries.push(this.createUniqueConstraintSql(table, columnUnique));\n    }\n    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN \"${column.name}\"`));\n    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, column)}`));\n    // drop enum type\n    if (column.type === \"enum\" || column.type === \"simple-enum\") {\n      const hasEnum = await this.hasEnumType(table, column);\n      if (hasEnum) {\n        const enumType = await this.getUserDefinedTypeName(table, column);\n        const escapedEnumName = `\"${enumType.schema}\".\"${enumType.name}\"`;\n        upQueries.push(this.dropEnumTypeSql(table, column, escapedEnumName));\n        downQueries.push(this.createEnumTypeSql(table, column, escapedEnumName));\n      }\n    }\n    if (column.generatedType === \"STORED\") {\n      const tableNameWithSchema = (await this.getTableNameWithSchema(table.name)).split(\".\");\n      const tableName = tableNameWithSchema[1];\n      const schema = tableNameWithSchema[0];\n      const deleteQuery = this.deleteTypeormMetadataSql({\n        database: this.driver.database,\n        schema,\n        table: tableName,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name\n      });\n      const insertQuery = this.insertTypeormMetadataSql({\n        database: this.driver.database,\n        schema,\n        table: tableName,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name,\n        value: column.asExpression\n      });\n      upQueries.push(deleteQuery);\n      downQueries.push(insertQuery);\n    }\n    await this.executeQueries(upQueries, downQueries);\n    clonedTable.removeColumn(column);\n    this.replaceCachedTable(table, clonedTable);\n  }\n  /**\n   * Drops the columns in the table.\n   */\n  async dropColumns(tableOrName, columns) {\n    for (const column of columns) {\n      await this.dropColumn(tableOrName, column);\n    }\n  }\n  /**\n   * Creates a new primary key.\n   */\n  async createPrimaryKey(tableOrName, columnNames, constraintName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const clonedTable = table.clone();\n    const up = this.createPrimaryKeySql(table, columnNames, constraintName);\n    // mark columns as primary, because dropPrimaryKeySql build constraint name from table primary column names.\n    clonedTable.columns.forEach(column => {\n      if (columnNames.find(columnName => columnName === column.name)) column.isPrimary = true;\n    });\n    const down = this.dropPrimaryKeySql(clonedTable);\n    await this.executeQueries(up, down);\n    this.replaceCachedTable(table, clonedTable);\n  }\n  /**\n   * Updates composite primary keys.\n   */\n  async updatePrimaryKeys(tableOrName, columns) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const clonedTable = table.clone();\n    const columnNames = columns.map(column => column.name);\n    const upQueries = [];\n    const downQueries = [];\n    // if table already have primary columns, we must drop them.\n    const primaryColumns = clonedTable.primaryColumns;\n    if (primaryColumns.length > 0) {\n      const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map(column => column.name));\n      const columnNamesString = primaryColumns.map(column => `\"${column.name}\"`).join(\", \");\n      upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${pkName}\"`));\n      downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNamesString})`));\n    }\n    // update columns in table.\n    clonedTable.columns.filter(column => columnNames.indexOf(column.name) !== -1).forEach(column => column.isPrimary = true);\n    const pkName = primaryColumns[0]?.primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);\n    const columnNamesString = columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNamesString})`));\n    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${pkName}\"`));\n    await this.executeQueries(upQueries, downQueries);\n    this.replaceCachedTable(table, clonedTable);\n  }\n  /**\n   * Drops a primary key.\n   */\n  async dropPrimaryKey(tableOrName, constraintName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const up = this.dropPrimaryKeySql(table);\n    const down = this.createPrimaryKeySql(table, table.primaryColumns.map(column => column.name), constraintName);\n    await this.executeQueries(up, down);\n    table.primaryColumns.forEach(column => {\n      column.isPrimary = false;\n    });\n  }\n  /**\n   * Creates new unique constraint.\n   */\n  async createUniqueConstraint(tableOrName, uniqueConstraint) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    // new unique constraint may be passed without name. In this case we generate unique name manually.\n    if (!uniqueConstraint.name) uniqueConstraint.name = this.connection.namingStrategy.uniqueConstraintName(table, uniqueConstraint.columnNames);\n    const up = this.createUniqueConstraintSql(table, uniqueConstraint);\n    const down = this.dropUniqueConstraintSql(table, uniqueConstraint);\n    await this.executeQueries(up, down);\n    table.addUniqueConstraint(uniqueConstraint);\n  }\n  /**\n   * Creates new unique constraints.\n   */\n  async createUniqueConstraints(tableOrName, uniqueConstraints) {\n    for (const uniqueConstraint of uniqueConstraints) {\n      await this.createUniqueConstraint(tableOrName, uniqueConstraint);\n    }\n  }\n  /**\n   * Drops unique constraint.\n   */\n  async dropUniqueConstraint(tableOrName, uniqueOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const uniqueConstraint = InstanceChecker.isTableUnique(uniqueOrName) ? uniqueOrName : table.uniques.find(u => u.name === uniqueOrName);\n    if (!uniqueConstraint) throw new TypeORMError(`Supplied unique constraint was not found in table ${table.name}`);\n    const up = this.dropUniqueConstraintSql(table, uniqueConstraint);\n    const down = this.createUniqueConstraintSql(table, uniqueConstraint);\n    await this.executeQueries(up, down);\n    table.removeUniqueConstraint(uniqueConstraint);\n  }\n  /**\n   * Drops unique constraints.\n   */\n  async dropUniqueConstraints(tableOrName, uniqueConstraints) {\n    for (const uniqueConstraint of uniqueConstraints) {\n      await this.dropUniqueConstraint(tableOrName, uniqueConstraint);\n    }\n  }\n  /**\n   * Creates new check constraint.\n   */\n  async createCheckConstraint(tableOrName, checkConstraint) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    // new unique constraint may be passed without name. In this case we generate unique name manually.\n    if (!checkConstraint.name) checkConstraint.name = this.connection.namingStrategy.checkConstraintName(table, checkConstraint.expression);\n    const up = this.createCheckConstraintSql(table, checkConstraint);\n    const down = this.dropCheckConstraintSql(table, checkConstraint);\n    await this.executeQueries(up, down);\n    table.addCheckConstraint(checkConstraint);\n  }\n  /**\n   * Creates new check constraints.\n   */\n  async createCheckConstraints(tableOrName, checkConstraints) {\n    const promises = checkConstraints.map(checkConstraint => this.createCheckConstraint(tableOrName, checkConstraint));\n    await Promise.all(promises);\n  }\n  /**\n   * Drops check constraint.\n   */\n  async dropCheckConstraint(tableOrName, checkOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const checkConstraint = InstanceChecker.isTableCheck(checkOrName) ? checkOrName : table.checks.find(c => c.name === checkOrName);\n    if (!checkConstraint) throw new TypeORMError(`Supplied check constraint was not found in table ${table.name}`);\n    const up = this.dropCheckConstraintSql(table, checkConstraint);\n    const down = this.createCheckConstraintSql(table, checkConstraint);\n    await this.executeQueries(up, down);\n    table.removeCheckConstraint(checkConstraint);\n  }\n  /**\n   * Drops check constraints.\n   */\n  async dropCheckConstraints(tableOrName, checkConstraints) {\n    const promises = checkConstraints.map(checkConstraint => this.dropCheckConstraint(tableOrName, checkConstraint));\n    await Promise.all(promises);\n  }\n  /**\n   * Creates new exclusion constraint.\n   */\n  async createExclusionConstraint(tableOrName, exclusionConstraint) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    // new unique constraint may be passed without name. In this case we generate unique name manually.\n    if (!exclusionConstraint.name) exclusionConstraint.name = this.connection.namingStrategy.exclusionConstraintName(table, exclusionConstraint.expression);\n    const up = this.createExclusionConstraintSql(table, exclusionConstraint);\n    const down = this.dropExclusionConstraintSql(table, exclusionConstraint);\n    await this.executeQueries(up, down);\n    table.addExclusionConstraint(exclusionConstraint);\n  }\n  /**\n   * Creates new exclusion constraints.\n   */\n  async createExclusionConstraints(tableOrName, exclusionConstraints) {\n    const promises = exclusionConstraints.map(exclusionConstraint => this.createExclusionConstraint(tableOrName, exclusionConstraint));\n    await Promise.all(promises);\n  }\n  /**\n   * Drops exclusion constraint.\n   */\n  async dropExclusionConstraint(tableOrName, exclusionOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const exclusionConstraint = InstanceChecker.isTableExclusion(exclusionOrName) ? exclusionOrName : table.exclusions.find(c => c.name === exclusionOrName);\n    if (!exclusionConstraint) throw new TypeORMError(`Supplied exclusion constraint was not found in table ${table.name}`);\n    const up = this.dropExclusionConstraintSql(table, exclusionConstraint);\n    const down = this.createExclusionConstraintSql(table, exclusionConstraint);\n    await this.executeQueries(up, down);\n    table.removeExclusionConstraint(exclusionConstraint);\n  }\n  /**\n   * Drops exclusion constraints.\n   */\n  async dropExclusionConstraints(tableOrName, exclusionConstraints) {\n    const promises = exclusionConstraints.map(exclusionConstraint => this.dropExclusionConstraint(tableOrName, exclusionConstraint));\n    await Promise.all(promises);\n  }\n  /**\n   * Creates a new foreign key.\n   */\n  async createForeignKey(tableOrName, foreignKey) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    // new FK may be passed without name. In this case we generate FK name manually.\n    if (!foreignKey.name) foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n    const up = this.createForeignKeySql(table, foreignKey);\n    const down = this.dropForeignKeySql(table, foreignKey);\n    await this.executeQueries(up, down);\n    table.addForeignKey(foreignKey);\n  }\n  /**\n   * Creates a new foreign keys.\n   */\n  async createForeignKeys(tableOrName, foreignKeys) {\n    for (const foreignKey of foreignKeys) {\n      await this.createForeignKey(tableOrName, foreignKey);\n    }\n  }\n  /**\n   * Drops a foreign key from the table.\n   */\n  async dropForeignKey(tableOrName, foreignKeyOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const foreignKey = InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName : table.foreignKeys.find(fk => fk.name === foreignKeyOrName);\n    if (!foreignKey) throw new TypeORMError(`Supplied foreign key was not found in table ${table.name}`);\n    if (!foreignKey.name) {\n      foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n    }\n    const up = this.dropForeignKeySql(table, foreignKey);\n    const down = this.createForeignKeySql(table, foreignKey);\n    await this.executeQueries(up, down);\n    table.removeForeignKey(foreignKey);\n  }\n  /**\n   * Drops a foreign keys from the table.\n   */\n  async dropForeignKeys(tableOrName, foreignKeys) {\n    for (const foreignKey of foreignKeys) {\n      await this.dropForeignKey(tableOrName, foreignKey);\n    }\n  }\n  /**\n   * Creates a new index.\n   */\n  async createIndex(tableOrName, index) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    // new index may be passed without name. In this case we generate index name manually.\n    if (!index.name) index.name = this.generateIndexName(table, index);\n    const up = this.createIndexSql(table, index);\n    const down = this.dropIndexSql(table, index);\n    await this.executeQueries(up, down);\n    table.addIndex(index);\n  }\n  /**\n   * Create a new view index.\n   */\n  async createViewIndex(viewOrName, index) {\n    const view = InstanceChecker.isView(viewOrName) ? viewOrName : await this.getCachedView(viewOrName);\n    // new index may be passed without name. In this case we generate index name manually.\n    if (!index.name) index.name = this.generateIndexName(view, index);\n    const up = this.createViewIndexSql(view, index);\n    const down = this.dropIndexSql(view, index);\n    await this.executeQueries(up, down);\n    view.addIndex(index);\n  }\n  /**\n   * Creates a new indices\n   */\n  async createIndices(tableOrName, indices) {\n    for (const index of indices) {\n      await this.createIndex(tableOrName, index);\n    }\n  }\n  /**\n   * Creates new view indices\n   */\n  async createViewIndices(viewOrName, indices) {\n    for (const index of indices) {\n      await this.createViewIndex(viewOrName, index);\n    }\n  }\n  /**\n   * Drops an index from the table.\n   */\n  async dropIndex(tableOrName, indexOrName) {\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    const index = InstanceChecker.isTableIndex(indexOrName) ? indexOrName : table.indices.find(i => i.name === indexOrName);\n    if (!index) throw new TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`);\n    // old index may be passed without name. In this case we generate index name manually.\n    if (!index.name) index.name = this.generateIndexName(table, index);\n    const up = this.dropIndexSql(table, index);\n    const down = this.createIndexSql(table, index);\n    await this.executeQueries(up, down);\n    table.removeIndex(index);\n  }\n  /**\n   * Drops an index from a view.\n   */\n  async dropViewIndex(viewOrName, indexOrName) {\n    const view = InstanceChecker.isView(viewOrName) ? viewOrName : await this.getCachedView(viewOrName);\n    const index = InstanceChecker.isTableIndex(indexOrName) ? indexOrName : view.indices.find(i => i.name === indexOrName);\n    if (!index) throw new TypeORMError(`Supplied index ${indexOrName} was not found in view ${view.name}`);\n    // old index may be passed without name. In this case we generate index name manually.\n    if (!index.name) index.name = this.generateIndexName(view, index);\n    const up = this.dropIndexSql(view, index);\n    const down = this.createViewIndexSql(view, index);\n    await this.executeQueries(up, down);\n    view.removeIndex(index);\n  }\n  /**\n   * Drops an indices from the table.\n   */\n  async dropIndices(tableOrName, indices) {\n    for (const index of indices) {\n      await this.dropIndex(tableOrName, index);\n    }\n  }\n  /**\n   * Clears all table contents.\n   * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.\n   */\n  async clearTable(tableName) {\n    await this.query(`TRUNCATE TABLE ${this.escapePath(tableName)}`);\n  }\n  /**\n   * Removes all tables from the currently connected database.\n   */\n  async clearDatabase() {\n    const schemas = [];\n    this.connection.entityMetadatas.filter(metadata => metadata.schema).forEach(metadata => {\n      const isSchemaExist = !!schemas.find(schema => schema === metadata.schema);\n      if (!isSchemaExist) schemas.push(metadata.schema);\n    });\n    schemas.push(this.driver.options.schema || \"current_schema()\");\n    const schemaNamesString = schemas.map(name => {\n      return name === \"current_schema()\" ? name : \"'\" + name + \"'\";\n    }).join(\", \");\n    const isAnotherTransactionActive = this.isTransactionActive;\n    if (!isAnotherTransactionActive) await this.startTransaction();\n    try {\n      const version = await this.getVersion();\n      // drop views\n      const selectViewDropsQuery = `SELECT 'DROP VIEW IF EXISTS \"' || schemaname || '\".\"' || viewname || '\" CASCADE;' as \"query\" ` + `FROM \"pg_views\" WHERE \"schemaname\" IN (${schemaNamesString}) AND \"viewname\" NOT IN ('geography_columns', 'geometry_columns', 'raster_columns', 'raster_overviews')`;\n      const dropViewQueries = await this.query(selectViewDropsQuery);\n      await Promise.all(dropViewQueries.map(q => this.query(q[\"query\"])));\n      // drop materialized views\n      // Note: materialized views introduced in Postgres 9.3\n      if (VersionUtils.isGreaterOrEqual(version, \"9.3\")) {\n        const selectMatViewDropsQuery = `SELECT 'DROP MATERIALIZED VIEW IF EXISTS \"' || schemaname || '\".\"' || matviewname || '\" CASCADE;' as \"query\" ` + `FROM \"pg_matviews\" WHERE \"schemaname\" IN (${schemaNamesString})`;\n        const dropMatViewQueries = await this.query(selectMatViewDropsQuery);\n        await Promise.all(dropMatViewQueries.map(q => this.query(q[\"query\"])));\n      }\n      // ignore spatial_ref_sys; it's a special table supporting PostGIS\n      // TODO generalize this as this.driver.ignoreTables\n      // drop tables\n      const selectTableDropsQuery = `SELECT 'DROP TABLE IF EXISTS \"' || schemaname || '\".\"' || tablename || '\" CASCADE;' as \"query\" FROM \"pg_tables\" WHERE \"schemaname\" IN (${schemaNamesString}) AND \"tablename\" NOT IN ('spatial_ref_sys')`;\n      const dropTableQueries = await this.query(selectTableDropsQuery);\n      await Promise.all(dropTableQueries.map(q => this.query(q[\"query\"])));\n      // drop enum types\n      await this.dropEnumTypes(schemaNamesString);\n      if (!isAnotherTransactionActive) {\n        await this.commitTransaction();\n      }\n    } catch (error) {\n      try {\n        // we throw original error even if rollback thrown an error\n        if (!isAnotherTransactionActive) {\n          await this.rollbackTransaction();\n        }\n      } catch (rollbackError) {}\n      throw error;\n    }\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  async loadViews(viewNames) {\n    const hasTable = await this.hasTable(this.getTypeormMetadataTableName());\n    if (!hasTable) return [];\n    if (!viewNames) {\n      viewNames = [];\n    }\n    const currentDatabase = await this.getCurrentDatabase();\n    const currentSchema = await this.getCurrentSchema();\n    const viewsCondition = viewNames.length === 0 ? \"1=1\" : viewNames.map(tableName => this.driver.parseTableName(tableName)).map(({\n      schema,\n      tableName\n    }) => {\n      if (!schema) {\n        schema = this.driver.options.schema || currentSchema;\n      }\n      return `(\"t\".\"schema\" = '${schema}' AND \"t\".\"name\" = '${tableName}')`;\n    }).join(\" OR \");\n    const constraintsCondition = viewNames.length === 0 ? \"1=1\" : viewNames.map(tableName => this.driver.parseTableName(tableName)).map(({\n      schema,\n      tableName\n    }) => {\n      if (!schema) {\n        schema = this.driver.options.schema || currentSchema;\n      }\n      return `(\"ns\".\"nspname\" = '${schema}' AND \"t\".\"relname\" = '${tableName}')`;\n    }).join(\" OR \");\n    const indicesSql = `SELECT \"ns\".\"nspname\" AS \"table_schema\", \"t\".\"relname\" AS \"table_name\", \"i\".\"relname\" AS \"constraint_name\", \"a\".\"attname\" AS \"column_name\", ` + `CASE \"ix\".\"indisunique\" WHEN 't' THEN 'TRUE' ELSE'FALSE' END AS \"is_unique\", pg_get_expr(\"ix\".\"indpred\", \"ix\".\"indrelid\") AS \"condition\", ` + `\"types\".\"typname\" AS \"type_name\" ` + `FROM \"pg_class\" \"t\" ` + `INNER JOIN \"pg_index\" \"ix\" ON \"ix\".\"indrelid\" = \"t\".\"oid\" ` + `INNER JOIN \"pg_attribute\" \"a\" ON \"a\".\"attrelid\" = \"t\".\"oid\"  AND \"a\".\"attnum\" = ANY (\"ix\".\"indkey\") ` + `INNER JOIN \"pg_namespace\" \"ns\" ON \"ns\".\"oid\" = \"t\".\"relnamespace\" ` + `INNER JOIN \"pg_class\" \"i\" ON \"i\".\"oid\" = \"ix\".\"indexrelid\" ` + `INNER JOIN \"pg_type\" \"types\" ON \"types\".\"oid\" = \"a\".\"atttypid\" ` + `LEFT JOIN \"pg_constraint\" \"cnst\" ON \"cnst\".\"conname\" = \"i\".\"relname\" ` + `WHERE \"t\".\"relkind\" IN ('m') AND \"cnst\".\"contype\" IS NULL AND (${constraintsCondition})`;\n    const query = `SELECT \"t\".* FROM ${this.escapePath(this.getTypeormMetadataTableName())} \"t\" ` + `INNER JOIN \"pg_catalog\".\"pg_class\" \"c\" ON \"c\".\"relname\" = \"t\".\"name\" ` + `INNER JOIN \"pg_namespace\" \"n\" ON \"n\".\"oid\" = \"c\".\"relnamespace\" AND \"n\".\"nspname\" = \"t\".\"schema\" ` + `WHERE \"t\".\"type\" IN ('${MetadataTableType.VIEW}', '${MetadataTableType.MATERIALIZED_VIEW}') ${viewsCondition ? `AND (${viewsCondition})` : \"\"}`;\n    const dbViews = await this.query(query);\n    const dbIndices = await this.query(indicesSql);\n    return dbViews.map(dbView => {\n      // find index constraints of table, group them by constraint name and build TableIndex.\n      const tableIndexConstraints = OrmUtils.uniq(dbIndices.filter(dbIndex => {\n        return dbIndex[\"table_name\"] === dbView[\"name\"] && dbIndex[\"table_schema\"] === dbView[\"schema\"];\n      }), dbIndex => dbIndex[\"constraint_name\"]);\n      const view = new View();\n      const schema = dbView[\"schema\"] === currentSchema && !this.driver.options.schema ? undefined : dbView[\"schema\"];\n      view.database = currentDatabase;\n      view.schema = dbView[\"schema\"];\n      view.name = this.driver.buildTableName(dbView[\"name\"], schema);\n      view.expression = dbView[\"value\"];\n      view.materialized = dbView[\"type\"] === MetadataTableType.MATERIALIZED_VIEW;\n      view.indices = tableIndexConstraints.map(constraint => {\n        const indices = dbIndices.filter(index => {\n          return index[\"table_schema\"] === constraint[\"table_schema\"] && index[\"table_name\"] === constraint[\"table_name\"] && index[\"constraint_name\"] === constraint[\"constraint_name\"];\n        });\n        return new TableIndex({\n          view: view,\n          name: constraint[\"constraint_name\"],\n          columnNames: indices.map(i => i[\"column_name\"]),\n          isUnique: constraint[\"is_unique\"] === \"TRUE\",\n          where: constraint[\"condition\"],\n          isFulltext: false\n        });\n      });\n      return view;\n    });\n  }\n  /**\n   * Loads all tables (with given names) from the database and creates a Table from them.\n   */\n  async loadTables(tableNames) {\n    // if no tables given then no need to proceed\n    if (tableNames && tableNames.length === 0) {\n      return [];\n    }\n    const currentSchema = await this.getCurrentSchema();\n    const currentDatabase = await this.getCurrentDatabase();\n    const dbTables = [];\n    if (!tableNames) {\n      const tablesSql = `SELECT \"table_schema\", \"table_name\", obj_description(('\"' || \"table_schema\" || '\".\"' || \"table_name\" || '\"')::regclass, 'pg_class') AS table_comment FROM \"information_schema\".\"tables\"`;\n      dbTables.push(...(await this.query(tablesSql)));\n    } else {\n      const tablesCondition = tableNames.map(tableName => this.driver.parseTableName(tableName)).map(({\n        schema,\n        tableName\n      }) => {\n        return `(\"table_schema\" = '${schema || currentSchema}' AND \"table_name\" = '${tableName}')`;\n      }).join(\" OR \");\n      const tablesSql = `SELECT \"table_schema\", \"table_name\", obj_description(('\"' || \"table_schema\" || '\".\"' || \"table_name\" || '\"')::regclass, 'pg_class') AS table_comment FROM \"information_schema\".\"tables\" WHERE ` + tablesCondition;\n      dbTables.push(...(await this.query(tablesSql)));\n    }\n    // if tables were not found in the db, no need to proceed\n    if (dbTables.length === 0) {\n      return [];\n    }\n    /**\n     * Uses standard SQL information_schema.columns table and postgres-specific\n     * pg_catalog.pg_attribute table to get column information.\n     * @see https://stackoverflow.com/a/19541865\n     */\n    const columnsCondition = dbTables.map(({\n      table_schema,\n      table_name\n    }) => {\n      return `(\"table_schema\" = '${table_schema}' AND \"table_name\" = '${table_name}')`;\n    }).join(\" OR \");\n    const columnsSql = `SELECT columns.*, pg_catalog.col_description(('\"' || table_catalog || '\".\"' || table_schema || '\".\"' || table_name || '\"')::regclass::oid, ordinal_position) AS description, ` + `('\"' || \"udt_schema\" || '\".\"' || \"udt_name\" || '\"')::\"regtype\" AS \"regtype\", pg_catalog.format_type(\"col_attr\".\"atttypid\", \"col_attr\".\"atttypmod\") AS \"format_type\" ` + `FROM \"information_schema\".\"columns\" ` + `LEFT JOIN \"pg_catalog\".\"pg_attribute\" AS \"col_attr\" ON \"col_attr\".\"attname\" = \"columns\".\"column_name\" ` + `AND \"col_attr\".\"attrelid\" = ( ` + `SELECT \"cls\".\"oid\" FROM \"pg_catalog\".\"pg_class\" AS \"cls\" ` + `LEFT JOIN \"pg_catalog\".\"pg_namespace\" AS \"ns\" ON \"ns\".\"oid\" = \"cls\".\"relnamespace\" ` + `WHERE \"cls\".\"relname\" = \"columns\".\"table_name\" ` + `AND \"ns\".\"nspname\" = \"columns\".\"table_schema\" ` + `) ` + `WHERE ` + columnsCondition;\n    const constraintsCondition = dbTables.map(({\n      table_schema,\n      table_name\n    }) => {\n      return `(\"ns\".\"nspname\" = '${table_schema}' AND \"t\".\"relname\" = '${table_name}')`;\n    }).join(\" OR \");\n    const constraintsSql = `SELECT \"ns\".\"nspname\" AS \"table_schema\", \"t\".\"relname\" AS \"table_name\", \"cnst\".\"conname\" AS \"constraint_name\", ` + `pg_get_constraintdef(\"cnst\".\"oid\") AS \"expression\", ` + `CASE \"cnst\".\"contype\" WHEN 'p' THEN 'PRIMARY' WHEN 'u' THEN 'UNIQUE' WHEN 'c' THEN 'CHECK' WHEN 'x' THEN 'EXCLUDE' END AS \"constraint_type\", \"a\".\"attname\" AS \"column_name\" ` + `FROM \"pg_constraint\" \"cnst\" ` + `INNER JOIN \"pg_class\" \"t\" ON \"t\".\"oid\" = \"cnst\".\"conrelid\" ` + `INNER JOIN \"pg_namespace\" \"ns\" ON \"ns\".\"oid\" = \"cnst\".\"connamespace\" ` + `LEFT JOIN \"pg_attribute\" \"a\" ON \"a\".\"attrelid\" = \"cnst\".\"conrelid\" AND \"a\".\"attnum\" = ANY (\"cnst\".\"conkey\") ` + `WHERE \"t\".\"relkind\" IN ('r', 'p') AND (${constraintsCondition})`;\n    const indicesSql = `SELECT \"ns\".\"nspname\" AS \"table_schema\", \"t\".\"relname\" AS \"table_name\", \"i\".\"relname\" AS \"constraint_name\", \"a\".\"attname\" AS \"column_name\", ` + `CASE \"ix\".\"indisunique\" WHEN 't' THEN 'TRUE' ELSE'FALSE' END AS \"is_unique\", pg_get_expr(\"ix\".\"indpred\", \"ix\".\"indrelid\") AS \"condition\", ` + `\"types\".\"typname\" AS \"type_name\", \"am\".\"amname\" AS \"index_type\" ` + `FROM \"pg_class\" \"t\" ` + `INNER JOIN \"pg_index\" \"ix\" ON \"ix\".\"indrelid\" = \"t\".\"oid\" ` + `INNER JOIN \"pg_attribute\" \"a\" ON \"a\".\"attrelid\" = \"t\".\"oid\"  AND \"a\".\"attnum\" = ANY (\"ix\".\"indkey\") ` + `INNER JOIN \"pg_namespace\" \"ns\" ON \"ns\".\"oid\" = \"t\".\"relnamespace\" ` + `INNER JOIN \"pg_class\" \"i\" ON \"i\".\"oid\" = \"ix\".\"indexrelid\" ` + `INNER JOIN \"pg_type\" \"types\" ON \"types\".\"oid\" = \"a\".\"atttypid\" ` + `INNER JOIN \"pg_am\" \"am\" ON \"i\".\"relam\" = \"am\".\"oid\" ` + `LEFT JOIN \"pg_constraint\" \"cnst\" ON \"cnst\".\"conname\" = \"i\".\"relname\" ` + `WHERE \"t\".\"relkind\" IN ('r', 'p') AND \"cnst\".\"contype\" IS NULL AND (${constraintsCondition})`;\n    const foreignKeysCondition = dbTables.map(({\n      table_schema,\n      table_name\n    }) => {\n      return `(\"ns\".\"nspname\" = '${table_schema}' AND \"cl\".\"relname\" = '${table_name}')`;\n    }).join(\" OR \");\n    const hasRelispartitionColumn = await this.hasSupportForPartitionedTables();\n    const isPartitionCondition = hasRelispartitionColumn ? ` AND \"cl\".\"relispartition\" = 'f'` : \"\";\n    const foreignKeysSql = `SELECT \"con\".\"conname\" AS \"constraint_name\", \"con\".\"nspname\" AS \"table_schema\", \"con\".\"relname\" AS \"table_name\", \"att2\".\"attname\" AS \"column_name\", ` + `\"ns\".\"nspname\" AS \"referenced_table_schema\", \"cl\".\"relname\" AS \"referenced_table_name\", \"att\".\"attname\" AS \"referenced_column_name\", \"con\".\"confdeltype\" AS \"on_delete\", ` + `\"con\".\"confupdtype\" AS \"on_update\", \"con\".\"condeferrable\" AS \"deferrable\", \"con\".\"condeferred\" AS \"deferred\" ` + `FROM ( ` + `SELECT UNNEST (\"con1\".\"conkey\") AS \"parent\", UNNEST (\"con1\".\"confkey\") AS \"child\", \"con1\".\"confrelid\", \"con1\".\"conrelid\", \"con1\".\"conname\", \"con1\".\"contype\", \"ns\".\"nspname\", ` + `\"cl\".\"relname\", \"con1\".\"condeferrable\", ` + `CASE WHEN \"con1\".\"condeferred\" THEN 'INITIALLY DEFERRED' ELSE 'INITIALLY IMMEDIATE' END as condeferred, ` + `CASE \"con1\".\"confdeltype\" WHEN 'a' THEN 'NO ACTION' WHEN 'r' THEN 'RESTRICT' WHEN 'c' THEN 'CASCADE' WHEN 'n' THEN 'SET NULL' WHEN 'd' THEN 'SET DEFAULT' END as \"confdeltype\", ` + `CASE \"con1\".\"confupdtype\" WHEN 'a' THEN 'NO ACTION' WHEN 'r' THEN 'RESTRICT' WHEN 'c' THEN 'CASCADE' WHEN 'n' THEN 'SET NULL' WHEN 'd' THEN 'SET DEFAULT' END as \"confupdtype\" ` + `FROM \"pg_class\" \"cl\" ` + `INNER JOIN \"pg_namespace\" \"ns\" ON \"cl\".\"relnamespace\" = \"ns\".\"oid\" ` + `INNER JOIN \"pg_constraint\" \"con1\" ON \"con1\".\"conrelid\" = \"cl\".\"oid\" ` + `WHERE \"con1\".\"contype\" = 'f' AND (${foreignKeysCondition}) ` + `) \"con\" ` + `INNER JOIN \"pg_attribute\" \"att\" ON \"att\".\"attrelid\" = \"con\".\"confrelid\" AND \"att\".\"attnum\" = \"con\".\"child\" ` + `INNER JOIN \"pg_class\" \"cl\" ON \"cl\".\"oid\" = \"con\".\"confrelid\" ${isPartitionCondition}` + `INNER JOIN \"pg_namespace\" \"ns\" ON \"cl\".\"relnamespace\" = \"ns\".\"oid\" ` + `INNER JOIN \"pg_attribute\" \"att2\" ON \"att2\".\"attrelid\" = \"con\".\"conrelid\" AND \"att2\".\"attnum\" = \"con\".\"parent\"`;\n    const [dbColumns, dbConstraints, dbIndices, dbForeignKeys] = await Promise.all([this.query(columnsSql), this.query(constraintsSql), this.query(indicesSql), this.query(foreignKeysSql)]);\n    // create tables for loaded tables\n    return Promise.all(dbTables.map(async dbTable => {\n      const table = new Table();\n      const getSchemaFromKey = (dbObject, key) => {\n        return dbObject[key] === currentSchema && (!this.driver.options.schema || this.driver.options.schema === currentSchema) ? undefined : dbObject[key];\n      };\n      // We do not need to join schema name, when database is by default.\n      const schema = getSchemaFromKey(dbTable, \"table_schema\");\n      table.database = currentDatabase;\n      table.schema = dbTable[\"table_schema\"];\n      table.comment = dbTable[\"table_comment\"];\n      table.name = this.driver.buildTableName(dbTable[\"table_name\"], schema);\n      // create columns from the loaded columns\n      table.columns = await Promise.all(dbColumns.filter(dbColumn => dbColumn[\"table_name\"] === dbTable[\"table_name\"] && dbColumn[\"table_schema\"] === dbTable[\"table_schema\"]).map(async dbColumn => {\n        const columnConstraints = dbConstraints.filter(dbConstraint => {\n          return dbConstraint[\"table_name\"] === dbColumn[\"table_name\"] && dbConstraint[\"table_schema\"] === dbColumn[\"table_schema\"] && dbConstraint[\"column_name\"] === dbColumn[\"column_name\"];\n        });\n        const tableColumn = new TableColumn();\n        tableColumn.name = dbColumn[\"column_name\"];\n        tableColumn.type = dbColumn[\"regtype\"].toLowerCase();\n        if (tableColumn.type === \"numeric\" || tableColumn.type === \"numeric[]\" || tableColumn.type === \"decimal\" || tableColumn.type === \"float\") {\n          let numericPrecision = dbColumn[\"numeric_precision\"];\n          let numericScale = dbColumn[\"numeric_scale\"];\n          if (dbColumn[\"data_type\"] === \"ARRAY\") {\n            const numericSize = dbColumn[\"format_type\"].match(/^numeric\\(([0-9]+),([0-9]+)\\)\\[\\]$/);\n            if (numericSize) {\n              numericPrecision = +numericSize[1];\n              numericScale = +numericSize[2];\n            }\n          }\n          // If one of these properties was set, and another was not, Postgres sets '0' in to unspecified property\n          // we set 'undefined' in to unspecified property to avoid changing column on sync\n          if (numericPrecision !== null && !this.isDefaultColumnPrecision(table, tableColumn, numericPrecision)) {\n            tableColumn.precision = numericPrecision;\n          } else if (numericScale !== null && !this.isDefaultColumnScale(table, tableColumn, numericScale)) {\n            tableColumn.precision = undefined;\n          }\n          if (numericScale !== null && !this.isDefaultColumnScale(table, tableColumn, numericScale)) {\n            tableColumn.scale = numericScale;\n          } else if (numericPrecision !== null && !this.isDefaultColumnPrecision(table, tableColumn, numericPrecision)) {\n            tableColumn.scale = undefined;\n          }\n        }\n        if (tableColumn.type === \"interval\" || tableColumn.type === \"time without time zone\" || tableColumn.type === \"time with time zone\" || tableColumn.type === \"timestamp without time zone\" || tableColumn.type === \"timestamp with time zone\") {\n          tableColumn.precision = !this.isDefaultColumnPrecision(table, tableColumn, dbColumn[\"datetime_precision\"]) ? dbColumn[\"datetime_precision\"] : undefined;\n        }\n        // check if column has user-defined data type.\n        // NOTE: if ENUM type defined with \"array:true\" it comes with ARRAY type instead of USER-DEFINED\n        if (dbColumn[\"data_type\"] === \"USER-DEFINED\" || dbColumn[\"data_type\"] === \"ARRAY\") {\n          const {\n            name\n          } = await this.getUserDefinedTypeName(table, tableColumn);\n          // check if `enumName` is specified by user\n          const builtEnumName = this.buildEnumName(table, tableColumn, false, true);\n          const enumName = builtEnumName !== name ? name : undefined;\n          // check if type is ENUM\n          const sql = `SELECT \"e\".\"enumlabel\" AS \"value\" FROM \"pg_enum\" \"e\" ` + `INNER JOIN \"pg_type\" \"t\" ON \"t\".\"oid\" = \"e\".\"enumtypid\" ` + `INNER JOIN \"pg_namespace\" \"n\" ON \"n\".\"oid\" = \"t\".\"typnamespace\" ` + `WHERE \"n\".\"nspname\" = '${dbTable[\"table_schema\"]}' AND \"t\".\"typname\" = '${enumName || name}'`;\n          const results = await this.query(sql);\n          if (results.length) {\n            tableColumn.type = \"enum\";\n            tableColumn.enum = results.map(result => result[\"value\"]);\n            tableColumn.enumName = enumName;\n          }\n          if (dbColumn[\"data_type\"] === \"ARRAY\") {\n            tableColumn.isArray = true;\n            const type = tableColumn.type.replace(\"[]\", \"\");\n            tableColumn.type = this.connection.driver.normalizeType({\n              type: type\n            });\n          }\n        }\n        if (tableColumn.type === \"geometry\" || tableColumn.type === \"geography\") {\n          const sql = `SELECT * FROM (` + `SELECT \"f_table_schema\" \"table_schema\", \"f_table_name\" \"table_name\", ` + `\"f_${tableColumn.type}_column\" \"column_name\", \"srid\", \"type\" ` + `FROM \"${tableColumn.type}_columns\"` + `) AS _ ` + `WHERE \"column_name\" = '${dbColumn[\"column_name\"]}' AND ` + `\"table_schema\" = '${dbColumn[\"table_schema\"]}' AND ` + `\"table_name\" = '${dbColumn[\"table_name\"]}'`;\n          const results = await this.query(sql);\n          if (results.length > 0) {\n            tableColumn.spatialFeatureType = results[0].type;\n            tableColumn.srid = results[0].srid;\n          }\n        }\n        // check only columns that have length property\n        if (this.driver.withLengthColumnTypes.indexOf(tableColumn.type) !== -1) {\n          let length;\n          if (tableColumn.isArray) {\n            const match = /\\((\\d+)\\)/.exec(dbColumn[\"format_type\"]);\n            length = match ? match[1] : undefined;\n          } else if (dbColumn[\"character_maximum_length\"]) {\n            length = dbColumn[\"character_maximum_length\"].toString();\n          }\n          if (length) {\n            tableColumn.length = !this.isDefaultColumnLength(table, tableColumn, length) ? length : \"\";\n          }\n        }\n        tableColumn.isNullable = dbColumn[\"is_nullable\"] === \"YES\";\n        const primaryConstraint = columnConstraints.find(constraint => constraint[\"constraint_type\"] === \"PRIMARY\");\n        if (primaryConstraint) {\n          tableColumn.isPrimary = true;\n          // find another columns involved in primary key constraint\n          const anotherPrimaryConstraints = dbConstraints.filter(constraint => constraint[\"table_name\"] === dbColumn[\"table_name\"] && constraint[\"table_schema\"] === dbColumn[\"table_schema\"] && constraint[\"column_name\"] !== dbColumn[\"column_name\"] && constraint[\"constraint_type\"] === \"PRIMARY\");\n          // collect all column names\n          const columnNames = anotherPrimaryConstraints.map(constraint => constraint[\"column_name\"]);\n          columnNames.push(dbColumn[\"column_name\"]);\n          // build default primary key constraint name\n          const pkName = this.connection.namingStrategy.primaryKeyName(table, columnNames);\n          // if primary key has user-defined constraint name, write it in table column\n          if (primaryConstraint[\"constraint_name\"] !== pkName) {\n            tableColumn.primaryKeyConstraintName = primaryConstraint[\"constraint_name\"];\n          }\n        }\n        const uniqueConstraints = columnConstraints.filter(constraint => constraint[\"constraint_type\"] === \"UNIQUE\");\n        const isConstraintComposite = uniqueConstraints.every(uniqueConstraint => {\n          return dbConstraints.some(dbConstraint => dbConstraint[\"constraint_type\"] === \"UNIQUE\" && dbConstraint[\"constraint_name\"] === uniqueConstraint[\"constraint_name\"] && dbConstraint[\"column_name\"] !== dbColumn[\"column_name\"]);\n        });\n        tableColumn.isUnique = uniqueConstraints.length > 0 && !isConstraintComposite;\n        if (dbColumn.is_identity === \"YES\") {\n          // Postgres 10+ Identity column\n          tableColumn.isGenerated = true;\n          tableColumn.generationStrategy = \"identity\";\n          tableColumn.generatedIdentity = dbColumn.identity_generation;\n        } else if (dbColumn[\"column_default\"] !== null && dbColumn[\"column_default\"] !== undefined) {\n          const serialDefaultName = `nextval('${this.buildSequenceName(table, dbColumn[\"column_name\"])}'::regclass)`;\n          const serialDefaultPath = `nextval('${this.buildSequencePath(table, dbColumn[\"column_name\"])}'::regclass)`;\n          const defaultWithoutQuotes = dbColumn[\"column_default\"].replace(/\"/g, \"\");\n          if (defaultWithoutQuotes === serialDefaultName || defaultWithoutQuotes === serialDefaultPath) {\n            tableColumn.isGenerated = true;\n            tableColumn.generationStrategy = \"increment\";\n          } else if (dbColumn[\"column_default\"] === \"gen_random_uuid()\" || /^uuid_generate_v\\d\\(\\)/.test(dbColumn[\"column_default\"])) {\n            if (tableColumn.type === \"uuid\") {\n              tableColumn.isGenerated = true;\n              tableColumn.generationStrategy = \"uuid\";\n            } else {\n              tableColumn.default = dbColumn[\"column_default\"];\n            }\n          } else if (dbColumn[\"column_default\"] === \"now()\" || dbColumn[\"column_default\"].indexOf(\"'now'::text\") !== -1) {\n            tableColumn.default = dbColumn[\"column_default\"];\n          } else {\n            tableColumn.default = dbColumn[\"column_default\"].replace(/::[\\w\\s.[\\]\\-\"]+/g, \"\");\n            tableColumn.default = tableColumn.default.replace(/^(-?\\d+)$/, \"'$1'\");\n          }\n        }\n        if (dbColumn[\"is_generated\"] === \"ALWAYS\" && dbColumn[\"generation_expression\"]) {\n          // In postgres there is no VIRTUAL generated column type\n          tableColumn.generatedType = \"STORED\";\n          // We cannot relay on information_schema.columns.generation_expression, because it is formatted different.\n          const asExpressionQuery = this.selectTypeormMetadataSql({\n            database: currentDatabase,\n            schema: dbTable[\"table_schema\"],\n            table: dbTable[\"table_name\"],\n            type: MetadataTableType.GENERATED_COLUMN,\n            name: tableColumn.name\n          });\n          const results = await this.query(asExpressionQuery.query, asExpressionQuery.parameters);\n          if (results[0] && results[0].value) {\n            tableColumn.asExpression = results[0].value;\n          } else {\n            tableColumn.asExpression = \"\";\n          }\n        }\n        tableColumn.comment = dbColumn[\"description\"] ? dbColumn[\"description\"] : undefined;\n        if (dbColumn[\"character_set_name\"]) tableColumn.charset = dbColumn[\"character_set_name\"];\n        if (dbColumn[\"collation_name\"]) tableColumn.collation = dbColumn[\"collation_name\"];\n        return tableColumn;\n      }));\n      // find unique constraints of table, group them by constraint name and build TableUnique.\n      const tableUniqueConstraints = OrmUtils.uniq(dbConstraints.filter(dbConstraint => {\n        return dbConstraint[\"table_name\"] === dbTable[\"table_name\"] && dbConstraint[\"table_schema\"] === dbTable[\"table_schema\"] && dbConstraint[\"constraint_type\"] === \"UNIQUE\";\n      }), dbConstraint => dbConstraint[\"constraint_name\"]);\n      table.uniques = tableUniqueConstraints.map(constraint => {\n        const uniques = dbConstraints.filter(dbC => dbC[\"constraint_name\"] === constraint[\"constraint_name\"]);\n        return new TableUnique({\n          name: constraint[\"constraint_name\"],\n          columnNames: uniques.map(u => u[\"column_name\"]),\n          deferrable: constraint[\"deferrable\"] ? constraint[\"deferred\"] : undefined\n        });\n      });\n      // find check constraints of table, group them by constraint name and build TableCheck.\n      const tableCheckConstraints = OrmUtils.uniq(dbConstraints.filter(dbConstraint => {\n        return dbConstraint[\"table_name\"] === dbTable[\"table_name\"] && dbConstraint[\"table_schema\"] === dbTable[\"table_schema\"] && dbConstraint[\"constraint_type\"] === \"CHECK\";\n      }), dbConstraint => dbConstraint[\"constraint_name\"]);\n      table.checks = tableCheckConstraints.map(constraint => {\n        const checks = dbConstraints.filter(dbC => dbC[\"constraint_name\"] === constraint[\"constraint_name\"]);\n        return new TableCheck({\n          name: constraint[\"constraint_name\"],\n          columnNames: checks.map(c => c[\"column_name\"]),\n          expression: constraint[\"expression\"].replace(/^\\s*CHECK\\s*\\((.*)\\)\\s*$/i, \"$1\")\n        });\n      });\n      // find exclusion constraints of table, group them by constraint name and build TableExclusion.\n      const tableExclusionConstraints = OrmUtils.uniq(dbConstraints.filter(dbConstraint => {\n        return dbConstraint[\"table_name\"] === dbTable[\"table_name\"] && dbConstraint[\"table_schema\"] === dbTable[\"table_schema\"] && dbConstraint[\"constraint_type\"] === \"EXCLUDE\";\n      }), dbConstraint => dbConstraint[\"constraint_name\"]);\n      table.exclusions = tableExclusionConstraints.map(constraint => {\n        return new TableExclusion({\n          name: constraint[\"constraint_name\"],\n          expression: constraint[\"expression\"].substring(8) // trim EXCLUDE from start of expression\n        });\n      });\n      // find foreign key constraints of table, group them by constraint name and build TableForeignKey.\n      const tableForeignKeyConstraints = OrmUtils.uniq(dbForeignKeys.filter(dbForeignKey => {\n        return dbForeignKey[\"table_name\"] === dbTable[\"table_name\"] && dbForeignKey[\"table_schema\"] === dbTable[\"table_schema\"];\n      }), dbForeignKey => dbForeignKey[\"constraint_name\"]);\n      table.foreignKeys = tableForeignKeyConstraints.map(dbForeignKey => {\n        const foreignKeys = dbForeignKeys.filter(dbFk => dbFk[\"constraint_name\"] === dbForeignKey[\"constraint_name\"]);\n        // if referenced table located in currently used schema, we don't need to concat schema name to table name.\n        const schema = getSchemaFromKey(dbForeignKey, \"referenced_table_schema\");\n        const referencedTableName = this.driver.buildTableName(dbForeignKey[\"referenced_table_name\"], schema);\n        return new TableForeignKey({\n          name: dbForeignKey[\"constraint_name\"],\n          columnNames: foreignKeys.map(dbFk => dbFk[\"column_name\"]),\n          referencedSchema: dbForeignKey[\"referenced_table_schema\"],\n          referencedTableName: referencedTableName,\n          referencedColumnNames: foreignKeys.map(dbFk => dbFk[\"referenced_column_name\"]),\n          onDelete: dbForeignKey[\"on_delete\"],\n          onUpdate: dbForeignKey[\"on_update\"],\n          deferrable: dbForeignKey[\"deferrable\"] ? dbForeignKey[\"deferred\"] : undefined\n        });\n      });\n      // find index constraints of table, group them by constraint name and build TableIndex.\n      const tableIndexConstraints = OrmUtils.uniq(dbIndices.filter(dbIndex => {\n        return dbIndex[\"table_name\"] === dbTable[\"table_name\"] && dbIndex[\"table_schema\"] === dbTable[\"table_schema\"];\n      }), dbIndex => dbIndex[\"constraint_name\"]);\n      table.indices = tableIndexConstraints.map(constraint => {\n        const indices = dbIndices.filter(index => {\n          return index[\"table_schema\"] === constraint[\"table_schema\"] && index[\"table_name\"] === constraint[\"table_name\"] && index[\"constraint_name\"] === constraint[\"constraint_name\"];\n        });\n        return new TableIndex({\n          table: table,\n          name: constraint[\"constraint_name\"],\n          columnNames: indices.map(i => i[\"column_name\"]),\n          isUnique: constraint[\"is_unique\"] === \"TRUE\",\n          where: constraint[\"condition\"],\n          isSpatial: constraint[\"index_type\"] === \"gist\",\n          isFulltext: false\n        });\n      });\n      return table;\n    }));\n  }\n  /**\n   * Builds create table sql.\n   */\n  createTableSql(table, createForeignKeys) {\n    const columnDefinitions = table.columns.map(column => this.buildCreateColumnSql(table, column)).join(\", \");\n    let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`;\n    table.columns.filter(column => column.isUnique).forEach(column => {\n      const isUniqueExist = table.uniques.some(unique => unique.columnNames.length === 1 && unique.columnNames[0] === column.name);\n      if (!isUniqueExist) table.uniques.push(new TableUnique({\n        name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),\n        columnNames: [column.name]\n      }));\n    });\n    if (table.uniques.length > 0) {\n      const uniquesSql = table.uniques.map(unique => {\n        const uniqueName = unique.name ? unique.name : this.connection.namingStrategy.uniqueConstraintName(table, unique.columnNames);\n        const columnNames = unique.columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n        let constraint = `CONSTRAINT \"${uniqueName}\" UNIQUE (${columnNames})`;\n        if (unique.deferrable) constraint += ` DEFERRABLE ${unique.deferrable}`;\n        return constraint;\n      }).join(\", \");\n      sql += `, ${uniquesSql}`;\n    }\n    if (table.checks.length > 0) {\n      const checksSql = table.checks.map(check => {\n        const checkName = check.name ? check.name : this.connection.namingStrategy.checkConstraintName(table, check.expression);\n        return `CONSTRAINT \"${checkName}\" CHECK (${check.expression})`;\n      }).join(\", \");\n      sql += `, ${checksSql}`;\n    }\n    if (table.exclusions.length > 0) {\n      const exclusionsSql = table.exclusions.map(exclusion => {\n        const exclusionName = exclusion.name ? exclusion.name : this.connection.namingStrategy.exclusionConstraintName(table, exclusion.expression);\n        return `CONSTRAINT \"${exclusionName}\" EXCLUDE ${exclusion.expression}`;\n      }).join(\", \");\n      sql += `, ${exclusionsSql}`;\n    }\n    if (table.foreignKeys.length > 0 && createForeignKeys) {\n      const foreignKeysSql = table.foreignKeys.map(fk => {\n        const columnNames = fk.columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n        if (!fk.name) fk.name = this.connection.namingStrategy.foreignKeyName(table, fk.columnNames, this.getTablePath(fk), fk.referencedColumnNames);\n        const referencedColumnNames = fk.referencedColumnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n        let constraint = `CONSTRAINT \"${fk.name}\" FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(fk))} (${referencedColumnNames})`;\n        if (fk.onDelete) constraint += ` ON DELETE ${fk.onDelete}`;\n        if (fk.onUpdate) constraint += ` ON UPDATE ${fk.onUpdate}`;\n        if (fk.deferrable) constraint += ` DEFERRABLE ${fk.deferrable}`;\n        return constraint;\n      }).join(\", \");\n      sql += `, ${foreignKeysSql}`;\n    }\n    const primaryColumns = table.columns.filter(column => column.isPrimary);\n    if (primaryColumns.length > 0) {\n      const primaryKeyName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(table, primaryColumns.map(column => column.name));\n      const columnNames = primaryColumns.map(column => `\"${column.name}\"`).join(\", \");\n      sql += `, CONSTRAINT \"${primaryKeyName}\" PRIMARY KEY (${columnNames})`;\n    }\n    sql += `)`;\n    table.columns.filter(it => it.comment).forEach(it => sql += `; COMMENT ON COLUMN ${this.escapePath(table)}.\"${it.name}\" IS ${this.escapeComment(it.comment)}`);\n    return new Query(sql);\n  }\n  /**\n   * Loads Postgres version.\n   */\n  async getVersion() {\n    const result = await this.query(`SELECT version()`);\n    return result[0][\"version\"].replace(/^PostgreSQL ([\\d.]+) .*$/, \"$1\");\n  }\n  /**\n   * Builds drop table sql.\n   */\n  dropTableSql(tableOrPath) {\n    return new Query(`DROP TABLE ${this.escapePath(tableOrPath)}`);\n  }\n  createViewSql(view) {\n    const materializedClause = view.materialized ? \"MATERIALIZED \" : \"\";\n    const viewName = this.escapePath(view);\n    if (typeof view.expression === \"string\") {\n      return new Query(`CREATE ${materializedClause}VIEW ${viewName} AS ${view.expression}`);\n    } else {\n      return new Query(`CREATE ${materializedClause}VIEW ${viewName} AS ${view.expression(this.connection).getQuery()}`);\n    }\n  }\n  async insertViewDefinitionSql(view) {\n    const currentSchema = await this.getCurrentSchema();\n    let {\n      schema,\n      tableName: name\n    } = this.driver.parseTableName(view);\n    if (!schema) {\n      schema = currentSchema;\n    }\n    const type = view.materialized ? MetadataTableType.MATERIALIZED_VIEW : MetadataTableType.VIEW;\n    const expression = typeof view.expression === \"string\" ? view.expression.trim() : view.expression(this.connection).getQuery();\n    return this.insertTypeormMetadataSql({\n      type,\n      schema,\n      name,\n      value: expression\n    });\n  }\n  /**\n   * Builds drop view sql.\n   */\n  dropViewSql(view) {\n    const materializedClause = view.materialized ? \"MATERIALIZED \" : \"\";\n    return new Query(`DROP ${materializedClause}VIEW ${this.escapePath(view)}`);\n  }\n  /**\n   * Builds remove view sql.\n   */\n  async deleteViewDefinitionSql(view) {\n    const currentSchema = await this.getCurrentSchema();\n    let {\n      schema,\n      tableName: name\n    } = this.driver.parseTableName(view);\n    if (!schema) {\n      schema = currentSchema;\n    }\n    const type = view.materialized ? MetadataTableType.MATERIALIZED_VIEW : MetadataTableType.VIEW;\n    return this.deleteTypeormMetadataSql({\n      type,\n      schema,\n      name\n    });\n  }\n  /**\n   * Drops ENUM type from given schemas.\n   */\n  async dropEnumTypes(schemaNames) {\n    const selectDropsQuery = `SELECT 'DROP TYPE IF EXISTS \"' || n.nspname || '\".\"' || t.typname || '\" CASCADE;' as \"query\" FROM \"pg_type\" \"t\" ` + `INNER JOIN \"pg_enum\" \"e\" ON \"e\".\"enumtypid\" = \"t\".\"oid\" ` + `INNER JOIN \"pg_namespace\" \"n\" ON \"n\".\"oid\" = \"t\".\"typnamespace\" ` + `WHERE \"n\".\"nspname\" IN (${schemaNames}) GROUP BY \"n\".\"nspname\", \"t\".\"typname\"`;\n    const dropQueries = await this.query(selectDropsQuery);\n    await Promise.all(dropQueries.map(q => this.query(q[\"query\"])));\n  }\n  /**\n   * Checks if enum with the given name exist in the database.\n   */\n  async hasEnumType(table, column) {\n    let {\n      schema\n    } = this.driver.parseTableName(table);\n    if (!schema) {\n      schema = await this.getCurrentSchema();\n    }\n    const enumName = this.buildEnumName(table, column, false, true);\n    const sql = `SELECT \"n\".\"nspname\", \"t\".\"typname\" FROM \"pg_type\" \"t\" ` + `INNER JOIN \"pg_namespace\" \"n\" ON \"n\".\"oid\" = \"t\".\"typnamespace\" ` + `WHERE \"n\".\"nspname\" = '${schema}' AND \"t\".\"typname\" = '${enumName}'`;\n    const result = await this.query(sql);\n    return result.length ? true : false;\n  }\n  /**\n   * Builds create ENUM type sql.\n   */\n  createEnumTypeSql(table, column, enumName) {\n    if (!enumName) enumName = this.buildEnumName(table, column);\n    const enumValues = column.enum.map(value => `'${value.replace(\"'\", \"''\")}'`).join(\", \");\n    return new Query(`CREATE TYPE ${enumName} AS ENUM(${enumValues})`);\n  }\n  /**\n   * Builds create ENUM type sql.\n   */\n  dropEnumTypeSql(table, column, enumName) {\n    if (!enumName) enumName = this.buildEnumName(table, column);\n    return new Query(`DROP TYPE ${enumName}`);\n  }\n  /**\n   * Builds create index sql.\n   */\n  createIndexSql(table, index) {\n    const columns = index.columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n    return new Query(`CREATE ${index.isUnique ? \"UNIQUE \" : \"\"}INDEX${index.isConcurrent ? \" CONCURRENTLY\" : \"\"} \"${index.name}\" ON ${this.escapePath(table)} ${index.isSpatial ? \"USING GiST \" : \"\"}(${columns}) ${index.where ? \"WHERE \" + index.where : \"\"}`);\n  }\n  /**\n   * Builds create view index sql.\n   */\n  createViewIndexSql(view, index) {\n    const columns = index.columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n    return new Query(`CREATE ${index.isUnique ? \"UNIQUE \" : \"\"}INDEX \"${index.name}\" ON ${this.escapePath(view)} (${columns}) ${index.where ? \"WHERE \" + index.where : \"\"}`);\n  }\n  /**\n   * Builds drop index sql.\n   */\n  dropIndexSql(table, indexOrName) {\n    const indexName = InstanceChecker.isTableIndex(indexOrName) ? indexOrName.name : indexOrName;\n    const concurrent = InstanceChecker.isTableIndex(indexOrName) ? indexOrName.isConcurrent : false;\n    const {\n      schema\n    } = this.driver.parseTableName(table);\n    return schema ? new Query(`DROP INDEX ${concurrent ? \"CONCURRENTLY \" : \"\"}\"${schema}\".\"${indexName}\"`) : new Query(`DROP INDEX ${concurrent ? \"CONCURRENTLY \" : \"\"}\"${indexName}\"`);\n  }\n  /**\n   * Builds create primary key sql.\n   */\n  createPrimaryKeySql(table, columnNames, constraintName) {\n    const primaryKeyName = constraintName ? constraintName : this.connection.namingStrategy.primaryKeyName(table, columnNames);\n    const columnNamesString = columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n    return new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${primaryKeyName}\" PRIMARY KEY (${columnNamesString})`);\n  }\n  /**\n   * Builds drop primary key sql.\n   */\n  dropPrimaryKeySql(table) {\n    if (!table.primaryColumns.length) throw new TypeORMError(`Table ${table} has no primary keys.`);\n    const columnNames = table.primaryColumns.map(column => column.name);\n    const constraintName = table.primaryColumns[0].primaryKeyConstraintName;\n    const primaryKeyName = constraintName ? constraintName : this.connection.namingStrategy.primaryKeyName(table, columnNames);\n    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${primaryKeyName}\"`);\n  }\n  /**\n   * Builds create unique constraint sql.\n   */\n  createUniqueConstraintSql(table, uniqueConstraint) {\n    const columnNames = uniqueConstraint.columnNames.map(column => `\"` + column + `\"`).join(\", \");\n    let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${uniqueConstraint.name}\" UNIQUE (${columnNames})`;\n    if (uniqueConstraint.deferrable) sql += ` DEFERRABLE ${uniqueConstraint.deferrable}`;\n    return new Query(sql);\n  }\n  /**\n   * Builds drop unique constraint sql.\n   */\n  dropUniqueConstraintSql(table, uniqueOrName) {\n    const uniqueName = InstanceChecker.isTableUnique(uniqueOrName) ? uniqueOrName.name : uniqueOrName;\n    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${uniqueName}\"`);\n  }\n  /**\n   * Builds create check constraint sql.\n   */\n  createCheckConstraintSql(table, checkConstraint) {\n    return new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${checkConstraint.name}\" CHECK (${checkConstraint.expression})`);\n  }\n  /**\n   * Builds drop check constraint sql.\n   */\n  dropCheckConstraintSql(table, checkOrName) {\n    const checkName = InstanceChecker.isTableCheck(checkOrName) ? checkOrName.name : checkOrName;\n    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${checkName}\"`);\n  }\n  /**\n   * Builds create exclusion constraint sql.\n   */\n  createExclusionConstraintSql(table, exclusionConstraint) {\n    return new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${exclusionConstraint.name}\" EXCLUDE ${exclusionConstraint.expression}`);\n  }\n  /**\n   * Builds drop exclusion constraint sql.\n   */\n  dropExclusionConstraintSql(table, exclusionOrName) {\n    const exclusionName = InstanceChecker.isTableExclusion(exclusionOrName) ? exclusionOrName.name : exclusionOrName;\n    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${exclusionName}\"`);\n  }\n  /**\n   * Builds create foreign key sql.\n   */\n  createForeignKeySql(table, foreignKey) {\n    const columnNames = foreignKey.columnNames.map(column => `\"` + column + `\"`).join(\", \");\n    const referencedColumnNames = foreignKey.referencedColumnNames.map(column => `\"` + column + `\"`).join(\",\");\n    let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${foreignKey.name}\" FOREIGN KEY (${columnNames}) ` + `REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;\n    if (foreignKey.onDelete) sql += ` ON DELETE ${foreignKey.onDelete}`;\n    if (foreignKey.onUpdate) sql += ` ON UPDATE ${foreignKey.onUpdate}`;\n    if (foreignKey.deferrable) sql += ` DEFERRABLE ${foreignKey.deferrable}`;\n    return new Query(sql);\n  }\n  /**\n   * Builds drop foreign key sql.\n   */\n  dropForeignKeySql(table, foreignKeyOrName) {\n    const foreignKeyName = InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName.name : foreignKeyOrName;\n    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${foreignKeyName}\"`);\n  }\n  /**\n   * Builds sequence name from given table and column.\n   */\n  buildSequenceName(table, columnOrName) {\n    const {\n      tableName\n    } = this.driver.parseTableName(table);\n    const columnName = InstanceChecker.isTableColumn(columnOrName) ? columnOrName.name : columnOrName;\n    let seqName = `${tableName}_${columnName}_seq`;\n    if (seqName.length > this.connection.driver.maxAliasLength) {\n      // note doesn't yet handle corner cases where .length differs from number of UTF-8 bytes\n      seqName = `${tableName.substring(0, 29)}_${columnName.substring(0, Math.max(29, 63 - table.name.length - 5))}_seq`;\n    }\n    return seqName;\n  }\n  buildSequencePath(table, columnOrName) {\n    const {\n      schema\n    } = this.driver.parseTableName(table);\n    return schema ? `${schema}.${this.buildSequenceName(table, columnOrName)}` : this.buildSequenceName(table, columnOrName);\n  }\n  /**\n   * Builds ENUM type name from given table and column.\n   */\n  buildEnumName(table, column, withSchema = true, disableEscape, toOld) {\n    const {\n      schema,\n      tableName\n    } = this.driver.parseTableName(table);\n    let enumName = column.enumName ? column.enumName : `${tableName}_${column.name.toLowerCase()}_enum`;\n    if (schema && withSchema) enumName = `${schema}.${enumName}`;\n    if (toOld) enumName = enumName + \"_old\";\n    return enumName.split(\".\").map(i => {\n      return disableEscape ? i : `\"${i}\"`;\n    }).join(\".\");\n  }\n  async getUserDefinedTypeName(table, column) {\n    let {\n      schema,\n      tableName: name\n    } = this.driver.parseTableName(table);\n    if (!schema) {\n      schema = await this.getCurrentSchema();\n    }\n    const result = await this.query(`SELECT \"udt_schema\", \"udt_name\" ` + `FROM \"information_schema\".\"columns\" WHERE \"table_schema\" = '${schema}' AND \"table_name\" = '${name}' AND \"column_name\"='${column.name}'`);\n    // docs: https://www.postgresql.org/docs/current/xtypes.html\n    // When you define a new base type, PostgreSQL automatically provides support for arrays of that type.\n    // The array type typically has the same name as the base type with the underscore character (_) prepended.\n    // ----\n    // so, we must remove this underscore character from enum type name\n    let udtName = result[0][\"udt_name\"];\n    if (udtName.indexOf(\"_\") === 0) {\n      udtName = udtName.substr(1, udtName.length);\n    }\n    return {\n      schema: result[0][\"udt_schema\"],\n      name: udtName\n    };\n  }\n  /**\n   * Escapes a given comment so it's safe to include in a query.\n   */\n  escapeComment(comment) {\n    if (!comment || comment.length === 0) {\n      return \"NULL\";\n    }\n    comment = comment.replace(/'/g, \"''\").replace(/\\u0000/g, \"\"); // Null bytes aren't allowed in comments\n    return `'${comment}'`;\n  }\n  /**\n   * Escapes given table or view path.\n   */\n  escapePath(target) {\n    const {\n      schema,\n      tableName\n    } = this.driver.parseTableName(target);\n    if (schema && schema !== this.driver.searchSchema) {\n      return `\"${schema}\".\"${tableName}\"`;\n    }\n    return `\"${tableName}\"`;\n  }\n  /**\n   * Get the table name with table schema\n   * Note: Without ' or \"\n   */\n  async getTableNameWithSchema(target) {\n    const tableName = InstanceChecker.isTable(target) ? target.name : target;\n    if (tableName.indexOf(\".\") === -1) {\n      const schemaResult = await this.query(`SELECT current_schema()`);\n      const schema = schemaResult[0][\"current_schema\"];\n      return `${schema}.${tableName}`;\n    } else {\n      return `${tableName.split(\".\")[0]}.${tableName.split(\".\")[1]}`;\n    }\n  }\n  /**\n   * Builds a query for create column.\n   */\n  buildCreateColumnSql(table, column) {\n    let c = '\"' + column.name + '\"';\n    if (column.isGenerated === true && column.generationStrategy !== \"uuid\") {\n      if (column.generationStrategy === \"identity\") {\n        // Postgres 10+ Identity generated column\n        const generatedIdentityOrDefault = column.generatedIdentity || \"BY DEFAULT\";\n        c += ` ${column.type} GENERATED ${generatedIdentityOrDefault} AS IDENTITY`;\n      } else {\n        // classic SERIAL primary column\n        if (column.type === \"integer\" || column.type === \"int\" || column.type === \"int4\") c += \" SERIAL\";\n        if (column.type === \"smallint\" || column.type === \"int2\") c += \" SMALLSERIAL\";\n        if (column.type === \"bigint\" || column.type === \"int8\") c += \" BIGSERIAL\";\n      }\n    }\n    if (column.type === \"enum\" || column.type === \"simple-enum\") {\n      c += \" \" + this.buildEnumName(table, column);\n      if (column.isArray) c += \" array\";\n    } else if (!column.isGenerated || column.type === \"uuid\") {\n      c += \" \" + this.connection.driver.createFullType(column);\n    }\n    // Postgres only supports the stored generated column type\n    if (column.generatedType === \"STORED\" && column.asExpression) {\n      c += ` GENERATED ALWAYS AS (${column.asExpression}) STORED`;\n    }\n    if (column.charset) c += ' CHARACTER SET \"' + column.charset + '\"';\n    if (column.collation) c += ' COLLATE \"' + column.collation + '\"';\n    if (column.isNullable !== true) c += \" NOT NULL\";\n    if (column.default !== undefined && column.default !== null) c += \" DEFAULT \" + column.default;\n    if (column.isGenerated && column.generationStrategy === \"uuid\" && !column.default) c += ` DEFAULT ${this.driver.uuidGenerator}`;\n    return c;\n  }\n  /**\n   * Checks if the PostgreSQL server has support for partitioned tables\n   */\n  async hasSupportForPartitionedTables() {\n    const result = await this.query(`SELECT TRUE FROM information_schema.columns WHERE table_name = 'pg_class' and column_name = 'relispartition'`);\n    return result.length ? true : false;\n  }\n  /**\n   * Change table comment.\n   */\n  async changeTableComment(tableOrName, newComment) {\n    const upQueries = [];\n    const downQueries = [];\n    const table = InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);\n    newComment = this.escapeComment(newComment);\n    const comment = this.escapeComment(table.comment);\n    if (newComment === comment) {\n      return;\n    }\n    const newTable = table.clone();\n    upQueries.push(new Query(`COMMENT ON TABLE ${this.escapePath(newTable)} IS ${newComment}`));\n    downQueries.push(new Query(`COMMENT ON TABLE ${this.escapePath(table)} IS ${comment}`));\n    await this.executeQueries(upQueries, downQueries);\n    table.comment = newTable.comment;\n    this.replaceCachedTable(table, newTable);\n  }\n}","map":{"version":3,"names":["TypeORMError","QueryFailedError","QueryRunnerAlreadyReleasedError","TransactionNotStartedError","BaseQueryRunner","QueryResult","Table","TableCheck","TableColumn","TableExclusion","TableForeignKey","TableIndex","TableUnique","View","Broadcaster","InstanceChecker","OrmUtils","VersionUtils","Query","MetadataTableType","BroadcasterResult","PostgresQueryRunner","constructor","driver","mode","connection","broadcaster","connect","databaseConnection","Promise","resolve","databaseConnectionPromise","isReplicated","obtainSlaveConnection","then","release","connectedQueryRunners","push","onErrorCallback","err","releasePostgresConnection","releaseCallback","removeListener","on","obtainMasterConnection","isReleased","undefined","index","indexOf","splice","startTransaction","isolationLevel","isTransactionActive","broadcast","transactionDepth","query","commitTransaction","rollbackTransaction","parameters","useStructuredResult","broadcasterResult","logger","logQuery","broadcastBeforeQueryEvent","queryStartTime","Date","raw","maxQueryExecutionTime","options","queryEndTime","queryExecutionTime","broadcastAfterQueryEvent","logQuerySlow","result","hasOwnProperty","records","rows","affected","rowCount","command","logQueryError","wait","stream","onEnd","onError","QueryStream","loadStreamDependency","getDatabases","getSchemas","database","hasDatabase","length","getCurrentDatabase","hasSchema","schema","getCurrentSchema","hasTable","tableOrName","parsedTableName","parseTableName","sql","tableName","hasColumn","columnName","createDatabase","ifNotExist","databaseAlreadyExists","up","down","executeQueries","dropDatabase","ifExist","createSchema","schemaPath","split","dropSchema","isCascade","createTable","table","createForeignKeys","createIndices","isTableExist","upQueries","downQueries","enumColumns","columns","filter","column","type","createdEnumTypes","hasEnum","hasEnumType","enumName","buildEnumName","createEnumTypeSql","dropEnumTypeSql","generatedColumns","generatedType","asExpression","tableNameWithSchema","getTableNameWithSchema","name","insertQuery","insertTypeormMetadataSql","GENERATED_COLUMN","value","deleteQuery","deleteTypeormMetadataSql","createTableSql","dropTableSql","foreignKeys","forEach","foreignKey","dropForeignKeySql","indices","namingStrategy","indexName","columnNames","where","createIndexSql","dropIndexSql","comment","escapePath","dropTable","target","dropForeignKeys","dropIndices","tablePath","getTablePath","getCachedTable","createView","view","syncWithMetadata","createViewSql","insertViewDefinitionSql","dropViewSql","deleteViewDefinitionSql","dropView","viewName","isView","getCachedView","renameTable","oldTableOrName","newTableName","oldTable","isTable","newTable","clone","schemaName","oldTableName","primaryColumns","primaryKeyConstraintName","map","oldPkName","primaryKeyName","newPkName","col","isGenerated","generationStrategy","sequencePath","buildSequencePath","sequenceName","buildSequenceName","newSequencePath","newSequenceName","uniques","unique","oldUniqueName","uniqueConstraintName","newUniqueName","oldIndexName","newIndexName","oldForeignKeyName","foreignKeyName","referencedColumnNames","newForeignKeyName","oldEnumType","getUserDefinedTypeName","addColumn","clonedTable","buildCreateColumnSql","isPrimary","pkName","join","columnIndex","find","isUnique","uniqueConstraint","escapeComment","replaceCachedTable","addColumns","renameColumn","oldTableColumnOrName","newTableColumnOrName","oldColumn","isTableColumn","c","newColumn","changeColumn","defaultValueChanged","isArray","dropColumn","findColumnUniques","findColumnIndices","findColumnForeignKeys","oldTableColumn","precision","scale","createFullType","isArraysEqual","enum","arraySuffix","newEnumName","oldEnumName","oldEnumNameWithoutSchema","oldEnumNameWithSchema_old","oldEnumNameWithoutSchema_old","default","upType","downType","isNullable","primaryColumn","uuidGenerator","spatialFeatureType","toLowerCase","srid","changeColumns","changedColumns","columnOrName","findColumnByName","tableColumn","columnCheck","checks","check","dropCheckConstraintSql","createCheckConstraintSql","columnUnique","dropUniqueConstraintSql","createUniqueConstraintSql","enumType","escapedEnumName","removeColumn","dropColumns","createPrimaryKey","constraintName","createPrimaryKeySql","dropPrimaryKeySql","updatePrimaryKeys","columnNamesString","dropPrimaryKey","createUniqueConstraint","addUniqueConstraint","createUniqueConstraints","uniqueConstraints","dropUniqueConstraint","uniqueOrName","isTableUnique","u","removeUniqueConstraint","dropUniqueConstraints","createCheckConstraint","checkConstraint","checkConstraintName","expression","addCheckConstraint","createCheckConstraints","checkConstraints","promises","all","dropCheckConstraint","checkOrName","isTableCheck","removeCheckConstraint","dropCheckConstraints","createExclusionConstraint","exclusionConstraint","exclusionConstraintName","createExclusionConstraintSql","dropExclusionConstraintSql","addExclusionConstraint","createExclusionConstraints","exclusionConstraints","dropExclusionConstraint","exclusionOrName","isTableExclusion","exclusions","removeExclusionConstraint","dropExclusionConstraints","createForeignKey","createForeignKeySql","addForeignKey","dropForeignKey","foreignKeyOrName","isTableForeignKey","fk","removeForeignKey","createIndex","generateIndexName","addIndex","createViewIndex","viewOrName","createViewIndexSql","createViewIndices","dropIndex","indexOrName","isTableIndex","i","removeIndex","dropViewIndex","clearTable","clearDatabase","schemas","entityMetadatas","metadata","isSchemaExist","schemaNamesString","isAnotherTransactionActive","version","getVersion","selectViewDropsQuery","dropViewQueries","q","isGreaterOrEqual","selectMatViewDropsQuery","dropMatViewQueries","selectTableDropsQuery","dropTableQueries","dropEnumTypes","error","rollbackError","loadViews","viewNames","getTypeormMetadataTableName","currentDatabase","currentSchema","viewsCondition","constraintsCondition","indicesSql","VIEW","MATERIALIZED_VIEW","dbViews","dbIndices","dbView","tableIndexConstraints","uniq","dbIndex","buildTableName","materialized","constraint","isFulltext","loadTables","tableNames","dbTables","tablesSql","tablesCondition","columnsCondition","table_schema","table_name","columnsSql","constraintsSql","foreignKeysCondition","hasRelispartitionColumn","hasSupportForPartitionedTables","isPartitionCondition","foreignKeysSql","dbColumns","dbConstraints","dbForeignKeys","dbTable","getSchemaFromKey","dbObject","key","dbColumn","columnConstraints","dbConstraint","numericPrecision","numericScale","numericSize","match","isDefaultColumnPrecision","isDefaultColumnScale","builtEnumName","results","replace","normalizeType","withLengthColumnTypes","exec","toString","isDefaultColumnLength","primaryConstraint","anotherPrimaryConstraints","isConstraintComposite","every","some","is_identity","generatedIdentity","identity_generation","serialDefaultName","serialDefaultPath","defaultWithoutQuotes","test","asExpressionQuery","selectTypeormMetadataSql","charset","collation","tableUniqueConstraints","dbC","deferrable","tableCheckConstraints","tableExclusionConstraints","substring","tableForeignKeyConstraints","dbForeignKey","dbFk","referencedTableName","referencedSchema","onDelete","onUpdate","isSpatial","columnDefinitions","isUniqueExist","uniquesSql","uniqueName","checksSql","checkName","exclusionsSql","exclusion","exclusionName","it","tableOrPath","materializedClause","getQuery","trim","schemaNames","selectDropsQuery","dropQueries","enumValues","isConcurrent","concurrent","seqName","maxAliasLength","Math","max","withSchema","disableEscape","toOld","udtName","substr","searchSchema","schemaResult","generatedIdentityOrDefault","changeTableComment","newComment"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\driver\\postgres\\PostgresQueryRunner.ts"],"sourcesContent":["import { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { TypeORMError } from \"../../error\"\nimport { QueryFailedError } from \"../../error/QueryFailedError\"\nimport { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\"\nimport { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\"\nimport { ReadStream } from \"../../platform/PlatformTools\"\nimport { BaseQueryRunner } from \"../../query-runner/BaseQueryRunner\"\nimport { QueryResult } from \"../../query-runner/QueryResult\"\nimport { QueryRunner } from \"../../query-runner/QueryRunner\"\nimport { TableIndexOptions } from \"../../schema-builder/options/TableIndexOptions\"\nimport { Table } from \"../../schema-builder/table/Table\"\nimport { TableCheck } from \"../../schema-builder/table/TableCheck\"\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\"\nimport { TableExclusion } from \"../../schema-builder/table/TableExclusion\"\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\"\nimport { TableIndex } from \"../../schema-builder/table/TableIndex\"\nimport { TableUnique } from \"../../schema-builder/table/TableUnique\"\nimport { View } from \"../../schema-builder/view/View\"\nimport { Broadcaster } from \"../../subscriber/Broadcaster\"\nimport { InstanceChecker } from \"../../util/InstanceChecker\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { VersionUtils } from \"../../util/VersionUtils\"\nimport { Query } from \"../Query\"\nimport { ColumnType } from \"../types/ColumnTypes\"\nimport { IsolationLevel } from \"../types/IsolationLevel\"\nimport { MetadataTableType } from \"../types/MetadataTableType\"\nimport { ReplicationMode } from \"../types/ReplicationMode\"\nimport { PostgresDriver } from \"./PostgresDriver\"\nimport { BroadcasterResult } from \"../../subscriber/BroadcasterResult\"\n\n/**\n * Runs queries on a single postgres database connection.\n */\nexport class PostgresQueryRunner\n    extends BaseQueryRunner\n    implements QueryRunner\n{\n    // -------------------------------------------------------------------------\n    // Public Implemented Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Database driver used by connection.\n     */\n    driver: PostgresDriver\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Promise used to obtain a database connection for a first time.\n     */\n    protected databaseConnectionPromise: Promise<any>\n\n    /**\n     * Special callback provided by a driver used to release a created connection.\n     */\n    protected releaseCallback?: (err: any) => void\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(driver: PostgresDriver, mode: ReplicationMode) {\n        super()\n        this.driver = driver\n        this.connection = driver.connection\n        this.mode = mode\n        this.broadcaster = new Broadcaster(this)\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates/uses database connection from the connection pool to perform further operations.\n     * Returns obtained database connection.\n     */\n    connect(): Promise<any> {\n        if (this.databaseConnection)\n            return Promise.resolve(this.databaseConnection)\n\n        if (this.databaseConnectionPromise)\n            return this.databaseConnectionPromise\n\n        if (this.mode === \"slave\" && this.driver.isReplicated) {\n            this.databaseConnectionPromise = this.driver\n                .obtainSlaveConnection()\n                .then(([connection, release]: any[]) => {\n                    this.driver.connectedQueryRunners.push(this)\n                    this.databaseConnection = connection\n\n                    const onErrorCallback = (err: Error) =>\n                        this.releasePostgresConnection(err)\n                    this.releaseCallback = (err?: Error) => {\n                        this.databaseConnection.removeListener(\n                            \"error\",\n                            onErrorCallback,\n                        )\n                        release(err)\n                    }\n                    this.databaseConnection.on(\"error\", onErrorCallback)\n\n                    return this.databaseConnection\n                })\n        } else {\n            // master\n            this.databaseConnectionPromise = this.driver\n                .obtainMasterConnection()\n                .then(([connection, release]: any[]) => {\n                    this.driver.connectedQueryRunners.push(this)\n                    this.databaseConnection = connection\n\n                    const onErrorCallback = (err: Error) =>\n                        this.releasePostgresConnection(err)\n                    this.releaseCallback = (err?: Error) => {\n                        this.databaseConnection.removeListener(\n                            \"error\",\n                            onErrorCallback,\n                        )\n                        release(err)\n                    }\n                    this.databaseConnection.on(\"error\", onErrorCallback)\n\n                    return this.databaseConnection\n                })\n        }\n\n        return this.databaseConnectionPromise\n    }\n\n    /**\n     * Release a connection back to the pool, optionally specifying an Error to release with.\n     * Per pg-pool documentation this will prevent the pool from re-using the broken connection.\n     */\n    private async releasePostgresConnection(err?: Error) {\n        if (this.isReleased) {\n            return\n        }\n\n        this.isReleased = true\n        if (this.releaseCallback) {\n            this.releaseCallback(err)\n            this.releaseCallback = undefined\n        }\n\n        const index = this.driver.connectedQueryRunners.indexOf(this)\n\n        if (index !== -1) {\n            this.driver.connectedQueryRunners.splice(index, 1)\n        }\n    }\n\n    /**\n     * Releases used database connection.\n     * You cannot use query runner methods once its released.\n     */\n    release(): Promise<void> {\n        return this.releasePostgresConnection()\n    }\n\n    /**\n     * Starts transaction.\n     */\n    async startTransaction(isolationLevel?: IsolationLevel): Promise<void> {\n        this.isTransactionActive = true\n        try {\n            await this.broadcaster.broadcast(\"BeforeTransactionStart\")\n        } catch (err) {\n            this.isTransactionActive = false\n            throw err\n        }\n\n        if (this.transactionDepth === 0) {\n            this.transactionDepth += 1\n            await this.query(\"START TRANSACTION\")\n            if (isolationLevel) {\n                await this.query(\n                    \"SET TRANSACTION ISOLATION LEVEL \" + isolationLevel,\n                )\n            }\n        } else {\n            this.transactionDepth += 1\n            await this.query(`SAVEPOINT typeorm_${this.transactionDepth - 1}`)\n        }\n\n        await this.broadcaster.broadcast(\"AfterTransactionStart\")\n    }\n\n    /**\n     * Commits transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async commitTransaction(): Promise<void> {\n        if (!this.isTransactionActive) throw new TransactionNotStartedError()\n\n        await this.broadcaster.broadcast(\"BeforeTransactionCommit\")\n\n        if (this.transactionDepth > 1) {\n            this.transactionDepth -= 1\n            await this.query(\n                `RELEASE SAVEPOINT typeorm_${this.transactionDepth}`,\n            )\n        } else {\n            this.transactionDepth -= 1\n            await this.query(\"COMMIT\")\n            this.isTransactionActive = false\n        }\n\n        await this.broadcaster.broadcast(\"AfterTransactionCommit\")\n    }\n\n    /**\n     * Rollbacks transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async rollbackTransaction(): Promise<void> {\n        if (!this.isTransactionActive) throw new TransactionNotStartedError()\n\n        await this.broadcaster.broadcast(\"BeforeTransactionRollback\")\n\n        if (this.transactionDepth > 1) {\n            this.transactionDepth -= 1\n            await this.query(\n                `ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth}`,\n            )\n        } else {\n            this.transactionDepth -= 1\n            await this.query(\"ROLLBACK\")\n            this.isTransactionActive = false\n        }\n\n        await this.broadcaster.broadcast(\"AfterTransactionRollback\")\n    }\n\n    /**\n     * Executes a given SQL query.\n     */\n    async query(\n        query: string,\n        parameters?: any[],\n        useStructuredResult: boolean = false,\n    ): Promise<any> {\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        const databaseConnection = await this.connect()\n        const broadcasterResult = new BroadcasterResult()\n\n        this.driver.connection.logger.logQuery(query, parameters, this)\n        this.broadcaster.broadcastBeforeQueryEvent(\n            broadcasterResult,\n            query,\n            parameters,\n        )\n\n        try {\n            const queryStartTime = +new Date()\n            const raw = await databaseConnection.query(query, parameters)\n            // log slow queries if maxQueryExecution time is set\n            const maxQueryExecutionTime =\n                this.driver.options.maxQueryExecutionTime\n            const queryEndTime = +new Date()\n            const queryExecutionTime = queryEndTime - queryStartTime\n\n            this.broadcaster.broadcastAfterQueryEvent(\n                broadcasterResult,\n                query,\n                parameters,\n                true,\n                queryExecutionTime,\n                raw,\n                undefined,\n            )\n\n            if (\n                maxQueryExecutionTime &&\n                queryExecutionTime > maxQueryExecutionTime\n            )\n                this.driver.connection.logger.logQuerySlow(\n                    queryExecutionTime,\n                    query,\n                    parameters,\n                    this,\n                )\n\n            const result = new QueryResult()\n            if (raw) {\n                if (raw.hasOwnProperty(\"rows\")) {\n                    result.records = raw.rows\n                }\n\n                if (raw.hasOwnProperty(\"rowCount\")) {\n                    result.affected = raw.rowCount\n                }\n\n                switch (raw.command) {\n                    case \"DELETE\":\n                    case \"UPDATE\":\n                        // for UPDATE and DELETE query additionally return number of affected rows\n                        result.raw = [raw.rows, raw.rowCount]\n                        break\n                    default:\n                        result.raw = raw.rows\n                }\n\n                if (!useStructuredResult) {\n                    return result.raw\n                }\n            }\n\n            return result\n        } catch (err) {\n            this.driver.connection.logger.logQueryError(\n                err,\n                query,\n                parameters,\n                this,\n            )\n            this.broadcaster.broadcastAfterQueryEvent(\n                broadcasterResult,\n                query,\n                parameters,\n                false,\n                undefined,\n                undefined,\n                err,\n            )\n\n            throw new QueryFailedError(query, parameters, err)\n        } finally {\n            await broadcasterResult.wait()\n        }\n    }\n\n    /**\n     * Returns raw data stream.\n     */\n    async stream(\n        query: string,\n        parameters?: any[],\n        onEnd?: Function,\n        onError?: Function,\n    ): Promise<ReadStream> {\n        const QueryStream = this.driver.loadStreamDependency()\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        const databaseConnection = await this.connect()\n        this.driver.connection.logger.logQuery(query, parameters, this)\n        const stream = databaseConnection.query(\n            new QueryStream(query, parameters),\n        )\n        if (onEnd) stream.on(\"end\", onEnd)\n        if (onError) stream.on(\"error\", onError)\n\n        return stream\n    }\n\n    /**\n     * Returns all available database names including system databases.\n     */\n    async getDatabases(): Promise<string[]> {\n        return Promise.resolve([])\n    }\n\n    /**\n     * Returns all available schema names including system schemas.\n     * If database parameter specified, returns schemas of that database.\n     */\n    async getSchemas(database?: string): Promise<string[]> {\n        return Promise.resolve([])\n    }\n\n    /**\n     * Checks if database with the given name exist.\n     */\n    async hasDatabase(database: string): Promise<boolean> {\n        const result = await this.query(\n            `SELECT * FROM pg_database WHERE datname='${database}';`,\n        )\n        return result.length ? true : false\n    }\n\n    /**\n     * Loads currently using database\n     */\n    async getCurrentDatabase(): Promise<string> {\n        const query = await this.query(`SELECT * FROM current_database()`)\n        return query[0][\"current_database\"]\n    }\n\n    /**\n     * Checks if schema with the given name exist.\n     */\n    async hasSchema(schema: string): Promise<boolean> {\n        const result = await this.query(\n            `SELECT * FROM \"information_schema\".\"schemata\" WHERE \"schema_name\" = '${schema}'`,\n        )\n        return result.length ? true : false\n    }\n\n    /**\n     * Loads currently using database schema\n     */\n    async getCurrentSchema(): Promise<string> {\n        const query = await this.query(`SELECT * FROM current_schema()`)\n        return query[0][\"current_schema\"]\n    }\n\n    /**\n     * Checks if table with the given name exist in the database.\n     */\n    async hasTable(tableOrName: Table | string): Promise<boolean> {\n        const parsedTableName = this.driver.parseTableName(tableOrName)\n\n        if (!parsedTableName.schema) {\n            parsedTableName.schema = await this.getCurrentSchema()\n        }\n\n        const sql = `SELECT * FROM \"information_schema\".\"tables\" WHERE \"table_schema\" = '${parsedTableName.schema}' AND \"table_name\" = '${parsedTableName.tableName}'`\n        const result = await this.query(sql)\n        return result.length ? true : false\n    }\n\n    /**\n     * Checks if column with the given name exist in the given table.\n     */\n    async hasColumn(\n        tableOrName: Table | string,\n        columnName: string,\n    ): Promise<boolean> {\n        const parsedTableName = this.driver.parseTableName(tableOrName)\n\n        if (!parsedTableName.schema) {\n            parsedTableName.schema = await this.getCurrentSchema()\n        }\n\n        const sql = `SELECT * FROM \"information_schema\".\"columns\" WHERE \"table_schema\" = '${parsedTableName.schema}' AND \"table_name\" = '${parsedTableName.tableName}' AND \"column_name\" = '${columnName}'`\n        const result = await this.query(sql)\n        return result.length ? true : false\n    }\n\n    /**\n     * Creates a new database.\n     * Note: Postgres does not support database creation inside a transaction block.\n     */\n    async createDatabase(\n        database: string,\n        ifNotExist?: boolean,\n    ): Promise<void> {\n        if (ifNotExist) {\n            const databaseAlreadyExists = await this.hasDatabase(database)\n\n            if (databaseAlreadyExists) return Promise.resolve()\n        }\n\n        const up = `CREATE DATABASE \"${database}\"`\n        const down = `DROP DATABASE \"${database}\"`\n        await this.executeQueries(new Query(up), new Query(down))\n    }\n\n    /**\n     * Drops database.\n     * Note: Postgres does not support database dropping inside a transaction block.\n     */\n    async dropDatabase(database: string, ifExist?: boolean): Promise<void> {\n        const up = ifExist\n            ? `DROP DATABASE IF EXISTS \"${database}\"`\n            : `DROP DATABASE \"${database}\"`\n        const down = `CREATE DATABASE \"${database}\"`\n        await this.executeQueries(new Query(up), new Query(down))\n    }\n\n    /**\n     * Creates a new table schema.\n     */\n    async createSchema(\n        schemaPath: string,\n        ifNotExist?: boolean,\n    ): Promise<void> {\n        const schema =\n            schemaPath.indexOf(\".\") === -1\n                ? schemaPath\n                : schemaPath.split(\".\")[1]\n\n        const up = ifNotExist\n            ? `CREATE SCHEMA IF NOT EXISTS \"${schema}\"`\n            : `CREATE SCHEMA \"${schema}\"`\n        const down = `DROP SCHEMA \"${schema}\" CASCADE`\n        await this.executeQueries(new Query(up), new Query(down))\n    }\n\n    /**\n     * Drops table schema.\n     */\n    async dropSchema(\n        schemaPath: string,\n        ifExist?: boolean,\n        isCascade?: boolean,\n    ): Promise<void> {\n        const schema =\n            schemaPath.indexOf(\".\") === -1\n                ? schemaPath\n                : schemaPath.split(\".\")[1]\n\n        const up = ifExist\n            ? `DROP SCHEMA IF EXISTS \"${schema}\" ${isCascade ? \"CASCADE\" : \"\"}`\n            : `DROP SCHEMA \"${schema}\" ${isCascade ? \"CASCADE\" : \"\"}`\n        const down = `CREATE SCHEMA \"${schema}\"`\n        await this.executeQueries(new Query(up), new Query(down))\n    }\n\n    /**\n     * Creates a new table.\n     */\n    async createTable(\n        table: Table,\n        ifNotExist: boolean = false,\n        createForeignKeys: boolean = true,\n        createIndices: boolean = true,\n    ): Promise<void> {\n        if (ifNotExist) {\n            const isTableExist = await this.hasTable(table)\n            if (isTableExist) return Promise.resolve()\n        }\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        // if table have column with ENUM type, we must create this type in postgres.\n        const enumColumns = table.columns.filter(\n            (column) => column.type === \"enum\" || column.type === \"simple-enum\",\n        )\n        const createdEnumTypes: string[] = []\n        for (const column of enumColumns) {\n            // TODO: Should also check if values of existing type matches expected ones\n            const hasEnum = await this.hasEnumType(table, column)\n            const enumName = this.buildEnumName(table, column)\n\n            // if enum with the same \"enumName\" is defined more then once, me must prevent double creation\n            if (!hasEnum && createdEnumTypes.indexOf(enumName) === -1) {\n                createdEnumTypes.push(enumName)\n                upQueries.push(this.createEnumTypeSql(table, column, enumName))\n                downQueries.push(this.dropEnumTypeSql(table, column, enumName))\n            }\n        }\n\n        // if table have column with generated type, we must add the expression to the metadata table\n        const generatedColumns = table.columns.filter(\n            (column) =>\n                column.generatedType === \"STORED\" && column.asExpression,\n        )\n        for (const column of generatedColumns) {\n            const tableNameWithSchema = (\n                await this.getTableNameWithSchema(table.name)\n            ).split(\".\")\n            const tableName = tableNameWithSchema[1]\n            const schema = tableNameWithSchema[0]\n\n            const insertQuery = this.insertTypeormMetadataSql({\n                database: this.driver.database,\n                schema,\n                table: tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            })\n\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                database: this.driver.database,\n                schema,\n                table: tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            })\n\n            upQueries.push(insertQuery)\n            downQueries.push(deleteQuery)\n        }\n\n        upQueries.push(this.createTableSql(table, createForeignKeys))\n        downQueries.push(this.dropTableSql(table))\n\n        // if createForeignKeys is true, we must drop created foreign keys in down query.\n        // createTable does not need separate method to create foreign keys, because it create fk's in the same query with table creation.\n        if (createForeignKeys)\n            table.foreignKeys.forEach((foreignKey) =>\n                downQueries.push(this.dropForeignKeySql(table, foreignKey)),\n            )\n\n        if (createIndices) {\n            table.indices.forEach((index) => {\n                // new index may be passed without name. In this case we generate index name manually.\n                if (!index.name)\n                    index.name = this.connection.namingStrategy.indexName(\n                        table,\n                        index.columnNames,\n                        index.where,\n                    )\n                upQueries.push(this.createIndexSql(table, index))\n                downQueries.push(this.dropIndexSql(table, index))\n            })\n        }\n        \n        if (table.comment) {\n            upQueries.push(new Query(\"COMMENT ON TABLE \" + this.escapePath(table) + \" IS '\" + table.comment + \"'\"));\n            downQueries.push(new Query(\"COMMENT ON TABLE \" + this.escapePath(table) + \" IS NULL\"));\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Drops the table.\n     */\n    async dropTable(\n        target: Table | string,\n        ifExist?: boolean,\n        dropForeignKeys: boolean = true,\n        dropIndices: boolean = true,\n    ): Promise<void> {\n        // It needs because if table does not exist and dropForeignKeys or dropIndices is true, we don't need\n        // to perform drop queries for foreign keys and indices.\n        if (ifExist) {\n            const isTableExist = await this.hasTable(target)\n            if (!isTableExist) return Promise.resolve()\n        }\n\n        // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.\n        const createForeignKeys: boolean = dropForeignKeys\n        const tablePath = this.getTablePath(target)\n        const table = await this.getCachedTable(tablePath)\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        if (dropIndices) {\n            table.indices.forEach((index) => {\n                upQueries.push(this.dropIndexSql(table, index))\n                downQueries.push(this.createIndexSql(table, index))\n            })\n        }\n\n        if (dropForeignKeys)\n            table.foreignKeys.forEach((foreignKey) =>\n                upQueries.push(this.dropForeignKeySql(table, foreignKey)),\n            )\n\n        upQueries.push(this.dropTableSql(table))\n        downQueries.push(this.createTableSql(table, createForeignKeys))\n\n        // if table had columns with generated type, we must remove the expression from the metadata table\n        const generatedColumns = table.columns.filter(\n            (column) => column.generatedType && column.asExpression,\n        )\n        for (const column of generatedColumns) {\n            const tableNameWithSchema = (\n                await this.getTableNameWithSchema(table.name)\n            ).split(\".\")\n            const tableName = tableNameWithSchema[1]\n            const schema = tableNameWithSchema[0]\n\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                database: this.driver.database,\n                schema,\n                table: tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            })\n\n            const insertQuery = this.insertTypeormMetadataSql({\n                database: this.driver.database,\n                schema,\n                table: tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            })\n\n            upQueries.push(deleteQuery)\n            downQueries.push(insertQuery)\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Creates a new view.\n     */\n    async createView(\n        view: View,\n        syncWithMetadata: boolean = false,\n    ): Promise<void> {\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n        upQueries.push(this.createViewSql(view))\n        if (syncWithMetadata)\n            upQueries.push(await this.insertViewDefinitionSql(view))\n        downQueries.push(this.dropViewSql(view))\n        if (syncWithMetadata)\n            downQueries.push(await this.deleteViewDefinitionSql(view))\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Drops the view.\n     */\n    async dropView(target: View | string): Promise<void> {\n        const viewName = InstanceChecker.isView(target) ? target.name : target\n        const view = await this.getCachedView(viewName)\n\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n        upQueries.push(await this.deleteViewDefinitionSql(view))\n        upQueries.push(this.dropViewSql(view))\n        downQueries.push(await this.insertViewDefinitionSql(view))\n        downQueries.push(this.createViewSql(view))\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Renames the given table.\n     */\n    async renameTable(\n        oldTableOrName: Table | string,\n        newTableName: string,\n    ): Promise<void> {\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n        const oldTable = InstanceChecker.isTable(oldTableOrName)\n            ? oldTableOrName\n            : await this.getCachedTable(oldTableOrName)\n        const newTable = oldTable.clone()\n\n        const { schema: schemaName, tableName: oldTableName } =\n            this.driver.parseTableName(oldTable)\n\n        newTable.name = schemaName\n            ? `${schemaName}.${newTableName}`\n            : newTableName\n\n        upQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    oldTable,\n                )} RENAME TO \"${newTableName}\"`,\n            ),\n        )\n        downQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    newTable,\n                )} RENAME TO \"${oldTableName}\"`,\n            ),\n        )\n\n        // rename column primary key constraint if it has default constraint name\n        if (\n            newTable.primaryColumns.length > 0 &&\n            !newTable.primaryColumns[0].primaryKeyConstraintName\n        ) {\n            const columnNames = newTable.primaryColumns.map(\n                (column) => column.name,\n            )\n\n            const oldPkName = this.connection.namingStrategy.primaryKeyName(\n                oldTable,\n                columnNames,\n            )\n\n            const newPkName = this.connection.namingStrategy.primaryKeyName(\n                newTable,\n                columnNames,\n            )\n\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        newTable,\n                    )} RENAME CONSTRAINT \"${oldPkName}\" TO \"${newPkName}\"`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        newTable,\n                    )} RENAME CONSTRAINT \"${newPkName}\" TO \"${oldPkName}\"`,\n                ),\n            )\n        }\n\n        // rename sequences\n        newTable.columns.map((col) => {\n            if (col.isGenerated && col.generationStrategy === \"increment\") {\n                const sequencePath = this.buildSequencePath(oldTable, col.name)\n                const sequenceName = this.buildSequenceName(oldTable, col.name)\n\n                const newSequencePath = this.buildSequencePath(\n                    newTable,\n                    col.name,\n                )\n                const newSequenceName = this.buildSequenceName(\n                    newTable,\n                    col.name,\n                )\n\n                const up = `ALTER SEQUENCE ${this.escapePath(\n                    sequencePath,\n                )} RENAME TO \"${newSequenceName}\"`\n                const down = `ALTER SEQUENCE ${this.escapePath(\n                    newSequencePath,\n                )} RENAME TO \"${sequenceName}\"`\n\n                upQueries.push(new Query(up))\n                downQueries.push(new Query(down))\n            }\n        })\n\n        // rename unique constraints\n        newTable.uniques.forEach((unique) => {\n            const oldUniqueName =\n                this.connection.namingStrategy.uniqueConstraintName(\n                    oldTable,\n                    unique.columnNames,\n                )\n\n            // Skip renaming if Unique has user defined constraint name\n            if (unique.name !== oldUniqueName) return\n\n            // build new constraint name\n            const newUniqueName =\n                this.connection.namingStrategy.uniqueConstraintName(\n                    newTable,\n                    unique.columnNames,\n                )\n\n            // build queries\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        newTable,\n                    )} RENAME CONSTRAINT \"${\n                        unique.name\n                    }\" TO \"${newUniqueName}\"`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        newTable,\n                    )} RENAME CONSTRAINT \"${newUniqueName}\" TO \"${\n                        unique.name\n                    }\"`,\n                ),\n            )\n\n            // replace constraint name\n            unique.name = newUniqueName\n        })\n\n        // rename index constraints\n        newTable.indices.forEach((index) => {\n            const oldIndexName = this.connection.namingStrategy.indexName(\n                oldTable,\n                index.columnNames,\n                index.where,\n            )\n\n            // Skip renaming if Index has user defined constraint name\n            if (index.name !== oldIndexName) return\n\n            // build new constraint name\n            const { schema } = this.driver.parseTableName(newTable)\n            const newIndexName = this.connection.namingStrategy.indexName(\n                newTable,\n                index.columnNames,\n                index.where,\n            )\n\n            // build queries\n            const up = schema\n                ? `ALTER INDEX \"${schema}\".\"${index.name}\" RENAME TO \"${newIndexName}\"`\n                : `ALTER INDEX \"${index.name}\" RENAME TO \"${newIndexName}\"`\n            const down = schema\n                ? `ALTER INDEX \"${schema}\".\"${newIndexName}\" RENAME TO \"${index.name}\"`\n                : `ALTER INDEX \"${newIndexName}\" RENAME TO \"${index.name}\"`\n            upQueries.push(new Query(up))\n            downQueries.push(new Query(down))\n\n            // replace constraint name\n            index.name = newIndexName\n        })\n\n        // rename foreign key constraints\n        newTable.foreignKeys.forEach((foreignKey) => {\n            const oldForeignKeyName =\n                this.connection.namingStrategy.foreignKeyName(\n                    oldTable,\n                    foreignKey.columnNames,\n                    this.getTablePath(foreignKey),\n                    foreignKey.referencedColumnNames,\n                )\n\n            // Skip renaming if foreign key has user defined constraint name\n            if (foreignKey.name !== oldForeignKeyName) return\n\n            // build new constraint name\n            const newForeignKeyName =\n                this.connection.namingStrategy.foreignKeyName(\n                    newTable,\n                    foreignKey.columnNames,\n                    this.getTablePath(foreignKey),\n                    foreignKey.referencedColumnNames,\n                )\n\n            // build queries\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        newTable,\n                    )} RENAME CONSTRAINT \"${\n                        foreignKey.name\n                    }\" TO \"${newForeignKeyName}\"`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        newTable,\n                    )} RENAME CONSTRAINT \"${newForeignKeyName}\" TO \"${\n                        foreignKey.name\n                    }\"`,\n                ),\n            )\n\n            // replace constraint name\n            foreignKey.name = newForeignKeyName\n        })\n\n        // rename ENUM types\n        const enumColumns = newTable.columns.filter(\n            (column) => column.type === \"enum\" || column.type === \"simple-enum\",\n        )\n        for (let column of enumColumns) {\n            // skip renaming for user-defined enum name\n            if (column.enumName) continue\n\n            const oldEnumType = await this.getUserDefinedTypeName(\n                oldTable,\n                column,\n            )\n            upQueries.push(\n                new Query(\n                    `ALTER TYPE \"${oldEnumType.schema}\".\"${\n                        oldEnumType.name\n                    }\" RENAME TO ${this.buildEnumName(\n                        newTable,\n                        column,\n                        false,\n                    )}`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TYPE ${this.buildEnumName(\n                        newTable,\n                        column,\n                    )} RENAME TO \"${oldEnumType.name}\"`,\n                ),\n            )\n        }\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Creates a new column from the column in the table.\n     */\n    async addColumn(\n        tableOrName: Table | string,\n        column: TableColumn,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const clonedTable = table.clone()\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        if (column.type === \"enum\" || column.type === \"simple-enum\") {\n            const hasEnum = await this.hasEnumType(table, column)\n            if (!hasEnum) {\n                upQueries.push(this.createEnumTypeSql(table, column))\n                downQueries.push(this.dropEnumTypeSql(table, column))\n            }\n        }\n\n        upQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    table,\n                )} ADD ${this.buildCreateColumnSql(table, column)}`,\n            ),\n        )\n        downQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(table)} DROP COLUMN \"${\n                    column.name\n                }\"`,\n            ),\n        )\n\n        // create or update primary key constraint\n        if (column.isPrimary) {\n            const primaryColumns = clonedTable.primaryColumns\n            // if table already have primary key, me must drop it and recreate again\n            if (primaryColumns.length > 0) {\n                const pkName = primaryColumns[0].primaryKeyConstraintName\n                    ? primaryColumns[0].primaryKeyConstraintName\n                    : this.connection.namingStrategy.primaryKeyName(\n                          clonedTable,\n                          primaryColumns.map((column) => column.name),\n                      )\n\n                const columnNames = primaryColumns\n                    .map((column) => `\"${column.name}\"`)\n                    .join(\", \")\n\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(\n                            table,\n                        )} DROP CONSTRAINT \"${pkName}\"`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(\n                            table,\n                        )} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`,\n                    ),\n                )\n            }\n\n            primaryColumns.push(column)\n            const pkName = primaryColumns[0].primaryKeyConstraintName\n                ? primaryColumns[0].primaryKeyConstraintName\n                : this.connection.namingStrategy.primaryKeyName(\n                      clonedTable,\n                      primaryColumns.map((column) => column.name),\n                  )\n\n            const columnNames = primaryColumns\n                .map((column) => `\"${column.name}\"`)\n                .join(\", \")\n\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        table,\n                    )} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        table,\n                    )} DROP CONSTRAINT \"${pkName}\"`,\n                ),\n            )\n        }\n\n        // create column index\n        const columnIndex = clonedTable.indices.find(\n            (index) =>\n                index.columnNames.length === 1 &&\n                index.columnNames[0] === column.name,\n        )\n        if (columnIndex) {\n            upQueries.push(this.createIndexSql(table, columnIndex))\n            downQueries.push(this.dropIndexSql(table, columnIndex))\n        }\n\n        // create unique constraint\n        if (column.isUnique) {\n            const uniqueConstraint = new TableUnique({\n                name: this.connection.namingStrategy.uniqueConstraintName(\n                    table,\n                    [column.name],\n                ),\n                columnNames: [column.name],\n            })\n            clonedTable.uniques.push(uniqueConstraint)\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${\n                        uniqueConstraint.name\n                    }\" UNIQUE (\"${column.name}\")`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${\n                        uniqueConstraint.name\n                    }\"`,\n                ),\n            )\n        }\n\n        if (column.generatedType === \"STORED\" && column.asExpression) {\n            const tableNameWithSchema = (\n                await this.getTableNameWithSchema(table.name)\n            ).split(\".\")\n            const tableName = tableNameWithSchema[1]\n            const schema = tableNameWithSchema[0]\n\n            const insertQuery = this.insertTypeormMetadataSql({\n                database: this.driver.database,\n                schema,\n                table: tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            })\n\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                database: this.driver.database,\n                schema,\n                table: tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            })\n\n            upQueries.push(insertQuery)\n            downQueries.push(deleteQuery)\n        }\n\n        // create column's comment\n        if (column.comment) {\n            upQueries.push(\n                new Query(\n                    `COMMENT ON COLUMN ${this.escapePath(table)}.\"${\n                        column.name\n                    }\" IS ${this.escapeComment(column.comment)}`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `COMMENT ON COLUMN ${this.escapePath(table)}.\"${\n                        column.name\n                    }\" IS ${this.escapeComment(column.comment)}`,\n                ),\n            )\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n\n        clonedTable.addColumn(column)\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Creates a new columns from the column in the table.\n     */\n    async addColumns(\n        tableOrName: Table | string,\n        columns: TableColumn[],\n    ): Promise<void> {\n        for (const column of columns) {\n            await this.addColumn(tableOrName, column)\n        }\n    }\n\n    /**\n     * Renames column in the given table.\n     */\n    async renameColumn(\n        tableOrName: Table | string,\n        oldTableColumnOrName: TableColumn | string,\n        newTableColumnOrName: TableColumn | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName)\n            ? oldTableColumnOrName\n            : table.columns.find((c) => c.name === oldTableColumnOrName)\n        if (!oldColumn)\n            throw new TypeORMError(\n                `Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`,\n            )\n\n        let newColumn\n        if (InstanceChecker.isTableColumn(newTableColumnOrName)) {\n            newColumn = newTableColumnOrName\n        } else {\n            newColumn = oldColumn.clone()\n            newColumn.name = newTableColumnOrName\n        }\n\n        return this.changeColumn(table, oldColumn, newColumn)\n    }\n\n    /**\n     * Changes a column in the table.\n     */\n    async changeColumn(\n        tableOrName: Table | string,\n        oldTableColumnOrName: TableColumn | string,\n        newColumn: TableColumn,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        let clonedTable = table.clone()\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n        let defaultValueChanged = false\n\n        const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName)\n            ? oldTableColumnOrName\n            : table.columns.find(\n                  (column) => column.name === oldTableColumnOrName,\n              )\n        if (!oldColumn)\n            throw new TypeORMError(\n                `Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`,\n            )\n\n        if (\n            oldColumn.type !== newColumn.type ||\n            oldColumn.length !== newColumn.length ||\n            newColumn.isArray !== oldColumn.isArray ||\n            (!oldColumn.generatedType &&\n                newColumn.generatedType === \"STORED\") ||\n            (oldColumn.asExpression !== newColumn.asExpression &&\n                newColumn.generatedType === \"STORED\")\n        ) {\n            // To avoid data conversion, we just recreate column\n            await this.dropColumn(table, oldColumn)\n            await this.addColumn(table, newColumn)\n\n            // update cloned table\n            clonedTable = table.clone()\n        } else {\n            if (oldColumn.name !== newColumn.name) {\n                // rename column\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} RENAME COLUMN \"${\n                            oldColumn.name\n                        }\" TO \"${newColumn.name}\"`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} RENAME COLUMN \"${\n                            newColumn.name\n                        }\" TO \"${oldColumn.name}\"`,\n                    ),\n                )\n\n                // rename ENUM type\n                if (\n                    oldColumn.type === \"enum\" ||\n                    oldColumn.type === \"simple-enum\"\n                ) {\n                    const oldEnumType = await this.getUserDefinedTypeName(\n                        table,\n                        oldColumn,\n                    )\n                    upQueries.push(\n                        new Query(\n                            `ALTER TYPE \"${oldEnumType.schema}\".\"${\n                                oldEnumType.name\n                            }\" RENAME TO ${this.buildEnumName(\n                                table,\n                                newColumn,\n                                false,\n                            )}`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TYPE ${this.buildEnumName(\n                                table,\n                                newColumn,\n                            )} RENAME TO \"${oldEnumType.name}\"`,\n                        ),\n                    )\n                }\n\n                // rename column primary key constraint\n                if (\n                    oldColumn.isPrimary === true &&\n                    !oldColumn.primaryKeyConstraintName\n                ) {\n                    const primaryColumns = clonedTable.primaryColumns\n\n                    // build old primary constraint name\n                    const columnNames = primaryColumns.map(\n                        (column) => column.name,\n                    )\n                    const oldPkName =\n                        this.connection.namingStrategy.primaryKeyName(\n                            clonedTable,\n                            columnNames,\n                        )\n\n                    // replace old column name with new column name\n                    columnNames.splice(columnNames.indexOf(oldColumn.name), 1)\n                    columnNames.push(newColumn.name)\n\n                    // build new primary constraint name\n                    const newPkName =\n                        this.connection.namingStrategy.primaryKeyName(\n                            clonedTable,\n                            columnNames,\n                        )\n\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} RENAME CONSTRAINT \"${oldPkName}\" TO \"${newPkName}\"`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} RENAME CONSTRAINT \"${newPkName}\" TO \"${oldPkName}\"`,\n                        ),\n                    )\n                }\n\n                // rename column sequence\n                if (\n                    oldColumn.isGenerated === true &&\n                    newColumn.generationStrategy === \"increment\"\n                ) {\n                    const sequencePath = this.buildSequencePath(\n                        table,\n                        oldColumn.name,\n                    )\n                    const sequenceName = this.buildSequenceName(\n                        table,\n                        oldColumn.name,\n                    )\n\n                    const newSequencePath = this.buildSequencePath(\n                        table,\n                        newColumn.name,\n                    )\n                    const newSequenceName = this.buildSequenceName(\n                        table,\n                        newColumn.name,\n                    )\n\n                    const up = `ALTER SEQUENCE ${this.escapePath(\n                        sequencePath,\n                    )} RENAME TO \"${newSequenceName}\"`\n                    const down = `ALTER SEQUENCE ${this.escapePath(\n                        newSequencePath,\n                    )} RENAME TO \"${sequenceName}\"`\n\n                    upQueries.push(new Query(up))\n                    downQueries.push(new Query(down))\n                }\n\n                // rename unique constraints\n                clonedTable.findColumnUniques(oldColumn).forEach((unique) => {\n                    const oldUniqueName =\n                        this.connection.namingStrategy.uniqueConstraintName(\n                            clonedTable,\n                            unique.columnNames,\n                        )\n\n                    // Skip renaming if Unique has user defined constraint name\n                    if (unique.name !== oldUniqueName) return\n\n                    // build new constraint name\n                    unique.columnNames.splice(\n                        unique.columnNames.indexOf(oldColumn.name),\n                        1,\n                    )\n                    unique.columnNames.push(newColumn.name)\n                    const newUniqueName =\n                        this.connection.namingStrategy.uniqueConstraintName(\n                            clonedTable,\n                            unique.columnNames,\n                        )\n\n                    // build queries\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} RENAME CONSTRAINT \"${\n                                unique.name\n                            }\" TO \"${newUniqueName}\"`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} RENAME CONSTRAINT \"${newUniqueName}\" TO \"${\n                                unique.name\n                            }\"`,\n                        ),\n                    )\n\n                    // replace constraint name\n                    unique.name = newUniqueName\n                })\n\n                // rename index constraints\n                clonedTable.findColumnIndices(oldColumn).forEach((index) => {\n                    const oldIndexName =\n                        this.connection.namingStrategy.indexName(\n                            clonedTable,\n                            index.columnNames,\n                            index.where,\n                        )\n\n                    // Skip renaming if Index has user defined constraint name\n                    if (index.name !== oldIndexName) return\n\n                    // build new constraint name\n                    index.columnNames.splice(\n                        index.columnNames.indexOf(oldColumn.name),\n                        1,\n                    )\n                    index.columnNames.push(newColumn.name)\n                    const { schema } = this.driver.parseTableName(table)\n                    const newIndexName =\n                        this.connection.namingStrategy.indexName(\n                            clonedTable,\n                            index.columnNames,\n                            index.where,\n                        )\n\n                    // build queries\n                    const up = schema\n                        ? `ALTER INDEX \"${schema}\".\"${index.name}\" RENAME TO \"${newIndexName}\"`\n                        : `ALTER INDEX \"${index.name}\" RENAME TO \"${newIndexName}\"`\n                    const down = schema\n                        ? `ALTER INDEX \"${schema}\".\"${newIndexName}\" RENAME TO \"${index.name}\"`\n                        : `ALTER INDEX \"${newIndexName}\" RENAME TO \"${index.name}\"`\n\n                    upQueries.push(new Query(up))\n                    downQueries.push(new Query(down))\n\n                    // replace constraint name\n                    index.name = newIndexName\n                })\n\n                // rename foreign key constraints\n                clonedTable\n                    .findColumnForeignKeys(oldColumn)\n                    .forEach((foreignKey) => {\n                        const foreignKeyName =\n                            this.connection.namingStrategy.foreignKeyName(\n                                clonedTable,\n                                foreignKey.columnNames,\n                                this.getTablePath(foreignKey),\n                                foreignKey.referencedColumnNames,\n                            )\n\n                        // Skip renaming if foreign key has user defined constraint name\n                        if (foreignKey.name !== foreignKeyName) return\n\n                        // build new constraint name\n                        foreignKey.columnNames.splice(\n                            foreignKey.columnNames.indexOf(oldColumn.name),\n                            1,\n                        )\n                        foreignKey.columnNames.push(newColumn.name)\n                        const newForeignKeyName =\n                            this.connection.namingStrategy.foreignKeyName(\n                                clonedTable,\n                                foreignKey.columnNames,\n                                this.getTablePath(foreignKey),\n                                foreignKey.referencedColumnNames,\n                            )\n\n                        // build queries\n                        upQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} RENAME CONSTRAINT \"${\n                                    foreignKey.name\n                                }\" TO \"${newForeignKeyName}\"`,\n                            ),\n                        )\n                        downQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} RENAME CONSTRAINT \"${newForeignKeyName}\" TO \"${\n                                    foreignKey.name\n                                }\"`,\n                            ),\n                        )\n\n                        // replace constraint name\n                        foreignKey.name = newForeignKeyName\n                    })\n\n                // rename old column in the Table object\n                const oldTableColumn = clonedTable.columns.find(\n                    (column) => column.name === oldColumn.name,\n                )\n                clonedTable.columns[\n                    clonedTable.columns.indexOf(oldTableColumn!)\n                ].name = newColumn.name\n                oldColumn.name = newColumn.name\n            }\n\n            if (\n                newColumn.precision !== oldColumn.precision ||\n                newColumn.scale !== oldColumn.scale\n            ) {\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${\n                            newColumn.name\n                        }\" TYPE ${this.driver.createFullType(newColumn)}`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${\n                            newColumn.name\n                        }\" TYPE ${this.driver.createFullType(oldColumn)}`,\n                    ),\n                )\n            }\n\n            if (\n                (newColumn.type === \"enum\" ||\n                    newColumn.type === \"simple-enum\") &&\n                (oldColumn.type === \"enum\" ||\n                    oldColumn.type === \"simple-enum\") &&\n                (!OrmUtils.isArraysEqual(newColumn.enum!, oldColumn.enum!) ||\n                    newColumn.enumName !== oldColumn.enumName)\n            ) {\n                const arraySuffix = newColumn.isArray ? \"[]\" : \"\"\n\n                // \"public\".\"new_enum\"\n                const newEnumName = this.buildEnumName(table, newColumn)\n\n                // \"public\".\"old_enum\"\n                const oldEnumName = this.buildEnumName(table, oldColumn)\n\n                // \"old_enum\"\n                const oldEnumNameWithoutSchema = this.buildEnumName(\n                    table,\n                    oldColumn,\n                    false,\n                )\n\n                //\"public\".\"old_enum_old\"\n                const oldEnumNameWithSchema_old = this.buildEnumName(\n                    table,\n                    oldColumn,\n                    true,\n                    false,\n                    true,\n                )\n\n                //\"old_enum_old\"\n                const oldEnumNameWithoutSchema_old = this.buildEnumName(\n                    table,\n                    oldColumn,\n                    false,\n                    false,\n                    true,\n                )\n\n                // rename old ENUM\n                upQueries.push(\n                    new Query(\n                        `ALTER TYPE ${oldEnumName} RENAME TO ${oldEnumNameWithoutSchema_old}`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TYPE ${oldEnumNameWithSchema_old} RENAME TO ${oldEnumNameWithoutSchema}`,\n                    ),\n                )\n\n                // create new ENUM\n                upQueries.push(\n                    this.createEnumTypeSql(table, newColumn, newEnumName),\n                )\n                downQueries.push(\n                    this.dropEnumTypeSql(table, newColumn, newEnumName),\n                )\n\n                // if column have default value, we must drop it to avoid issues with type casting\n                if (\n                    oldColumn.default !== null &&\n                    oldColumn.default !== undefined\n                ) {\n                    // mark default as changed to prevent double update\n                    defaultValueChanged = true\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${oldColumn.name}\" DROP DEFAULT`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${oldColumn.name}\" SET DEFAULT ${\n                                oldColumn.default\n                            }`,\n                        ),\n                    )\n                }\n\n                // build column types\n                const upType = `${newEnumName}${arraySuffix} USING \"${newColumn.name}\"::\"text\"::${newEnumName}${arraySuffix}`\n                const downType = `${oldEnumNameWithSchema_old}${arraySuffix} USING \"${newColumn.name}\"::\"text\"::${oldEnumNameWithSchema_old}${arraySuffix}`\n\n                // update column to use new type\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${\n                            newColumn.name\n                        }\" TYPE ${upType}`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${\n                            newColumn.name\n                        }\" TYPE ${downType}`,\n                    ),\n                )\n\n                // restore column default or create new one\n                if (\n                    newColumn.default !== null &&\n                    newColumn.default !== undefined\n                ) {\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${\n                                newColumn.default\n                            }`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`,\n                        ),\n                    )\n                }\n\n                // remove old ENUM\n                upQueries.push(\n                    this.dropEnumTypeSql(\n                        table,\n                        oldColumn,\n                        oldEnumNameWithSchema_old,\n                    ),\n                )\n                downQueries.push(\n                    this.createEnumTypeSql(\n                        table,\n                        oldColumn,\n                        oldEnumNameWithSchema_old,\n                    ),\n                )\n            }\n\n            if (oldColumn.isNullable !== newColumn.isNullable) {\n                if (newColumn.isNullable) {\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${oldColumn.name}\" DROP NOT NULL`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${oldColumn.name}\" SET NOT NULL`,\n                        ),\n                    )\n                } else {\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${oldColumn.name}\" SET NOT NULL`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${oldColumn.name}\" DROP NOT NULL`,\n                        ),\n                    )\n                }\n            }\n\n            if (oldColumn.comment !== newColumn.comment) {\n                upQueries.push(\n                    new Query(\n                        `COMMENT ON COLUMN ${this.escapePath(table)}.\"${\n                            oldColumn.name\n                        }\" IS ${this.escapeComment(newColumn.comment)}`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `COMMENT ON COLUMN ${this.escapePath(table)}.\"${\n                            newColumn.name\n                        }\" IS ${this.escapeComment(oldColumn.comment)}`,\n                    ),\n                )\n            }\n\n            if (newColumn.isPrimary !== oldColumn.isPrimary) {\n                const primaryColumns = clonedTable.primaryColumns\n\n                // if primary column state changed, we must always drop existed constraint.\n                if (primaryColumns.length > 0) {\n                    const pkName = primaryColumns[0].primaryKeyConstraintName\n                        ? primaryColumns[0].primaryKeyConstraintName\n                        : this.connection.namingStrategy.primaryKeyName(\n                              clonedTable,\n                              primaryColumns.map((column) => column.name),\n                          )\n\n                    const columnNames = primaryColumns\n                        .map((column) => `\"${column.name}\"`)\n                        .join(\", \")\n\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP CONSTRAINT \"${pkName}\"`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`,\n                        ),\n                    )\n                }\n\n                if (newColumn.isPrimary === true) {\n                    primaryColumns.push(newColumn)\n                    // update column in table\n                    const column = clonedTable.columns.find(\n                        (column) => column.name === newColumn.name,\n                    )\n                    column!.isPrimary = true\n                    const pkName = primaryColumns[0].primaryKeyConstraintName\n                        ? primaryColumns[0].primaryKeyConstraintName\n                        : this.connection.namingStrategy.primaryKeyName(\n                              clonedTable,\n                              primaryColumns.map((column) => column.name),\n                          )\n\n                    const columnNames = primaryColumns\n                        .map((column) => `\"${column.name}\"`)\n                        .join(\", \")\n\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP CONSTRAINT \"${pkName}\"`,\n                        ),\n                    )\n                } else {\n                    const primaryColumn = primaryColumns.find(\n                        (c) => c.name === newColumn.name,\n                    )\n                    primaryColumns.splice(\n                        primaryColumns.indexOf(primaryColumn!),\n                        1,\n                    )\n\n                    // update column in table\n                    const column = clonedTable.columns.find(\n                        (column) => column.name === newColumn.name,\n                    )\n                    column!.isPrimary = false\n\n                    // if we have another primary keys, we must recreate constraint.\n                    if (primaryColumns.length > 0) {\n                        const pkName = primaryColumns[0]\n                            .primaryKeyConstraintName\n                            ? primaryColumns[0].primaryKeyConstraintName\n                            : this.connection.namingStrategy.primaryKeyName(\n                                  clonedTable,\n                                  primaryColumns.map((column) => column.name),\n                              )\n\n                        const columnNames = primaryColumns\n                            .map((column) => `\"${column.name}\"`)\n                            .join(\", \")\n\n                        upQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`,\n                            ),\n                        )\n                        downQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} DROP CONSTRAINT \"${pkName}\"`,\n                            ),\n                        )\n                    }\n                }\n            }\n\n            if (newColumn.isUnique !== oldColumn.isUnique) {\n                if (newColumn.isUnique === true) {\n                    const uniqueConstraint = new TableUnique({\n                        name: this.connection.namingStrategy.uniqueConstraintName(\n                            table,\n                            [newColumn.name],\n                        ),\n                        columnNames: [newColumn.name],\n                    })\n                    clonedTable.uniques.push(uniqueConstraint)\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ADD CONSTRAINT \"${\n                                uniqueConstraint.name\n                            }\" UNIQUE (\"${newColumn.name}\")`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP CONSTRAINT \"${uniqueConstraint.name}\"`,\n                        ),\n                    )\n                } else {\n                    const uniqueConstraint = clonedTable.uniques.find(\n                        (unique) => {\n                            return (\n                                unique.columnNames.length === 1 &&\n                                !!unique.columnNames.find(\n                                    (columnName) =>\n                                        columnName === newColumn.name,\n                                )\n                            )\n                        },\n                    )\n                    clonedTable.uniques.splice(\n                        clonedTable.uniques.indexOf(uniqueConstraint!),\n                        1,\n                    )\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP CONSTRAINT \"${uniqueConstraint!.name}\"`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ADD CONSTRAINT \"${\n                                uniqueConstraint!.name\n                            }\" UNIQUE (\"${newColumn.name}\")`,\n                        ),\n                    )\n                }\n            }\n\n            if (oldColumn.isGenerated !== newColumn.isGenerated) {\n                // if old column was \"generated\", we should clear defaults\n                if (oldColumn.isGenerated) {\n                    if (oldColumn.generationStrategy === \"uuid\") {\n                        upQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ALTER COLUMN \"${\n                                    oldColumn.name\n                                }\" DROP DEFAULT`,\n                            ),\n                        )\n                        downQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ALTER COLUMN \"${\n                                    oldColumn.name\n                                }\" SET DEFAULT ${this.driver.uuidGenerator}`,\n                            ),\n                        )\n                    } else if (oldColumn.generationStrategy === \"increment\") {\n                        upQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ALTER COLUMN \"${\n                                    newColumn.name\n                                }\" DROP DEFAULT`,\n                            ),\n                        )\n                        downQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ALTER COLUMN \"${\n                                    newColumn.name\n                                }\" SET DEFAULT nextval('${this.escapePath(\n                                    this.buildSequencePath(table, newColumn),\n                                )}')`,\n                            ),\n                        )\n\n                        upQueries.push(\n                            new Query(\n                                `DROP SEQUENCE ${this.escapePath(\n                                    this.buildSequencePath(table, newColumn),\n                                )}`,\n                            ),\n                        )\n                        downQueries.push(\n                            new Query(\n                                `CREATE SEQUENCE IF NOT EXISTS ${this.escapePath(\n                                    this.buildSequencePath(table, newColumn),\n                                )} OWNED BY ${this.escapePath(table)}.\"${\n                                    newColumn.name\n                                }\"`,\n                            ),\n                        )\n                    }\n                }\n\n                if (newColumn.generationStrategy === \"uuid\") {\n                    if (newColumn.isGenerated === true) {\n                        upQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ALTER COLUMN \"${\n                                    newColumn.name\n                                }\" SET DEFAULT ${this.driver.uuidGenerator}`,\n                            ),\n                        )\n                        downQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ALTER COLUMN \"${\n                                    newColumn.name\n                                }\" DROP DEFAULT`,\n                            ),\n                        )\n                    } else {\n                        upQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ALTER COLUMN \"${\n                                    newColumn.name\n                                }\" DROP DEFAULT`,\n                            ),\n                        )\n                        downQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ALTER COLUMN \"${\n                                    newColumn.name\n                                }\" SET DEFAULT ${this.driver.uuidGenerator}`,\n                            ),\n                        )\n                    }\n                } else if (newColumn.generationStrategy === \"increment\") {\n                    if (newColumn.isGenerated === true) {\n                        upQueries.push(\n                            new Query(\n                                `CREATE SEQUENCE IF NOT EXISTS ${this.escapePath(\n                                    this.buildSequencePath(table, newColumn),\n                                )} OWNED BY ${this.escapePath(table)}.\"${\n                                    newColumn.name\n                                }\"`,\n                            ),\n                        )\n                        downQueries.push(\n                            new Query(\n                                `DROP SEQUENCE ${this.escapePath(\n                                    this.buildSequencePath(table, newColumn),\n                                )}`,\n                            ),\n                        )\n\n                        upQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ALTER COLUMN \"${\n                                    newColumn.name\n                                }\" SET DEFAULT nextval('${this.escapePath(\n                                    this.buildSequencePath(table, newColumn),\n                                )}')`,\n                            ),\n                        )\n                        downQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ALTER COLUMN \"${\n                                    newColumn.name\n                                }\" DROP DEFAULT`,\n                            ),\n                        )\n                    } else {\n                        upQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ALTER COLUMN \"${\n                                    newColumn.name\n                                }\" DROP DEFAULT`,\n                            ),\n                        )\n                        downQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ALTER COLUMN \"${\n                                    newColumn.name\n                                }\" SET DEFAULT nextval('${this.escapePath(\n                                    this.buildSequencePath(table, newColumn),\n                                )}')`,\n                            ),\n                        )\n\n                        upQueries.push(\n                            new Query(\n                                `DROP SEQUENCE ${this.escapePath(\n                                    this.buildSequencePath(table, newColumn),\n                                )}`,\n                            ),\n                        )\n                        downQueries.push(\n                            new Query(\n                                `CREATE SEQUENCE IF NOT EXISTS ${this.escapePath(\n                                    this.buildSequencePath(table, newColumn),\n                                )} OWNED BY ${this.escapePath(table)}.\"${\n                                    newColumn.name\n                                }\"`,\n                            ),\n                        )\n                    }\n                }\n            }\n\n            // the default might have changed when the enum changed\n            if (\n                newColumn.default !== oldColumn.default &&\n                !defaultValueChanged\n            ) {\n                if (\n                    newColumn.default !== null &&\n                    newColumn.default !== undefined\n                ) {\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${\n                                newColumn.default\n                            }`,\n                        ),\n                    )\n\n                    if (\n                        oldColumn.default !== null &&\n                        oldColumn.default !== undefined\n                    ) {\n                        downQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ALTER COLUMN \"${\n                                    newColumn.name\n                                }\" SET DEFAULT ${oldColumn.default}`,\n                            ),\n                        )\n                    } else {\n                        downQueries.push(\n                            new Query(\n                                `ALTER TABLE ${this.escapePath(\n                                    table,\n                                )} ALTER COLUMN \"${\n                                    newColumn.name\n                                }\" DROP DEFAULT`,\n                            ),\n                        )\n                    }\n                } else if (\n                    oldColumn.default !== null &&\n                    oldColumn.default !== undefined\n                ) {\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${\n                                oldColumn.default\n                            }`,\n                        ),\n                    )\n                }\n            }\n\n            if (\n                (newColumn.spatialFeatureType || \"\").toLowerCase() !==\n                    (oldColumn.spatialFeatureType || \"\").toLowerCase() ||\n                newColumn.srid !== oldColumn.srid\n            ) {\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${\n                            newColumn.name\n                        }\" TYPE ${this.driver.createFullType(newColumn)}`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${\n                            newColumn.name\n                        }\" TYPE ${this.driver.createFullType(oldColumn)}`,\n                    ),\n                )\n            }\n\n            if (newColumn.generatedType !== oldColumn.generatedType) {\n                // Convert generated column data to normal column\n                if (\n                    !newColumn.generatedType ||\n                    newColumn.generatedType === \"VIRTUAL\"\n                ) {\n                    // We can copy the generated data to the new column\n                    const tableNameWithSchema = (\n                        await this.getTableNameWithSchema(table.name)\n                    ).split(\".\")\n                    const tableName = tableNameWithSchema[1]\n                    const schema = tableNameWithSchema[0]\n\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} RENAME COLUMN \"${oldColumn.name}\" TO \"TEMP_OLD_${\n                                oldColumn.name\n                            }\"`,\n                        ),\n                    )\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ADD ${this.buildCreateColumnSql(\n                                table,\n                                newColumn,\n                            )}`,\n                        ),\n                    )\n                    upQueries.push(\n                        new Query(\n                            `UPDATE ${this.escapePath(table)} SET \"${\n                                newColumn.name\n                            }\" = \"TEMP_OLD_${oldColumn.name}\"`,\n                        ),\n                    )\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP COLUMN \"TEMP_OLD_${oldColumn.name}\"`,\n                        ),\n                    )\n                    upQueries.push(\n                        this.deleteTypeormMetadataSql({\n                            database: this.driver.database,\n                            schema,\n                            table: tableName,\n                            type: MetadataTableType.GENERATED_COLUMN,\n                            name: oldColumn.name,\n                        }),\n                    )\n                    // However, we can't copy it back on downgrade. It needs to regenerate.\n                    downQueries.push(\n                        this.insertTypeormMetadataSql({\n                            database: this.driver.database,\n                            schema,\n                            table: tableName,\n                            type: MetadataTableType.GENERATED_COLUMN,\n                            name: oldColumn.name,\n                            value: oldColumn.asExpression,\n                        }),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ADD ${this.buildCreateColumnSql(\n                                table,\n                                oldColumn,\n                            )}`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} DROP COLUMN \"${newColumn.name}\"`,\n                        ),\n                    )\n                    // downQueries.push(\n                    //     this.deleteTypeormMetadataSql({\n                    //         database: this.driver.database,\n                    //         schema,\n                    //         table: tableName,\n                    //         type: MetadataTableType.GENERATED_COLUMN,\n                    //         name: newColumn.name,\n                    //     }),\n                    // )\n                }\n            }\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Changes a column in the table.\n     */\n    async changeColumns(\n        tableOrName: Table | string,\n        changedColumns: { newColumn: TableColumn; oldColumn: TableColumn }[],\n    ): Promise<void> {\n        for (const { oldColumn, newColumn } of changedColumns) {\n            await this.changeColumn(tableOrName, oldColumn, newColumn)\n        }\n    }\n\n    /**\n     * Drops column in the table.\n     */\n    async dropColumn(\n        tableOrName: Table | string,\n        columnOrName: TableColumn | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const column = InstanceChecker.isTableColumn(columnOrName)\n            ? columnOrName\n            : table.findColumnByName(columnOrName)\n        if (!column)\n            throw new TypeORMError(\n                `Column \"${columnOrName}\" was not found in table \"${table.name}\"`,\n            )\n\n        const clonedTable = table.clone()\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        // drop primary key constraint\n        if (column.isPrimary) {\n            const pkName = column.primaryKeyConstraintName\n                ? column.primaryKeyConstraintName\n                : this.connection.namingStrategy.primaryKeyName(\n                      clonedTable,\n                      clonedTable.primaryColumns.map((column) => column.name),\n                  )\n\n            const columnNames = clonedTable.primaryColumns\n                .map((primaryColumn) => `\"${primaryColumn.name}\"`)\n                .join(\", \")\n\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        clonedTable,\n                    )} DROP CONSTRAINT \"${pkName}\"`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        clonedTable,\n                    )} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`,\n                ),\n            )\n\n            // update column in table\n            const tableColumn = clonedTable.findColumnByName(column.name)\n            tableColumn!.isPrimary = false\n\n            // if primary key have multiple columns, we must recreate it without dropped column\n            if (clonedTable.primaryColumns.length > 0) {\n                const pkName = clonedTable.primaryColumns[0]\n                    .primaryKeyConstraintName\n                    ? clonedTable.primaryColumns[0].primaryKeyConstraintName\n                    : this.connection.namingStrategy.primaryKeyName(\n                          clonedTable,\n                          clonedTable.primaryColumns.map(\n                              (column) => column.name,\n                          ),\n                      )\n\n                const columnNames = clonedTable.primaryColumns\n                    .map((primaryColumn) => `\"${primaryColumn.name}\"`)\n                    .join(\", \")\n\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(\n                            clonedTable,\n                        )} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(\n                            clonedTable,\n                        )} DROP CONSTRAINT \"${pkName}\"`,\n                    ),\n                )\n            }\n        }\n\n        // drop column index\n        const columnIndex = clonedTable.indices.find(\n            (index) =>\n                index.columnNames.length === 1 &&\n                index.columnNames[0] === column.name,\n        )\n        if (columnIndex) {\n            clonedTable.indices.splice(\n                clonedTable.indices.indexOf(columnIndex),\n                1,\n            )\n            upQueries.push(this.dropIndexSql(table, columnIndex))\n            downQueries.push(this.createIndexSql(table, columnIndex))\n        }\n\n        // drop column check\n        const columnCheck = clonedTable.checks.find(\n            (check) =>\n                !!check.columnNames &&\n                check.columnNames.length === 1 &&\n                check.columnNames[0] === column.name,\n        )\n        if (columnCheck) {\n            clonedTable.checks.splice(\n                clonedTable.checks.indexOf(columnCheck),\n                1,\n            )\n            upQueries.push(this.dropCheckConstraintSql(table, columnCheck))\n            downQueries.push(this.createCheckConstraintSql(table, columnCheck))\n        }\n\n        // drop column unique\n        const columnUnique = clonedTable.uniques.find(\n            (unique) =>\n                unique.columnNames.length === 1 &&\n                unique.columnNames[0] === column.name,\n        )\n        if (columnUnique) {\n            clonedTable.uniques.splice(\n                clonedTable.uniques.indexOf(columnUnique),\n                1,\n            )\n            upQueries.push(this.dropUniqueConstraintSql(table, columnUnique))\n            downQueries.push(\n                this.createUniqueConstraintSql(table, columnUnique),\n            )\n        }\n\n        upQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(table)} DROP COLUMN \"${\n                    column.name\n                }\"`,\n            ),\n        )\n        downQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    table,\n                )} ADD ${this.buildCreateColumnSql(table, column)}`,\n            ),\n        )\n\n        // drop enum type\n        if (column.type === \"enum\" || column.type === \"simple-enum\") {\n            const hasEnum = await this.hasEnumType(table, column)\n            if (hasEnum) {\n                const enumType = await this.getUserDefinedTypeName(\n                    table,\n                    column,\n                )\n                const escapedEnumName = `\"${enumType.schema}\".\"${enumType.name}\"`\n                upQueries.push(\n                    this.dropEnumTypeSql(table, column, escapedEnumName),\n                )\n                downQueries.push(\n                    this.createEnumTypeSql(table, column, escapedEnumName),\n                )\n            }\n        }\n\n        if (column.generatedType === \"STORED\") {\n            const tableNameWithSchema = (\n                await this.getTableNameWithSchema(table.name)\n            ).split(\".\")\n            const tableName = tableNameWithSchema[1]\n            const schema = tableNameWithSchema[0]\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                database: this.driver.database,\n                schema,\n                table: tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            })\n            const insertQuery = this.insertTypeormMetadataSql({\n                database: this.driver.database,\n                schema,\n                table: tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            })\n\n            upQueries.push(deleteQuery)\n            downQueries.push(insertQuery)\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n\n        clonedTable.removeColumn(column)\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Drops the columns in the table.\n     */\n    async dropColumns(\n        tableOrName: Table | string,\n        columns: TableColumn[] | string[],\n    ): Promise<void> {\n        for (const column of columns) {\n            await this.dropColumn(tableOrName, column)\n        }\n    }\n\n    /**\n     * Creates a new primary key.\n     */\n    async createPrimaryKey(\n        tableOrName: Table | string,\n        columnNames: string[],\n        constraintName?: string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const clonedTable = table.clone()\n\n        const up = this.createPrimaryKeySql(table, columnNames, constraintName)\n\n        // mark columns as primary, because dropPrimaryKeySql build constraint name from table primary column names.\n        clonedTable.columns.forEach((column) => {\n            if (columnNames.find((columnName) => columnName === column.name))\n                column.isPrimary = true\n        })\n        const down = this.dropPrimaryKeySql(clonedTable)\n\n        await this.executeQueries(up, down)\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Updates composite primary keys.\n     */\n    async updatePrimaryKeys(\n        tableOrName: Table | string,\n        columns: TableColumn[],\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const clonedTable = table.clone()\n        const columnNames = columns.map((column) => column.name)\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        // if table already have primary columns, we must drop them.\n        const primaryColumns = clonedTable.primaryColumns\n        if (primaryColumns.length > 0) {\n            const pkName = primaryColumns[0].primaryKeyConstraintName\n                ? primaryColumns[0].primaryKeyConstraintName\n                : this.connection.namingStrategy.primaryKeyName(\n                      clonedTable,\n                      primaryColumns.map((column) => column.name),\n                  )\n\n            const columnNamesString = primaryColumns\n                .map((column) => `\"${column.name}\"`)\n                .join(\", \")\n\n            upQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        table,\n                    )} DROP CONSTRAINT \"${pkName}\"`,\n                ),\n            )\n            downQueries.push(\n                new Query(\n                    `ALTER TABLE ${this.escapePath(\n                        table,\n                    )} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNamesString})`,\n                ),\n            )\n        }\n\n        // update columns in table.\n        clonedTable.columns\n            .filter((column) => columnNames.indexOf(column.name) !== -1)\n            .forEach((column) => (column.isPrimary = true))\n\n        const pkName = primaryColumns[0]?.primaryKeyConstraintName\n            ? primaryColumns[0].primaryKeyConstraintName\n            : this.connection.namingStrategy.primaryKeyName(\n                  clonedTable,\n                  columnNames,\n              )\n\n        const columnNamesString = columnNames\n            .map((columnName) => `\"${columnName}\"`)\n            .join(\", \")\n\n        upQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    table,\n                )} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNamesString})`,\n            ),\n        )\n        downQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    table,\n                )} DROP CONSTRAINT \"${pkName}\"`,\n            ),\n        )\n\n        await this.executeQueries(upQueries, downQueries)\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Drops a primary key.\n     */\n    async dropPrimaryKey(\n        tableOrName: Table | string,\n        constraintName?: string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const up = this.dropPrimaryKeySql(table)\n        const down = this.createPrimaryKeySql(\n            table,\n            table.primaryColumns.map((column) => column.name),\n            constraintName,\n        )\n        await this.executeQueries(up, down)\n        table.primaryColumns.forEach((column) => {\n            column.isPrimary = false\n        })\n    }\n\n    /**\n     * Creates new unique constraint.\n     */\n    async createUniqueConstraint(\n        tableOrName: Table | string,\n        uniqueConstraint: TableUnique,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // new unique constraint may be passed without name. In this case we generate unique name manually.\n        if (!uniqueConstraint.name)\n            uniqueConstraint.name =\n                this.connection.namingStrategy.uniqueConstraintName(\n                    table,\n                    uniqueConstraint.columnNames,\n                )\n\n        const up = this.createUniqueConstraintSql(table, uniqueConstraint)\n        const down = this.dropUniqueConstraintSql(table, uniqueConstraint)\n        await this.executeQueries(up, down)\n        table.addUniqueConstraint(uniqueConstraint)\n    }\n\n    /**\n     * Creates new unique constraints.\n     */\n    async createUniqueConstraints(\n        tableOrName: Table | string,\n        uniqueConstraints: TableUnique[],\n    ): Promise<void> {\n        for (const uniqueConstraint of uniqueConstraints) {\n            await this.createUniqueConstraint(tableOrName, uniqueConstraint)\n        }\n    }\n\n    /**\n     * Drops unique constraint.\n     */\n    async dropUniqueConstraint(\n        tableOrName: Table | string,\n        uniqueOrName: TableUnique | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const uniqueConstraint = InstanceChecker.isTableUnique(uniqueOrName)\n            ? uniqueOrName\n            : table.uniques.find((u) => u.name === uniqueOrName)\n        if (!uniqueConstraint)\n            throw new TypeORMError(\n                `Supplied unique constraint was not found in table ${table.name}`,\n            )\n\n        const up = this.dropUniqueConstraintSql(table, uniqueConstraint)\n        const down = this.createUniqueConstraintSql(table, uniqueConstraint)\n        await this.executeQueries(up, down)\n        table.removeUniqueConstraint(uniqueConstraint)\n    }\n\n    /**\n     * Drops unique constraints.\n     */\n    async dropUniqueConstraints(\n        tableOrName: Table | string,\n        uniqueConstraints: TableUnique[],\n    ): Promise<void> {\n        for (const uniqueConstraint of uniqueConstraints) {\n            await this.dropUniqueConstraint(tableOrName, uniqueConstraint)\n        }\n    }\n\n    /**\n     * Creates new check constraint.\n     */\n    async createCheckConstraint(\n        tableOrName: Table | string,\n        checkConstraint: TableCheck,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // new unique constraint may be passed without name. In this case we generate unique name manually.\n        if (!checkConstraint.name)\n            checkConstraint.name =\n                this.connection.namingStrategy.checkConstraintName(\n                    table,\n                    checkConstraint.expression!,\n                )\n\n        const up = this.createCheckConstraintSql(table, checkConstraint)\n        const down = this.dropCheckConstraintSql(table, checkConstraint)\n        await this.executeQueries(up, down)\n        table.addCheckConstraint(checkConstraint)\n    }\n\n    /**\n     * Creates new check constraints.\n     */\n    async createCheckConstraints(\n        tableOrName: Table | string,\n        checkConstraints: TableCheck[],\n    ): Promise<void> {\n        const promises = checkConstraints.map((checkConstraint) =>\n            this.createCheckConstraint(tableOrName, checkConstraint),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Drops check constraint.\n     */\n    async dropCheckConstraint(\n        tableOrName: Table | string,\n        checkOrName: TableCheck | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const checkConstraint = InstanceChecker.isTableCheck(checkOrName)\n            ? checkOrName\n            : table.checks.find((c) => c.name === checkOrName)\n        if (!checkConstraint)\n            throw new TypeORMError(\n                `Supplied check constraint was not found in table ${table.name}`,\n            )\n\n        const up = this.dropCheckConstraintSql(table, checkConstraint)\n        const down = this.createCheckConstraintSql(table, checkConstraint)\n        await this.executeQueries(up, down)\n        table.removeCheckConstraint(checkConstraint)\n    }\n\n    /**\n     * Drops check constraints.\n     */\n    async dropCheckConstraints(\n        tableOrName: Table | string,\n        checkConstraints: TableCheck[],\n    ): Promise<void> {\n        const promises = checkConstraints.map((checkConstraint) =>\n            this.dropCheckConstraint(tableOrName, checkConstraint),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Creates new exclusion constraint.\n     */\n    async createExclusionConstraint(\n        tableOrName: Table | string,\n        exclusionConstraint: TableExclusion,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // new unique constraint may be passed without name. In this case we generate unique name manually.\n        if (!exclusionConstraint.name)\n            exclusionConstraint.name =\n                this.connection.namingStrategy.exclusionConstraintName(\n                    table,\n                    exclusionConstraint.expression!,\n                )\n\n        const up = this.createExclusionConstraintSql(table, exclusionConstraint)\n        const down = this.dropExclusionConstraintSql(table, exclusionConstraint)\n        await this.executeQueries(up, down)\n        table.addExclusionConstraint(exclusionConstraint)\n    }\n\n    /**\n     * Creates new exclusion constraints.\n     */\n    async createExclusionConstraints(\n        tableOrName: Table | string,\n        exclusionConstraints: TableExclusion[],\n    ): Promise<void> {\n        const promises = exclusionConstraints.map((exclusionConstraint) =>\n            this.createExclusionConstraint(tableOrName, exclusionConstraint),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Drops exclusion constraint.\n     */\n    async dropExclusionConstraint(\n        tableOrName: Table | string,\n        exclusionOrName: TableExclusion | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const exclusionConstraint = InstanceChecker.isTableExclusion(\n            exclusionOrName,\n        )\n            ? exclusionOrName\n            : table.exclusions.find((c) => c.name === exclusionOrName)\n        if (!exclusionConstraint)\n            throw new TypeORMError(\n                `Supplied exclusion constraint was not found in table ${table.name}`,\n            )\n\n        const up = this.dropExclusionConstraintSql(table, exclusionConstraint)\n        const down = this.createExclusionConstraintSql(\n            table,\n            exclusionConstraint,\n        )\n        await this.executeQueries(up, down)\n        table.removeExclusionConstraint(exclusionConstraint)\n    }\n\n    /**\n     * Drops exclusion constraints.\n     */\n    async dropExclusionConstraints(\n        tableOrName: Table | string,\n        exclusionConstraints: TableExclusion[],\n    ): Promise<void> {\n        const promises = exclusionConstraints.map((exclusionConstraint) =>\n            this.dropExclusionConstraint(tableOrName, exclusionConstraint),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Creates a new foreign key.\n     */\n    async createForeignKey(\n        tableOrName: Table | string,\n        foreignKey: TableForeignKey,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // new FK may be passed without name. In this case we generate FK name manually.\n        if (!foreignKey.name)\n            foreignKey.name = this.connection.namingStrategy.foreignKeyName(\n                table,\n                foreignKey.columnNames,\n                this.getTablePath(foreignKey),\n                foreignKey.referencedColumnNames,\n            )\n\n        const up = this.createForeignKeySql(table, foreignKey)\n        const down = this.dropForeignKeySql(table, foreignKey)\n        await this.executeQueries(up, down)\n        table.addForeignKey(foreignKey)\n    }\n\n    /**\n     * Creates a new foreign keys.\n     */\n    async createForeignKeys(\n        tableOrName: Table | string,\n        foreignKeys: TableForeignKey[],\n    ): Promise<void> {\n        for (const foreignKey of foreignKeys) {\n            await this.createForeignKey(tableOrName, foreignKey)\n        }\n    }\n\n    /**\n     * Drops a foreign key from the table.\n     */\n    async dropForeignKey(\n        tableOrName: Table | string,\n        foreignKeyOrName: TableForeignKey | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const foreignKey = InstanceChecker.isTableForeignKey(foreignKeyOrName)\n            ? foreignKeyOrName\n            : table.foreignKeys.find((fk) => fk.name === foreignKeyOrName)\n        if (!foreignKey)\n            throw new TypeORMError(\n                `Supplied foreign key was not found in table ${table.name}`,\n            )\n\n        if (!foreignKey.name) {\n            foreignKey.name = this.connection.namingStrategy.foreignKeyName(\n                table,\n                foreignKey.columnNames,\n                this.getTablePath(foreignKey),\n                foreignKey.referencedColumnNames,\n            )\n        }\n\n        const up = this.dropForeignKeySql(table, foreignKey)\n        const down = this.createForeignKeySql(table, foreignKey)\n        await this.executeQueries(up, down)\n        table.removeForeignKey(foreignKey)\n    }\n\n    /**\n     * Drops a foreign keys from the table.\n     */\n    async dropForeignKeys(\n        tableOrName: Table | string,\n        foreignKeys: TableForeignKey[],\n    ): Promise<void> {\n        for (const foreignKey of foreignKeys) {\n            await this.dropForeignKey(tableOrName, foreignKey)\n        }\n    }\n\n    /**\n     * Creates a new index.\n     */\n    async createIndex(\n        tableOrName: Table | string,\n        index: TableIndex,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        // new index may be passed without name. In this case we generate index name manually.\n        if (!index.name) index.name = this.generateIndexName(table, index)\n\n        const up = this.createIndexSql(table, index)\n        const down = this.dropIndexSql(table, index)\n        await this.executeQueries(up, down)\n        table.addIndex(index)\n    }\n\n    /**\n     * Create a new view index.\n     */\n    async createViewIndex(\n        viewOrName: View | string,\n        index: TableIndex,\n    ): Promise<void> {\n        const view = InstanceChecker.isView(viewOrName)\n            ? viewOrName\n            : await this.getCachedView(viewOrName)\n\n        // new index may be passed without name. In this case we generate index name manually.\n        if (!index.name) index.name = this.generateIndexName(view, index)\n\n        const up = this.createViewIndexSql(view, index)\n        const down = this.dropIndexSql(view, index)\n        await this.executeQueries(up, down)\n        view.addIndex(index)\n    }\n\n    /**\n     * Creates a new indices\n     */\n    async createIndices(\n        tableOrName: Table | string,\n        indices: TableIndex[],\n    ): Promise<void> {\n        for (const index of indices) {\n            await this.createIndex(tableOrName, index)\n        }\n    }\n\n    /**\n     * Creates new view indices\n     */\n    async createViewIndices(\n        viewOrName: View | string,\n        indices: TableIndex[],\n    ): Promise<void> {\n        for (const index of indices) {\n            await this.createViewIndex(viewOrName, index)\n        }\n    }\n\n    /**\n     * Drops an index from the table.\n     */\n    async dropIndex(\n        tableOrName: Table | string,\n        indexOrName: TableIndex | string,\n    ): Promise<void> {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n        const index = InstanceChecker.isTableIndex(indexOrName)\n            ? indexOrName\n            : table.indices.find((i) => i.name === indexOrName)\n        if (!index)\n            throw new TypeORMError(\n                `Supplied index ${indexOrName} was not found in table ${table.name}`,\n            )\n        // old index may be passed without name. In this case we generate index name manually.\n        if (!index.name) index.name = this.generateIndexName(table, index)\n\n        const up = this.dropIndexSql(table, index)\n        const down = this.createIndexSql(table, index)\n        await this.executeQueries(up, down)\n        table.removeIndex(index)\n    }\n\n    /**\n     * Drops an index from a view.\n     */\n    async dropViewIndex(\n        viewOrName: View | string,\n        indexOrName: TableIndex | string,\n    ): Promise<void> {\n        const view = InstanceChecker.isView(viewOrName)\n            ? viewOrName\n            : await this.getCachedView(viewOrName)\n        const index = InstanceChecker.isTableIndex(indexOrName)\n            ? indexOrName\n            : view.indices.find((i) => i.name === indexOrName)\n        if (!index)\n            throw new TypeORMError(\n                `Supplied index ${indexOrName} was not found in view ${view.name}`,\n            )\n        // old index may be passed without name. In this case we generate index name manually.\n        if (!index.name) index.name = this.generateIndexName(view, index)\n\n        const up = this.dropIndexSql(view, index)\n        const down = this.createViewIndexSql(view, index)\n        await this.executeQueries(up, down)\n        view.removeIndex(index)\n    }\n\n    /**\n     * Drops an indices from the table.\n     */\n    async dropIndices(\n        tableOrName: Table | string,\n        indices: TableIndex[],\n    ): Promise<void> {\n        for (const index of indices) {\n            await this.dropIndex(tableOrName, index)\n        }\n    }\n\n    /**\n     * Clears all table contents.\n     * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.\n     */\n    async clearTable(tableName: string): Promise<void> {\n        await this.query(`TRUNCATE TABLE ${this.escapePath(tableName)}`)\n    }\n\n    /**\n     * Removes all tables from the currently connected database.\n     */\n    async clearDatabase(): Promise<void> {\n        const schemas: string[] = []\n        this.connection.entityMetadatas\n            .filter((metadata) => metadata.schema)\n            .forEach((metadata) => {\n                const isSchemaExist = !!schemas.find(\n                    (schema) => schema === metadata.schema,\n                )\n                if (!isSchemaExist) schemas.push(metadata.schema!)\n            })\n        schemas.push(this.driver.options.schema || \"current_schema()\")\n        const schemaNamesString = schemas\n            .map((name) => {\n                return name === \"current_schema()\" ? name : \"'\" + name + \"'\"\n            })\n            .join(\", \")\n\n        const isAnotherTransactionActive = this.isTransactionActive\n        if (!isAnotherTransactionActive) await this.startTransaction()\n        try {\n            const version = await this.getVersion()\n            // drop views\n            const selectViewDropsQuery =\n                `SELECT 'DROP VIEW IF EXISTS \"' || schemaname || '\".\"' || viewname || '\" CASCADE;' as \"query\" ` +\n                `FROM \"pg_views\" WHERE \"schemaname\" IN (${schemaNamesString}) AND \"viewname\" NOT IN ('geography_columns', 'geometry_columns', 'raster_columns', 'raster_overviews')`\n            const dropViewQueries: ObjectLiteral[] = await this.query(\n                selectViewDropsQuery,\n            )\n            await Promise.all(\n                dropViewQueries.map((q) => this.query(q[\"query\"])),\n            )\n\n            // drop materialized views\n            // Note: materialized views introduced in Postgres 9.3\n            if (VersionUtils.isGreaterOrEqual(version, \"9.3\")) {\n                const selectMatViewDropsQuery =\n                    `SELECT 'DROP MATERIALIZED VIEW IF EXISTS \"' || schemaname || '\".\"' || matviewname || '\" CASCADE;' as \"query\" ` +\n                    `FROM \"pg_matviews\" WHERE \"schemaname\" IN (${schemaNamesString})`\n                const dropMatViewQueries: ObjectLiteral[] = await this.query(\n                    selectMatViewDropsQuery,\n                )\n                await Promise.all(\n                    dropMatViewQueries.map((q) => this.query(q[\"query\"])),\n                )\n            }\n\n            // ignore spatial_ref_sys; it's a special table supporting PostGIS\n            // TODO generalize this as this.driver.ignoreTables\n\n            // drop tables\n            const selectTableDropsQuery = `SELECT 'DROP TABLE IF EXISTS \"' || schemaname || '\".\"' || tablename || '\" CASCADE;' as \"query\" FROM \"pg_tables\" WHERE \"schemaname\" IN (${schemaNamesString}) AND \"tablename\" NOT IN ('spatial_ref_sys')`\n            const dropTableQueries: ObjectLiteral[] = await this.query(\n                selectTableDropsQuery,\n            )\n            await Promise.all(\n                dropTableQueries.map((q) => this.query(q[\"query\"])),\n            )\n\n            // drop enum types\n            await this.dropEnumTypes(schemaNamesString)\n\n            if (!isAnotherTransactionActive) {\n                await this.commitTransaction()\n            }\n        } catch (error) {\n            try {\n                // we throw original error even if rollback thrown an error\n                if (!isAnotherTransactionActive) {\n                    await this.rollbackTransaction()\n                }\n            } catch (rollbackError) {}\n            throw error\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    protected async loadViews(viewNames?: string[]): Promise<View[]> {\n        const hasTable = await this.hasTable(this.getTypeormMetadataTableName())\n\n        if (!hasTable) return []\n\n        if (!viewNames) {\n            viewNames = []\n        }\n\n        const currentDatabase = await this.getCurrentDatabase()\n        const currentSchema = await this.getCurrentSchema()\n        const viewsCondition =\n            viewNames.length === 0\n                ? \"1=1\"\n                : viewNames\n                      .map((tableName) => this.driver.parseTableName(tableName))\n                      .map(({ schema, tableName }) => {\n                          if (!schema) {\n                              schema =\n                                  this.driver.options.schema || currentSchema\n                          }\n\n                          return `(\"t\".\"schema\" = '${schema}' AND \"t\".\"name\" = '${tableName}')`\n                      })\n                      .join(\" OR \")\n\n        const constraintsCondition =\n            viewNames.length === 0\n                ? \"1=1\"\n                : viewNames\n                      .map((tableName) => this.driver.parseTableName(tableName))\n                      .map(({ schema, tableName }) => {\n                          if (!schema) {\n                              schema =\n                                  this.driver.options.schema || currentSchema\n                          }\n\n                          return `(\"ns\".\"nspname\" = '${schema}' AND \"t\".\"relname\" = '${tableName}')`\n                      })\n                      .join(\" OR \")\n\n        const indicesSql =\n            `SELECT \"ns\".\"nspname\" AS \"table_schema\", \"t\".\"relname\" AS \"table_name\", \"i\".\"relname\" AS \"constraint_name\", \"a\".\"attname\" AS \"column_name\", ` +\n            `CASE \"ix\".\"indisunique\" WHEN 't' THEN 'TRUE' ELSE'FALSE' END AS \"is_unique\", pg_get_expr(\"ix\".\"indpred\", \"ix\".\"indrelid\") AS \"condition\", ` +\n            `\"types\".\"typname\" AS \"type_name\" ` +\n            `FROM \"pg_class\" \"t\" ` +\n            `INNER JOIN \"pg_index\" \"ix\" ON \"ix\".\"indrelid\" = \"t\".\"oid\" ` +\n            `INNER JOIN \"pg_attribute\" \"a\" ON \"a\".\"attrelid\" = \"t\".\"oid\"  AND \"a\".\"attnum\" = ANY (\"ix\".\"indkey\") ` +\n            `INNER JOIN \"pg_namespace\" \"ns\" ON \"ns\".\"oid\" = \"t\".\"relnamespace\" ` +\n            `INNER JOIN \"pg_class\" \"i\" ON \"i\".\"oid\" = \"ix\".\"indexrelid\" ` +\n            `INNER JOIN \"pg_type\" \"types\" ON \"types\".\"oid\" = \"a\".\"atttypid\" ` +\n            `LEFT JOIN \"pg_constraint\" \"cnst\" ON \"cnst\".\"conname\" = \"i\".\"relname\" ` +\n            `WHERE \"t\".\"relkind\" IN ('m') AND \"cnst\".\"contype\" IS NULL AND (${constraintsCondition})`\n\n        const query =\n            `SELECT \"t\".* FROM ${this.escapePath(\n                this.getTypeormMetadataTableName(),\n            )} \"t\" ` +\n            `INNER JOIN \"pg_catalog\".\"pg_class\" \"c\" ON \"c\".\"relname\" = \"t\".\"name\" ` +\n            `INNER JOIN \"pg_namespace\" \"n\" ON \"n\".\"oid\" = \"c\".\"relnamespace\" AND \"n\".\"nspname\" = \"t\".\"schema\" ` +\n            `WHERE \"t\".\"type\" IN ('${MetadataTableType.VIEW}', '${\n                MetadataTableType.MATERIALIZED_VIEW\n            }') ${viewsCondition ? `AND (${viewsCondition})` : \"\"}`\n\n        const dbViews = await this.query(query)\n        const dbIndices: ObjectLiteral[] = await this.query(indicesSql)\n        return dbViews.map((dbView: any) => {\n            // find index constraints of table, group them by constraint name and build TableIndex.\n            const tableIndexConstraints = OrmUtils.uniq(\n                dbIndices.filter((dbIndex) => {\n                    return (\n                        dbIndex[\"table_name\"] === dbView[\"name\"] &&\n                        dbIndex[\"table_schema\"] === dbView[\"schema\"]\n                    )\n                }),\n                (dbIndex) => dbIndex[\"constraint_name\"],\n            )\n            const view = new View()\n            const schema =\n                dbView[\"schema\"] === currentSchema &&\n                !this.driver.options.schema\n                    ? undefined\n                    : dbView[\"schema\"]\n            view.database = currentDatabase\n            view.schema = dbView[\"schema\"]\n            view.name = this.driver.buildTableName(dbView[\"name\"], schema)\n            view.expression = dbView[\"value\"]\n            view.materialized =\n                dbView[\"type\"] === MetadataTableType.MATERIALIZED_VIEW\n            view.indices = tableIndexConstraints.map((constraint) => {\n                const indices = dbIndices.filter((index) => {\n                    return (\n                        index[\"table_schema\"] === constraint[\"table_schema\"] &&\n                        index[\"table_name\"] === constraint[\"table_name\"] &&\n                        index[\"constraint_name\"] ===\n                            constraint[\"constraint_name\"]\n                    )\n                })\n                return new TableIndex(<TableIndexOptions>{\n                    view: view,\n                    name: constraint[\"constraint_name\"],\n                    columnNames: indices.map((i) => i[\"column_name\"]),\n                    isUnique: constraint[\"is_unique\"] === \"TRUE\",\n                    where: constraint[\"condition\"],\n                    isFulltext: false,\n                })\n            })\n            return view\n        })\n    }\n\n    /**\n     * Loads all tables (with given names) from the database and creates a Table from them.\n     */\n    protected async loadTables(tableNames?: string[]): Promise<Table[]> {\n        // if no tables given then no need to proceed\n        if (tableNames && tableNames.length === 0) {\n            return []\n        }\n\n        const currentSchema = await this.getCurrentSchema()\n        const currentDatabase = await this.getCurrentDatabase()\n\n        const dbTables: {\n            table_schema: string\n            table_name: string\n            table_comment: string\n        }[] = []\n\n        if (!tableNames) {\n            const tablesSql = `SELECT \"table_schema\", \"table_name\", obj_description(('\"' || \"table_schema\" || '\".\"' || \"table_name\" || '\"')::regclass, 'pg_class') AS table_comment FROM \"information_schema\".\"tables\"`\n            dbTables.push(...(await this.query(tablesSql)))\n        } else {\n            const tablesCondition = tableNames\n                .map((tableName) => this.driver.parseTableName(tableName))\n                .map(({ schema, tableName }) => {\n                    return `(\"table_schema\" = '${\n                        schema || currentSchema\n                    }' AND \"table_name\" = '${tableName}')`\n                })\n                .join(\" OR \")\n\n            const tablesSql =\n                `SELECT \"table_schema\", \"table_name\", obj_description(('\"' || \"table_schema\" || '\".\"' || \"table_name\" || '\"')::regclass, 'pg_class') AS table_comment FROM \"information_schema\".\"tables\" WHERE ` +\n                tablesCondition\n            dbTables.push(...(await this.query(tablesSql)))\n        }\n\n        // if tables were not found in the db, no need to proceed\n        if (dbTables.length === 0) {\n            return []\n        }\n\n        /**\n         * Uses standard SQL information_schema.columns table and postgres-specific\n         * pg_catalog.pg_attribute table to get column information.\n         * @see https://stackoverflow.com/a/19541865\n         */\n        const columnsCondition = dbTables\n            .map(({ table_schema, table_name }) => {\n                return `(\"table_schema\" = '${table_schema}' AND \"table_name\" = '${table_name}')`\n            })\n            .join(\" OR \")\n        const columnsSql =\n            `SELECT columns.*, pg_catalog.col_description(('\"' || table_catalog || '\".\"' || table_schema || '\".\"' || table_name || '\"')::regclass::oid, ordinal_position) AS description, ` +\n            `('\"' || \"udt_schema\" || '\".\"' || \"udt_name\" || '\"')::\"regtype\" AS \"regtype\", pg_catalog.format_type(\"col_attr\".\"atttypid\", \"col_attr\".\"atttypmod\") AS \"format_type\" ` +\n            `FROM \"information_schema\".\"columns\" ` +\n            `LEFT JOIN \"pg_catalog\".\"pg_attribute\" AS \"col_attr\" ON \"col_attr\".\"attname\" = \"columns\".\"column_name\" ` +\n            `AND \"col_attr\".\"attrelid\" = ( ` +\n            `SELECT \"cls\".\"oid\" FROM \"pg_catalog\".\"pg_class\" AS \"cls\" ` +\n            `LEFT JOIN \"pg_catalog\".\"pg_namespace\" AS \"ns\" ON \"ns\".\"oid\" = \"cls\".\"relnamespace\" ` +\n            `WHERE \"cls\".\"relname\" = \"columns\".\"table_name\" ` +\n            `AND \"ns\".\"nspname\" = \"columns\".\"table_schema\" ` +\n            `) ` +\n            `WHERE ` +\n            columnsCondition\n\n        const constraintsCondition = dbTables\n            .map(({ table_schema, table_name }) => {\n                return `(\"ns\".\"nspname\" = '${table_schema}' AND \"t\".\"relname\" = '${table_name}')`\n            })\n            .join(\" OR \")\n\n        const constraintsSql =\n            `SELECT \"ns\".\"nspname\" AS \"table_schema\", \"t\".\"relname\" AS \"table_name\", \"cnst\".\"conname\" AS \"constraint_name\", ` +\n            `pg_get_constraintdef(\"cnst\".\"oid\") AS \"expression\", ` +\n            `CASE \"cnst\".\"contype\" WHEN 'p' THEN 'PRIMARY' WHEN 'u' THEN 'UNIQUE' WHEN 'c' THEN 'CHECK' WHEN 'x' THEN 'EXCLUDE' END AS \"constraint_type\", \"a\".\"attname\" AS \"column_name\" ` +\n            `FROM \"pg_constraint\" \"cnst\" ` +\n            `INNER JOIN \"pg_class\" \"t\" ON \"t\".\"oid\" = \"cnst\".\"conrelid\" ` +\n            `INNER JOIN \"pg_namespace\" \"ns\" ON \"ns\".\"oid\" = \"cnst\".\"connamespace\" ` +\n            `LEFT JOIN \"pg_attribute\" \"a\" ON \"a\".\"attrelid\" = \"cnst\".\"conrelid\" AND \"a\".\"attnum\" = ANY (\"cnst\".\"conkey\") ` +\n            `WHERE \"t\".\"relkind\" IN ('r', 'p') AND (${constraintsCondition})`\n\n        const indicesSql =\n            `SELECT \"ns\".\"nspname\" AS \"table_schema\", \"t\".\"relname\" AS \"table_name\", \"i\".\"relname\" AS \"constraint_name\", \"a\".\"attname\" AS \"column_name\", ` +\n            `CASE \"ix\".\"indisunique\" WHEN 't' THEN 'TRUE' ELSE'FALSE' END AS \"is_unique\", pg_get_expr(\"ix\".\"indpred\", \"ix\".\"indrelid\") AS \"condition\", ` +\n            `\"types\".\"typname\" AS \"type_name\", \"am\".\"amname\" AS \"index_type\" ` +\n            `FROM \"pg_class\" \"t\" ` +\n            `INNER JOIN \"pg_index\" \"ix\" ON \"ix\".\"indrelid\" = \"t\".\"oid\" ` +\n            `INNER JOIN \"pg_attribute\" \"a\" ON \"a\".\"attrelid\" = \"t\".\"oid\"  AND \"a\".\"attnum\" = ANY (\"ix\".\"indkey\") ` +\n            `INNER JOIN \"pg_namespace\" \"ns\" ON \"ns\".\"oid\" = \"t\".\"relnamespace\" ` +\n            `INNER JOIN \"pg_class\" \"i\" ON \"i\".\"oid\" = \"ix\".\"indexrelid\" ` +\n            `INNER JOIN \"pg_type\" \"types\" ON \"types\".\"oid\" = \"a\".\"atttypid\" ` +\n            `INNER JOIN \"pg_am\" \"am\" ON \"i\".\"relam\" = \"am\".\"oid\" ` +\n            `LEFT JOIN \"pg_constraint\" \"cnst\" ON \"cnst\".\"conname\" = \"i\".\"relname\" ` +\n            `WHERE \"t\".\"relkind\" IN ('r', 'p') AND \"cnst\".\"contype\" IS NULL AND (${constraintsCondition})`\n\n        const foreignKeysCondition = dbTables\n            .map(({ table_schema, table_name }) => {\n                return `(\"ns\".\"nspname\" = '${table_schema}' AND \"cl\".\"relname\" = '${table_name}')`\n            })\n            .join(\" OR \")\n\n        const hasRelispartitionColumn =\n            await this.hasSupportForPartitionedTables()\n        const isPartitionCondition = hasRelispartitionColumn\n            ? ` AND \"cl\".\"relispartition\" = 'f'`\n            : \"\"\n\n        const foreignKeysSql =\n            `SELECT \"con\".\"conname\" AS \"constraint_name\", \"con\".\"nspname\" AS \"table_schema\", \"con\".\"relname\" AS \"table_name\", \"att2\".\"attname\" AS \"column_name\", ` +\n            `\"ns\".\"nspname\" AS \"referenced_table_schema\", \"cl\".\"relname\" AS \"referenced_table_name\", \"att\".\"attname\" AS \"referenced_column_name\", \"con\".\"confdeltype\" AS \"on_delete\", ` +\n            `\"con\".\"confupdtype\" AS \"on_update\", \"con\".\"condeferrable\" AS \"deferrable\", \"con\".\"condeferred\" AS \"deferred\" ` +\n            `FROM ( ` +\n            `SELECT UNNEST (\"con1\".\"conkey\") AS \"parent\", UNNEST (\"con1\".\"confkey\") AS \"child\", \"con1\".\"confrelid\", \"con1\".\"conrelid\", \"con1\".\"conname\", \"con1\".\"contype\", \"ns\".\"nspname\", ` +\n            `\"cl\".\"relname\", \"con1\".\"condeferrable\", ` +\n            `CASE WHEN \"con1\".\"condeferred\" THEN 'INITIALLY DEFERRED' ELSE 'INITIALLY IMMEDIATE' END as condeferred, ` +\n            `CASE \"con1\".\"confdeltype\" WHEN 'a' THEN 'NO ACTION' WHEN 'r' THEN 'RESTRICT' WHEN 'c' THEN 'CASCADE' WHEN 'n' THEN 'SET NULL' WHEN 'd' THEN 'SET DEFAULT' END as \"confdeltype\", ` +\n            `CASE \"con1\".\"confupdtype\" WHEN 'a' THEN 'NO ACTION' WHEN 'r' THEN 'RESTRICT' WHEN 'c' THEN 'CASCADE' WHEN 'n' THEN 'SET NULL' WHEN 'd' THEN 'SET DEFAULT' END as \"confupdtype\" ` +\n            `FROM \"pg_class\" \"cl\" ` +\n            `INNER JOIN \"pg_namespace\" \"ns\" ON \"cl\".\"relnamespace\" = \"ns\".\"oid\" ` +\n            `INNER JOIN \"pg_constraint\" \"con1\" ON \"con1\".\"conrelid\" = \"cl\".\"oid\" ` +\n            `WHERE \"con1\".\"contype\" = 'f' AND (${foreignKeysCondition}) ` +\n            `) \"con\" ` +\n            `INNER JOIN \"pg_attribute\" \"att\" ON \"att\".\"attrelid\" = \"con\".\"confrelid\" AND \"att\".\"attnum\" = \"con\".\"child\" ` +\n            `INNER JOIN \"pg_class\" \"cl\" ON \"cl\".\"oid\" = \"con\".\"confrelid\" ${isPartitionCondition}` +\n            `INNER JOIN \"pg_namespace\" \"ns\" ON \"cl\".\"relnamespace\" = \"ns\".\"oid\" ` +\n            `INNER JOIN \"pg_attribute\" \"att2\" ON \"att2\".\"attrelid\" = \"con\".\"conrelid\" AND \"att2\".\"attnum\" = \"con\".\"parent\"`\n\n        const [\n            dbColumns,\n            dbConstraints,\n            dbIndices,\n            dbForeignKeys,\n        ]: ObjectLiteral[][] = await Promise.all([\n            this.query(columnsSql),\n            this.query(constraintsSql),\n            this.query(indicesSql),\n            this.query(foreignKeysSql),\n        ])\n\n        // create tables for loaded tables\n        return Promise.all(\n            dbTables.map(async (dbTable) => {\n                const table = new Table()\n\n                const getSchemaFromKey = (dbObject: any, key: string) => {\n                    return dbObject[key] === currentSchema &&\n                        (!this.driver.options.schema ||\n                            this.driver.options.schema === currentSchema)\n                        ? undefined\n                        : dbObject[key]\n                }\n                // We do not need to join schema name, when database is by default.\n                const schema = getSchemaFromKey(dbTable, \"table_schema\")\n                table.database = currentDatabase\n                table.schema = dbTable[\"table_schema\"]\n                table.comment = dbTable[\"table_comment\"]\n                table.name = this.driver.buildTableName(\n                    dbTable[\"table_name\"],\n                    schema,\n                )\n\n                // create columns from the loaded columns\n                table.columns = await Promise.all(\n                    dbColumns\n                        .filter(\n                            (dbColumn) =>\n                                dbColumn[\"table_name\"] ===\n                                    dbTable[\"table_name\"] &&\n                                dbColumn[\"table_schema\"] ===\n                                    dbTable[\"table_schema\"],\n                        )\n                        .map(async (dbColumn) => {\n                            const columnConstraints = dbConstraints.filter(\n                                (dbConstraint) => {\n                                    return (\n                                        dbConstraint[\"table_name\"] ===\n                                            dbColumn[\"table_name\"] &&\n                                        dbConstraint[\"table_schema\"] ===\n                                            dbColumn[\"table_schema\"] &&\n                                        dbConstraint[\"column_name\"] ===\n                                            dbColumn[\"column_name\"]\n                                    )\n                                },\n                            )\n\n                            const tableColumn = new TableColumn()\n                            tableColumn.name = dbColumn[\"column_name\"]\n                            tableColumn.type = dbColumn[\"regtype\"].toLowerCase()\n\n                            if (\n                                tableColumn.type === \"numeric\" ||\n                                tableColumn.type === \"numeric[]\" ||\n                                tableColumn.type === \"decimal\" ||\n                                tableColumn.type === \"float\"\n                            ) {\n                                let numericPrecision =\n                                    dbColumn[\"numeric_precision\"]\n                                let numericScale = dbColumn[\"numeric_scale\"]\n                                if (dbColumn[\"data_type\"] === \"ARRAY\") {\n                                    const numericSize = dbColumn[\n                                        \"format_type\"\n                                    ].match(\n                                        /^numeric\\(([0-9]+),([0-9]+)\\)\\[\\]$/,\n                                    )\n                                    if (numericSize) {\n                                        numericPrecision = +numericSize[1]\n                                        numericScale = +numericSize[2]\n                                    }\n                                }\n                                // If one of these properties was set, and another was not, Postgres sets '0' in to unspecified property\n                                // we set 'undefined' in to unspecified property to avoid changing column on sync\n                                if (\n                                    numericPrecision !== null &&\n                                    !this.isDefaultColumnPrecision(\n                                        table,\n                                        tableColumn,\n                                        numericPrecision,\n                                    )\n                                ) {\n                                    tableColumn.precision = numericPrecision\n                                } else if (\n                                    numericScale !== null &&\n                                    !this.isDefaultColumnScale(\n                                        table,\n                                        tableColumn,\n                                        numericScale,\n                                    )\n                                ) {\n                                    tableColumn.precision = undefined\n                                }\n                                if (\n                                    numericScale !== null &&\n                                    !this.isDefaultColumnScale(\n                                        table,\n                                        tableColumn,\n                                        numericScale,\n                                    )\n                                ) {\n                                    tableColumn.scale = numericScale\n                                } else if (\n                                    numericPrecision !== null &&\n                                    !this.isDefaultColumnPrecision(\n                                        table,\n                                        tableColumn,\n                                        numericPrecision,\n                                    )\n                                ) {\n                                    tableColumn.scale = undefined\n                                }\n                            }\n\n                            if (\n                                tableColumn.type === \"interval\" ||\n                                tableColumn.type === \"time without time zone\" ||\n                                tableColumn.type === \"time with time zone\" ||\n                                tableColumn.type ===\n                                    \"timestamp without time zone\" ||\n                                tableColumn.type === \"timestamp with time zone\"\n                            ) {\n                                tableColumn.precision =\n                                    !this.isDefaultColumnPrecision(\n                                        table,\n                                        tableColumn,\n                                        dbColumn[\"datetime_precision\"],\n                                    )\n                                        ? dbColumn[\"datetime_precision\"]\n                                        : undefined\n                            }\n\n                            // check if column has user-defined data type.\n                            // NOTE: if ENUM type defined with \"array:true\" it comes with ARRAY type instead of USER-DEFINED\n                            if (\n                                dbColumn[\"data_type\"] === \"USER-DEFINED\" ||\n                                dbColumn[\"data_type\"] === \"ARRAY\"\n                            ) {\n                                const { name } =\n                                    await this.getUserDefinedTypeName(\n                                        table,\n                                        tableColumn,\n                                    )\n\n                                // check if `enumName` is specified by user\n                                const builtEnumName = this.buildEnumName(\n                                    table,\n                                    tableColumn,\n                                    false,\n                                    true,\n                                )\n                                const enumName =\n                                    builtEnumName !== name ? name : undefined\n\n                                // check if type is ENUM\n                                const sql =\n                                    `SELECT \"e\".\"enumlabel\" AS \"value\" FROM \"pg_enum\" \"e\" ` +\n                                    `INNER JOIN \"pg_type\" \"t\" ON \"t\".\"oid\" = \"e\".\"enumtypid\" ` +\n                                    `INNER JOIN \"pg_namespace\" \"n\" ON \"n\".\"oid\" = \"t\".\"typnamespace\" ` +\n                                    `WHERE \"n\".\"nspname\" = '${\n                                        dbTable[\"table_schema\"]\n                                    }' AND \"t\".\"typname\" = '${\n                                        enumName || name\n                                    }'`\n                                const results: ObjectLiteral[] =\n                                    await this.query(sql)\n\n                                if (results.length) {\n                                    tableColumn.type = \"enum\"\n                                    tableColumn.enum = results.map(\n                                        (result) => result[\"value\"],\n                                    )\n                                    tableColumn.enumName = enumName\n                                }\n\n                                if (dbColumn[\"data_type\"] === \"ARRAY\") {\n                                    tableColumn.isArray = true\n                                    const type = tableColumn.type.replace(\n                                        \"[]\",\n                                        \"\",\n                                    )\n                                    tableColumn.type =\n                                        this.connection.driver.normalizeType({\n                                            type: type,\n                                        })\n                                }\n                            }\n\n                            if (\n                                tableColumn.type === \"geometry\" ||\n                                tableColumn.type === \"geography\"\n                            ) {\n                                const sql =\n                                    `SELECT * FROM (` +\n                                    `SELECT \"f_table_schema\" \"table_schema\", \"f_table_name\" \"table_name\", ` +\n                                    `\"f_${tableColumn.type}_column\" \"column_name\", \"srid\", \"type\" ` +\n                                    `FROM \"${tableColumn.type}_columns\"` +\n                                    `) AS _ ` +\n                                    `WHERE \"column_name\" = '${dbColumn[\"column_name\"]}' AND ` +\n                                    `\"table_schema\" = '${dbColumn[\"table_schema\"]}' AND ` +\n                                    `\"table_name\" = '${dbColumn[\"table_name\"]}'`\n\n                                const results: ObjectLiteral[] =\n                                    await this.query(sql)\n\n                                if (results.length > 0) {\n                                    tableColumn.spatialFeatureType =\n                                        results[0].type\n                                    tableColumn.srid = results[0].srid\n                                }\n                            }\n\n                            // check only columns that have length property\n                            if (\n                                this.driver.withLengthColumnTypes.indexOf(\n                                    tableColumn.type as ColumnType,\n                                ) !== -1\n                            ) {\n                                let length\n                                if (tableColumn.isArray) {\n                                    const match = /\\((\\d+)\\)/.exec(\n                                        dbColumn[\"format_type\"],\n                                    )\n                                    length = match ? match[1] : undefined\n                                } else if (\n                                    dbColumn[\"character_maximum_length\"]\n                                ) {\n                                    length =\n                                        dbColumn[\n                                            \"character_maximum_length\"\n                                        ].toString()\n                                }\n                                if (length) {\n                                    tableColumn.length =\n                                        !this.isDefaultColumnLength(\n                                            table,\n                                            tableColumn,\n                                            length,\n                                        )\n                                            ? length\n                                            : \"\"\n                                }\n                            }\n                            tableColumn.isNullable =\n                                dbColumn[\"is_nullable\"] === \"YES\"\n\n                            const primaryConstraint = columnConstraints.find(\n                                (constraint) =>\n                                    constraint[\"constraint_type\"] === \"PRIMARY\",\n                            )\n                            if (primaryConstraint) {\n                                tableColumn.isPrimary = true\n                                // find another columns involved in primary key constraint\n                                const anotherPrimaryConstraints =\n                                    dbConstraints.filter(\n                                        (constraint) =>\n                                            constraint[\"table_name\"] ===\n                                                dbColumn[\"table_name\"] &&\n                                            constraint[\"table_schema\"] ===\n                                                dbColumn[\"table_schema\"] &&\n                                            constraint[\"column_name\"] !==\n                                                dbColumn[\"column_name\"] &&\n                                            constraint[\"constraint_type\"] ===\n                                                \"PRIMARY\",\n                                    )\n\n                                // collect all column names\n                                const columnNames =\n                                    anotherPrimaryConstraints.map(\n                                        (constraint) =>\n                                            constraint[\"column_name\"],\n                                    )\n                                columnNames.push(dbColumn[\"column_name\"])\n\n                                // build default primary key constraint name\n                                const pkName =\n                                    this.connection.namingStrategy.primaryKeyName(\n                                        table,\n                                        columnNames,\n                                    )\n\n                                // if primary key has user-defined constraint name, write it in table column\n                                if (\n                                    primaryConstraint[\"constraint_name\"] !==\n                                    pkName\n                                ) {\n                                    tableColumn.primaryKeyConstraintName =\n                                        primaryConstraint[\"constraint_name\"]\n                                }\n                            }\n\n                            const uniqueConstraints = columnConstraints.filter(\n                                (constraint) =>\n                                    constraint[\"constraint_type\"] === \"UNIQUE\",\n                            )\n                            const isConstraintComposite =\n                                uniqueConstraints.every((uniqueConstraint) => {\n                                    return dbConstraints.some(\n                                        (dbConstraint) =>\n                                            dbConstraint[\"constraint_type\"] ===\n                                                \"UNIQUE\" &&\n                                            dbConstraint[\"constraint_name\"] ===\n                                                uniqueConstraint[\n                                                    \"constraint_name\"\n                                                ] &&\n                                            dbConstraint[\"column_name\"] !==\n                                                dbColumn[\"column_name\"],\n                                    )\n                                })\n                            tableColumn.isUnique =\n                                uniqueConstraints.length > 0 &&\n                                !isConstraintComposite\n\n                            if (dbColumn.is_identity === \"YES\") {\n                                // Postgres 10+ Identity column\n                                tableColumn.isGenerated = true\n                                tableColumn.generationStrategy = \"identity\"\n                                tableColumn.generatedIdentity =\n                                    dbColumn.identity_generation\n                            } else if (\n                                dbColumn[\"column_default\"] !== null &&\n                                dbColumn[\"column_default\"] !== undefined\n                            ) {\n                                const serialDefaultName = `nextval('${this.buildSequenceName(\n                                    table,\n                                    dbColumn[\"column_name\"],\n                                )}'::regclass)`\n                                const serialDefaultPath = `nextval('${this.buildSequencePath(\n                                    table,\n                                    dbColumn[\"column_name\"],\n                                )}'::regclass)`\n\n                                const defaultWithoutQuotes = dbColumn[\n                                    \"column_default\"\n                                ].replace(/\"/g, \"\")\n\n                                if (\n                                    defaultWithoutQuotes ===\n                                        serialDefaultName ||\n                                    defaultWithoutQuotes === serialDefaultPath\n                                ) {\n                                    tableColumn.isGenerated = true\n                                    tableColumn.generationStrategy = \"increment\"\n                                } else if (\n                                    dbColumn[\"column_default\"] ===\n                                        \"gen_random_uuid()\" ||\n                                    /^uuid_generate_v\\d\\(\\)/.test(\n                                        dbColumn[\"column_default\"],\n                                    )\n                                ) {\n                                    if (tableColumn.type === \"uuid\") {\n                                        tableColumn.isGenerated = true\n                                        tableColumn.generationStrategy = \"uuid\"\n                                    } else {\n                                        tableColumn.default =\n                                            dbColumn[\"column_default\"]\n                                    }\n                                } else if (\n                                    dbColumn[\"column_default\"] === \"now()\" ||\n                                    dbColumn[\"column_default\"].indexOf(\n                                        \"'now'::text\",\n                                    ) !== -1\n                                ) {\n                                    tableColumn.default =\n                                        dbColumn[\"column_default\"]\n                                } else {\n                                    tableColumn.default = dbColumn[\n                                        \"column_default\"\n                                    ].replace(/::[\\w\\s.[\\]\\-\"]+/g, \"\")\n                                    tableColumn.default =\n                                        tableColumn.default.replace(\n                                            /^(-?\\d+)$/,\n                                            \"'$1'\",\n                                        )\n                                }\n                            }\n\n                            if (\n                                dbColumn[\"is_generated\"] === \"ALWAYS\" &&\n                                dbColumn[\"generation_expression\"]\n                            ) {\n                                // In postgres there is no VIRTUAL generated column type\n                                tableColumn.generatedType = \"STORED\"\n                                // We cannot relay on information_schema.columns.generation_expression, because it is formatted different.\n                                const asExpressionQuery =\n                                    this.selectTypeormMetadataSql({\n                                        database: currentDatabase,\n                                        schema: dbTable[\"table_schema\"],\n                                        table: dbTable[\"table_name\"],\n                                        type: MetadataTableType.GENERATED_COLUMN,\n                                        name: tableColumn.name,\n                                    })\n\n                                const results = await this.query(\n                                    asExpressionQuery.query,\n                                    asExpressionQuery.parameters,\n                                )\n                                if (results[0] && results[0].value) {\n                                    tableColumn.asExpression = results[0].value\n                                } else {\n                                    tableColumn.asExpression = \"\"\n                                }\n                            }\n\n                            tableColumn.comment = dbColumn[\"description\"]\n                                ? dbColumn[\"description\"]\n                                : undefined\n                            if (dbColumn[\"character_set_name\"])\n                                tableColumn.charset =\n                                    dbColumn[\"character_set_name\"]\n                            if (dbColumn[\"collation_name\"])\n                                tableColumn.collation =\n                                    dbColumn[\"collation_name\"]\n                            return tableColumn\n                        }),\n                )\n\n                // find unique constraints of table, group them by constraint name and build TableUnique.\n                const tableUniqueConstraints = OrmUtils.uniq(\n                    dbConstraints.filter((dbConstraint) => {\n                        return (\n                            dbConstraint[\"table_name\"] ===\n                                dbTable[\"table_name\"] &&\n                            dbConstraint[\"table_schema\"] ===\n                                dbTable[\"table_schema\"] &&\n                            dbConstraint[\"constraint_type\"] === \"UNIQUE\"\n                        )\n                    }),\n                    (dbConstraint) => dbConstraint[\"constraint_name\"],\n                )\n\n                table.uniques = tableUniqueConstraints.map((constraint) => {\n                    const uniques = dbConstraints.filter(\n                        (dbC) =>\n                            dbC[\"constraint_name\"] ===\n                            constraint[\"constraint_name\"],\n                    )\n                    return new TableUnique({\n                        name: constraint[\"constraint_name\"],\n                        columnNames: uniques.map((u) => u[\"column_name\"]),\n                        deferrable: constraint[\"deferrable\"]\n                            ? constraint[\"deferred\"]\n                            : undefined,\n                    })\n                })\n\n                // find check constraints of table, group them by constraint name and build TableCheck.\n                const tableCheckConstraints = OrmUtils.uniq(\n                    dbConstraints.filter((dbConstraint) => {\n                        return (\n                            dbConstraint[\"table_name\"] ===\n                                dbTable[\"table_name\"] &&\n                            dbConstraint[\"table_schema\"] ===\n                                dbTable[\"table_schema\"] &&\n                            dbConstraint[\"constraint_type\"] === \"CHECK\"\n                        )\n                    }),\n                    (dbConstraint) => dbConstraint[\"constraint_name\"],\n                )\n\n                table.checks = tableCheckConstraints.map((constraint) => {\n                    const checks = dbConstraints.filter(\n                        (dbC) =>\n                            dbC[\"constraint_name\"] ===\n                            constraint[\"constraint_name\"],\n                    )\n                    return new TableCheck({\n                        name: constraint[\"constraint_name\"],\n                        columnNames: checks.map((c) => c[\"column_name\"]),\n                        expression: constraint[\"expression\"].replace(\n                            /^\\s*CHECK\\s*\\((.*)\\)\\s*$/i,\n                            \"$1\",\n                        ),\n                    })\n                })\n\n                // find exclusion constraints of table, group them by constraint name and build TableExclusion.\n                const tableExclusionConstraints = OrmUtils.uniq(\n                    dbConstraints.filter((dbConstraint) => {\n                        return (\n                            dbConstraint[\"table_name\"] ===\n                                dbTable[\"table_name\"] &&\n                            dbConstraint[\"table_schema\"] ===\n                                dbTable[\"table_schema\"] &&\n                            dbConstraint[\"constraint_type\"] === \"EXCLUDE\"\n                        )\n                    }),\n                    (dbConstraint) => dbConstraint[\"constraint_name\"],\n                )\n\n                table.exclusions = tableExclusionConstraints.map(\n                    (constraint) => {\n                        return new TableExclusion({\n                            name: constraint[\"constraint_name\"],\n                            expression: constraint[\"expression\"].substring(8), // trim EXCLUDE from start of expression\n                        })\n                    },\n                )\n\n                // find foreign key constraints of table, group them by constraint name and build TableForeignKey.\n                const tableForeignKeyConstraints = OrmUtils.uniq(\n                    dbForeignKeys.filter((dbForeignKey) => {\n                        return (\n                            dbForeignKey[\"table_name\"] ===\n                                dbTable[\"table_name\"] &&\n                            dbForeignKey[\"table_schema\"] ===\n                                dbTable[\"table_schema\"]\n                        )\n                    }),\n                    (dbForeignKey) => dbForeignKey[\"constraint_name\"],\n                )\n\n                table.foreignKeys = tableForeignKeyConstraints.map(\n                    (dbForeignKey) => {\n                        const foreignKeys = dbForeignKeys.filter(\n                            (dbFk) =>\n                                dbFk[\"constraint_name\"] ===\n                                dbForeignKey[\"constraint_name\"],\n                        )\n\n                        // if referenced table located in currently used schema, we don't need to concat schema name to table name.\n                        const schema = getSchemaFromKey(\n                            dbForeignKey,\n                            \"referenced_table_schema\",\n                        )\n                        const referencedTableName = this.driver.buildTableName(\n                            dbForeignKey[\"referenced_table_name\"],\n                            schema,\n                        )\n\n                        return new TableForeignKey({\n                            name: dbForeignKey[\"constraint_name\"],\n                            columnNames: foreignKeys.map(\n                                (dbFk) => dbFk[\"column_name\"],\n                            ),\n                            referencedSchema:\n                                dbForeignKey[\"referenced_table_schema\"],\n                            referencedTableName: referencedTableName,\n                            referencedColumnNames: foreignKeys.map(\n                                (dbFk) => dbFk[\"referenced_column_name\"],\n                            ),\n                            onDelete: dbForeignKey[\"on_delete\"],\n                            onUpdate: dbForeignKey[\"on_update\"],\n                            deferrable: dbForeignKey[\"deferrable\"]\n                                ? dbForeignKey[\"deferred\"]\n                                : undefined,\n                        })\n                    },\n                )\n\n                // find index constraints of table, group them by constraint name and build TableIndex.\n                const tableIndexConstraints = OrmUtils.uniq(\n                    dbIndices.filter((dbIndex) => {\n                        return (\n                            dbIndex[\"table_name\"] === dbTable[\"table_name\"] &&\n                            dbIndex[\"table_schema\"] === dbTable[\"table_schema\"]\n                        )\n                    }),\n                    (dbIndex) => dbIndex[\"constraint_name\"],\n                )\n\n                table.indices = tableIndexConstraints.map((constraint) => {\n                    const indices = dbIndices.filter((index) => {\n                        return (\n                            index[\"table_schema\"] ===\n                                constraint[\"table_schema\"] &&\n                            index[\"table_name\"] === constraint[\"table_name\"] &&\n                            index[\"constraint_name\"] ===\n                                constraint[\"constraint_name\"]\n                        )\n                    })\n                    return new TableIndex(<TableIndexOptions>{\n                        table: table,\n                        name: constraint[\"constraint_name\"],\n                        columnNames: indices.map((i) => i[\"column_name\"]),\n                        isUnique: constraint[\"is_unique\"] === \"TRUE\",\n                        where: constraint[\"condition\"],\n                        isSpatial: constraint[\"index_type\"] === \"gist\",\n                        isFulltext: false,\n                    })\n                })\n\n                return table\n            }),\n        )\n    }\n\n    /**\n     * Builds create table sql.\n     */\n    protected createTableSql(table: Table, createForeignKeys?: boolean): Query {\n        const columnDefinitions = table.columns\n            .map((column) => this.buildCreateColumnSql(table, column))\n            .join(\", \")\n        let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`\n\n        table.columns\n            .filter((column) => column.isUnique)\n            .forEach((column) => {\n                const isUniqueExist = table.uniques.some(\n                    (unique) =>\n                        unique.columnNames.length === 1 &&\n                        unique.columnNames[0] === column.name,\n                )\n                if (!isUniqueExist)\n                    table.uniques.push(\n                        new TableUnique({\n                            name: this.connection.namingStrategy.uniqueConstraintName(\n                                table,\n                                [column.name],\n                            ),\n                            columnNames: [column.name],\n                        }),\n                    )\n            })\n\n        if (table.uniques.length > 0) {\n            const uniquesSql = table.uniques\n                .map((unique) => {\n                    const uniqueName = unique.name\n                        ? unique.name\n                        : this.connection.namingStrategy.uniqueConstraintName(\n                              table,\n                              unique.columnNames,\n                          )\n                    const columnNames = unique.columnNames\n                        .map((columnName) => `\"${columnName}\"`)\n                        .join(\", \")\n                    let constraint = `CONSTRAINT \"${uniqueName}\" UNIQUE (${columnNames})`\n                    if (unique.deferrable)\n                        constraint += ` DEFERRABLE ${unique.deferrable}`\n                    return constraint\n                })\n                .join(\", \")\n\n            sql += `, ${uniquesSql}`\n        }\n\n        if (table.checks.length > 0) {\n            const checksSql = table.checks\n                .map((check) => {\n                    const checkName = check.name\n                        ? check.name\n                        : this.connection.namingStrategy.checkConstraintName(\n                              table,\n                              check.expression!,\n                          )\n                    return `CONSTRAINT \"${checkName}\" CHECK (${check.expression})`\n                })\n                .join(\", \")\n\n            sql += `, ${checksSql}`\n        }\n\n        if (table.exclusions.length > 0) {\n            const exclusionsSql = table.exclusions\n                .map((exclusion) => {\n                    const exclusionName = exclusion.name\n                        ? exclusion.name\n                        : this.connection.namingStrategy.exclusionConstraintName(\n                              table,\n                              exclusion.expression!,\n                          )\n                    return `CONSTRAINT \"${exclusionName}\" EXCLUDE ${exclusion.expression}`\n                })\n                .join(\", \")\n\n            sql += `, ${exclusionsSql}`\n        }\n\n        if (table.foreignKeys.length > 0 && createForeignKeys) {\n            const foreignKeysSql = table.foreignKeys\n                .map((fk) => {\n                    const columnNames = fk.columnNames\n                        .map((columnName) => `\"${columnName}\"`)\n                        .join(\", \")\n                    if (!fk.name)\n                        fk.name = this.connection.namingStrategy.foreignKeyName(\n                            table,\n                            fk.columnNames,\n                            this.getTablePath(fk),\n                            fk.referencedColumnNames,\n                        )\n\n                    const referencedColumnNames = fk.referencedColumnNames\n                        .map((columnName) => `\"${columnName}\"`)\n                        .join(\", \")\n\n                    let constraint = `CONSTRAINT \"${\n                        fk.name\n                    }\" FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(\n                        this.getTablePath(fk),\n                    )} (${referencedColumnNames})`\n                    if (fk.onDelete) constraint += ` ON DELETE ${fk.onDelete}`\n                    if (fk.onUpdate) constraint += ` ON UPDATE ${fk.onUpdate}`\n                    if (fk.deferrable)\n                        constraint += ` DEFERRABLE ${fk.deferrable}`\n\n                    return constraint\n                })\n                .join(\", \")\n\n            sql += `, ${foreignKeysSql}`\n        }\n\n        const primaryColumns = table.columns.filter(\n            (column) => column.isPrimary,\n        )\n        if (primaryColumns.length > 0) {\n            const primaryKeyName = primaryColumns[0].primaryKeyConstraintName\n                ? primaryColumns[0].primaryKeyConstraintName\n                : this.connection.namingStrategy.primaryKeyName(\n                      table,\n                      primaryColumns.map((column) => column.name),\n                  )\n\n            const columnNames = primaryColumns\n                .map((column) => `\"${column.name}\"`)\n                .join(\", \")\n            sql += `, CONSTRAINT \"${primaryKeyName}\" PRIMARY KEY (${columnNames})`\n        }\n\n        sql += `)`\n\n        table.columns\n            .filter((it) => it.comment)\n            .forEach(\n                (it) =>\n                    (sql += `; COMMENT ON COLUMN ${this.escapePath(table)}.\"${\n                        it.name\n                    }\" IS ${this.escapeComment(it.comment)}`),\n            )\n\n        return new Query(sql)\n    }\n\n    /**\n     * Loads Postgres version.\n     */\n    protected async getVersion(): Promise<string> {\n        const result = await this.query(`SELECT version()`)\n        return result[0][\"version\"].replace(/^PostgreSQL ([\\d.]+) .*$/, \"$1\")\n    }\n\n    /**\n     * Builds drop table sql.\n     */\n    protected dropTableSql(tableOrPath: Table | string): Query {\n        return new Query(`DROP TABLE ${this.escapePath(tableOrPath)}`)\n    }\n\n    protected createViewSql(view: View): Query {\n        const materializedClause = view.materialized ? \"MATERIALIZED \" : \"\"\n        const viewName = this.escapePath(view)\n\n        if (typeof view.expression === \"string\") {\n            return new Query(\n                `CREATE ${materializedClause}VIEW ${viewName} AS ${view.expression}`,\n            )\n        } else {\n            return new Query(\n                `CREATE ${materializedClause}VIEW ${viewName} AS ${view\n                    .expression(this.connection)\n                    .getQuery()}`,\n            )\n        }\n    }\n\n    protected async insertViewDefinitionSql(view: View): Promise<Query> {\n        const currentSchema = await this.getCurrentSchema()\n\n        let { schema, tableName: name } = this.driver.parseTableName(view)\n\n        if (!schema) {\n            schema = currentSchema\n        }\n\n        const type = view.materialized\n            ? MetadataTableType.MATERIALIZED_VIEW\n            : MetadataTableType.VIEW\n        const expression =\n            typeof view.expression === \"string\"\n                ? view.expression.trim()\n                : view.expression(this.connection).getQuery()\n        return this.insertTypeormMetadataSql({\n            type,\n            schema,\n            name,\n            value: expression,\n        })\n    }\n\n    /**\n     * Builds drop view sql.\n     */\n    protected dropViewSql(view: View): Query {\n        const materializedClause = view.materialized ? \"MATERIALIZED \" : \"\"\n        return new Query(\n            `DROP ${materializedClause}VIEW ${this.escapePath(view)}`,\n        )\n    }\n\n    /**\n     * Builds remove view sql.\n     */\n    protected async deleteViewDefinitionSql(view: View): Promise<Query> {\n        const currentSchema = await this.getCurrentSchema()\n\n        let { schema, tableName: name } = this.driver.parseTableName(view)\n\n        if (!schema) {\n            schema = currentSchema\n        }\n\n        const type = view.materialized\n            ? MetadataTableType.MATERIALIZED_VIEW\n            : MetadataTableType.VIEW\n        return this.deleteTypeormMetadataSql({ type, schema, name })\n    }\n\n    /**\n     * Drops ENUM type from given schemas.\n     */\n    protected async dropEnumTypes(schemaNames: string): Promise<void> {\n        const selectDropsQuery =\n            `SELECT 'DROP TYPE IF EXISTS \"' || n.nspname || '\".\"' || t.typname || '\" CASCADE;' as \"query\" FROM \"pg_type\" \"t\" ` +\n            `INNER JOIN \"pg_enum\" \"e\" ON \"e\".\"enumtypid\" = \"t\".\"oid\" ` +\n            `INNER JOIN \"pg_namespace\" \"n\" ON \"n\".\"oid\" = \"t\".\"typnamespace\" ` +\n            `WHERE \"n\".\"nspname\" IN (${schemaNames}) GROUP BY \"n\".\"nspname\", \"t\".\"typname\"`\n        const dropQueries: ObjectLiteral[] = await this.query(selectDropsQuery)\n        await Promise.all(dropQueries.map((q) => this.query(q[\"query\"])))\n    }\n\n    /**\n     * Checks if enum with the given name exist in the database.\n     */\n    protected async hasEnumType(\n        table: Table,\n        column: TableColumn,\n    ): Promise<boolean> {\n        let { schema } = this.driver.parseTableName(table)\n\n        if (!schema) {\n            schema = await this.getCurrentSchema()\n        }\n\n        const enumName = this.buildEnumName(table, column, false, true)\n        const sql =\n            `SELECT \"n\".\"nspname\", \"t\".\"typname\" FROM \"pg_type\" \"t\" ` +\n            `INNER JOIN \"pg_namespace\" \"n\" ON \"n\".\"oid\" = \"t\".\"typnamespace\" ` +\n            `WHERE \"n\".\"nspname\" = '${schema}' AND \"t\".\"typname\" = '${enumName}'`\n        const result = await this.query(sql)\n        return result.length ? true : false\n    }\n\n    /**\n     * Builds create ENUM type sql.\n     */\n    protected createEnumTypeSql(\n        table: Table,\n        column: TableColumn,\n        enumName?: string,\n    ): Query {\n        if (!enumName) enumName = this.buildEnumName(table, column)\n        const enumValues = column\n            .enum!.map((value) => `'${value.replace(\"'\", \"''\")}'`)\n            .join(\", \")\n        return new Query(`CREATE TYPE ${enumName} AS ENUM(${enumValues})`)\n    }\n\n    /**\n     * Builds create ENUM type sql.\n     */\n    protected dropEnumTypeSql(\n        table: Table,\n        column: TableColumn,\n        enumName?: string,\n    ): Query {\n        if (!enumName) enumName = this.buildEnumName(table, column)\n        return new Query(`DROP TYPE ${enumName}`)\n    }\n\n    /**\n     * Builds create index sql.\n     */\n    protected createIndexSql(table: Table, index: TableIndex): Query {\n        const columns = index.columnNames\n            .map((columnName) => `\"${columnName}\"`)\n            .join(\", \")\n        return new Query(\n            `CREATE ${index.isUnique ? \"UNIQUE \" : \"\"}INDEX${\n                index.isConcurrent ? \" CONCURRENTLY\" : \"\"\n            } \"${index.name}\" ON ${this.escapePath(table)} ${\n                index.isSpatial ? \"USING GiST \" : \"\"\n            }(${columns}) ${index.where ? \"WHERE \" + index.where : \"\"}`,\n        )\n    }\n\n    /**\n     * Builds create view index sql.\n     */\n    protected createViewIndexSql(view: View, index: TableIndex): Query {\n        const columns = index.columnNames\n            .map((columnName) => `\"${columnName}\"`)\n            .join(\", \")\n        return new Query(\n            `CREATE ${index.isUnique ? \"UNIQUE \" : \"\"}INDEX \"${\n                index.name\n            }\" ON ${this.escapePath(view)} (${columns}) ${\n                index.where ? \"WHERE \" + index.where : \"\"\n            }`,\n        )\n    }\n\n    /**\n     * Builds drop index sql.\n     */\n    protected dropIndexSql(\n        table: Table | View,\n        indexOrName: TableIndex | string,\n    ): Query {\n        const indexName = InstanceChecker.isTableIndex(indexOrName)\n            ? indexOrName.name\n            : indexOrName\n        const concurrent = InstanceChecker.isTableIndex(indexOrName)\n            ? indexOrName.isConcurrent\n            : false\n        const { schema } = this.driver.parseTableName(table)\n        return schema\n            ? new Query(\n                  `DROP INDEX ${\n                      concurrent ? \"CONCURRENTLY \" : \"\"\n                  }\"${schema}\".\"${indexName}\"`,\n              )\n            : new Query(\n                  `DROP INDEX ${\n                      concurrent ? \"CONCURRENTLY \" : \"\"\n                  }\"${indexName}\"`,\n              )\n    }\n\n    /**\n     * Builds create primary key sql.\n     */\n    protected createPrimaryKeySql(\n        table: Table,\n        columnNames: string[],\n        constraintName?: string,\n    ): Query {\n        const primaryKeyName = constraintName\n            ? constraintName\n            : this.connection.namingStrategy.primaryKeyName(table, columnNames)\n\n        const columnNamesString = columnNames\n            .map((columnName) => `\"${columnName}\"`)\n            .join(\", \")\n\n        return new Query(\n            `ALTER TABLE ${this.escapePath(\n                table,\n            )} ADD CONSTRAINT \"${primaryKeyName}\" PRIMARY KEY (${columnNamesString})`,\n        )\n    }\n\n    /**\n     * Builds drop primary key sql.\n     */\n    protected dropPrimaryKeySql(table: Table): Query {\n        if (!table.primaryColumns.length)\n            throw new TypeORMError(`Table ${table} has no primary keys.`)\n\n        const columnNames = table.primaryColumns.map((column) => column.name)\n        const constraintName = table.primaryColumns[0].primaryKeyConstraintName\n        const primaryKeyName = constraintName\n            ? constraintName\n            : this.connection.namingStrategy.primaryKeyName(table, columnNames)\n\n        return new Query(\n            `ALTER TABLE ${this.escapePath(\n                table,\n            )} DROP CONSTRAINT \"${primaryKeyName}\"`,\n        )\n    }\n\n    /**\n     * Builds create unique constraint sql.\n     */\n    protected createUniqueConstraintSql(\n        table: Table,\n        uniqueConstraint: TableUnique,\n    ): Query {\n        const columnNames = uniqueConstraint.columnNames\n            .map((column) => `\"` + column + `\"`)\n            .join(\", \")\n        let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${\n            uniqueConstraint.name\n        }\" UNIQUE (${columnNames})`\n        if (uniqueConstraint.deferrable)\n            sql += ` DEFERRABLE ${uniqueConstraint.deferrable}`\n        return new Query(sql)\n    }\n\n    /**\n     * Builds drop unique constraint sql.\n     */\n    protected dropUniqueConstraintSql(\n        table: Table,\n        uniqueOrName: TableUnique | string,\n    ): Query {\n        const uniqueName = InstanceChecker.isTableUnique(uniqueOrName)\n            ? uniqueOrName.name\n            : uniqueOrName\n        return new Query(\n            `ALTER TABLE ${this.escapePath(\n                table,\n            )} DROP CONSTRAINT \"${uniqueName}\"`,\n        )\n    }\n\n    /**\n     * Builds create check constraint sql.\n     */\n    protected createCheckConstraintSql(\n        table: Table,\n        checkConstraint: TableCheck,\n    ): Query {\n        return new Query(\n            `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${\n                checkConstraint.name\n            }\" CHECK (${checkConstraint.expression})`,\n        )\n    }\n\n    /**\n     * Builds drop check constraint sql.\n     */\n    protected dropCheckConstraintSql(\n        table: Table,\n        checkOrName: TableCheck | string,\n    ): Query {\n        const checkName = InstanceChecker.isTableCheck(checkOrName)\n            ? checkOrName.name\n            : checkOrName\n        return new Query(\n            `ALTER TABLE ${this.escapePath(\n                table,\n            )} DROP CONSTRAINT \"${checkName}\"`,\n        )\n    }\n\n    /**\n     * Builds create exclusion constraint sql.\n     */\n    protected createExclusionConstraintSql(\n        table: Table,\n        exclusionConstraint: TableExclusion,\n    ): Query {\n        return new Query(\n            `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${\n                exclusionConstraint.name\n            }\" EXCLUDE ${exclusionConstraint.expression}`,\n        )\n    }\n\n    /**\n     * Builds drop exclusion constraint sql.\n     */\n    protected dropExclusionConstraintSql(\n        table: Table,\n        exclusionOrName: TableExclusion | string,\n    ): Query {\n        const exclusionName = InstanceChecker.isTableExclusion(exclusionOrName)\n            ? exclusionOrName.name\n            : exclusionOrName\n        return new Query(\n            `ALTER TABLE ${this.escapePath(\n                table,\n            )} DROP CONSTRAINT \"${exclusionName}\"`,\n        )\n    }\n\n    /**\n     * Builds create foreign key sql.\n     */\n    protected createForeignKeySql(\n        table: Table,\n        foreignKey: TableForeignKey,\n    ): Query {\n        const columnNames = foreignKey.columnNames\n            .map((column) => `\"` + column + `\"`)\n            .join(\", \")\n        const referencedColumnNames = foreignKey.referencedColumnNames\n            .map((column) => `\"` + column + `\"`)\n            .join(\",\")\n        let sql =\n            `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${\n                foreignKey.name\n            }\" FOREIGN KEY (${columnNames}) ` +\n            `REFERENCES ${this.escapePath(\n                this.getTablePath(foreignKey),\n            )}(${referencedColumnNames})`\n        if (foreignKey.onDelete) sql += ` ON DELETE ${foreignKey.onDelete}`\n        if (foreignKey.onUpdate) sql += ` ON UPDATE ${foreignKey.onUpdate}`\n        if (foreignKey.deferrable) sql += ` DEFERRABLE ${foreignKey.deferrable}`\n\n        return new Query(sql)\n    }\n\n    /**\n     * Builds drop foreign key sql.\n     */\n    protected dropForeignKeySql(\n        table: Table,\n        foreignKeyOrName: TableForeignKey | string,\n    ): Query {\n        const foreignKeyName = InstanceChecker.isTableForeignKey(\n            foreignKeyOrName,\n        )\n            ? foreignKeyOrName.name\n            : foreignKeyOrName\n        return new Query(\n            `ALTER TABLE ${this.escapePath(\n                table,\n            )} DROP CONSTRAINT \"${foreignKeyName}\"`,\n        )\n    }\n\n    /**\n     * Builds sequence name from given table and column.\n     */\n    protected buildSequenceName(\n        table: Table,\n        columnOrName: TableColumn | string,\n    ): string {\n        const { tableName } = this.driver.parseTableName(table)\n\n        const columnName = InstanceChecker.isTableColumn(columnOrName)\n            ? columnOrName.name\n            : columnOrName\n\n        let seqName = `${tableName}_${columnName}_seq`\n\n        if (seqName.length > this.connection.driver.maxAliasLength!) {\n            // note doesn't yet handle corner cases where .length differs from number of UTF-8 bytes\n            seqName = `${tableName.substring(0, 29)}_${columnName.substring(\n                0,\n                Math.max(29, 63 - table.name.length - 5),\n            )}_seq`\n        }\n\n        return seqName\n    }\n\n    protected buildSequencePath(\n        table: Table,\n        columnOrName: TableColumn | string,\n    ): string {\n        const { schema } = this.driver.parseTableName(table)\n\n        return schema\n            ? `${schema}.${this.buildSequenceName(table, columnOrName)}`\n            : this.buildSequenceName(table, columnOrName)\n    }\n\n    /**\n     * Builds ENUM type name from given table and column.\n     */\n    protected buildEnumName(\n        table: Table,\n        column: TableColumn,\n        withSchema: boolean = true,\n        disableEscape?: boolean,\n        toOld?: boolean,\n    ): string {\n        const { schema, tableName } = this.driver.parseTableName(table)\n        let enumName = column.enumName\n            ? column.enumName\n            : `${tableName}_${column.name.toLowerCase()}_enum`\n        if (schema && withSchema) enumName = `${schema}.${enumName}`\n        if (toOld) enumName = enumName + \"_old\"\n        return enumName\n            .split(\".\")\n            .map((i) => {\n                return disableEscape ? i : `\"${i}\"`\n            })\n            .join(\".\")\n    }\n\n    protected async getUserDefinedTypeName(table: Table, column: TableColumn) {\n        let { schema, tableName: name } = this.driver.parseTableName(table)\n\n        if (!schema) {\n            schema = await this.getCurrentSchema()\n        }\n\n        const result = await this.query(\n            `SELECT \"udt_schema\", \"udt_name\" ` +\n                `FROM \"information_schema\".\"columns\" WHERE \"table_schema\" = '${schema}' AND \"table_name\" = '${name}' AND \"column_name\"='${column.name}'`,\n        )\n\n        // docs: https://www.postgresql.org/docs/current/xtypes.html\n        // When you define a new base type, PostgreSQL automatically provides support for arrays of that type.\n        // The array type typically has the same name as the base type with the underscore character (_) prepended.\n        // ----\n        // so, we must remove this underscore character from enum type name\n        let udtName = result[0][\"udt_name\"]\n        if (udtName.indexOf(\"_\") === 0) {\n            udtName = udtName.substr(1, udtName.length)\n        }\n        return {\n            schema: result[0][\"udt_schema\"],\n            name: udtName,\n        }\n    }\n\n    /**\n     * Escapes a given comment so it's safe to include in a query.\n     */\n    protected escapeComment(comment?: string) {\n        if (!comment || comment.length === 0) {\n            return \"NULL\"\n        }\n\n        comment = comment.replace(/'/g, \"''\").replace(/\\u0000/g, \"\") // Null bytes aren't allowed in comments\n\n        return `'${comment}'`\n    }\n\n    /**\n     * Escapes given table or view path.\n     */\n    protected escapePath(target: Table | View | string): string {\n        const { schema, tableName } = this.driver.parseTableName(target)\n\n        if (schema && schema !== this.driver.searchSchema) {\n            return `\"${schema}\".\"${tableName}\"`\n        }\n\n        return `\"${tableName}\"`\n    }\n\n    /**\n     * Get the table name with table schema\n     * Note: Without ' or \"\n     */\n    protected async getTableNameWithSchema(target: Table | string) {\n        const tableName = InstanceChecker.isTable(target) ? target.name : target\n        if (tableName.indexOf(\".\") === -1) {\n            const schemaResult = await this.query(`SELECT current_schema()`)\n            const schema = schemaResult[0][\"current_schema\"]\n            return `${schema}.${tableName}`\n        } else {\n            return `${tableName.split(\".\")[0]}.${tableName.split(\".\")[1]}`\n        }\n    }\n\n    /**\n     * Builds a query for create column.\n     */\n    protected buildCreateColumnSql(table: Table, column: TableColumn) {\n        let c = '\"' + column.name + '\"'\n        if (\n            column.isGenerated === true &&\n            column.generationStrategy !== \"uuid\"\n        ) {\n            if (column.generationStrategy === \"identity\") {\n                // Postgres 10+ Identity generated column\n                const generatedIdentityOrDefault =\n                    column.generatedIdentity || \"BY DEFAULT\"\n                c += ` ${column.type} GENERATED ${generatedIdentityOrDefault} AS IDENTITY`\n            } else {\n                // classic SERIAL primary column\n                if (\n                    column.type === \"integer\" ||\n                    column.type === \"int\" ||\n                    column.type === \"int4\"\n                )\n                    c += \" SERIAL\"\n                if (column.type === \"smallint\" || column.type === \"int2\")\n                    c += \" SMALLSERIAL\"\n                if (column.type === \"bigint\" || column.type === \"int8\")\n                    c += \" BIGSERIAL\"\n            }\n        }\n        if (column.type === \"enum\" || column.type === \"simple-enum\") {\n            c += \" \" + this.buildEnumName(table, column)\n            if (column.isArray) c += \" array\"\n        } else if (!column.isGenerated || column.type === \"uuid\") {\n            c += \" \" + this.connection.driver.createFullType(column)\n        }\n\n        // Postgres only supports the stored generated column type\n        if (column.generatedType === \"STORED\" && column.asExpression) {\n            c += ` GENERATED ALWAYS AS (${column.asExpression}) STORED`\n        }\n\n        if (column.charset) c += ' CHARACTER SET \"' + column.charset + '\"'\n        if (column.collation) c += ' COLLATE \"' + column.collation + '\"'\n        if (column.isNullable !== true) c += \" NOT NULL\"\n        if (column.default !== undefined && column.default !== null)\n            c += \" DEFAULT \" + column.default\n        if (\n            column.isGenerated &&\n            column.generationStrategy === \"uuid\" &&\n            !column.default\n        )\n            c += ` DEFAULT ${this.driver.uuidGenerator}`\n\n        return c\n    }\n\n    /**\n     * Checks if the PostgreSQL server has support for partitioned tables\n     */\n    protected async hasSupportForPartitionedTables() {\n        const result = await this.query(\n            `SELECT TRUE FROM information_schema.columns WHERE table_name = 'pg_class' and column_name = 'relispartition'`,\n        )\n        return result.length ? true : false\n    }\n\n    /**\n     * Change table comment.\n     */\n    async changeTableComment(\n        tableOrName: Table | string,\n        newComment?: string,\n    ): Promise<void> {\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName)\n\n        newComment = this.escapeComment(newComment)\n        const comment = this.escapeComment(table.comment)\n        \n        if (newComment === comment) {\n            return\n        }\n\n        const newTable = table.clone()\n\n        upQueries.push(\n            new Query(\n                `COMMENT ON TABLE ${this.escapePath(\n                    newTable,\n                )} IS ${newComment}`,\n            ),\n        )\n\n        downQueries.push(\n            new Query(\n                `COMMENT ON TABLE ${this.escapePath(table)} IS ${comment}`,\n            ),\n        )\n\n        await this.executeQueries(upQueries, downQueries)\n\n        table.comment = newTable.comment\n        this.replaceCachedTable(table, newTable)\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}