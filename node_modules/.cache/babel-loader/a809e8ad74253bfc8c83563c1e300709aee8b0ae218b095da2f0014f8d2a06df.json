{"ast":null,"code":"import { importClassesFromDirectories } from \"../util/DirectoryExportedClassesLoader\";\nimport { OrmUtils } from \"../util/OrmUtils\";\nimport { getFromContainer } from \"../container\";\nimport { getMetadataArgsStorage } from \"../globals\";\nimport { EntityMetadataBuilder } from \"../metadata-builder/EntityMetadataBuilder\";\nimport { EntitySchemaTransformer } from \"../entity-schema/EntitySchemaTransformer\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\n/**\n * Builds migration instances, subscriber instances and entity metadatas for the given classes.\n */\nexport class ConnectionMetadataBuilder {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    this.connection = connection;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Builds migration instances for the given classes or directories.\n   */\n  async buildMigrations(migrations) {\n    const [migrationClasses, migrationDirectories] = OrmUtils.splitClassesAndStrings(migrations);\n    const allMigrationClasses = [...migrationClasses, ...(await importClassesFromDirectories(this.connection.logger, migrationDirectories))];\n    return allMigrationClasses.map(migrationClass => getFromContainer(migrationClass));\n  }\n  /**\n   * Builds subscriber instances for the given classes or directories.\n   */\n  async buildSubscribers(subscribers) {\n    const [subscriberClasses, subscriberDirectories] = OrmUtils.splitClassesAndStrings(subscribers || []);\n    const allSubscriberClasses = [...subscriberClasses, ...(await importClassesFromDirectories(this.connection.logger, subscriberDirectories))];\n    return getMetadataArgsStorage().filterSubscribers(allSubscriberClasses).map(metadata => getFromContainer(metadata.target));\n  }\n  /**\n   * Builds entity metadatas for the given classes or directories.\n   */\n  async buildEntityMetadatas(entities) {\n    // todo: instead we need to merge multiple metadata args storages\n    const [entityClassesOrSchemas, entityDirectories] = OrmUtils.splitClassesAndStrings(entities || []);\n    const entityClasses = entityClassesOrSchemas.filter(entityClass => !InstanceChecker.isEntitySchema(entityClass));\n    const entitySchemas = entityClassesOrSchemas.filter(entityClass => InstanceChecker.isEntitySchema(entityClass));\n    const allEntityClasses = [...entityClasses, ...(await importClassesFromDirectories(this.connection.logger, entityDirectories))];\n    allEntityClasses.forEach(entityClass => {\n      // if we have entity schemas loaded from directories\n      if (InstanceChecker.isEntitySchema(entityClass)) {\n        entitySchemas.push(entityClass);\n      }\n    });\n    const decoratorEntityMetadatas = new EntityMetadataBuilder(this.connection, getMetadataArgsStorage()).build(allEntityClasses);\n    const metadataArgsStorageFromSchema = new EntitySchemaTransformer().transform(entitySchemas);\n    const schemaEntityMetadatas = new EntityMetadataBuilder(this.connection, metadataArgsStorageFromSchema).build();\n    return [...decoratorEntityMetadatas, ...schemaEntityMetadatas];\n  }\n}","map":{"version":3,"names":["importClassesFromDirectories","OrmUtils","getFromContainer","getMetadataArgsStorage","EntityMetadataBuilder","EntitySchemaTransformer","InstanceChecker","ConnectionMetadataBuilder","constructor","connection","buildMigrations","migrations","migrationClasses","migrationDirectories","splitClassesAndStrings","allMigrationClasses","logger","map","migrationClass","buildSubscribers","subscribers","subscriberClasses","subscriberDirectories","allSubscriberClasses","filterSubscribers","metadata","target","buildEntityMetadatas","entities","entityClassesOrSchemas","entityDirectories","entityClasses","filter","entityClass","isEntitySchema","entitySchemas","allEntityClasses","forEach","push","decoratorEntityMetadatas","build","metadataArgsStorageFromSchema","transform","schemaEntityMetadatas"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\connection\\ConnectionMetadataBuilder.ts"],"sourcesContent":["import { importClassesFromDirectories } from \"../util/DirectoryExportedClassesLoader\"\nimport { OrmUtils } from \"../util/OrmUtils\"\nimport { getFromContainer } from \"../container\"\nimport { MigrationInterface } from \"../migration/MigrationInterface\"\nimport { getMetadataArgsStorage } from \"../globals\"\nimport { EntityMetadataBuilder } from \"../metadata-builder/EntityMetadataBuilder\"\nimport { EntitySchemaTransformer } from \"../entity-schema/EntitySchemaTransformer\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { EntitySchema } from \"../entity-schema/EntitySchema\"\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { EntitySubscriberInterface } from \"../subscriber/EntitySubscriberInterface\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\n\n/**\n * Builds migration instances, subscriber instances and entity metadatas for the given classes.\n */\nexport class ConnectionMetadataBuilder {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected connection: DataSource) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Builds migration instances for the given classes or directories.\n     */\n    async buildMigrations(\n        migrations: (Function | string)[],\n    ): Promise<MigrationInterface[]> {\n        const [migrationClasses, migrationDirectories] =\n            OrmUtils.splitClassesAndStrings(migrations)\n        const allMigrationClasses = [\n            ...migrationClasses,\n            ...(await importClassesFromDirectories(\n                this.connection.logger,\n                migrationDirectories,\n            )),\n        ]\n        return allMigrationClasses.map((migrationClass) =>\n            getFromContainer<MigrationInterface>(migrationClass),\n        )\n    }\n\n    /**\n     * Builds subscriber instances for the given classes or directories.\n     */\n    async buildSubscribers(\n        subscribers: (Function | string)[],\n    ): Promise<EntitySubscriberInterface<any>[]> {\n        const [subscriberClasses, subscriberDirectories] =\n            OrmUtils.splitClassesAndStrings(subscribers || [])\n        const allSubscriberClasses = [\n            ...subscriberClasses,\n            ...(await importClassesFromDirectories(\n                this.connection.logger,\n                subscriberDirectories,\n            )),\n        ]\n        return getMetadataArgsStorage()\n            .filterSubscribers(allSubscriberClasses)\n            .map((metadata) =>\n                getFromContainer<EntitySubscriberInterface<any>>(\n                    metadata.target,\n                ),\n            )\n    }\n\n    /**\n     * Builds entity metadatas for the given classes or directories.\n     */\n    async buildEntityMetadatas(\n        entities: (Function | EntitySchema<any> | string)[],\n    ): Promise<EntityMetadata[]> {\n        // todo: instead we need to merge multiple metadata args storages\n\n        const [entityClassesOrSchemas, entityDirectories] =\n            OrmUtils.splitClassesAndStrings(entities || [])\n        const entityClasses: Function[] = entityClassesOrSchemas.filter(\n            (entityClass) => !InstanceChecker.isEntitySchema(entityClass),\n        ) as any\n        const entitySchemas: EntitySchema<any>[] =\n            entityClassesOrSchemas.filter((entityClass) =>\n                InstanceChecker.isEntitySchema(entityClass),\n            ) as any\n\n        const allEntityClasses = [\n            ...entityClasses,\n            ...(await importClassesFromDirectories(\n                this.connection.logger,\n                entityDirectories,\n            )),\n        ]\n        allEntityClasses.forEach((entityClass) => {\n            // if we have entity schemas loaded from directories\n            if (InstanceChecker.isEntitySchema(entityClass)) {\n                entitySchemas.push(entityClass)\n            }\n        })\n        const decoratorEntityMetadatas = new EntityMetadataBuilder(\n            this.connection,\n            getMetadataArgsStorage(),\n        ).build(allEntityClasses)\n\n        const metadataArgsStorageFromSchema =\n            new EntitySchemaTransformer().transform(entitySchemas)\n        const schemaEntityMetadatas = new EntityMetadataBuilder(\n            this.connection,\n            metadataArgsStorageFromSchema,\n        ).build()\n\n        return [...decoratorEntityMetadatas, ...schemaEntityMetadatas]\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}