{"ast":null,"code":"/**\n * Repository is supposed to work with your entity objects. Find entities, insert, update, delete, etc.\n */\nexport class Repository {\n  // -------------------------------------------------------------------------\n  // Accessors\n  // -------------------------------------------------------------------------\n  /**\n   * Entity metadata of the entity current repository manages.\n   */\n  get metadata() {\n    return this.manager.connection.getMetadata(this.target);\n  }\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(target, manager, queryRunner) {\n    this.target = target;\n    this.manager = manager;\n    this.queryRunner = queryRunner;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates a new query builder that can be used to build a SQL query.\n   */\n  createQueryBuilder(alias, queryRunner) {\n    return this.manager.createQueryBuilder(this.metadata.target, alias || this.metadata.targetName, queryRunner || this.queryRunner);\n  }\n  /**\n   * Checks if entity has an id.\n   * If entity composite compose ids, it will check them all.\n   */\n  hasId(entity) {\n    return this.manager.hasId(this.metadata.target, entity);\n  }\n  /**\n   * Gets entity mixed id.\n   */\n  getId(entity) {\n    return this.manager.getId(this.metadata.target, entity);\n  }\n  /**\n   * Creates a new entity instance or instances.\n   * Can copy properties from the given object into new entities.\n   */\n  create(plainEntityLikeOrPlainEntityLikes) {\n    return this.manager.create(this.metadata.target, plainEntityLikeOrPlainEntityLikes);\n  }\n  /**\n   * Merges multiple entities (or entity-like objects) into a given entity.\n   */\n  merge(mergeIntoEntity, ...entityLikes) {\n    return this.manager.merge(this.metadata.target, mergeIntoEntity, ...entityLikes);\n  }\n  /**\n   * Creates a new entity from the given plain javascript object. If entity already exist in the database, then\n   * it loads it (and everything related to it), replaces all values with the new ones from the given object\n   * and returns this new entity. This new entity is actually a loaded from the db entity with all properties\n   * replaced from the new object.\n   *\n   * Note that given entity-like object must have an entity id / primary key to find entity by.\n   * Returns undefined if entity with given id was not found.\n   */\n  preload(entityLike) {\n    return this.manager.preload(this.metadata.target, entityLike);\n  }\n  /**\n   * Saves one or many given entities.\n   */\n  save(entityOrEntities, options) {\n    return this.manager.save(this.metadata.target, entityOrEntities, options);\n  }\n  /**\n   * Removes one or many given entities.\n   */\n  remove(entityOrEntities, options) {\n    return this.manager.remove(this.metadata.target, entityOrEntities, options);\n  }\n  /**\n   * Records the delete date of one or many given entities.\n   */\n  softRemove(entityOrEntities, options) {\n    return this.manager.softRemove(this.metadata.target, entityOrEntities, options);\n  }\n  /**\n   * Recovers one or many given entities.\n   */\n  recover(entityOrEntities, options) {\n    return this.manager.recover(this.metadata.target, entityOrEntities, options);\n  }\n  /**\n   * Inserts a given entity into the database.\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient INSERT query.\n   * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.\n   */\n  insert(entity) {\n    return this.manager.insert(this.metadata.target, entity);\n  }\n  /**\n   * Updates entity partially. Entity can be found by a given conditions.\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient UPDATE query.\n   * Does not check if entity exist in the database.\n   */\n  update(criteria, partialEntity) {\n    return this.manager.update(this.metadata.target, criteria, partialEntity);\n  }\n  /**\n   * Inserts a given entity into the database, unless a unique constraint conflicts then updates the entity\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient INSERT ... ON CONFLICT DO UPDATE/ON DUPLICATE KEY UPDATE query.\n   */\n  upsert(entityOrEntities, conflictPathsOrOptions) {\n    return this.manager.upsert(this.metadata.target, entityOrEntities, conflictPathsOrOptions);\n  }\n  /**\n   * Deletes entities by a given criteria.\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient DELETE query.\n   * Does not check if entity exist in the database.\n   */\n  delete(criteria) {\n    return this.manager.delete(this.metadata.target, criteria);\n  }\n  /**\n   * Records the delete date of entities by a given criteria.\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient SOFT-DELETE query.\n   * Does not check if entity exist in the database.\n   */\n  softDelete(criteria) {\n    return this.manager.softDelete(this.metadata.target, criteria);\n  }\n  /**\n   * Restores entities by a given criteria.\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient SOFT-DELETE query.\n   * Does not check if entity exist in the database.\n   */\n  restore(criteria) {\n    return this.manager.restore(this.metadata.target, criteria);\n  }\n  /**\n   * Checks whether any entity exists that matches the given options.\n   *\n   * @deprecated use `exists` method instead, for example:\n   *\n   * .exists()\n   */\n  exist(options) {\n    return this.manager.exists(this.metadata.target, options);\n  }\n  /**\n   * Checks whether any entity exists that matches the given options.\n   */\n  exists(options) {\n    return this.manager.exists(this.metadata.target, options);\n  }\n  /**\n   * Checks whether any entity exists that matches the given conditions.\n   */\n  existsBy(where) {\n    return this.manager.existsBy(this.metadata.target, where);\n  }\n  /**\n   * Counts entities that match given options.\n   * Useful for pagination.\n   */\n  count(options) {\n    return this.manager.count(this.metadata.target, options);\n  }\n  /**\n   * Counts entities that match given conditions.\n   * Useful for pagination.\n   */\n  countBy(where) {\n    return this.manager.countBy(this.metadata.target, where);\n  }\n  /**\n   * Return the SUM of a column\n   */\n  sum(columnName, where) {\n    return this.manager.sum(this.metadata.target, columnName, where);\n  }\n  /**\n   * Return the AVG of a column\n   */\n  average(columnName, where) {\n    return this.manager.average(this.metadata.target, columnName, where);\n  }\n  /**\n   * Return the MIN of a column\n   */\n  minimum(columnName, where) {\n    return this.manager.minimum(this.metadata.target, columnName, where);\n  }\n  /**\n   * Return the MAX of a column\n   */\n  maximum(columnName, where) {\n    return this.manager.maximum(this.metadata.target, columnName, where);\n  }\n  /**\n   * Finds entities that match given find options.\n   */\n  async find(options) {\n    return this.manager.find(this.metadata.target, options);\n  }\n  /**\n   * Finds entities that match given find options.\n   */\n  async findBy(where) {\n    return this.manager.findBy(this.metadata.target, where);\n  }\n  /**\n   * Finds entities that match given find options.\n   * Also counts all entities that match given conditions,\n   * but ignores pagination settings (from and take options).\n   */\n  findAndCount(options) {\n    return this.manager.findAndCount(this.metadata.target, options);\n  }\n  /**\n   * Finds entities that match given WHERE conditions.\n   * Also counts all entities that match given conditions,\n   * but ignores pagination settings (from and take options).\n   */\n  findAndCountBy(where) {\n    return this.manager.findAndCountBy(this.metadata.target, where);\n  }\n  /**\n   * Finds entities with ids.\n   * Optionally find options or conditions can be applied.\n   *\n   * @deprecated use `findBy` method instead in conjunction with `In` operator, for example:\n   *\n   * .findBy({\n   *     id: In([1, 2, 3])\n   * })\n   */\n  async findByIds(ids) {\n    return this.manager.findByIds(this.metadata.target, ids);\n  }\n  /**\n   * Finds first entity by a given find options.\n   * If entity was not found in the database - returns null.\n   */\n  async findOne(options) {\n    return this.manager.findOne(this.metadata.target, options);\n  }\n  /**\n   * Finds first entity that matches given where condition.\n   * If entity was not found in the database - returns null.\n   */\n  async findOneBy(where) {\n    return this.manager.findOneBy(this.metadata.target, where);\n  }\n  /**\n   * Finds first entity that matches given id.\n   * If entity was not found in the database - returns null.\n   *\n   * @deprecated use `findOneBy` method instead in conjunction with `In` operator, for example:\n   *\n   * .findOneBy({\n   *     id: 1 // where \"id\" is your primary column name\n   * })\n   */\n  async findOneById(id) {\n    return this.manager.findOneById(this.metadata.target, id);\n  }\n  /**\n   * Finds first entity by a given find options.\n   * If entity was not found in the database - rejects with error.\n   */\n  async findOneOrFail(options) {\n    return this.manager.findOneOrFail(this.metadata.target, options);\n  }\n  /**\n   * Finds first entity that matches given where condition.\n   * If entity was not found in the database - rejects with error.\n   */\n  async findOneByOrFail(where) {\n    return this.manager.findOneByOrFail(this.metadata.target, where);\n  }\n  /**\n   * Executes a raw SQL query and returns a raw database results.\n   * Raw query execution is supported only by relational databases (MongoDB is not supported).\n   */\n  query(query, parameters) {\n    return this.manager.query(query, parameters);\n  }\n  /**\n   * Clears all the data from the given table/collection (truncates/drops it).\n   *\n   * Note: this method uses TRUNCATE and may not work as you expect in transactions on some platforms.\n   * @see https://stackoverflow.com/a/5972738/925151\n   */\n  clear() {\n    return this.manager.clear(this.metadata.target);\n  }\n  /**\n   * Increments some column by provided value of the entities matched given conditions.\n   */\n  increment(conditions, propertyPath, value) {\n    return this.manager.increment(this.metadata.target, conditions, propertyPath, value);\n  }\n  /**\n   * Decrements some column by provided value of the entities matched given conditions.\n   */\n  decrement(conditions, propertyPath, value) {\n    return this.manager.decrement(this.metadata.target, conditions, propertyPath, value);\n  }\n  /**\n   * Extends repository with provided functions.\n   */\n  extend(customs) {\n    // return {\n    //     ...this,\n    //     ...custom\n    // };\n    const thisRepo = this.constructor;\n    const {\n      target,\n      manager,\n      queryRunner\n    } = this;\n    const ChildClass = class extends thisRepo {\n      constructor(target, manager, queryRunner) {\n        super(target, manager, queryRunner);\n      }\n    };\n    for (const custom in customs) ChildClass.prototype[custom] = customs[custom];\n    return new ChildClass(target, manager, queryRunner);\n  }\n}","map":{"version":3,"names":["Repository","metadata","manager","connection","getMetadata","target","constructor","queryRunner","createQueryBuilder","alias","targetName","hasId","entity","getId","create","plainEntityLikeOrPlainEntityLikes","merge","mergeIntoEntity","entityLikes","preload","entityLike","save","entityOrEntities","options","remove","softRemove","recover","insert","update","criteria","partialEntity","upsert","conflictPathsOrOptions","delete","softDelete","restore","exist","exists","existsBy","where","count","countBy","sum","columnName","average","minimum","maximum","find","findBy","findAndCount","findAndCountBy","findByIds","ids","findOne","findOneBy","findOneById","id","findOneOrFail","findOneByOrFail","query","parameters","clear","increment","conditions","propertyPath","value","decrement","extend","customs","thisRepo","ChildClass","custom","prototype"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\repository\\Repository.ts"],"sourcesContent":["import { FindManyOptions } from \"../find-options/FindManyOptions\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { FindOneOptions } from \"../find-options/FindOneOptions\"\nimport { DeepPartial } from \"../common/DeepPartial\"\nimport { SaveOptions } from \"./SaveOptions\"\nimport { RemoveOptions } from \"./RemoveOptions\"\nimport { EntityManager } from \"../entity-manager/EntityManager\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { SelectQueryBuilder } from \"../query-builder/SelectQueryBuilder\"\nimport { DeleteResult } from \"../query-builder/result/DeleteResult\"\nimport { UpdateResult } from \"../query-builder/result/UpdateResult\"\nimport { InsertResult } from \"../query-builder/result/InsertResult\"\nimport { QueryDeepPartialEntity } from \"../query-builder/QueryPartialEntity\"\nimport { ObjectId } from \"../driver/mongodb/typings\"\nimport { FindOptionsWhere } from \"../find-options/FindOptionsWhere\"\nimport { UpsertOptions } from \"./UpsertOptions\"\nimport { EntityTarget } from \"../common/EntityTarget\"\nimport { PickKeysByType } from \"../common/PickKeysByType\"\n\n/**\n * Repository is supposed to work with your entity objects. Find entities, insert, update, delete, etc.\n */\nexport class Repository<Entity extends ObjectLiteral> {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Entity target that is managed by this repository.\n     * If this repository manages entity from schema,\n     * then it returns a name of that schema instead.\n     */\n    readonly target: EntityTarget<Entity>\n\n    /**\n     * Entity Manager used by this repository.\n     */\n    readonly manager: EntityManager\n\n    /**\n     * Query runner provider used for this repository.\n     */\n    readonly queryRunner?: QueryRunner\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Entity metadata of the entity current repository manages.\n     */\n    get metadata() {\n        return this.manager.connection.getMetadata(this.target)\n    }\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        target: EntityTarget<Entity>,\n        manager: EntityManager,\n        queryRunner?: QueryRunner,\n    ) {\n        this.target = target\n        this.manager = manager\n        this.queryRunner = queryRunner\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a new query builder that can be used to build a SQL query.\n     */\n    createQueryBuilder(\n        alias?: string,\n        queryRunner?: QueryRunner,\n    ): SelectQueryBuilder<Entity> {\n        return this.manager.createQueryBuilder<Entity>(\n            this.metadata.target as any,\n            alias || this.metadata.targetName,\n            queryRunner || this.queryRunner,\n        )\n    }\n\n    /**\n     * Checks if entity has an id.\n     * If entity composite compose ids, it will check them all.\n     */\n    hasId(entity: Entity): boolean {\n        return this.manager.hasId(this.metadata.target, entity)\n    }\n\n    /**\n     * Gets entity mixed id.\n     */\n    getId(entity: Entity): any {\n        return this.manager.getId(this.metadata.target, entity)\n    }\n\n    /**\n     * Creates a new entity instance.\n     */\n    create(): Entity\n\n    /**\n     * Creates new entities and copies all entity properties from given objects into their new entities.\n     * Note that it copies only properties that are present in entity schema.\n     */\n    create(entityLikeArray: DeepPartial<Entity>[]): Entity[]\n\n    /**\n     * Creates a new entity instance and copies all entity properties from this object into a new entity.\n     * Note that it copies only properties that are present in entity schema.\n     */\n    create(entityLike: DeepPartial<Entity>): Entity\n\n    /**\n     * Creates a new entity instance or instances.\n     * Can copy properties from the given object into new entities.\n     */\n    create(\n        plainEntityLikeOrPlainEntityLikes?:\n            | DeepPartial<Entity>\n            | DeepPartial<Entity>[],\n    ): Entity | Entity[] {\n        return this.manager.create(\n            this.metadata.target as any,\n            plainEntityLikeOrPlainEntityLikes as any,\n        )\n    }\n\n    /**\n     * Merges multiple entities (or entity-like objects) into a given entity.\n     */\n    merge(\n        mergeIntoEntity: Entity,\n        ...entityLikes: DeepPartial<Entity>[]\n    ): Entity {\n        return this.manager.merge(\n            this.metadata.target as any,\n            mergeIntoEntity,\n            ...entityLikes,\n        )\n    }\n\n    /**\n     * Creates a new entity from the given plain javascript object. If entity already exist in the database, then\n     * it loads it (and everything related to it), replaces all values with the new ones from the given object\n     * and returns this new entity. This new entity is actually a loaded from the db entity with all properties\n     * replaced from the new object.\n     *\n     * Note that given entity-like object must have an entity id / primary key to find entity by.\n     * Returns undefined if entity with given id was not found.\n     */\n    preload(entityLike: DeepPartial<Entity>): Promise<Entity | undefined> {\n        return this.manager.preload(this.metadata.target as any, entityLike)\n    }\n\n    /**\n     * Saves all given entities in the database.\n     * If entities do not exist in the database then inserts, otherwise updates.\n     */\n    save<T extends DeepPartial<Entity>>(\n        entities: T[],\n        options: SaveOptions & { reload: false },\n    ): Promise<T[]>\n\n    /**\n     * Saves all given entities in the database.\n     * If entities do not exist in the database then inserts, otherwise updates.\n     */\n    save<T extends DeepPartial<Entity>>(\n        entities: T[],\n        options?: SaveOptions,\n    ): Promise<(T & Entity)[]>\n\n    /**\n     * Saves a given entity in the database.\n     * If entity does not exist in the database then inserts, otherwise updates.\n     */\n    save<T extends DeepPartial<Entity>>(\n        entity: T,\n        options: SaveOptions & { reload: false },\n    ): Promise<T>\n\n    /**\n     * Saves a given entity in the database.\n     * If entity does not exist in the database then inserts, otherwise updates.\n     */\n    save<T extends DeepPartial<Entity>>(\n        entity: T,\n        options?: SaveOptions,\n    ): Promise<T & Entity>\n\n    /**\n     * Saves one or many given entities.\n     */\n    save<T extends DeepPartial<Entity>>(\n        entityOrEntities: T | T[],\n        options?: SaveOptions,\n    ): Promise<T | T[]> {\n        return this.manager.save<Entity, T>(\n            this.metadata.target as any,\n            entityOrEntities as any,\n            options,\n        )\n    }\n\n    /**\n     * Removes a given entities from the database.\n     */\n    remove(entities: Entity[], options?: RemoveOptions): Promise<Entity[]>\n\n    /**\n     * Removes a given entity from the database.\n     */\n    remove(entity: Entity, options?: RemoveOptions): Promise<Entity>\n\n    /**\n     * Removes one or many given entities.\n     */\n    remove(\n        entityOrEntities: Entity | Entity[],\n        options?: RemoveOptions,\n    ): Promise<Entity | Entity[]> {\n        return this.manager.remove(\n            this.metadata.target as any,\n            entityOrEntities as any,\n            options,\n        )\n    }\n\n    /**\n     * Records the delete date of all given entities.\n     */\n    softRemove<T extends DeepPartial<Entity>>(\n        entities: T[],\n        options: SaveOptions & { reload: false },\n    ): Promise<T[]>\n\n    /**\n     * Records the delete date of all given entities.\n     */\n    softRemove<T extends DeepPartial<Entity>>(\n        entities: T[],\n        options?: SaveOptions,\n    ): Promise<(T & Entity)[]>\n\n    /**\n     * Records the delete date of a given entity.\n     */\n    softRemove<T extends DeepPartial<Entity>>(\n        entity: T,\n        options: SaveOptions & { reload: false },\n    ): Promise<T>\n\n    /**\n     * Records the delete date of a given entity.\n     */\n    softRemove<T extends DeepPartial<Entity>>(\n        entity: T,\n        options?: SaveOptions,\n    ): Promise<T & Entity>\n\n    /**\n     * Records the delete date of one or many given entities.\n     */\n    softRemove<T extends DeepPartial<Entity>>(\n        entityOrEntities: T | T[],\n        options?: SaveOptions,\n    ): Promise<T | T[]> {\n        return this.manager.softRemove<Entity, T>(\n            this.metadata.target as any,\n            entityOrEntities as any,\n            options,\n        )\n    }\n\n    /**\n     * Recovers all given entities in the database.\n     */\n    recover<T extends DeepPartial<Entity>>(\n        entities: T[],\n        options: SaveOptions & { reload: false },\n    ): Promise<T[]>\n\n    /**\n     * Recovers all given entities in the database.\n     */\n    recover<T extends DeepPartial<Entity>>(\n        entities: T[],\n        options?: SaveOptions,\n    ): Promise<(T & Entity)[]>\n\n    /**\n     * Recovers a given entity in the database.\n     */\n    recover<T extends DeepPartial<Entity>>(\n        entity: T,\n        options: SaveOptions & { reload: false },\n    ): Promise<T>\n\n    /**\n     * Recovers a given entity in the database.\n     */\n    recover<T extends DeepPartial<Entity>>(\n        entity: T,\n        options?: SaveOptions,\n    ): Promise<T & Entity>\n\n    /**\n     * Recovers one or many given entities.\n     */\n    recover<T extends DeepPartial<Entity>>(\n        entityOrEntities: T | T[],\n        options?: SaveOptions,\n    ): Promise<T | T[]> {\n        return this.manager.recover<Entity, T>(\n            this.metadata.target as any,\n            entityOrEntities as any,\n            options,\n        )\n    }\n\n    /**\n     * Inserts a given entity into the database.\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient INSERT query.\n     * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.\n     */\n    insert(\n        entity:\n            | QueryDeepPartialEntity<Entity>\n            | QueryDeepPartialEntity<Entity>[],\n    ): Promise<InsertResult> {\n        return this.manager.insert(this.metadata.target as any, entity)\n    }\n\n    /**\n     * Updates entity partially. Entity can be found by a given conditions.\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient UPDATE query.\n     * Does not check if entity exist in the database.\n     */\n    update(\n        criteria:\n            | string\n            | string[]\n            | number\n            | number[]\n            | Date\n            | Date[]\n            | ObjectId\n            | ObjectId[]\n            | FindOptionsWhere<Entity>,\n        partialEntity: QueryDeepPartialEntity<Entity>,\n    ): Promise<UpdateResult> {\n        return this.manager.update(\n            this.metadata.target as any,\n            criteria as any,\n            partialEntity,\n        )\n    }\n\n    /**\n     * Inserts a given entity into the database, unless a unique constraint conflicts then updates the entity\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient INSERT ... ON CONFLICT DO UPDATE/ON DUPLICATE KEY UPDATE query.\n     */\n    upsert(\n        entityOrEntities:\n            | QueryDeepPartialEntity<Entity>\n            | QueryDeepPartialEntity<Entity>[],\n        conflictPathsOrOptions: string[] | UpsertOptions<Entity>,\n    ): Promise<InsertResult> {\n        return this.manager.upsert(\n            this.metadata.target as any,\n            entityOrEntities,\n            conflictPathsOrOptions,\n        )\n    }\n\n    /**\n     * Deletes entities by a given criteria.\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient DELETE query.\n     * Does not check if entity exist in the database.\n     */\n    delete(\n        criteria:\n            | string\n            | string[]\n            | number\n            | number[]\n            | Date\n            | Date[]\n            | ObjectId\n            | ObjectId[]\n            | FindOptionsWhere<Entity>,\n    ): Promise<DeleteResult> {\n        return this.manager.delete(this.metadata.target as any, criteria as any)\n    }\n\n    /**\n     * Records the delete date of entities by a given criteria.\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient SOFT-DELETE query.\n     * Does not check if entity exist in the database.\n     */\n    softDelete(\n        criteria:\n            | string\n            | string[]\n            | number\n            | number[]\n            | Date\n            | Date[]\n            | ObjectId\n            | ObjectId[]\n            | FindOptionsWhere<Entity>,\n    ): Promise<UpdateResult> {\n        return this.manager.softDelete(\n            this.metadata.target as any,\n            criteria as any,\n        )\n    }\n\n    /**\n     * Restores entities by a given criteria.\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient SOFT-DELETE query.\n     * Does not check if entity exist in the database.\n     */\n    restore(\n        criteria:\n            | string\n            | string[]\n            | number\n            | number[]\n            | Date\n            | Date[]\n            | ObjectId\n            | ObjectId[]\n            | FindOptionsWhere<Entity>,\n    ): Promise<UpdateResult> {\n        return this.manager.restore(\n            this.metadata.target as any,\n            criteria as any,\n        )\n    }\n\n    /**\n     * Checks whether any entity exists that matches the given options.\n     *\n     * @deprecated use `exists` method instead, for example:\n     *\n     * .exists()\n     */\n    exist(options?: FindManyOptions<Entity>): Promise<boolean> {\n        return this.manager.exists(this.metadata.target, options)\n    }\n\n    /**\n     * Checks whether any entity exists that matches the given options.\n     */\n    exists(options?: FindManyOptions<Entity>): Promise<boolean> {\n        return this.manager.exists(this.metadata.target, options)\n    }\n\n    /**\n     * Checks whether any entity exists that matches the given conditions.\n     */\n    existsBy(\n        where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    ): Promise<boolean> {\n        return this.manager.existsBy(this.metadata.target, where)\n    }\n\n    /**\n     * Counts entities that match given options.\n     * Useful for pagination.\n     */\n    count(options?: FindManyOptions<Entity>): Promise<number> {\n        return this.manager.count(this.metadata.target, options)\n    }\n\n    /**\n     * Counts entities that match given conditions.\n     * Useful for pagination.\n     */\n    countBy(\n        where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    ): Promise<number> {\n        return this.manager.countBy(this.metadata.target, where)\n    }\n\n    /**\n     * Return the SUM of a column\n     */\n    sum(\n        columnName: PickKeysByType<Entity, number>,\n        where?: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    ): Promise<number | null> {\n        return this.manager.sum(this.metadata.target, columnName, where)\n    }\n\n    /**\n     * Return the AVG of a column\n     */\n    average(\n        columnName: PickKeysByType<Entity, number>,\n        where?: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    ): Promise<number | null> {\n        return this.manager.average(this.metadata.target, columnName, where)\n    }\n\n    /**\n     * Return the MIN of a column\n     */\n    minimum(\n        columnName: PickKeysByType<Entity, number>,\n        where?: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    ): Promise<number | null> {\n        return this.manager.minimum(this.metadata.target, columnName, where)\n    }\n\n    /**\n     * Return the MAX of a column\n     */\n    maximum(\n        columnName: PickKeysByType<Entity, number>,\n        where?: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    ): Promise<number | null> {\n        return this.manager.maximum(this.metadata.target, columnName, where)\n    }\n\n    /**\n     * Finds entities that match given find options.\n     */\n    async find(options?: FindManyOptions<Entity>): Promise<Entity[]> {\n        return this.manager.find(this.metadata.target, options)\n    }\n\n    /**\n     * Finds entities that match given find options.\n     */\n    async findBy(\n        where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    ): Promise<Entity[]> {\n        return this.manager.findBy(this.metadata.target, where)\n    }\n\n    /**\n     * Finds entities that match given find options.\n     * Also counts all entities that match given conditions,\n     * but ignores pagination settings (from and take options).\n     */\n    findAndCount(\n        options?: FindManyOptions<Entity>,\n    ): Promise<[Entity[], number]> {\n        return this.manager.findAndCount(this.metadata.target, options)\n    }\n\n    /**\n     * Finds entities that match given WHERE conditions.\n     * Also counts all entities that match given conditions,\n     * but ignores pagination settings (from and take options).\n     */\n    findAndCountBy(\n        where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    ): Promise<[Entity[], number]> {\n        return this.manager.findAndCountBy(this.metadata.target, where)\n    }\n\n    /**\n     * Finds entities with ids.\n     * Optionally find options or conditions can be applied.\n     *\n     * @deprecated use `findBy` method instead in conjunction with `In` operator, for example:\n     *\n     * .findBy({\n     *     id: In([1, 2, 3])\n     * })\n     */\n    async findByIds(ids: any[]): Promise<Entity[]> {\n        return this.manager.findByIds(this.metadata.target, ids)\n    }\n\n    /**\n     * Finds first entity by a given find options.\n     * If entity was not found in the database - returns null.\n     */\n    async findOne(options: FindOneOptions<Entity>): Promise<Entity | null> {\n        return this.manager.findOne(this.metadata.target, options)\n    }\n\n    /**\n     * Finds first entity that matches given where condition.\n     * If entity was not found in the database - returns null.\n     */\n    async findOneBy(\n        where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    ): Promise<Entity | null> {\n        return this.manager.findOneBy(this.metadata.target, where)\n    }\n\n    /**\n     * Finds first entity that matches given id.\n     * If entity was not found in the database - returns null.\n     *\n     * @deprecated use `findOneBy` method instead in conjunction with `In` operator, for example:\n     *\n     * .findOneBy({\n     *     id: 1 // where \"id\" is your primary column name\n     * })\n     */\n    async findOneById(\n        id: number | string | Date | ObjectId,\n    ): Promise<Entity | null> {\n        return this.manager.findOneById(this.metadata.target, id)\n    }\n\n    /**\n     * Finds first entity by a given find options.\n     * If entity was not found in the database - rejects with error.\n     */\n    async findOneOrFail(options: FindOneOptions<Entity>): Promise<Entity> {\n        return this.manager.findOneOrFail(this.metadata.target, options)\n    }\n\n    /**\n     * Finds first entity that matches given where condition.\n     * If entity was not found in the database - rejects with error.\n     */\n    async findOneByOrFail(\n        where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    ): Promise<Entity> {\n        return this.manager.findOneByOrFail(this.metadata.target, where)\n    }\n\n    /**\n     * Executes a raw SQL query and returns a raw database results.\n     * Raw query execution is supported only by relational databases (MongoDB is not supported).\n     */\n    query(query: string, parameters?: any[]): Promise<any> {\n        return this.manager.query(query, parameters)\n    }\n\n    /**\n     * Clears all the data from the given table/collection (truncates/drops it).\n     *\n     * Note: this method uses TRUNCATE and may not work as you expect in transactions on some platforms.\n     * @see https://stackoverflow.com/a/5972738/925151\n     */\n    clear(): Promise<void> {\n        return this.manager.clear(this.metadata.target)\n    }\n\n    /**\n     * Increments some column by provided value of the entities matched given conditions.\n     */\n    increment(\n        conditions: FindOptionsWhere<Entity>,\n        propertyPath: string,\n        value: number | string,\n    ): Promise<UpdateResult> {\n        return this.manager.increment(\n            this.metadata.target,\n            conditions,\n            propertyPath,\n            value,\n        )\n    }\n\n    /**\n     * Decrements some column by provided value of the entities matched given conditions.\n     */\n    decrement(\n        conditions: FindOptionsWhere<Entity>,\n        propertyPath: string,\n        value: number | string,\n    ): Promise<UpdateResult> {\n        return this.manager.decrement(\n            this.metadata.target,\n            conditions,\n            propertyPath,\n            value,\n        )\n    }\n\n    /**\n     * Extends repository with provided functions.\n     */\n    extend<CustomRepository>(\n        customs: CustomRepository & ThisType<this & CustomRepository>,\n    ): this & CustomRepository {\n        // return {\n        //     ...this,\n        //     ...custom\n        // };\n        const thisRepo: any = this.constructor\n        const { target, manager, queryRunner } = this\n        const ChildClass = class extends thisRepo {\n            constructor(\n                target: EntityTarget<Entity>,\n                manager: EntityManager,\n                queryRunner?: QueryRunner,\n            ) {\n                super(target, manager, queryRunner)\n            }\n        }\n        for (const custom in customs)\n            ChildClass.prototype[custom] = customs[custom]\n        return new ChildClass(target, manager, queryRunner) as any\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}