{"ast":null,"code":"import { registerQueryBuilders } from \"../query-builder\";\nimport { DefaultNamingStrategy } from \"../naming-strategy/DefaultNamingStrategy\";\nimport { CannotConnectAlreadyConnectedError, CannotExecuteNotConnectedError, EntityMetadataNotFoundError, QueryRunnerProviderAlreadyReleasedError, TypeORMError } from \"../error\";\nimport { MigrationExecutor } from \"../migration/MigrationExecutor\";\nimport { EntityMetadataValidator } from \"../metadata-builder/EntityMetadataValidator\";\nimport { EntityManagerFactory } from \"../entity-manager/EntityManagerFactory\";\nimport { DriverFactory } from \"../driver/DriverFactory\";\nimport { ConnectionMetadataBuilder } from \"../connection/ConnectionMetadataBuilder\";\nimport { SelectQueryBuilder } from \"../query-builder/SelectQueryBuilder\";\nimport { LoggerFactory } from \"../logger/LoggerFactory\";\nimport { QueryResultCacheFactory } from \"../cache/QueryResultCacheFactory\";\nimport { RelationLoader } from \"../query-builder/RelationLoader\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { RelationIdLoader } from \"../query-builder/RelationIdLoader\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\nregisterQueryBuilders();\n/**\n * DataSource is a pre-defined connection configuration to a specific database.\n * You can have multiple data sources connected (with multiple connections in it),\n * connected to multiple databases in your application.\n *\n * Before, it was called `Connection`, but now `Connection` is deprecated\n * because `Connection` isn't the best name for what it's actually is.\n */\nexport class DataSource {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(options) {\n    this[\"@instanceof\"] = Symbol.for(\"DataSource\");\n    /**\n     * Migration instances that are registered for this connection.\n     */\n    this.migrations = [];\n    /**\n     * Entity subscriber instances that are registered for this connection.\n     */\n    this.subscribers = [];\n    /**\n     * All entity metadatas that are registered for this connection.\n     */\n    this.entityMetadatas = [];\n    /**\n     * All entity metadatas that are registered for this connection.\n     * This is a copy of #.entityMetadatas property -> used for more performant searches.\n     */\n    this.entityMetadatasMap = new Map();\n    registerQueryBuilders();\n    this.name = options.name || \"default\";\n    this.options = options;\n    this.logger = new LoggerFactory().create(this.options.logger, this.options.logging);\n    this.driver = new DriverFactory().create(this);\n    this.manager = this.createEntityManager();\n    this.namingStrategy = options.namingStrategy || new DefaultNamingStrategy();\n    this.metadataTableName = options.metadataTableName || \"typeorm_metadata\";\n    this.queryResultCache = options.cache ? new QueryResultCacheFactory(this).create() : undefined;\n    this.relationLoader = new RelationLoader(this);\n    this.relationIdLoader = new RelationIdLoader(this);\n    this.isInitialized = false;\n  }\n  // -------------------------------------------------------------------------\n  // Public Accessors\n  // -------------------------------------------------------------------------\n  /**\n   Indicates if DataSource is initialized or not.\n   *\n   * @deprecated use .isInitialized instead\n   */\n  get isConnected() {\n    return this.isInitialized;\n  }\n  /**\n   * Gets the mongodb entity manager that allows to perform mongodb-specific repository operations\n   * with any entity in this connection.\n   *\n   * Available only in mongodb connections.\n   */\n  get mongoManager() {\n    if (!InstanceChecker.isMongoEntityManager(this.manager)) throw new TypeORMError(`MongoEntityManager is only available for MongoDB databases.`);\n    return this.manager;\n  }\n  /**\n   * Gets a sql.js specific Entity Manager that allows to perform special load and save operations\n   *\n   * Available only in connection with the sqljs driver.\n   */\n  get sqljsManager() {\n    if (!InstanceChecker.isSqljsEntityManager(this.manager)) throw new TypeORMError(`SqljsEntityManager is only available for Sqljs databases.`);\n    return this.manager;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Updates current connection options with provided options.\n   */\n  setOptions(options) {\n    Object.assign(this.options, options);\n    if (options.logger || options.logging) {\n      this.logger = new LoggerFactory().create(options.logger || this.options.logger, options.logging || this.options.logging);\n    }\n    if (options.namingStrategy) {\n      this.namingStrategy = options.namingStrategy;\n    }\n    if (options.cache) {\n      this.queryResultCache = new QueryResultCacheFactory(this).create();\n    }\n    // todo: we must update the database in the driver as well, if it was set by setOptions method\n    //  in the future we need to refactor the code and remove \"database\" from the driver, and instead\n    //  use database (and options) from a single place - data source.\n    if (options.database) {\n      this.driver.database = DriverUtils.buildDriverOptions(this.options).database;\n    }\n    // todo: need to take a look if we need to update schema and other \"poor\" properties\n    return this;\n  }\n  /**\n   * Performs connection to the database.\n   * This method should be called once on application bootstrap.\n   * This method not necessarily creates database connection (depend on database type),\n   * but it also can setup a connection pool with database to use.\n   */\n  async initialize() {\n    if (this.isInitialized) throw new CannotConnectAlreadyConnectedError(this.name);\n    // connect to the database via its driver\n    await this.driver.connect();\n    // connect to the cache-specific database if cache is enabled\n    if (this.queryResultCache) await this.queryResultCache.connect();\n    // set connected status for the current connection\n    ObjectUtils.assign(this, {\n      isInitialized: true\n    });\n    try {\n      // build all metadatas registered in the current connection\n      await this.buildMetadatas();\n      await this.driver.afterConnect();\n      // if option is set - drop schema once connection is done\n      if (this.options.dropSchema) await this.dropDatabase();\n      // if option is set - automatically synchronize a schema\n      if (this.options.migrationsRun) await this.runMigrations({\n        transaction: this.options.migrationsTransactionMode\n      });\n      // if option is set - automatically synchronize a schema\n      if (this.options.synchronize) await this.synchronize();\n    } catch (error) {\n      // if for some reason build metadata fail (for example validation error during entity metadata check)\n      // connection needs to be closed\n      await this.destroy();\n      throw error;\n    }\n    return this;\n  }\n  /**\n   * Performs connection to the database.\n   * This method should be called once on application bootstrap.\n   * This method not necessarily creates database connection (depend on database type),\n   * but it also can setup a connection pool with database to use.\n   *\n   * @deprecated use .initialize method instead\n   */\n  async connect() {\n    return this.initialize();\n  }\n  /**\n   * Closes connection with the database.\n   * Once connection is closed, you cannot use repositories or perform any operations except opening connection again.\n   */\n  async destroy() {\n    if (!this.isInitialized) throw new CannotExecuteNotConnectedError(this.name);\n    await this.driver.disconnect();\n    // disconnect from the cache-specific database if cache was enabled\n    if (this.queryResultCache) await this.queryResultCache.disconnect();\n    ObjectUtils.assign(this, {\n      isInitialized: false\n    });\n  }\n  /**\n   * Closes connection with the database.\n   * Once connection is closed, you cannot use repositories or perform any operations except opening connection again.\n   *\n   * @deprecated use .destroy method instead\n   */\n  async close() {\n    return this.destroy();\n  }\n  /**\n   * Creates database schema for all entities registered in this connection.\n   * Can be used only after connection to the database is established.\n   *\n   * @param dropBeforeSync If set to true then it drops the database with all its tables and data\n   */\n  async synchronize(dropBeforeSync = false) {\n    if (!this.isInitialized) throw new CannotExecuteNotConnectedError(this.name);\n    if (dropBeforeSync) await this.dropDatabase();\n    const schemaBuilder = this.driver.createSchemaBuilder();\n    await schemaBuilder.build();\n  }\n  /**\n   * Drops the database and all its data.\n   * Be careful with this method on production since this method will erase all your database tables and their data.\n   * Can be used only after connection to the database is established.\n   */\n  // TODO rename\n  async dropDatabase() {\n    const queryRunner = this.createQueryRunner();\n    try {\n      if (this.driver.options.type === \"mssql\" || DriverUtils.isMySQLFamily(this.driver) || this.driver.options.type === \"aurora-mysql\" || DriverUtils.isSQLiteFamily(this.driver)) {\n        const databases = [];\n        this.entityMetadatas.forEach(metadata => {\n          if (metadata.database && databases.indexOf(metadata.database) === -1) databases.push(metadata.database);\n        });\n        if (databases.length === 0 && this.driver.database) {\n          databases.push(this.driver.database);\n        }\n        if (databases.length === 0) {\n          await queryRunner.clearDatabase();\n        } else {\n          for (const database of databases) {\n            await queryRunner.clearDatabase(database);\n          }\n        }\n      } else {\n        await queryRunner.clearDatabase();\n      }\n    } finally {\n      await queryRunner.release();\n    }\n  }\n  /**\n   * Runs all pending migrations.\n   * Can be used only after connection to the database is established.\n   */\n  async runMigrations(options) {\n    if (!this.isInitialized) throw new CannotExecuteNotConnectedError(this.name);\n    const migrationExecutor = new MigrationExecutor(this);\n    migrationExecutor.transaction = options?.transaction || this.options?.migrationsTransactionMode || \"all\";\n    migrationExecutor.fake = options && options.fake || false;\n    const successMigrations = await migrationExecutor.executePendingMigrations();\n    return successMigrations;\n  }\n  /**\n   * Reverts last executed migration.\n   * Can be used only after connection to the database is established.\n   */\n  async undoLastMigration(options) {\n    if (!this.isInitialized) throw new CannotExecuteNotConnectedError(this.name);\n    const migrationExecutor = new MigrationExecutor(this);\n    migrationExecutor.transaction = options && options.transaction || \"all\";\n    migrationExecutor.fake = options && options.fake || false;\n    await migrationExecutor.undoLastMigration();\n  }\n  /**\n   * Lists all migrations and whether they have been run.\n   * Returns true if there are pending migrations\n   */\n  async showMigrations() {\n    if (!this.isInitialized) {\n      throw new CannotExecuteNotConnectedError(this.name);\n    }\n    const migrationExecutor = new MigrationExecutor(this);\n    return await migrationExecutor.showMigrations();\n  }\n  /**\n   * Checks if entity metadata exist for the given entity class, target name or table name.\n   */\n  hasMetadata(target) {\n    return !!this.findMetadata(target);\n  }\n  /**\n   * Gets entity metadata for the given entity class or schema name.\n   */\n  getMetadata(target) {\n    const metadata = this.findMetadata(target);\n    if (!metadata) throw new EntityMetadataNotFoundError(target);\n    return metadata;\n  }\n  /**\n   * Gets repository for the given entity.\n   */\n  getRepository(target) {\n    return this.manager.getRepository(target);\n  }\n  /**\n   * Gets tree repository for the given entity class or name.\n   * Only tree-type entities can have a TreeRepository, like ones decorated with @Tree decorator.\n   */\n  getTreeRepository(target) {\n    return this.manager.getTreeRepository(target);\n  }\n  /**\n   * Gets mongodb-specific repository for the given entity class or name.\n   * Works only if connection is mongodb-specific.\n   */\n  getMongoRepository(target) {\n    if (!(this.driver.options.type === \"mongodb\")) throw new TypeORMError(`You can use getMongoRepository only for MongoDB connections.`);\n    return this.manager.getRepository(target);\n  }\n  /**\n   * Gets custom entity repository marked with @EntityRepository decorator.\n   *\n   * @deprecated use Repository.extend function to create a custom repository\n   */\n  getCustomRepository(customRepository) {\n    return this.manager.getCustomRepository(customRepository);\n  }\n  async transaction(isolationOrRunInTransaction, runInTransactionParam) {\n    return this.manager.transaction(isolationOrRunInTransaction, runInTransactionParam);\n  }\n  /**\n   * Executes raw SQL query and returns raw database results.\n   */\n  async query(query, parameters, queryRunner) {\n    if (InstanceChecker.isMongoEntityManager(this.manager)) throw new TypeORMError(`Queries aren't supported by MongoDB.`);\n    if (queryRunner && queryRunner.isReleased) throw new QueryRunnerProviderAlreadyReleasedError();\n    const usedQueryRunner = queryRunner || this.createQueryRunner();\n    try {\n      return await usedQueryRunner.query(query, parameters); // await is needed here because we are using finally\n    } finally {\n      if (!queryRunner) await usedQueryRunner.release();\n    }\n  }\n  /**\n   * Creates a new query builder that can be used to build a SQL query.\n   */\n  createQueryBuilder(entityOrRunner, alias, queryRunner) {\n    if (InstanceChecker.isMongoEntityManager(this.manager)) throw new TypeORMError(`Query Builder is not supported by MongoDB.`);\n    if (alias) {\n      alias = DriverUtils.buildAlias(this.driver, undefined, alias);\n      const metadata = this.getMetadata(entityOrRunner);\n      return new SelectQueryBuilder(this, queryRunner).select(alias).from(metadata.target, alias);\n    } else {\n      return new SelectQueryBuilder(this, entityOrRunner);\n    }\n  }\n  /**\n   * Creates a query runner used for perform queries on a single database connection.\n   * Using query runners you can control your queries to execute using single database connection and\n   * manually control your database transaction.\n   *\n   * Mode is used in replication mode and indicates whatever you want to connect\n   * to master database or any of slave databases.\n   * If you perform writes you must use master database,\n   * if you perform reads you can use slave databases.\n   */\n  createQueryRunner(mode = \"master\") {\n    const queryRunner = this.driver.createQueryRunner(mode);\n    const manager = this.createEntityManager(queryRunner);\n    Object.assign(queryRunner, {\n      manager: manager\n    });\n    return queryRunner;\n  }\n  /**\n   * Gets entity metadata of the junction table (many-to-many table).\n   */\n  getManyToManyMetadata(entityTarget, relationPropertyPath) {\n    const relationMetadata = this.getMetadata(entityTarget).findRelationWithPropertyPath(relationPropertyPath);\n    if (!relationMetadata) throw new TypeORMError(`Relation \"${relationPropertyPath}\" was not found in ${entityTarget} entity.`);\n    if (!relationMetadata.isManyToMany) throw new TypeORMError(`Relation \"${entityTarget}#${relationPropertyPath}\" does not have a many-to-many relationship.` + `You can use this method only on many-to-many relations.`);\n    return relationMetadata.junctionEntityMetadata;\n  }\n  /**\n   * Creates an Entity Manager for the current connection with the help of the EntityManagerFactory.\n   */\n  createEntityManager(queryRunner) {\n    return new EntityManagerFactory().create(this, queryRunner);\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Finds exist entity metadata by the given entity class, target name or table name.\n   */\n  findMetadata(target) {\n    const metadataFromMap = this.entityMetadatasMap.get(target);\n    if (metadataFromMap) return metadataFromMap;\n    for (let [_, metadata] of this.entityMetadatasMap) {\n      if (InstanceChecker.isEntitySchema(target) && metadata.name === target.options.name) {\n        return metadata;\n      }\n      if (typeof target === \"string\") {\n        if (target.indexOf(\".\") !== -1) {\n          if (metadata.tablePath === target) {\n            return metadata;\n          }\n        } else {\n          if (metadata.name === target || metadata.tableName === target) {\n            return metadata;\n          }\n        }\n      }\n      if (ObjectUtils.isObjectWithName(target) && typeof target.name === \"string\") {\n        if (target.name.indexOf(\".\") !== -1) {\n          if (metadata.tablePath === target.name) {\n            return metadata;\n          }\n        } else {\n          if (metadata.name === target.name || metadata.tableName === target.name) {\n            return metadata;\n          }\n        }\n      }\n    }\n    return undefined;\n  }\n  /**\n   * Builds metadatas for all registered classes inside this connection.\n   */\n  async buildMetadatas() {\n    const connectionMetadataBuilder = new ConnectionMetadataBuilder(this);\n    const entityMetadataValidator = new EntityMetadataValidator();\n    // create subscribers instances if they are not disallowed from high-level (for example they can disallowed from migrations run process)\n    const flattenedSubscribers = ObjectUtils.mixedListToArray(this.options.subscribers || []);\n    const subscribers = await connectionMetadataBuilder.buildSubscribers(flattenedSubscribers);\n    ObjectUtils.assign(this, {\n      subscribers: subscribers\n    });\n    // build entity metadatas\n    const flattenedEntities = ObjectUtils.mixedListToArray(this.options.entities || []);\n    const entityMetadatas = await connectionMetadataBuilder.buildEntityMetadatas(flattenedEntities);\n    ObjectUtils.assign(this, {\n      entityMetadatas: entityMetadatas,\n      entityMetadatasMap: new Map(entityMetadatas.map(metadata => [metadata.target, metadata]))\n    });\n    // create migration instances\n    const flattenedMigrations = ObjectUtils.mixedListToArray(this.options.migrations || []);\n    const migrations = await connectionMetadataBuilder.buildMigrations(flattenedMigrations);\n    ObjectUtils.assign(this, {\n      migrations: migrations\n    });\n    // validate all created entity metadatas to make sure user created entities are valid and correct\n    entityMetadataValidator.validateMany(this.entityMetadatas.filter(metadata => metadata.tableType !== \"view\"), this.driver);\n    // set current data source to the entities\n    for (let entityMetadata of entityMetadatas) {\n      if (InstanceChecker.isBaseEntityConstructor(entityMetadata.target)) {\n        entityMetadata.target.useDataSource(this);\n      }\n    }\n  }\n  /**\n   * Get the replication mode SELECT queries should use for this datasource by default\n   */\n  defaultReplicationModeForReads() {\n    if (\"replication\" in this.driver.options) {\n      const value = this.driver.options.replication.defaultMode;\n      if (value) {\n        return value;\n      }\n    }\n    return \"slave\";\n  }\n}","map":{"version":3,"names":["registerQueryBuilders","DefaultNamingStrategy","CannotConnectAlreadyConnectedError","CannotExecuteNotConnectedError","EntityMetadataNotFoundError","QueryRunnerProviderAlreadyReleasedError","TypeORMError","MigrationExecutor","EntityMetadataValidator","EntityManagerFactory","DriverFactory","ConnectionMetadataBuilder","SelectQueryBuilder","LoggerFactory","QueryResultCacheFactory","RelationLoader","ObjectUtils","RelationIdLoader","DriverUtils","InstanceChecker","DataSource","constructor","options","Symbol","for","migrations","subscribers","entityMetadatas","entityMetadatasMap","Map","name","logger","create","logging","driver","manager","createEntityManager","namingStrategy","metadataTableName","queryResultCache","cache","undefined","relationLoader","relationIdLoader","isInitialized","isConnected","mongoManager","isMongoEntityManager","sqljsManager","isSqljsEntityManager","setOptions","Object","assign","database","buildDriverOptions","initialize","connect","buildMetadatas","afterConnect","dropSchema","dropDatabase","migrationsRun","runMigrations","transaction","migrationsTransactionMode","synchronize","error","destroy","disconnect","close","dropBeforeSync","schemaBuilder","createSchemaBuilder","build","queryRunner","createQueryRunner","type","isMySQLFamily","isSQLiteFamily","databases","forEach","metadata","indexOf","push","length","clearDatabase","release","migrationExecutor","fake","successMigrations","executePendingMigrations","undoLastMigration","showMigrations","hasMetadata","target","findMetadata","getMetadata","getRepository","getTreeRepository","getMongoRepository","getCustomRepository","customRepository","isolationOrRunInTransaction","runInTransactionParam","query","parameters","isReleased","usedQueryRunner","createQueryBuilder","entityOrRunner","alias","buildAlias","select","from","mode","getManyToManyMetadata","entityTarget","relationPropertyPath","relationMetadata","findRelationWithPropertyPath","isManyToMany","junctionEntityMetadata","metadataFromMap","get","_","isEntitySchema","tablePath","tableName","isObjectWithName","connectionMetadataBuilder","entityMetadataValidator","flattenedSubscribers","mixedListToArray","buildSubscribers","flattenedEntities","entities","buildEntityMetadatas","map","flattenedMigrations","buildMigrations","validateMany","filter","tableType","entityMetadata","isBaseEntityConstructor","useDataSource","defaultReplicationModeForReads","value","replication","defaultMode"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\data-source\\DataSource.ts"],"sourcesContent":["import { Driver } from \"../driver/Driver\"\nimport { registerQueryBuilders } from \"../query-builder\"\nimport { Repository } from \"../repository/Repository\"\nimport { EntitySubscriberInterface } from \"../subscriber/EntitySubscriberInterface\"\nimport { EntityTarget } from \"../common/EntityTarget\"\nimport { ObjectType } from \"../common/ObjectType\"\nimport { EntityManager } from \"../entity-manager/EntityManager\"\nimport { DefaultNamingStrategy } from \"../naming-strategy/DefaultNamingStrategy\"\nimport {\n    CannotConnectAlreadyConnectedError,\n    CannotExecuteNotConnectedError,\n    EntityMetadataNotFoundError,\n    QueryRunnerProviderAlreadyReleasedError,\n    TypeORMError,\n} from \"../error\"\nimport { TreeRepository } from \"../repository/TreeRepository\"\nimport { NamingStrategyInterface } from \"../naming-strategy/NamingStrategyInterface\"\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { Logger } from \"../logger/Logger\"\nimport { MigrationInterface } from \"../migration/MigrationInterface\"\nimport { MigrationExecutor } from \"../migration/MigrationExecutor\"\nimport { Migration } from \"../migration/Migration\"\nimport { MongoRepository } from \"../repository/MongoRepository\"\nimport { MongoEntityManager } from \"../entity-manager/MongoEntityManager\"\nimport { EntityMetadataValidator } from \"../metadata-builder/EntityMetadataValidator\"\nimport { DataSourceOptions } from \"./DataSourceOptions\"\nimport { EntityManagerFactory } from \"../entity-manager/EntityManagerFactory\"\nimport { DriverFactory } from \"../driver/DriverFactory\"\nimport { ConnectionMetadataBuilder } from \"../connection/ConnectionMetadataBuilder\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { SelectQueryBuilder } from \"../query-builder/SelectQueryBuilder\"\nimport { LoggerFactory } from \"../logger/LoggerFactory\"\nimport { QueryResultCacheFactory } from \"../cache/QueryResultCacheFactory\"\nimport { QueryResultCache } from \"../cache/QueryResultCache\"\nimport { SqljsEntityManager } from \"../entity-manager/SqljsEntityManager\"\nimport { RelationLoader } from \"../query-builder/RelationLoader\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { IsolationLevel } from \"../driver/types/IsolationLevel\"\nimport { ReplicationMode } from \"../driver/types/ReplicationMode\"\nimport { RelationIdLoader } from \"../query-builder/RelationIdLoader\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\n\nregisterQueryBuilders()\n\n/**\n * DataSource is a pre-defined connection configuration to a specific database.\n * You can have multiple data sources connected (with multiple connections in it),\n * connected to multiple databases in your application.\n *\n * Before, it was called `Connection`, but now `Connection` is deprecated\n * because `Connection` isn't the best name for what it's actually is.\n */\nexport class DataSource {\n    readonly \"@instanceof\" = Symbol.for(\"DataSource\")\n\n    // -------------------------------------------------------------------------\n    // Public Readonly Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection name.\n     *\n     * @deprecated we don't need names anymore since we are going to drop all related methods relying on this property.\n     */\n    readonly name: string\n\n    /**\n     * Connection options.\n     */\n    readonly options: DataSourceOptions\n\n    /**\n     * Indicates if DataSource is initialized or not.\n     */\n    readonly isInitialized: boolean\n\n    /**\n     * Database driver used by this connection.\n     */\n    driver: Driver\n\n    /**\n     * EntityManager of this connection.\n     */\n    readonly manager: EntityManager\n\n    /**\n     * Naming strategy used in the connection.\n     */\n    namingStrategy: NamingStrategyInterface\n\n    /**\n     * Name for the metadata table\n     */\n    readonly metadataTableName: string\n\n    /**\n     * Logger used to log orm events.\n     */\n    logger: Logger\n\n    /**\n     * Migration instances that are registered for this connection.\n     */\n    readonly migrations: MigrationInterface[] = []\n\n    /**\n     * Entity subscriber instances that are registered for this connection.\n     */\n    readonly subscribers: EntitySubscriberInterface<any>[] = []\n\n    /**\n     * All entity metadatas that are registered for this connection.\n     */\n    readonly entityMetadatas: EntityMetadata[] = []\n\n    /**\n     * All entity metadatas that are registered for this connection.\n     * This is a copy of #.entityMetadatas property -> used for more performant searches.\n     */\n    readonly entityMetadatasMap = new Map<EntityTarget<any>, EntityMetadata>()\n\n    /**\n     * Used to work with query result cache.\n     */\n    queryResultCache?: QueryResultCache\n\n    /**\n     * Used to load relations and work with lazy relations.\n     */\n    readonly relationLoader: RelationLoader\n\n    readonly relationIdLoader: RelationIdLoader\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(options: DataSourceOptions) {\n        registerQueryBuilders()\n        this.name = options.name || \"default\"\n        this.options = options\n        this.logger = new LoggerFactory().create(\n            this.options.logger,\n            this.options.logging,\n        )\n        this.driver = new DriverFactory().create(this)\n        this.manager = this.createEntityManager()\n        this.namingStrategy =\n            options.namingStrategy || new DefaultNamingStrategy()\n        this.metadataTableName = options.metadataTableName || \"typeorm_metadata\"\n        this.queryResultCache = options.cache\n            ? new QueryResultCacheFactory(this).create()\n            : undefined\n        this.relationLoader = new RelationLoader(this)\n        this.relationIdLoader = new RelationIdLoader(this)\n        this.isInitialized = false\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     Indicates if DataSource is initialized or not.\n     *\n     * @deprecated use .isInitialized instead\n     */\n    get isConnected() {\n        return this.isInitialized\n    }\n\n    /**\n     * Gets the mongodb entity manager that allows to perform mongodb-specific repository operations\n     * with any entity in this connection.\n     *\n     * Available only in mongodb connections.\n     */\n    get mongoManager(): MongoEntityManager {\n        if (!InstanceChecker.isMongoEntityManager(this.manager))\n            throw new TypeORMError(\n                `MongoEntityManager is only available for MongoDB databases.`,\n            )\n\n        return this.manager as MongoEntityManager\n    }\n\n    /**\n     * Gets a sql.js specific Entity Manager that allows to perform special load and save operations\n     *\n     * Available only in connection with the sqljs driver.\n     */\n    get sqljsManager(): SqljsEntityManager {\n        if (!InstanceChecker.isSqljsEntityManager(this.manager))\n            throw new TypeORMError(\n                `SqljsEntityManager is only available for Sqljs databases.`,\n            )\n\n        return this.manager\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Updates current connection options with provided options.\n     */\n    setOptions(options: Partial<DataSourceOptions>): this {\n        Object.assign(this.options, options)\n\n        if (options.logger || options.logging) {\n            this.logger = new LoggerFactory().create(\n                options.logger || this.options.logger,\n                options.logging || this.options.logging,\n            )\n        }\n\n        if (options.namingStrategy) {\n            this.namingStrategy = options.namingStrategy\n        }\n\n        if (options.cache) {\n            this.queryResultCache = new QueryResultCacheFactory(this).create()\n        }\n\n        // todo: we must update the database in the driver as well, if it was set by setOptions method\n        //  in the future we need to refactor the code and remove \"database\" from the driver, and instead\n        //  use database (and options) from a single place - data source.\n        if (options.database) {\n            this.driver.database = DriverUtils.buildDriverOptions(\n                this.options,\n            ).database\n        }\n\n        // todo: need to take a look if we need to update schema and other \"poor\" properties\n\n        return this\n    }\n\n    /**\n     * Performs connection to the database.\n     * This method should be called once on application bootstrap.\n     * This method not necessarily creates database connection (depend on database type),\n     * but it also can setup a connection pool with database to use.\n     */\n    async initialize(): Promise<this> {\n        if (this.isInitialized)\n            throw new CannotConnectAlreadyConnectedError(this.name)\n\n        // connect to the database via its driver\n        await this.driver.connect()\n\n        // connect to the cache-specific database if cache is enabled\n        if (this.queryResultCache) await this.queryResultCache.connect()\n\n        // set connected status for the current connection\n        ObjectUtils.assign(this, { isInitialized: true })\n\n        try {\n            // build all metadatas registered in the current connection\n            await this.buildMetadatas()\n\n            await this.driver.afterConnect()\n\n            // if option is set - drop schema once connection is done\n            if (this.options.dropSchema) await this.dropDatabase()\n\n            // if option is set - automatically synchronize a schema\n            if (this.options.migrationsRun)\n                await this.runMigrations({\n                    transaction: this.options.migrationsTransactionMode,\n                })\n\n            // if option is set - automatically synchronize a schema\n            if (this.options.synchronize) await this.synchronize()\n        } catch (error) {\n            // if for some reason build metadata fail (for example validation error during entity metadata check)\n            // connection needs to be closed\n            await this.destroy()\n            throw error\n        }\n\n        return this\n    }\n\n    /**\n     * Performs connection to the database.\n     * This method should be called once on application bootstrap.\n     * This method not necessarily creates database connection (depend on database type),\n     * but it also can setup a connection pool with database to use.\n     *\n     * @deprecated use .initialize method instead\n     */\n    async connect(): Promise<this> {\n        return this.initialize()\n    }\n\n    /**\n     * Closes connection with the database.\n     * Once connection is closed, you cannot use repositories or perform any operations except opening connection again.\n     */\n    async destroy(): Promise<void> {\n        if (!this.isInitialized)\n            throw new CannotExecuteNotConnectedError(this.name)\n\n        await this.driver.disconnect()\n\n        // disconnect from the cache-specific database if cache was enabled\n        if (this.queryResultCache) await this.queryResultCache.disconnect()\n\n        ObjectUtils.assign(this, { isInitialized: false })\n    }\n\n    /**\n     * Closes connection with the database.\n     * Once connection is closed, you cannot use repositories or perform any operations except opening connection again.\n     *\n     * @deprecated use .destroy method instead\n     */\n    async close(): Promise<void> {\n        return this.destroy()\n    }\n\n    /**\n     * Creates database schema for all entities registered in this connection.\n     * Can be used only after connection to the database is established.\n     *\n     * @param dropBeforeSync If set to true then it drops the database with all its tables and data\n     */\n    async synchronize(dropBeforeSync: boolean = false): Promise<void> {\n        if (!this.isInitialized)\n            throw new CannotExecuteNotConnectedError(this.name)\n\n        if (dropBeforeSync) await this.dropDatabase()\n\n        const schemaBuilder = this.driver.createSchemaBuilder()\n        await schemaBuilder.build()\n    }\n\n    /**\n     * Drops the database and all its data.\n     * Be careful with this method on production since this method will erase all your database tables and their data.\n     * Can be used only after connection to the database is established.\n     */\n    // TODO rename\n    async dropDatabase(): Promise<void> {\n        const queryRunner = this.createQueryRunner()\n        try {\n            if (\n                this.driver.options.type === \"mssql\" ||\n                DriverUtils.isMySQLFamily(this.driver) ||\n                this.driver.options.type === \"aurora-mysql\" ||\n                DriverUtils.isSQLiteFamily(this.driver)\n            ) {\n                const databases: string[] = []\n                this.entityMetadatas.forEach((metadata) => {\n                    if (\n                        metadata.database &&\n                        databases.indexOf(metadata.database) === -1\n                    )\n                        databases.push(metadata.database)\n                })\n                if (databases.length === 0 && this.driver.database) {\n                    databases.push(this.driver.database)\n                }\n\n                if (databases.length === 0) {\n                    await queryRunner.clearDatabase()\n                } else {\n                    for (const database of databases) {\n                        await queryRunner.clearDatabase(database)\n                    }\n                }\n            } else {\n                await queryRunner.clearDatabase()\n            }\n        } finally {\n            await queryRunner.release()\n        }\n    }\n\n    /**\n     * Runs all pending migrations.\n     * Can be used only after connection to the database is established.\n     */\n    async runMigrations(options?: {\n        transaction?: \"all\" | \"none\" | \"each\"\n        fake?: boolean\n    }): Promise<Migration[]> {\n        if (!this.isInitialized)\n            throw new CannotExecuteNotConnectedError(this.name)\n\n        const migrationExecutor = new MigrationExecutor(this)\n        migrationExecutor.transaction =\n            options?.transaction ||\n            this.options?.migrationsTransactionMode ||\n            \"all\"\n        migrationExecutor.fake = (options && options.fake) || false\n\n        const successMigrations =\n            await migrationExecutor.executePendingMigrations()\n        return successMigrations\n    }\n\n    /**\n     * Reverts last executed migration.\n     * Can be used only after connection to the database is established.\n     */\n    async undoLastMigration(options?: {\n        transaction?: \"all\" | \"none\" | \"each\"\n        fake?: boolean\n    }): Promise<void> {\n        if (!this.isInitialized)\n            throw new CannotExecuteNotConnectedError(this.name)\n\n        const migrationExecutor = new MigrationExecutor(this)\n        migrationExecutor.transaction =\n            (options && options.transaction) || \"all\"\n        migrationExecutor.fake = (options && options.fake) || false\n\n        await migrationExecutor.undoLastMigration()\n    }\n\n    /**\n     * Lists all migrations and whether they have been run.\n     * Returns true if there are pending migrations\n     */\n    async showMigrations(): Promise<boolean> {\n        if (!this.isInitialized) {\n            throw new CannotExecuteNotConnectedError(this.name)\n        }\n        const migrationExecutor = new MigrationExecutor(this)\n        return await migrationExecutor.showMigrations()\n    }\n\n    /**\n     * Checks if entity metadata exist for the given entity class, target name or table name.\n     */\n    hasMetadata(target: EntityTarget<any>): boolean {\n        return !!this.findMetadata(target)\n    }\n\n    /**\n     * Gets entity metadata for the given entity class or schema name.\n     */\n    getMetadata(target: EntityTarget<any>): EntityMetadata {\n        const metadata = this.findMetadata(target)\n        if (!metadata) throw new EntityMetadataNotFoundError(target)\n\n        return metadata\n    }\n\n    /**\n     * Gets repository for the given entity.\n     */\n    getRepository<Entity extends ObjectLiteral>(\n        target: EntityTarget<Entity>,\n    ): Repository<Entity> {\n        return this.manager.getRepository(target)\n    }\n\n    /**\n     * Gets tree repository for the given entity class or name.\n     * Only tree-type entities can have a TreeRepository, like ones decorated with @Tree decorator.\n     */\n    getTreeRepository<Entity extends ObjectLiteral>(\n        target: EntityTarget<Entity>,\n    ): TreeRepository<Entity> {\n        return this.manager.getTreeRepository(target)\n    }\n\n    /**\n     * Gets mongodb-specific repository for the given entity class or name.\n     * Works only if connection is mongodb-specific.\n     */\n    getMongoRepository<Entity extends ObjectLiteral>(\n        target: EntityTarget<Entity>,\n    ): MongoRepository<Entity> {\n        if (!(this.driver.options.type === \"mongodb\"))\n            throw new TypeORMError(\n                `You can use getMongoRepository only for MongoDB connections.`,\n            )\n\n        return this.manager.getRepository(target) as any\n    }\n\n    /**\n     * Gets custom entity repository marked with @EntityRepository decorator.\n     *\n     * @deprecated use Repository.extend function to create a custom repository\n     */\n    getCustomRepository<T>(customRepository: ObjectType<T>): T {\n        return this.manager.getCustomRepository(customRepository)\n    }\n\n    /**\n     * Wraps given function execution (and all operations made there) into a transaction.\n     * All database operations must be executed using provided entity manager.\n     */\n    async transaction<T>(\n        runInTransaction: (entityManager: EntityManager) => Promise<T>,\n    ): Promise<T>\n    async transaction<T>(\n        isolationLevel: IsolationLevel,\n        runInTransaction: (entityManager: EntityManager) => Promise<T>,\n    ): Promise<T>\n    async transaction<T>(\n        isolationOrRunInTransaction:\n            | IsolationLevel\n            | ((entityManager: EntityManager) => Promise<T>),\n        runInTransactionParam?: (entityManager: EntityManager) => Promise<T>,\n    ): Promise<any> {\n        return this.manager.transaction(\n            isolationOrRunInTransaction as any,\n            runInTransactionParam as any,\n        )\n    }\n\n    /**\n     * Executes raw SQL query and returns raw database results.\n     */\n    async query<T = any>(\n        query: string,\n        parameters?: any[],\n        queryRunner?: QueryRunner,\n    ): Promise<T> {\n        if (InstanceChecker.isMongoEntityManager(this.manager))\n            throw new TypeORMError(`Queries aren't supported by MongoDB.`)\n\n        if (queryRunner && queryRunner.isReleased)\n            throw new QueryRunnerProviderAlreadyReleasedError()\n\n        const usedQueryRunner = queryRunner || this.createQueryRunner()\n\n        try {\n            return await usedQueryRunner.query(query, parameters) // await is needed here because we are using finally\n        } finally {\n            if (!queryRunner) await usedQueryRunner.release()\n        }\n    }\n\n    /**\n     * Creates a new query builder that can be used to build a SQL query.\n     */\n    createQueryBuilder<Entity extends ObjectLiteral>(\n        entityClass: EntityTarget<Entity>,\n        alias: string,\n        queryRunner?: QueryRunner,\n    ): SelectQueryBuilder<Entity>\n\n    /**\n     * Creates a new query builder that can be used to build a SQL query.\n     */\n    createQueryBuilder(queryRunner?: QueryRunner): SelectQueryBuilder<any>\n\n    /**\n     * Creates a new query builder that can be used to build a SQL query.\n     */\n    createQueryBuilder<Entity extends ObjectLiteral>(\n        entityOrRunner?: EntityTarget<Entity> | QueryRunner,\n        alias?: string,\n        queryRunner?: QueryRunner,\n    ): SelectQueryBuilder<Entity> {\n        if (InstanceChecker.isMongoEntityManager(this.manager))\n            throw new TypeORMError(`Query Builder is not supported by MongoDB.`)\n\n        if (alias) {\n            alias = DriverUtils.buildAlias(this.driver, undefined, alias)\n            const metadata = this.getMetadata(\n                entityOrRunner as EntityTarget<Entity>,\n            )\n            return new SelectQueryBuilder(this, queryRunner)\n                .select(alias)\n                .from(metadata.target, alias)\n        } else {\n            return new SelectQueryBuilder(\n                this,\n                entityOrRunner as QueryRunner | undefined,\n            )\n        }\n    }\n\n    /**\n     * Creates a query runner used for perform queries on a single database connection.\n     * Using query runners you can control your queries to execute using single database connection and\n     * manually control your database transaction.\n     *\n     * Mode is used in replication mode and indicates whatever you want to connect\n     * to master database or any of slave databases.\n     * If you perform writes you must use master database,\n     * if you perform reads you can use slave databases.\n     */\n    createQueryRunner(mode: ReplicationMode = \"master\"): QueryRunner {\n        const queryRunner = this.driver.createQueryRunner(mode)\n        const manager = this.createEntityManager(queryRunner)\n        Object.assign(queryRunner, { manager: manager })\n        return queryRunner\n    }\n\n    /**\n     * Gets entity metadata of the junction table (many-to-many table).\n     */\n    getManyToManyMetadata(\n        entityTarget: EntityTarget<any>,\n        relationPropertyPath: string,\n    ) {\n        const relationMetadata =\n            this.getMetadata(entityTarget).findRelationWithPropertyPath(\n                relationPropertyPath,\n            )\n        if (!relationMetadata)\n            throw new TypeORMError(\n                `Relation \"${relationPropertyPath}\" was not found in ${entityTarget} entity.`,\n            )\n        if (!relationMetadata.isManyToMany)\n            throw new TypeORMError(\n                `Relation \"${entityTarget}#${relationPropertyPath}\" does not have a many-to-many relationship.` +\n                    `You can use this method only on many-to-many relations.`,\n            )\n\n        return relationMetadata.junctionEntityMetadata\n    }\n\n    /**\n     * Creates an Entity Manager for the current connection with the help of the EntityManagerFactory.\n     */\n    createEntityManager(queryRunner?: QueryRunner): EntityManager {\n        return new EntityManagerFactory().create(this, queryRunner)\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Finds exist entity metadata by the given entity class, target name or table name.\n     */\n    protected findMetadata(\n        target: EntityTarget<any>,\n    ): EntityMetadata | undefined {\n        const metadataFromMap = this.entityMetadatasMap.get(target)\n        if (metadataFromMap) return metadataFromMap\n\n        for (let [_, metadata] of this.entityMetadatasMap) {\n            if (\n                InstanceChecker.isEntitySchema(target) &&\n                metadata.name === target.options.name\n            ) {\n                return metadata\n            }\n            if (typeof target === \"string\") {\n                if (target.indexOf(\".\") !== -1) {\n                    if (metadata.tablePath === target) {\n                        return metadata\n                    }\n                } else {\n                    if (\n                        metadata.name === target ||\n                        metadata.tableName === target\n                    ) {\n                        return metadata\n                    }\n                }\n            }\n            if (\n                ObjectUtils.isObjectWithName(target) &&\n                typeof target.name === \"string\"\n            ) {\n                if (target.name.indexOf(\".\") !== -1) {\n                    if (metadata.tablePath === target.name) {\n                        return metadata\n                    }\n                } else {\n                    if (\n                        metadata.name === target.name ||\n                        metadata.tableName === target.name\n                    ) {\n                        return metadata\n                    }\n                }\n            }\n        }\n\n        return undefined\n    }\n\n    /**\n     * Builds metadatas for all registered classes inside this connection.\n     */\n    protected async buildMetadatas(): Promise<void> {\n        const connectionMetadataBuilder = new ConnectionMetadataBuilder(this)\n        const entityMetadataValidator = new EntityMetadataValidator()\n\n        // create subscribers instances if they are not disallowed from high-level (for example they can disallowed from migrations run process)\n        const flattenedSubscribers = ObjectUtils.mixedListToArray(\n            this.options.subscribers || [],\n        )\n        const subscribers = await connectionMetadataBuilder.buildSubscribers(\n            flattenedSubscribers,\n        )\n        ObjectUtils.assign(this, { subscribers: subscribers })\n\n        // build entity metadatas\n        const flattenedEntities = ObjectUtils.mixedListToArray(\n            this.options.entities || [],\n        )\n        const entityMetadatas =\n            await connectionMetadataBuilder.buildEntityMetadatas(\n                flattenedEntities,\n            )\n        ObjectUtils.assign(this, {\n            entityMetadatas: entityMetadatas,\n            entityMetadatasMap: new Map(\n                entityMetadatas.map((metadata) => [metadata.target, metadata]),\n            ),\n        })\n\n        // create migration instances\n        const flattenedMigrations = ObjectUtils.mixedListToArray(\n            this.options.migrations || [],\n        )\n        const migrations = await connectionMetadataBuilder.buildMigrations(\n            flattenedMigrations,\n        )\n        ObjectUtils.assign(this, { migrations: migrations })\n\n        // validate all created entity metadatas to make sure user created entities are valid and correct\n        entityMetadataValidator.validateMany(\n            this.entityMetadatas.filter(\n                (metadata) => metadata.tableType !== \"view\",\n            ),\n            this.driver,\n        )\n\n        // set current data source to the entities\n        for (let entityMetadata of entityMetadatas) {\n            if (\n                InstanceChecker.isBaseEntityConstructor(entityMetadata.target)\n            ) {\n                entityMetadata.target.useDataSource(this)\n            }\n        }\n    }\n\n    /**\n     * Get the replication mode SELECT queries should use for this datasource by default\n     */\n    defaultReplicationModeForReads(): ReplicationMode {\n        if (\"replication\" in this.driver.options) {\n            const value = (\n                this.driver.options.replication as {\n                    defaultMode?: ReplicationMode\n                }\n            ).defaultMode\n            if (value) {\n                return value\n            }\n        }\n        return \"slave\"\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}