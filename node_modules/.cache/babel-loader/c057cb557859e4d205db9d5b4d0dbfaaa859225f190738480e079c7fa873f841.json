{"ast":null,"code":"import { EntityMetadata } from \"../metadata/EntityMetadata\";\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\";\nimport { ForeignKeyMetadata } from \"../metadata/ForeignKeyMetadata\";\nimport { IndexMetadata } from \"../metadata/IndexMetadata\";\n/**\n * Creates EntityMetadata for junction tables of the closure entities.\n * Closure junction tables are tables generated by closure entities.\n */\nexport class ClosureJunctionEntityMetadataBuilder {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    this.connection = connection;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Builds EntityMetadata for the closure junction of the given closure entity.\n   */\n  build(parentClosureEntityMetadata) {\n    // create entity metadata itself\n    const entityMetadata = new EntityMetadata({\n      parentClosureEntityMetadata: parentClosureEntityMetadata,\n      connection: this.connection,\n      args: {\n        target: \"\",\n        name: parentClosureEntityMetadata.treeOptions && parentClosureEntityMetadata.treeOptions.closureTableName ? parentClosureEntityMetadata.treeOptions.closureTableName : parentClosureEntityMetadata.tableNameWithoutPrefix,\n        type: \"closure-junction\"\n      }\n    });\n    entityMetadata.build();\n    // create ancestor and descendant columns for new closure junction table\n    parentClosureEntityMetadata.primaryColumns.forEach(primaryColumn => {\n      entityMetadata.ownColumns.push(new ColumnMetadata({\n        connection: this.connection,\n        entityMetadata: entityMetadata,\n        closureType: \"ancestor\",\n        referencedColumn: primaryColumn,\n        args: {\n          target: \"\",\n          mode: \"virtual\",\n          propertyName: parentClosureEntityMetadata.treeOptions && parentClosureEntityMetadata.treeOptions.ancestorColumnName ? parentClosureEntityMetadata.treeOptions.ancestorColumnName(primaryColumn) : primaryColumn.propertyName + \"_ancestor\",\n          options: {\n            primary: true,\n            length: primaryColumn.length,\n            type: primaryColumn.type\n          }\n        }\n      }));\n      entityMetadata.ownColumns.push(new ColumnMetadata({\n        connection: this.connection,\n        entityMetadata: entityMetadata,\n        closureType: \"descendant\",\n        referencedColumn: primaryColumn,\n        args: {\n          target: \"\",\n          mode: \"virtual\",\n          propertyName: parentClosureEntityMetadata.treeOptions && parentClosureEntityMetadata.treeOptions.descendantColumnName ? parentClosureEntityMetadata.treeOptions.descendantColumnName(primaryColumn) : primaryColumn.propertyName + \"_descendant\",\n          options: {\n            primary: true,\n            length: primaryColumn.length,\n            type: primaryColumn.type\n          }\n        }\n      }));\n    });\n    entityMetadata.ownIndices = [new IndexMetadata({\n      entityMetadata: entityMetadata,\n      columns: [entityMetadata.ownColumns[0]],\n      args: {\n        target: entityMetadata.target,\n        synchronize: true\n      }\n    }), new IndexMetadata({\n      entityMetadata: entityMetadata,\n      columns: [entityMetadata.ownColumns[1]],\n      args: {\n        target: entityMetadata.target,\n        synchronize: true\n      }\n    })];\n    // if tree level column was defined by a closure entity then add it to the junction columns as well\n    if (parentClosureEntityMetadata.treeLevelColumn) {\n      entityMetadata.ownColumns.push(new ColumnMetadata({\n        connection: this.connection,\n        entityMetadata: entityMetadata,\n        args: {\n          target: \"\",\n          mode: \"virtual\",\n          propertyName: \"level\",\n          options: {\n            type: this.connection.driver.mappedDataTypes.treeLevel\n          }\n        }\n      }));\n    }\n    // create junction table foreign keys\n    // Note: CASCADE is not applied to mssql because it does not support multi cascade paths\n    entityMetadata.foreignKeys = [new ForeignKeyMetadata({\n      entityMetadata: entityMetadata,\n      referencedEntityMetadata: parentClosureEntityMetadata,\n      columns: [entityMetadata.ownColumns[0]],\n      referencedColumns: parentClosureEntityMetadata.primaryColumns,\n      onDelete: this.connection.driver.options.type === \"mssql\" ? \"NO ACTION\" : \"CASCADE\"\n    }), new ForeignKeyMetadata({\n      entityMetadata: entityMetadata,\n      referencedEntityMetadata: parentClosureEntityMetadata,\n      columns: [entityMetadata.ownColumns[1]],\n      referencedColumns: parentClosureEntityMetadata.primaryColumns,\n      onDelete: this.connection.driver.options.type === \"mssql\" ? \"NO ACTION\" : \"CASCADE\"\n    })];\n    return entityMetadata;\n  }\n}","map":{"version":3,"names":["EntityMetadata","ColumnMetadata","ForeignKeyMetadata","IndexMetadata","ClosureJunctionEntityMetadataBuilder","constructor","connection","build","parentClosureEntityMetadata","entityMetadata","args","target","name","treeOptions","closureTableName","tableNameWithoutPrefix","type","primaryColumns","forEach","primaryColumn","ownColumns","push","closureType","referencedColumn","mode","propertyName","ancestorColumnName","options","primary","length","descendantColumnName","ownIndices","columns","synchronize","treeLevelColumn","driver","mappedDataTypes","treeLevel","foreignKeys","referencedEntityMetadata","referencedColumns","onDelete"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\metadata-builder\\ClosureJunctionEntityMetadataBuilder.ts"],"sourcesContent":["import { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { ForeignKeyMetadata } from \"../metadata/ForeignKeyMetadata\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { IndexMetadata } from \"../metadata/IndexMetadata\"\n\n/**\n * Creates EntityMetadata for junction tables of the closure entities.\n * Closure junction tables are tables generated by closure entities.\n */\nexport class ClosureJunctionEntityMetadataBuilder {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private connection: DataSource) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Builds EntityMetadata for the closure junction of the given closure entity.\n     */\n    build(parentClosureEntityMetadata: EntityMetadata) {\n        // create entity metadata itself\n        const entityMetadata = new EntityMetadata({\n            parentClosureEntityMetadata: parentClosureEntityMetadata,\n            connection: this.connection,\n            args: {\n                target: \"\",\n                name:\n                    parentClosureEntityMetadata.treeOptions &&\n                    parentClosureEntityMetadata.treeOptions.closureTableName\n                        ? parentClosureEntityMetadata.treeOptions\n                              .closureTableName\n                        : parentClosureEntityMetadata.tableNameWithoutPrefix,\n                type: \"closure-junction\",\n            },\n        })\n        entityMetadata.build()\n\n        // create ancestor and descendant columns for new closure junction table\n        parentClosureEntityMetadata.primaryColumns.forEach((primaryColumn) => {\n            entityMetadata.ownColumns.push(\n                new ColumnMetadata({\n                    connection: this.connection,\n                    entityMetadata: entityMetadata,\n                    closureType: \"ancestor\",\n                    referencedColumn: primaryColumn,\n                    args: {\n                        target: \"\",\n                        mode: \"virtual\",\n                        propertyName:\n                            parentClosureEntityMetadata.treeOptions &&\n                            parentClosureEntityMetadata.treeOptions\n                                .ancestorColumnName\n                                ? parentClosureEntityMetadata.treeOptions.ancestorColumnName(\n                                      primaryColumn,\n                                  )\n                                : primaryColumn.propertyName + \"_ancestor\",\n                        options: {\n                            primary: true,\n                            length: primaryColumn.length,\n                            type: primaryColumn.type,\n                        },\n                    },\n                }),\n            )\n            entityMetadata.ownColumns.push(\n                new ColumnMetadata({\n                    connection: this.connection,\n                    entityMetadata: entityMetadata,\n                    closureType: \"descendant\",\n                    referencedColumn: primaryColumn,\n                    args: {\n                        target: \"\",\n                        mode: \"virtual\",\n                        propertyName:\n                            parentClosureEntityMetadata.treeOptions &&\n                            parentClosureEntityMetadata.treeOptions\n                                .descendantColumnName\n                                ? parentClosureEntityMetadata.treeOptions.descendantColumnName(\n                                      primaryColumn,\n                                  )\n                                : primaryColumn.propertyName + \"_descendant\",\n                        options: {\n                            primary: true,\n                            length: primaryColumn.length,\n                            type: primaryColumn.type,\n                        },\n                    },\n                }),\n            )\n        })\n\n        entityMetadata.ownIndices = [\n            new IndexMetadata({\n                entityMetadata: entityMetadata,\n                columns: [entityMetadata.ownColumns[0]],\n                args: {\n                    target: entityMetadata.target,\n                    synchronize: true,\n                },\n            }),\n            new IndexMetadata({\n                entityMetadata: entityMetadata,\n                columns: [entityMetadata.ownColumns[1]],\n                args: {\n                    target: entityMetadata.target,\n                    synchronize: true,\n                },\n            }),\n        ]\n\n        // if tree level column was defined by a closure entity then add it to the junction columns as well\n        if (parentClosureEntityMetadata.treeLevelColumn) {\n            entityMetadata.ownColumns.push(\n                new ColumnMetadata({\n                    connection: this.connection,\n                    entityMetadata: entityMetadata,\n                    args: {\n                        target: \"\",\n                        mode: \"virtual\",\n                        propertyName: \"level\",\n                        options: {\n                            type: this.connection.driver.mappedDataTypes\n                                .treeLevel,\n                        },\n                    },\n                }),\n            )\n        }\n\n        // create junction table foreign keys\n        // Note: CASCADE is not applied to mssql because it does not support multi cascade paths\n        entityMetadata.foreignKeys = [\n            new ForeignKeyMetadata({\n                entityMetadata: entityMetadata,\n                referencedEntityMetadata: parentClosureEntityMetadata,\n                columns: [entityMetadata.ownColumns[0]],\n                referencedColumns: parentClosureEntityMetadata.primaryColumns,\n                onDelete:\n                    this.connection.driver.options.type === \"mssql\"\n                        ? \"NO ACTION\"\n                        : \"CASCADE\",\n            }),\n            new ForeignKeyMetadata({\n                entityMetadata: entityMetadata,\n                referencedEntityMetadata: parentClosureEntityMetadata,\n                columns: [entityMetadata.ownColumns[1]],\n                referencedColumns: parentClosureEntityMetadata.primaryColumns,\n                onDelete:\n                    this.connection.driver.options.type === \"mssql\"\n                        ? \"NO ACTION\"\n                        : \"CASCADE\",\n            }),\n        ]\n\n        return entityMetadata\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}