{"ast":null,"code":"import { QueryFailedError } from \"../../error/QueryFailedError\";\nimport { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\";\nimport { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\";\nimport { BaseQueryRunner } from \"../../query-runner/BaseQueryRunner\";\nimport { Table } from \"../../schema-builder/table/Table\";\nimport { TableCheck } from \"../../schema-builder/table/TableCheck\";\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\";\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\";\nimport { TableIndex } from \"../../schema-builder/table/TableIndex\";\nimport { TableUnique } from \"../../schema-builder/table/TableUnique\";\nimport { View } from \"../../schema-builder/view/View\";\nimport { Broadcaster } from \"../../subscriber/Broadcaster\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { Query } from \"../Query\";\nimport { TypeORMError } from \"../../error\";\nimport { QueryResult } from \"../../query-runner/QueryResult\";\nimport { MetadataTableType } from \"../types/MetadataTableType\";\nimport { BroadcasterResult } from \"../../subscriber/BroadcasterResult\";\n/**\n * Runs queries on a single postgres database connection.\n */\nexport class SpannerQueryRunner extends BaseQueryRunner {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(driver, mode) {\n    super();\n    this.driver = driver;\n    this.connection = driver.connection;\n    this.mode = mode;\n    this.broadcaster = new Broadcaster(this);\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates/uses database connection from the connection pool to perform further operations.\n   * Returns obtained database connection.\n   */\n  async connect() {\n    if (this.session) {\n      return Promise.resolve(this.session);\n    }\n    const [session] = await this.driver.instanceDatabase.createSession({});\n    this.session = session;\n    this.sessionTransaction = await session.transaction();\n    return this.session;\n  }\n  /**\n   * Releases used database connection.\n   * You cannot use query runner methods once its released.\n   */\n  async release() {\n    this.isReleased = true;\n    if (this.session) {\n      await this.session.delete();\n    }\n    this.session = undefined;\n    return Promise.resolve();\n  }\n  /**\n   * Starts transaction.\n   */\n  async startTransaction(isolationLevel) {\n    this.isTransactionActive = true;\n    try {\n      await this.broadcaster.broadcast(\"BeforeTransactionStart\");\n    } catch (err) {\n      this.isTransactionActive = false;\n      throw err;\n    }\n    await this.connect();\n    await this.sessionTransaction.begin();\n    this.connection.logger.logQuery(\"START TRANSACTION\");\n    await this.broadcaster.broadcast(\"AfterTransactionStart\");\n  }\n  /**\n   * Commits transaction.\n   * Error will be thrown if transaction was not started.\n   */\n  async commitTransaction() {\n    if (!this.isTransactionActive || !this.sessionTransaction) throw new TransactionNotStartedError();\n    await this.broadcaster.broadcast(\"BeforeTransactionCommit\");\n    await this.sessionTransaction.commit();\n    this.connection.logger.logQuery(\"COMMIT\");\n    this.isTransactionActive = false;\n    await this.broadcaster.broadcast(\"AfterTransactionCommit\");\n  }\n  /**\n   * Rollbacks transaction.\n   * Error will be thrown if transaction was not started.\n   */\n  async rollbackTransaction() {\n    if (!this.isTransactionActive || !this.sessionTransaction) throw new TransactionNotStartedError();\n    await this.broadcaster.broadcast(\"BeforeTransactionRollback\");\n    await this.sessionTransaction.rollback();\n    this.connection.logger.logQuery(\"ROLLBACK\");\n    this.isTransactionActive = false;\n    await this.broadcaster.broadcast(\"AfterTransactionRollback\");\n  }\n  /**\n   * Executes a given SQL query.\n   */\n  async query(query, parameters, useStructuredResult = false) {\n    if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();\n    const broadcasterResult = new BroadcasterResult();\n    try {\n      const queryStartTime = +new Date();\n      await this.connect();\n      let rawResult = undefined;\n      const isSelect = query.startsWith(\"SELECT\");\n      const executor = isSelect && !this.isTransactionActive ? this.driver.instanceDatabase : this.sessionTransaction;\n      if (!this.isTransactionActive && !isSelect) {\n        await this.sessionTransaction.begin();\n      }\n      try {\n        this.driver.connection.logger.logQuery(query, parameters, this);\n        this.broadcaster.broadcastBeforeQueryEvent(broadcasterResult, query, parameters);\n        rawResult = await executor.run({\n          sql: query,\n          params: parameters ? parameters.reduce((params, value, index) => {\n            params[\"param\" + index] = value;\n            return params;\n          }, {}) : undefined,\n          json: true\n        });\n        if (!this.isTransactionActive && !isSelect) {\n          await this.sessionTransaction.commit();\n        }\n      } catch (error) {\n        try {\n          // we throw original error even if rollback thrown an error\n          if (!this.isTransactionActive && !isSelect) await this.sessionTransaction.rollback();\n        } catch (rollbackError) {}\n        throw error;\n      }\n      // log slow queries if maxQueryExecution time is set\n      const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;\n      const queryEndTime = +new Date();\n      const queryExecutionTime = queryEndTime - queryStartTime;\n      this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, rawResult, undefined);\n      if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);\n      const result = new QueryResult();\n      result.raw = rawResult;\n      result.records = rawResult ? rawResult[0] : [];\n      if (rawResult && rawResult[1] && rawResult[1].rowCountExact) {\n        result.affected = parseInt(rawResult[1].rowCountExact);\n      }\n      if (!useStructuredResult) {\n        return result.records;\n      }\n      return result;\n    } catch (err) {\n      this.driver.connection.logger.logQueryError(err, query, parameters, this);\n      this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, undefined, undefined, err);\n      throw new QueryFailedError(query, parameters, err);\n    } finally {\n      await broadcasterResult.wait();\n    }\n  }\n  /**\n   * Update database schema.\n   * Used for creating/altering/dropping tables, columns, indexes, etc.\n   *\n   * DDL changing queries should be executed by `updateSchema()` method.\n   */\n  async updateDDL(query, parameters) {\n    if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();\n    this.driver.connection.logger.logQuery(query, parameters, this);\n    try {\n      const queryStartTime = +new Date();\n      const [operation] = await this.driver.instanceDatabase.updateSchema(query);\n      await operation.promise();\n      // log slow queries if maxQueryExecution time is set\n      const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;\n      const queryEndTime = +new Date();\n      const queryExecutionTime = queryEndTime - queryStartTime;\n      if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);\n    } catch (err) {\n      this.driver.connection.logger.logQueryError(err, query, parameters, this);\n      throw new QueryFailedError(query, parameters, err);\n    }\n  }\n  /**\n   * Returns raw data stream.\n   */\n  async stream(query, parameters, onEnd, onError) {\n    if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();\n    try {\n      this.driver.connection.logger.logQuery(query, parameters, this);\n      const request = {\n        sql: query,\n        params: parameters ? parameters.reduce((params, value, index) => {\n          params[\"param\" + index] = value;\n          return params;\n        }, {}) : undefined,\n        json: true\n      };\n      const stream = this.driver.instanceDatabase.runStream(request);\n      if (onEnd) {\n        stream.on(\"end\", onEnd);\n      }\n      if (onError) {\n        stream.on(\"error\", onError);\n      }\n      return stream;\n    } catch (err) {\n      this.driver.connection.logger.logQueryError(err, query, parameters, this);\n      throw new QueryFailedError(query, parameters, err);\n    }\n  }\n  /**\n   * Returns all available database names including system databases.\n   */\n  async getDatabases() {\n    return Promise.resolve([]);\n  }\n  /**\n   * Returns all available schema names including system schemas.\n   * If database parameter specified, returns schemas of that database.\n   */\n  async getSchemas(database) {\n    return Promise.resolve([]);\n  }\n  /**\n   * Checks if database with the given name exist.\n   */\n  async hasDatabase(database) {\n    throw new TypeORMError(`Check database queries are not supported by Spanner driver.`);\n  }\n  /**\n   * Loads currently using database\n   */\n  async getCurrentDatabase() {\n    throw new TypeORMError(`Check database queries are not supported by Spanner driver.`);\n  }\n  /**\n   * Checks if schema with the given name exist.\n   */\n  async hasSchema(schema) {\n    const result = await this.query(`SELECT * FROM \"information_schema\".\"schemata\" WHERE \"schema_name\" = '${schema}'`);\n    return result.length ? true : false;\n  }\n  /**\n   * Loads currently using database schema\n   */\n  async getCurrentSchema() {\n    throw new TypeORMError(`Check schema queries are not supported by Spanner driver.`);\n  }\n  /**\n   * Checks if table with the given name exist in the database.\n   */\n  async hasTable(tableOrName) {\n    const tableName = tableOrName instanceof Table ? tableOrName.name : tableOrName;\n    const sql = `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` ` + `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_TYPE\\` = 'BASE TABLE' ` + `AND \\`TABLE_NAME\\` = '${tableName}'`;\n    const result = await this.query(sql);\n    return result.length ? true : false;\n  }\n  /**\n   * Checks if column with the given name exist in the given table.\n   */\n  async hasColumn(tableOrName, columnName) {\n    const tableName = tableOrName instanceof Table ? tableOrName.name : tableOrName;\n    const sql = `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`COLUMNS\\` ` + `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' ` + `AND \\`TABLE_NAME\\` = '${tableName}' AND \\`COLUMN_NAME\\` = '${columnName}'`;\n    const result = await this.query(sql);\n    return result.length ? true : false;\n  }\n  /**\n   * Creates a new database.\n   * Note: Spanner does not support database creation inside a transaction block.\n   */\n  async createDatabase(database, ifNotExist) {\n    if (ifNotExist) {\n      const databaseAlreadyExists = await this.hasDatabase(database);\n      if (databaseAlreadyExists) return Promise.resolve();\n    }\n    const up = `CREATE DATABASE \"${database}\"`;\n    const down = `DROP DATABASE \"${database}\"`;\n    await this.executeQueries(new Query(up), new Query(down));\n  }\n  /**\n   * Drops database.\n   * Note: Spanner does not support database dropping inside a transaction block.\n   */\n  async dropDatabase(database, ifExist) {\n    const up = ifExist ? `DROP DATABASE IF EXISTS \"${database}\"` : `DROP DATABASE \"${database}\"`;\n    const down = `CREATE DATABASE \"${database}\"`;\n    await this.executeQueries(new Query(up), new Query(down));\n  }\n  /**\n   * Creates a new table schema.\n   */\n  async createSchema(schemaPath, ifNotExist) {\n    return Promise.resolve();\n  }\n  /**\n   * Drops table schema.\n   */\n  async dropSchema(schemaPath, ifExist, isCascade) {\n    return Promise.resolve();\n  }\n  /**\n   * Creates a new table.\n   */\n  async createTable(table, ifNotExist = false, createForeignKeys = true, createIndices = true) {\n    if (ifNotExist) {\n      const isTableExist = await this.hasTable(table);\n      if (isTableExist) return Promise.resolve();\n    }\n    const upQueries = [];\n    const downQueries = [];\n    upQueries.push(this.createTableSql(table, createForeignKeys));\n    downQueries.push(this.dropTableSql(table));\n    // if createForeignKeys is true, we must drop created foreign keys in down query.\n    // createTable does not need separate method to create foreign keys, because it create fk's in the same query with table creation.\n    if (createForeignKeys) table.foreignKeys.forEach(foreignKey => downQueries.push(this.dropForeignKeySql(table, foreignKey)));\n    if (createIndices) {\n      table.indices.forEach(index => {\n        // new index may be passed without name. In this case we generate index name manually.\n        if (!index.name) index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);\n        upQueries.push(this.createIndexSql(table, index));\n        downQueries.push(this.dropIndexSql(table, index));\n      });\n    }\n    // if table has column with generated type, we must add the expression to the metadata table\n    const generatedColumns = table.columns.filter(column => column.generatedType && column.asExpression);\n    for (const column of generatedColumns) {\n      const insertQuery = this.insertTypeormMetadataSql({\n        table: table.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name,\n        value: column.asExpression\n      });\n      const deleteQuery = this.deleteTypeormMetadataSql({\n        table: table.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name\n      });\n      upQueries.push(insertQuery);\n      downQueries.push(deleteQuery);\n    }\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Drops the table.\n   */\n  async dropTable(target, ifExist, dropForeignKeys = true, dropIndices = true) {\n    // It needs because if table does not exist and dropForeignKeys or dropIndices is true, we don't need\n    // to perform drop queries for foreign keys and indices.\n    if (ifExist) {\n      const isTableExist = await this.hasTable(target);\n      if (!isTableExist) return Promise.resolve();\n    }\n    // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.\n    const createForeignKeys = dropForeignKeys;\n    const tablePath = this.getTablePath(target);\n    const table = await this.getCachedTable(tablePath);\n    const upQueries = [];\n    const downQueries = [];\n    if (dropIndices) {\n      table.indices.forEach(index => {\n        upQueries.push(this.dropIndexSql(table, index));\n        downQueries.push(this.createIndexSql(table, index));\n      });\n    }\n    if (dropForeignKeys) table.foreignKeys.forEach(foreignKey => upQueries.push(this.dropForeignKeySql(table, foreignKey)));\n    upQueries.push(this.dropTableSql(table));\n    downQueries.push(this.createTableSql(table, createForeignKeys));\n    // if table had columns with generated type, we must remove the expression from the metadata table\n    const generatedColumns = table.columns.filter(column => column.generatedType && column.asExpression);\n    for (const column of generatedColumns) {\n      const deleteQuery = this.deleteTypeormMetadataSql({\n        table: table.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name\n      });\n      const insertQuery = this.insertTypeormMetadataSql({\n        table: table.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name,\n        value: column.asExpression\n      });\n      upQueries.push(deleteQuery);\n      downQueries.push(insertQuery);\n    }\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Creates a new view.\n   */\n  async createView(view) {\n    const upQueries = [];\n    const downQueries = [];\n    upQueries.push(this.createViewSql(view));\n    upQueries.push(await this.insertViewDefinitionSql(view));\n    downQueries.push(this.dropViewSql(view));\n    downQueries.push(await this.deleteViewDefinitionSql(view));\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Drops the view.\n   */\n  async dropView(target) {\n    const viewName = target instanceof View ? target.name : target;\n    const view = await this.getCachedView(viewName);\n    const upQueries = [];\n    const downQueries = [];\n    upQueries.push(await this.deleteViewDefinitionSql(view));\n    upQueries.push(this.dropViewSql(view));\n    downQueries.push(await this.insertViewDefinitionSql(view));\n    downQueries.push(this.createViewSql(view));\n    await this.executeQueries(upQueries, downQueries);\n  }\n  /**\n   * Renames the given table.\n   */\n  async renameTable(oldTableOrName, newTableName) {\n    throw new TypeORMError(`Rename table queries are not supported by Spanner driver.`);\n  }\n  /**\n   * Creates a new column from the column in the table.\n   */\n  async addColumn(tableOrName, column) {\n    const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n    const clonedTable = table.clone();\n    const upQueries = [];\n    const downQueries = [];\n    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(column)}`));\n    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN ${this.driver.escape(column.name)}`));\n    // create column index\n    const columnIndex = clonedTable.indices.find(index => index.columnNames.length === 1 && index.columnNames[0] === column.name);\n    if (columnIndex) {\n      upQueries.push(this.createIndexSql(table, columnIndex));\n      downQueries.push(this.dropIndexSql(table, columnIndex));\n    } else if (column.isUnique) {\n      const uniqueIndex = new TableIndex({\n        name: this.connection.namingStrategy.indexName(table, [column.name]),\n        columnNames: [column.name],\n        isUnique: true\n      });\n      clonedTable.indices.push(uniqueIndex);\n      clonedTable.uniques.push(new TableUnique({\n        name: uniqueIndex.name,\n        columnNames: uniqueIndex.columnNames\n      }));\n      upQueries.push(this.createIndexSql(table, uniqueIndex));\n      downQueries.push(this.dropIndexSql(table, uniqueIndex));\n    }\n    if (column.generatedType && column.asExpression) {\n      const insertQuery = this.insertTypeormMetadataSql({\n        table: table.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name,\n        value: column.asExpression\n      });\n      const deleteQuery = this.deleteTypeormMetadataSql({\n        table: table.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name\n      });\n      upQueries.push(insertQuery);\n      downQueries.push(deleteQuery);\n    }\n    await this.executeQueries(upQueries, downQueries);\n    clonedTable.addColumn(column);\n    this.replaceCachedTable(table, clonedTable);\n  }\n  /**\n   * Creates a new columns from the column in the table.\n   */\n  async addColumns(tableOrName, columns) {\n    for (const column of columns) {\n      await this.addColumn(tableOrName, column);\n    }\n  }\n  /**\n   * Renames column in the given table.\n   */\n  async renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {\n    const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n    const oldColumn = oldTableColumnOrName instanceof TableColumn ? oldTableColumnOrName : table.columns.find(c => c.name === oldTableColumnOrName);\n    if (!oldColumn) throw new TypeORMError(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n    let newColumn;\n    if (newTableColumnOrName instanceof TableColumn) {\n      newColumn = newTableColumnOrName;\n    } else {\n      newColumn = oldColumn.clone();\n      newColumn.name = newTableColumnOrName;\n    }\n    return this.changeColumn(table, oldColumn, newColumn);\n  }\n  /**\n   * Changes a column in the table.\n   */\n  async changeColumn(tableOrName, oldTableColumnOrName, newColumn) {\n    const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n    let clonedTable = table.clone();\n    const upQueries = [];\n    const downQueries = [];\n    const oldColumn = oldTableColumnOrName instanceof TableColumn ? oldTableColumnOrName : table.columns.find(column => column.name === oldTableColumnOrName);\n    if (!oldColumn) throw new TypeORMError(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n    if (oldColumn.name !== newColumn.name || oldColumn.type !== newColumn.type || oldColumn.length !== newColumn.length || oldColumn.isArray !== newColumn.isArray || oldColumn.generatedType !== newColumn.generatedType || oldColumn.asExpression !== newColumn.asExpression) {\n      // To avoid data conversion, we just recreate column\n      await this.dropColumn(table, oldColumn);\n      await this.addColumn(table, newColumn);\n      // update cloned table\n      clonedTable = table.clone();\n    } else {\n      if (newColumn.precision !== oldColumn.precision || newColumn.scale !== oldColumn.scale) {\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${this.driver.createFullType(newColumn)}`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${this.driver.createFullType(oldColumn)}`));\n      }\n      if (oldColumn.isNullable !== newColumn.isNullable) {\n        if (newColumn.isNullable) {\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" DROP NOT NULL`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" SET NOT NULL`));\n        } else {\n          upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" SET NOT NULL`));\n          downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" DROP NOT NULL`));\n        }\n      }\n      if (newColumn.isUnique !== oldColumn.isUnique) {\n        if (newColumn.isUnique === true) {\n          const uniqueIndex = new TableIndex({\n            name: this.connection.namingStrategy.indexName(table, [newColumn.name]),\n            columnNames: [newColumn.name],\n            isUnique: true\n          });\n          clonedTable.indices.push(uniqueIndex);\n          clonedTable.uniques.push(new TableUnique({\n            name: uniqueIndex.name,\n            columnNames: uniqueIndex.columnNames\n          }));\n          upQueries.push(this.createIndexSql(table, uniqueIndex));\n          downQueries.push(this.dropIndexSql(table, uniqueIndex));\n        } else {\n          const uniqueIndex = clonedTable.indices.find(index => {\n            return index.columnNames.length === 1 && index.isUnique === true && !!index.columnNames.find(columnName => columnName === newColumn.name);\n          });\n          clonedTable.indices.splice(clonedTable.indices.indexOf(uniqueIndex), 1);\n          const tableUnique = clonedTable.uniques.find(unique => unique.name === uniqueIndex.name);\n          clonedTable.uniques.splice(clonedTable.uniques.indexOf(tableUnique), 1);\n          upQueries.push(this.dropIndexSql(table, uniqueIndex));\n          downQueries.push(this.createIndexSql(table, uniqueIndex));\n        }\n      }\n    }\n    await this.executeQueries(upQueries, downQueries);\n    this.replaceCachedTable(table, clonedTable);\n  }\n  /**\n   * Changes a column in the table.\n   */\n  async changeColumns(tableOrName, changedColumns) {\n    for (const {\n      oldColumn,\n      newColumn\n    } of changedColumns) {\n      await this.changeColumn(tableOrName, oldColumn, newColumn);\n    }\n  }\n  /**\n   * Drops column in the table.\n   */\n  async dropColumn(tableOrName, columnOrName) {\n    const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n    const column = columnOrName instanceof TableColumn ? columnOrName : table.findColumnByName(columnOrName);\n    if (!column) throw new TypeORMError(`Column \"${columnOrName}\" was not found in table \"${table.name}\"`);\n    const clonedTable = table.clone();\n    const upQueries = [];\n    const downQueries = [];\n    // drop column index\n    const columnIndex = clonedTable.indices.find(index => index.columnNames.length === 1 && index.columnNames[0] === column.name);\n    if (columnIndex) {\n      clonedTable.indices.splice(clonedTable.indices.indexOf(columnIndex), 1);\n      upQueries.push(this.dropIndexSql(table, columnIndex));\n      downQueries.push(this.createIndexSql(table, columnIndex));\n    }\n    // drop column check\n    const columnCheck = clonedTable.checks.find(check => !!check.columnNames && check.columnNames.length === 1 && check.columnNames[0] === column.name);\n    if (columnCheck) {\n      clonedTable.checks.splice(clonedTable.checks.indexOf(columnCheck), 1);\n      upQueries.push(this.dropCheckConstraintSql(table, columnCheck));\n      downQueries.push(this.createCheckConstraintSql(table, columnCheck));\n    }\n    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN ${this.driver.escape(column.name)}`));\n    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(column)}`));\n    if (column.generatedType && column.asExpression) {\n      const deleteQuery = this.deleteTypeormMetadataSql({\n        table: table.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name\n      });\n      const insertQuery = this.insertTypeormMetadataSql({\n        table: table.name,\n        type: MetadataTableType.GENERATED_COLUMN,\n        name: column.name,\n        value: column.asExpression\n      });\n      upQueries.push(deleteQuery);\n      downQueries.push(insertQuery);\n    }\n    await this.executeQueries(upQueries, downQueries);\n    clonedTable.removeColumn(column);\n    this.replaceCachedTable(table, clonedTable);\n  }\n  /**\n   * Drops the columns in the table.\n   */\n  async dropColumns(tableOrName, columns) {\n    for (const column of columns) {\n      await this.dropColumn(tableOrName, column);\n    }\n  }\n  /**\n   * Creates a new primary key.\n   *\n   * Not supported in Spanner.\n   * @see https://cloud.google.com/spanner/docs/schema-and-data-model#notes_about_key_columns\n   */\n  async createPrimaryKey(tableOrName, columnNames) {\n    throw new Error(\"The keys of a table can't change; you can't add a key column to an existing table or remove a key column from an existing table.\");\n  }\n  /**\n   * Updates composite primary keys.\n   */\n  async updatePrimaryKeys(tableOrName, columns) {\n    throw new Error(\"The keys of a table can't change; you can't add a key column to an existing table or remove a key column from an existing table.\");\n  }\n  /**\n   * Creates a new primary key.\n   *\n   * Not supported in Spanner.\n   * @see https://cloud.google.com/spanner/docs/schema-and-data-model#notes_about_key_columns\n   */\n  async dropPrimaryKey(tableOrName) {\n    throw new Error(\"The keys of a table can't change; you can't add a key column to an existing table or remove a key column from an existing table.\");\n  }\n  /**\n   * Creates new unique constraint.\n   */\n  async createUniqueConstraint(tableOrName, uniqueConstraint) {\n    throw new TypeORMError(`Spanner does not support unique constraints. Use unique index instead.`);\n  }\n  /**\n   * Creates new unique constraints.\n   */\n  async createUniqueConstraints(tableOrName, uniqueConstraints) {\n    throw new TypeORMError(`Spanner does not support unique constraints. Use unique index instead.`);\n  }\n  /**\n   * Drops unique constraint.\n   */\n  async dropUniqueConstraint(tableOrName, uniqueOrName) {\n    throw new TypeORMError(`Spanner does not support unique constraints. Use unique index instead.`);\n  }\n  /**\n   * Drops unique constraints.\n   */\n  async dropUniqueConstraints(tableOrName, uniqueConstraints) {\n    throw new TypeORMError(`Spanner does not support unique constraints. Use unique index instead.`);\n  }\n  /**\n   * Creates new check constraint.\n   */\n  async createCheckConstraint(tableOrName, checkConstraint) {\n    const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n    // new check constraint may be passed without name. In this case we generate unique name manually.\n    if (!checkConstraint.name) checkConstraint.name = this.connection.namingStrategy.checkConstraintName(table, checkConstraint.expression);\n    const up = this.createCheckConstraintSql(table, checkConstraint);\n    const down = this.dropCheckConstraintSql(table, checkConstraint);\n    await this.executeQueries(up, down);\n    table.addCheckConstraint(checkConstraint);\n  }\n  /**\n   * Creates new check constraints.\n   */\n  async createCheckConstraints(tableOrName, checkConstraints) {\n    const promises = checkConstraints.map(checkConstraint => this.createCheckConstraint(tableOrName, checkConstraint));\n    await Promise.all(promises);\n  }\n  /**\n   * Drops check constraint.\n   */\n  async dropCheckConstraint(tableOrName, checkOrName) {\n    const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n    const checkConstraint = checkOrName instanceof TableCheck ? checkOrName : table.checks.find(c => c.name === checkOrName);\n    if (!checkConstraint) throw new TypeORMError(`Supplied check constraint was not found in table ${table.name}`);\n    const up = this.dropCheckConstraintSql(table, checkConstraint);\n    const down = this.createCheckConstraintSql(table, checkConstraint);\n    await this.executeQueries(up, down);\n    table.removeCheckConstraint(checkConstraint);\n  }\n  /**\n   * Drops check constraints.\n   */\n  async dropCheckConstraints(tableOrName, checkConstraints) {\n    const promises = checkConstraints.map(checkConstraint => this.dropCheckConstraint(tableOrName, checkConstraint));\n    await Promise.all(promises);\n  }\n  /**\n   * Creates new exclusion constraint.\n   */\n  async createExclusionConstraint(tableOrName, exclusionConstraint) {\n    throw new TypeORMError(`Spanner does not support exclusion constraints.`);\n  }\n  /**\n   * Creates new exclusion constraints.\n   */\n  async createExclusionConstraints(tableOrName, exclusionConstraints) {\n    throw new TypeORMError(`Spanner does not support exclusion constraints.`);\n  }\n  /**\n   * Drops exclusion constraint.\n   */\n  async dropExclusionConstraint(tableOrName, exclusionOrName) {\n    throw new TypeORMError(`Spanner does not support exclusion constraints.`);\n  }\n  /**\n   * Drops exclusion constraints.\n   */\n  async dropExclusionConstraints(tableOrName, exclusionConstraints) {\n    throw new TypeORMError(`Spanner does not support exclusion constraints.`);\n  }\n  /**\n   * Creates a new foreign key.\n   */\n  async createForeignKey(tableOrName, foreignKey) {\n    const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n    // new FK may be passed without name. In this case we generate FK name manually.\n    if (!foreignKey.name) foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n    const up = this.createForeignKeySql(table, foreignKey);\n    const down = this.dropForeignKeySql(table, foreignKey);\n    await this.executeQueries(up, down);\n    table.addForeignKey(foreignKey);\n  }\n  /**\n   * Creates a new foreign keys.\n   */\n  async createForeignKeys(tableOrName, foreignKeys) {\n    for (const foreignKey of foreignKeys) {\n      await this.createForeignKey(tableOrName, foreignKey);\n    }\n  }\n  /**\n   * Drops a foreign key from the table.\n   */\n  async dropForeignKey(tableOrName, foreignKeyOrName) {\n    const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n    const foreignKey = foreignKeyOrName instanceof TableForeignKey ? foreignKeyOrName : table.foreignKeys.find(fk => fk.name === foreignKeyOrName);\n    if (!foreignKey) throw new TypeORMError(`Supplied foreign key was not found in table ${table.name}`);\n    const up = this.dropForeignKeySql(table, foreignKey);\n    const down = this.createForeignKeySql(table, foreignKey);\n    await this.executeQueries(up, down);\n    table.removeForeignKey(foreignKey);\n  }\n  /**\n   * Drops a foreign keys from the table.\n   */\n  async dropForeignKeys(tableOrName, foreignKeys) {\n    for (const foreignKey of foreignKeys) {\n      await this.dropForeignKey(tableOrName, foreignKey);\n    }\n  }\n  /**\n   * Creates a new index.\n   */\n  async createIndex(tableOrName, index) {\n    const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n    // new index may be passed without name. In this case we generate index name manually.\n    if (!index.name) index.name = this.generateIndexName(table, index);\n    const up = this.createIndexSql(table, index);\n    const down = this.dropIndexSql(table, index);\n    await this.executeQueries(up, down);\n    table.addIndex(index);\n  }\n  /**\n   * Creates a new indices\n   */\n  async createIndices(tableOrName, indices) {\n    for (const index of indices) {\n      await this.createIndex(tableOrName, index);\n    }\n  }\n  /**\n   * Drops an index from the table.\n   */\n  async dropIndex(tableOrName, indexOrName) {\n    const table = tableOrName instanceof Table ? tableOrName : await this.getCachedTable(tableOrName);\n    const index = indexOrName instanceof TableIndex ? indexOrName : table.indices.find(i => i.name === indexOrName);\n    if (!index) throw new TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`);\n    // new index may be passed without name. In this case we generate index name manually.\n    if (!index.name) index.name = this.generateIndexName(table, index);\n    const up = this.dropIndexSql(table, index);\n    const down = this.createIndexSql(table, index);\n    await this.executeQueries(up, down);\n    table.removeIndex(index);\n  }\n  /**\n   * Drops an indices from the table.\n   */\n  async dropIndices(tableOrName, indices) {\n    for (const index of indices) {\n      await this.dropIndex(tableOrName, index);\n    }\n  }\n  /**\n   * Clears all table contents.\n   * Spanner does not support TRUNCATE TABLE statement, so we use DELETE FROM.\n   */\n  async clearTable(tableName) {\n    await this.query(`DELETE FROM ${this.escapePath(tableName)} WHERE true`);\n  }\n  /**\n   * Removes all tables from the currently connected database.\n   */\n  async clearDatabase() {\n    // drop index queries\n    const selectIndexDropsQuery = `SELECT concat('DROP INDEX \\`', INDEX_NAME, '\\`') AS \\`query\\` ` + `FROM \\`INFORMATION_SCHEMA\\`.\\`INDEXES\\` ` + `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`INDEX_TYPE\\` = 'INDEX' AND \\`SPANNER_IS_MANAGED\\` = false`;\n    const dropIndexQueries = await this.query(selectIndexDropsQuery);\n    // drop foreign key queries\n    const selectFKDropsQuery = `SELECT concat('ALTER TABLE \\`', TABLE_NAME, '\\`', ' DROP CONSTRAINT \\`', CONSTRAINT_NAME, '\\`') AS \\`query\\` ` + `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLE_CONSTRAINTS\\` ` + `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`CONSTRAINT_TYPE\\` = 'FOREIGN KEY'`;\n    const dropFKQueries = await this.query(selectFKDropsQuery);\n    // drop view queries\n    // const selectViewDropsQuery = `SELECT concat('DROP VIEW \\`', TABLE_NAME, '\\`') AS \\`query\\` FROM \\`INFORMATION_SCHEMA\\`.\\`VIEWS\\``\n    // const dropViewQueries: ObjectLiteral[] = await this.query(\n    //     selectViewDropsQuery,\n    // )\n    // drop table queries\n    const dropTablesQuery = `SELECT concat('DROP TABLE \\`', TABLE_NAME, '\\`') AS \\`query\\` ` + `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` ` + `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_TYPE\\` = 'BASE TABLE'`;\n    const dropTableQueries = await this.query(dropTablesQuery);\n    if (!dropIndexQueries.length && !dropFKQueries.length &&\n    // !dropViewQueries.length &&\n    !dropTableQueries.length) return;\n    const isAnotherTransactionActive = this.isTransactionActive;\n    if (!isAnotherTransactionActive) await this.startTransaction();\n    try {\n      for (let query of dropIndexQueries) {\n        await this.updateDDL(query[\"query\"]);\n      }\n      for (let query of dropFKQueries) {\n        await this.updateDDL(query[\"query\"]);\n      }\n      // for (let query of dropViewQueries) {\n      //     await this.updateDDL(query[\"query\"])\n      // }\n      for (let query of dropTableQueries) {\n        await this.updateDDL(query[\"query\"]);\n      }\n      await this.commitTransaction();\n    } catch (error) {\n      try {\n        // we throw original error even if rollback thrown an error\n        if (!isAnotherTransactionActive) await this.rollbackTransaction();\n      } catch (rollbackError) {}\n      throw error;\n    }\n  }\n  // -------------------------------------------------------------------------\n  // Override Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Executes up sql queries.\n   */\n  async executeMemoryUpSql() {\n    for (const {\n      query,\n      parameters\n    } of this.sqlInMemory.upQueries) {\n      if (this.isDMLQuery(query)) {\n        await this.query(query, parameters);\n      } else {\n        await this.updateDDL(query, parameters);\n      }\n    }\n  }\n  /**\n   * Executes down sql queries.\n   */\n  async executeMemoryDownSql() {\n    for (const {\n      query,\n      parameters\n    } of this.sqlInMemory.downQueries.reverse()) {\n      if (this.isDMLQuery(query)) {\n        await this.query(query, parameters);\n      } else {\n        await this.updateDDL(query, parameters);\n      }\n    }\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  async loadViews(viewNames) {\n    // const hasTable = await this.hasTable(this.getTypeormMetadataTableName())\n    // if (!hasTable) {\n    //     return []\n    // }\n    //\n    // if (!viewNames) {\n    //     viewNames = []\n    // }\n    //\n    // const escapedViewNames = viewNames\n    //     .map((viewName) => `'${viewName}'`)\n    //     .join(\", \")\n    //\n    // const query =\n    //     `SELECT \\`T\\`.*, \\`V\\`.\\`VIEW_DEFINITION\\` FROM ${this.escapePath(\n    //         this.getTypeormMetadataTableName(),\n    //     )} \\`T\\` ` +\n    //     `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`VIEWS\\` \\`V\\` ON \\`V\\`.\\`TABLE_NAME\\` = \\`T\\`.\\`NAME\\` ` +\n    //     `WHERE \\`T\\`.\\`TYPE\\` = '${MetadataTableType.VIEW}' ${\n    //         viewNames.length\n    //             ? ` AND \\`T\\`.\\`NAME\\` IN (${escapedViewNames})`\n    //             : \"\"\n    //     }`\n    // const dbViews = await this.query(query)\n    // return dbViews.map((dbView: any) => {\n    //     const view = new View()\n    //     view.database = dbView[\"NAME\"]\n    //     view.name = this.driver.buildTableName(dbView[\"NAME\"])\n    //     view.expression = dbView[\"NAME\"]\n    //     return view\n    // })\n    return Promise.resolve([]);\n  }\n  /**\n   * Loads all tables (with given names) from the database and creates a Table from them.\n   */\n  async loadTables(tableNames) {\n    if (tableNames && tableNames.length === 0) {\n      return [];\n    }\n    const dbTables = [];\n    if (!tableNames || !tableNames.length) {\n      // Since we don't have any of this data we have to do a scan\n      const tablesSql = `SELECT \\`TABLE_NAME\\` ` + `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` ` + `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_TYPE\\` = 'BASE TABLE'`;\n      dbTables.push(...(await this.query(tablesSql)));\n    } else {\n      const tablesSql = `SELECT \\`TABLE_NAME\\` ` + `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` ` + `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_TYPE\\` = 'BASE TABLE' ` + `AND \\`TABLE_NAME\\` IN (${tableNames.map(tableName => `'${tableName}'`).join(\", \")})`;\n      dbTables.push(...(await this.query(tablesSql)));\n    }\n    // if tables were not found in the db, no need to proceed\n    if (!dbTables.length) return [];\n    const loadedTableNames = dbTables.map(dbTable => `'${dbTable.TABLE_NAME}'`).join(\", \");\n    const columnsSql = `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`COLUMNS\\` WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_NAME\\` IN (${loadedTableNames})`;\n    const primaryKeySql = `SELECT \\`KCU\\`.\\`TABLE_NAME\\`, \\`KCU\\`.\\`COLUMN_NAME\\` ` + `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLE_CONSTRAINTS\\` \\`TC\\` ` + `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`KEY_COLUMN_USAGE\\` \\`KCU\\` ON \\`KCU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` + `WHERE \\`TC\\`.\\`TABLE_CATALOG\\` = '' AND \\`TC\\`.\\`TABLE_SCHEMA\\` = '' AND \\`TC\\`.\\`CONSTRAINT_TYPE\\` = 'PRIMARY KEY' ` + `AND \\`TC\\`.\\`TABLE_NAME\\` IN (${loadedTableNames})`;\n    const indicesSql = `SELECT \\`I\\`.\\`TABLE_NAME\\`, \\`I\\`.\\`INDEX_NAME\\`, \\`I\\`.\\`IS_UNIQUE\\`, \\`I\\`.\\`IS_NULL_FILTERED\\`, \\`IC\\`.\\`COLUMN_NAME\\` ` + `FROM \\`INFORMATION_SCHEMA\\`.\\`INDEXES\\` \\`I\\` ` + `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`INDEX_COLUMNS\\` \\`IC\\` ON \\`IC\\`.\\`INDEX_NAME\\` = \\`I\\`.\\`INDEX_NAME\\` ` + `AND \\`IC\\`.\\`TABLE_NAME\\` = \\`I\\`.\\`TABLE_NAME\\` ` + `WHERE \\`I\\`.\\`TABLE_CATALOG\\` = '' AND \\`I\\`.\\`TABLE_SCHEMA\\` = '' AND \\`I\\`.\\`TABLE_NAME\\` IN (${loadedTableNames}) ` + `AND \\`I\\`.\\`INDEX_TYPE\\` = 'INDEX' AND \\`I\\`.\\`SPANNER_IS_MANAGED\\` = false`;\n    const checksSql = `SELECT \\`TC\\`.\\`TABLE_NAME\\`, \\`TC\\`.\\`CONSTRAINT_NAME\\`, \\`CC\\`.\\`CHECK_CLAUSE\\`, \\`CCU\\`.\\`COLUMN_NAME\\`` + `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLE_CONSTRAINTS\\` \\`TC\\` ` + `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`CONSTRAINT_COLUMN_USAGE\\` \\`CCU\\` ON \\`CCU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` + `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`CHECK_CONSTRAINTS\\` \\`CC\\` ON \\`CC\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` + `WHERE \\`TC\\`.\\`TABLE_CATALOG\\` = '' AND \\`TC\\`.\\`TABLE_SCHEMA\\` = '' AND \\`TC\\`.\\`CONSTRAINT_TYPE\\` = 'CHECK' ` + `AND \\`TC\\`.\\`TABLE_NAME\\` IN (${loadedTableNames}) AND \\`TC\\`.\\`CONSTRAINT_NAME\\` NOT LIKE 'CK_IS_NOT_NULL%'`;\n    const foreignKeysSql = `SELECT \\`TC\\`.\\`TABLE_NAME\\`, \\`TC\\`.\\`CONSTRAINT_NAME\\`, \\`KCU\\`.\\`COLUMN_NAME\\`, ` + `\\`CTU\\`.\\`TABLE_NAME\\` AS \\`REFERENCED_TABLE_NAME\\`, \\`CCU\\`.\\`COLUMN_NAME\\` AS \\`REFERENCED_COLUMN_NAME\\`, ` + `\\`RC\\`.\\`UPDATE_RULE\\`, \\`RC\\`.\\`DELETE_RULE\\` ` + `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLE_CONSTRAINTS\\` \\`TC\\` ` + `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`KEY_COLUMN_USAGE\\` \\`KCU\\` ON \\`KCU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` + `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`CONSTRAINT_TABLE_USAGE\\` \\`CTU\\` ON \\`CTU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` + `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`REFERENTIAL_CONSTRAINTS\\` \\`RC\\` ON \\`RC\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` + `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`CONSTRAINT_COLUMN_USAGE\\` \\`CCU\\` ON \\`CCU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` + `WHERE \\`TC\\`.\\`TABLE_CATALOG\\` = '' AND \\`TC\\`.\\`TABLE_SCHEMA\\` = '' AND \\`TC\\`.\\`CONSTRAINT_TYPE\\` = 'FOREIGN KEY' ` + `AND \\`TC\\`.\\`TABLE_NAME\\` IN (${loadedTableNames})`;\n    const [dbColumns, dbPrimaryKeys, dbIndices, dbChecks, dbForeignKeys] = await Promise.all([this.query(columnsSql), this.query(primaryKeySql), this.query(indicesSql), this.query(checksSql), this.query(foreignKeysSql)]);\n    // create tables for loaded tables\n    return Promise.all(dbTables.map(async dbTable => {\n      const table = new Table();\n      table.name = this.driver.buildTableName(dbTable[\"TABLE_NAME\"]);\n      // create columns from the loaded columns\n      table.columns = await Promise.all(dbColumns.filter(dbColumn => dbColumn[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"]).map(async dbColumn => {\n        const columnUniqueIndices = dbIndices.filter(dbIndex => {\n          return dbIndex[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"] && dbIndex[\"COLUMN_NAME\"] === dbColumn[\"COLUMN_NAME\"] && dbIndex[\"IS_UNIQUE\"] === true;\n        });\n        const tableMetadata = this.connection.entityMetadatas.find(metadata => this.getTablePath(table) === this.getTablePath(metadata));\n        const hasIgnoredIndex = columnUniqueIndices.length > 0 && tableMetadata && tableMetadata.indices.some(index => {\n          return columnUniqueIndices.some(uniqueIndex => {\n            return index.name === uniqueIndex[\"INDEX_NAME\"] && index.synchronize === false;\n          });\n        });\n        const isConstraintComposite = columnUniqueIndices.every(uniqueIndex => {\n          return dbIndices.some(dbIndex => dbIndex[\"INDEX_NAME\"] === uniqueIndex[\"INDEX_NAME\"] && dbIndex[\"COLUMN_NAME\"] !== dbColumn[\"COLUMN_NAME\"]);\n        });\n        const tableColumn = new TableColumn();\n        tableColumn.name = dbColumn[\"COLUMN_NAME\"];\n        let fullType = dbColumn[\"SPANNER_TYPE\"].toLowerCase();\n        if (fullType.indexOf(\"array\") !== -1) {\n          tableColumn.isArray = true;\n          fullType = fullType.substring(fullType.indexOf(\"<\") + 1, fullType.indexOf(\">\"));\n        }\n        if (fullType.indexOf(\"(\") !== -1) {\n          tableColumn.type = fullType.substring(0, fullType.indexOf(\"(\"));\n        } else {\n          tableColumn.type = fullType;\n        }\n        if (this.driver.withLengthColumnTypes.indexOf(tableColumn.type) !== -1) {\n          tableColumn.length = fullType.substring(fullType.indexOf(\"(\") + 1, fullType.indexOf(\")\"));\n        }\n        if (dbColumn[\"IS_GENERATED\"] === \"ALWAYS\") {\n          tableColumn.asExpression = dbColumn[\"GENERATION_EXPRESSION\"];\n          tableColumn.generatedType = \"STORED\";\n          // We cannot relay on information_schema.columns.generation_expression, because it is formatted different.\n          const asExpressionQuery = this.selectTypeormMetadataSql({\n            table: dbTable[\"TABLE_NAME\"],\n            type: MetadataTableType.GENERATED_COLUMN,\n            name: tableColumn.name\n          });\n          const results = await this.query(asExpressionQuery.query, asExpressionQuery.parameters);\n          if (results[0] && results[0].value) {\n            tableColumn.asExpression = results[0].value;\n          } else {\n            tableColumn.asExpression = \"\";\n          }\n        }\n        tableColumn.isUnique = columnUniqueIndices.length > 0 && !hasIgnoredIndex && !isConstraintComposite;\n        tableColumn.isNullable = dbColumn[\"IS_NULLABLE\"] === \"YES\";\n        tableColumn.isPrimary = dbPrimaryKeys.some(dbPrimaryKey => {\n          return dbPrimaryKey[\"TABLE_NAME\"] === dbColumn[\"TABLE_NAME\"] && dbPrimaryKey[\"COLUMN_NAME\"] === dbColumn[\"COLUMN_NAME\"];\n        });\n        return tableColumn;\n      }));\n      const tableForeignKeys = dbForeignKeys.filter(dbForeignKey => {\n        return dbForeignKey[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"];\n      });\n      table.foreignKeys = OrmUtils.uniq(tableForeignKeys, dbForeignKey => dbForeignKey[\"CONSTRAINT_NAME\"]).map(dbForeignKey => {\n        const foreignKeys = tableForeignKeys.filter(dbFk => dbFk[\"CONSTRAINT_NAME\"] === dbForeignKey[\"CONSTRAINT_NAME\"]);\n        return new TableForeignKey({\n          name: dbForeignKey[\"CONSTRAINT_NAME\"],\n          columnNames: OrmUtils.uniq(foreignKeys.map(dbFk => dbFk[\"COLUMN_NAME\"])),\n          referencedDatabase: dbForeignKey[\"REFERENCED_TABLE_SCHEMA\"],\n          referencedTableName: dbForeignKey[\"REFERENCED_TABLE_NAME\"],\n          referencedColumnNames: OrmUtils.uniq(foreignKeys.map(dbFk => dbFk[\"REFERENCED_COLUMN_NAME\"])),\n          onDelete: dbForeignKey[\"DELETE_RULE\"],\n          onUpdate: dbForeignKey[\"UPDATE_RULE\"]\n        });\n      });\n      const tableIndices = dbIndices.filter(dbIndex => dbIndex[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"]);\n      table.indices = OrmUtils.uniq(tableIndices, dbIndex => dbIndex[\"INDEX_NAME\"]).map(constraint => {\n        const indices = tableIndices.filter(index => {\n          return index[\"INDEX_NAME\"] === constraint[\"INDEX_NAME\"];\n        });\n        return new TableIndex({\n          table: table,\n          name: constraint[\"INDEX_NAME\"],\n          columnNames: indices.map(i => i[\"COLUMN_NAME\"]),\n          isUnique: constraint[\"IS_UNIQUE\"],\n          isNullFiltered: constraint[\"IS_NULL_FILTERED\"]\n        });\n      });\n      const tableChecks = dbChecks.filter(dbCheck => dbCheck[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"]);\n      table.checks = OrmUtils.uniq(tableChecks, dbIndex => dbIndex[\"CONSTRAINT_NAME\"]).map(constraint => {\n        const checks = tableChecks.filter(dbC => dbC[\"CONSTRAINT_NAME\"] === constraint[\"CONSTRAINT_NAME\"]);\n        return new TableCheck({\n          name: constraint[\"CONSTRAINT_NAME\"],\n          columnNames: checks.map(c => c[\"COLUMN_NAME\"]),\n          expression: constraint[\"CHECK_CLAUSE\"]\n        });\n      });\n      return table;\n    }));\n  }\n  /**\n   * Builds create table sql.\n   */\n  createTableSql(table, createForeignKeys) {\n    const columnDefinitions = table.columns.map(column => this.buildCreateColumnSql(column)).join(\", \");\n    let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`;\n    // we create unique indexes instead of unique constraints, because Spanner does not have unique constraints.\n    // if we mark column as Unique, it means that we create UNIQUE INDEX.\n    table.columns.filter(column => column.isUnique).forEach(column => {\n      const isUniqueIndexExist = table.indices.some(index => {\n        return index.columnNames.length === 1 && !!index.isUnique && index.columnNames.indexOf(column.name) !== -1;\n      });\n      const isUniqueConstraintExist = table.uniques.some(unique => {\n        return unique.columnNames.length === 1 && unique.columnNames.indexOf(column.name) !== -1;\n      });\n      if (!isUniqueIndexExist && !isUniqueConstraintExist) table.indices.push(new TableIndex({\n        name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),\n        columnNames: [column.name],\n        isUnique: true\n      }));\n    });\n    // as Spanner does not have unique constraints, we must create table indices from table uniques and mark them as unique.\n    if (table.uniques.length > 0) {\n      table.uniques.forEach(unique => {\n        const uniqueExist = table.indices.some(index => index.name === unique.name);\n        if (!uniqueExist) {\n          table.indices.push(new TableIndex({\n            name: unique.name,\n            columnNames: unique.columnNames,\n            isUnique: true\n          }));\n        }\n      });\n    }\n    if (table.checks.length > 0) {\n      const checksSql = table.checks.map(check => {\n        const checkName = check.name ? check.name : this.connection.namingStrategy.checkConstraintName(table, check.expression);\n        return `CONSTRAINT \\`${checkName}\\` CHECK (${check.expression})`;\n      }).join(\", \");\n      sql += `, ${checksSql}`;\n    }\n    if (table.foreignKeys.length > 0 && createForeignKeys) {\n      const foreignKeysSql = table.foreignKeys.map(fk => {\n        const columnNames = fk.columnNames.map(columnName => `\\`${columnName}\\``).join(\", \");\n        if (!fk.name) fk.name = this.connection.namingStrategy.foreignKeyName(table, fk.columnNames, this.getTablePath(fk), fk.referencedColumnNames);\n        const referencedColumnNames = fk.referencedColumnNames.map(columnName => `\\`${columnName}\\``).join(\", \");\n        return `CONSTRAINT \\`${fk.name}\\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(fk))} (${referencedColumnNames})`;\n      }).join(\", \");\n      sql += `, ${foreignKeysSql}`;\n    }\n    sql += `)`;\n    const primaryColumns = table.columns.filter(column => column.isPrimary);\n    if (primaryColumns.length > 0) {\n      const columnNames = primaryColumns.map(column => this.driver.escape(column.name)).join(\", \");\n      sql += ` PRIMARY KEY (${columnNames})`;\n    }\n    return new Query(sql);\n  }\n  /**\n   * Builds drop table sql.\n   */\n  dropTableSql(tableOrPath) {\n    return new Query(`DROP TABLE ${this.escapePath(tableOrPath)}`);\n  }\n  createViewSql(view) {\n    const materializedClause = view.materialized ? \"MATERIALIZED \" : \"\";\n    const viewName = this.escapePath(view);\n    const expression = typeof view.expression === \"string\" ? view.expression : view.expression(this.connection).getQuery();\n    return new Query(`CREATE ${materializedClause}VIEW ${viewName} SQL SECURITY INVOKER AS ${expression}`);\n  }\n  async insertViewDefinitionSql(view) {\n    let {\n      schema,\n      tableName: name\n    } = this.driver.parseTableName(view);\n    const type = view.materialized ? MetadataTableType.MATERIALIZED_VIEW : MetadataTableType.VIEW;\n    const expression = typeof view.expression === \"string\" ? view.expression.trim() : view.expression(this.connection).getQuery();\n    return this.insertTypeormMetadataSql({\n      type,\n      schema,\n      name,\n      value: expression\n    });\n  }\n  /**\n   * Builds drop view sql.\n   */\n  dropViewSql(view) {\n    const materializedClause = view.materialized ? \"MATERIALIZED \" : \"\";\n    return new Query(`DROP ${materializedClause}VIEW ${this.escapePath(view)}`);\n  }\n  /**\n   * Builds remove view sql.\n   */\n  async deleteViewDefinitionSql(view) {\n    let {\n      schema,\n      tableName: name\n    } = this.driver.parseTableName(view);\n    const type = view.materialized ? MetadataTableType.MATERIALIZED_VIEW : MetadataTableType.VIEW;\n    return this.deleteTypeormMetadataSql({\n      type,\n      schema,\n      name\n    });\n  }\n  /**\n   * Builds create index sql.\n   */\n  createIndexSql(table, index) {\n    const columns = index.columnNames.map(columnName => this.driver.escape(columnName)).join(\", \");\n    let indexType = \"\";\n    if (index.isUnique) indexType += \"UNIQUE \";\n    if (index.isNullFiltered) indexType += \"NULL_FILTERED \";\n    return new Query(`CREATE ${indexType}INDEX \\`${index.name}\\` ON ${this.escapePath(table)} (${columns})`);\n  }\n  /**\n   * Builds drop index sql.\n   */\n  dropIndexSql(table, indexOrName) {\n    let indexName = indexOrName instanceof TableIndex ? indexOrName.name : indexOrName;\n    return new Query(`DROP INDEX \\`${indexName}\\``);\n  }\n  /**\n   * Builds create check constraint sql.\n   */\n  createCheckConstraintSql(table, checkConstraint) {\n    return new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \\`${checkConstraint.name}\\` CHECK (${checkConstraint.expression})`);\n  }\n  /**\n   * Builds drop check constraint sql.\n   */\n  dropCheckConstraintSql(table, checkOrName) {\n    const checkName = checkOrName instanceof TableCheck ? checkOrName.name : checkOrName;\n    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \\`${checkName}\\``);\n  }\n  /**\n   * Builds create foreign key sql.\n   */\n  createForeignKeySql(table, foreignKey) {\n    const columnNames = foreignKey.columnNames.map(column => this.driver.escape(column)).join(\", \");\n    const referencedColumnNames = foreignKey.referencedColumnNames.map(column => this.driver.escape(column)).join(\",\");\n    let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \\`${foreignKey.name}\\` FOREIGN KEY (${columnNames}) ` + `REFERENCES ${this.escapePath(this.getTablePath(foreignKey))} (${referencedColumnNames})`;\n    return new Query(sql);\n  }\n  /**\n   * Builds drop foreign key sql.\n   */\n  dropForeignKeySql(table, foreignKeyOrName) {\n    const foreignKeyName = foreignKeyOrName instanceof TableForeignKey ? foreignKeyOrName.name : foreignKeyOrName;\n    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \\`${foreignKeyName}\\``);\n  }\n  /**\n   * Escapes given table or view path.\n   */\n  escapePath(target) {\n    const {\n      tableName\n    } = this.driver.parseTableName(target);\n    return `\\`${tableName}\\``;\n  }\n  /**\n   * Builds a part of query to create/change a column.\n   */\n  buildCreateColumnSql(column) {\n    let c = `${this.driver.escape(column.name)} ${this.connection.driver.createFullType(column)}`;\n    // Spanner supports only STORED generated column type\n    if (column.generatedType === \"STORED\" && column.asExpression) {\n      c += ` AS (${column.asExpression}) STORED`;\n    } else {\n      if (!column.isNullable) c += \" NOT NULL\";\n    }\n    return c;\n  }\n  /**\n   * Executes sql used special for schema build.\n   */\n  async executeQueries(upQueries, downQueries) {\n    if (upQueries instanceof Query) upQueries = [upQueries];\n    if (downQueries instanceof Query) downQueries = [downQueries];\n    this.sqlInMemory.upQueries.push(...upQueries);\n    this.sqlInMemory.downQueries.push(...downQueries);\n    // if sql-in-memory mode is enabled then simply store sql in memory and return\n    if (this.sqlMemoryMode === true) return Promise.resolve();\n    for (const {\n      query,\n      parameters\n    } of upQueries) {\n      if (this.isDMLQuery(query)) {\n        await this.query(query, parameters);\n      } else {\n        await this.updateDDL(query, parameters);\n      }\n    }\n  }\n  isDMLQuery(query) {\n    return query.startsWith(\"INSERT\") || query.startsWith(\"UPDATE\") || query.startsWith(\"DELETE\");\n  }\n  /**\n   * Change table comment.\n   */\n  changeTableComment(tableOrName, comment) {\n    throw new TypeORMError(`spanner driver does not support change table comment.`);\n  }\n}","map":{"version":3,"names":["QueryFailedError","QueryRunnerAlreadyReleasedError","TransactionNotStartedError","BaseQueryRunner","Table","TableCheck","TableColumn","TableForeignKey","TableIndex","TableUnique","View","Broadcaster","OrmUtils","Query","TypeORMError","QueryResult","MetadataTableType","BroadcasterResult","SpannerQueryRunner","constructor","driver","mode","connection","broadcaster","connect","session","Promise","resolve","instanceDatabase","createSession","sessionTransaction","transaction","release","isReleased","delete","undefined","startTransaction","isolationLevel","isTransactionActive","broadcast","err","begin","logger","logQuery","commitTransaction","commit","rollbackTransaction","rollback","query","parameters","useStructuredResult","broadcasterResult","queryStartTime","Date","rawResult","isSelect","startsWith","executor","broadcastBeforeQueryEvent","run","sql","params","reduce","value","index","json","error","rollbackError","maxQueryExecutionTime","options","queryEndTime","queryExecutionTime","broadcastAfterQueryEvent","logQuerySlow","result","raw","records","rowCountExact","affected","parseInt","logQueryError","wait","updateDDL","operation","updateSchema","promise","stream","onEnd","onError","request","runStream","on","getDatabases","getSchemas","database","hasDatabase","getCurrentDatabase","hasSchema","schema","length","getCurrentSchema","hasTable","tableOrName","tableName","name","hasColumn","columnName","createDatabase","ifNotExist","databaseAlreadyExists","up","down","executeQueries","dropDatabase","ifExist","createSchema","schemaPath","dropSchema","isCascade","createTable","table","createForeignKeys","createIndices","isTableExist","upQueries","downQueries","push","createTableSql","dropTableSql","foreignKeys","forEach","foreignKey","dropForeignKeySql","indices","namingStrategy","indexName","columnNames","where","createIndexSql","dropIndexSql","generatedColumns","columns","filter","column","generatedType","asExpression","insertQuery","insertTypeormMetadataSql","type","GENERATED_COLUMN","deleteQuery","deleteTypeormMetadataSql","dropTable","target","dropForeignKeys","dropIndices","tablePath","getTablePath","getCachedTable","createView","view","createViewSql","insertViewDefinitionSql","dropViewSql","deleteViewDefinitionSql","dropView","viewName","getCachedView","renameTable","oldTableOrName","newTableName","addColumn","clonedTable","clone","escapePath","buildCreateColumnSql","escape","columnIndex","find","isUnique","uniqueIndex","uniques","replaceCachedTable","addColumns","renameColumn","oldTableColumnOrName","newTableColumnOrName","oldColumn","c","newColumn","changeColumn","isArray","dropColumn","precision","scale","createFullType","isNullable","splice","indexOf","tableUnique","unique","changeColumns","changedColumns","columnOrName","findColumnByName","columnCheck","checks","check","dropCheckConstraintSql","createCheckConstraintSql","removeColumn","dropColumns","createPrimaryKey","Error","updatePrimaryKeys","dropPrimaryKey","createUniqueConstraint","uniqueConstraint","createUniqueConstraints","uniqueConstraints","dropUniqueConstraint","uniqueOrName","dropUniqueConstraints","createCheckConstraint","checkConstraint","checkConstraintName","expression","addCheckConstraint","createCheckConstraints","checkConstraints","promises","map","all","dropCheckConstraint","checkOrName","removeCheckConstraint","dropCheckConstraints","createExclusionConstraint","exclusionConstraint","createExclusionConstraints","exclusionConstraints","dropExclusionConstraint","exclusionOrName","dropExclusionConstraints","createForeignKey","foreignKeyName","referencedColumnNames","createForeignKeySql","addForeignKey","dropForeignKey","foreignKeyOrName","fk","removeForeignKey","createIndex","generateIndexName","addIndex","dropIndex","indexOrName","i","removeIndex","clearTable","clearDatabase","selectIndexDropsQuery","dropIndexQueries","selectFKDropsQuery","dropFKQueries","dropTablesQuery","dropTableQueries","isAnotherTransactionActive","executeMemoryUpSql","sqlInMemory","isDMLQuery","executeMemoryDownSql","reverse","loadViews","viewNames","loadTables","tableNames","dbTables","tablesSql","join","loadedTableNames","dbTable","TABLE_NAME","columnsSql","primaryKeySql","indicesSql","checksSql","foreignKeysSql","dbColumns","dbPrimaryKeys","dbIndices","dbChecks","dbForeignKeys","buildTableName","dbColumn","columnUniqueIndices","dbIndex","tableMetadata","entityMetadatas","metadata","hasIgnoredIndex","some","synchronize","isConstraintComposite","every","tableColumn","fullType","toLowerCase","substring","withLengthColumnTypes","asExpressionQuery","selectTypeormMetadataSql","results","isPrimary","dbPrimaryKey","tableForeignKeys","dbForeignKey","uniq","dbFk","referencedDatabase","referencedTableName","onDelete","onUpdate","tableIndices","constraint","isNullFiltered","tableChecks","dbCheck","dbC","columnDefinitions","isUniqueIndexExist","isUniqueConstraintExist","uniqueConstraintName","uniqueExist","checkName","primaryColumns","tableOrPath","materializedClause","materialized","getQuery","parseTableName","MATERIALIZED_VIEW","VIEW","trim","indexType","sqlMemoryMode","changeTableComment","comment"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\driver\\spanner\\SpannerQueryRunner.ts"],"sourcesContent":["import { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { QueryFailedError } from \"../../error/QueryFailedError\"\nimport { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\"\nimport { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\"\nimport { ColumnType } from \"../types/ColumnTypes\"\nimport { ReadStream } from \"../../platform/PlatformTools\"\nimport { BaseQueryRunner } from \"../../query-runner/BaseQueryRunner\"\nimport { QueryRunner } from \"../../query-runner/QueryRunner\"\nimport { TableIndexOptions } from \"../../schema-builder/options/TableIndexOptions\"\nimport { Table } from \"../../schema-builder/table/Table\"\nimport { TableCheck } from \"../../schema-builder/table/TableCheck\"\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\"\nimport { TableExclusion } from \"../../schema-builder/table/TableExclusion\"\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\"\nimport { TableIndex } from \"../../schema-builder/table/TableIndex\"\nimport { TableUnique } from \"../../schema-builder/table/TableUnique\"\nimport { View } from \"../../schema-builder/view/View\"\nimport { Broadcaster } from \"../../subscriber/Broadcaster\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { Query } from \"../Query\"\nimport { IsolationLevel } from \"../types/IsolationLevel\"\nimport { ReplicationMode } from \"../types/ReplicationMode\"\nimport { TypeORMError } from \"../../error\"\nimport { QueryResult } from \"../../query-runner/QueryResult\"\nimport { MetadataTableType } from \"../types/MetadataTableType\"\nimport { SpannerDriver } from \"./SpannerDriver\"\nimport { BroadcasterResult } from \"../../subscriber/BroadcasterResult\"\n\n/**\n * Runs queries on a single postgres database connection.\n */\nexport class SpannerQueryRunner extends BaseQueryRunner implements QueryRunner {\n    // -------------------------------------------------------------------------\n    // Public Implemented Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Database driver used by connection.\n     */\n    driver: SpannerDriver\n\n    /**\n     * Real database connection from a connection pool used to perform queries.\n     */\n    protected session?: any\n\n    /**\n     * Transaction currently executed by this session.\n     */\n    protected sessionTransaction?: any\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(driver: SpannerDriver, mode: ReplicationMode) {\n        super()\n        this.driver = driver\n        this.connection = driver.connection\n        this.mode = mode\n        this.broadcaster = new Broadcaster(this)\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates/uses database connection from the connection pool to perform further operations.\n     * Returns obtained database connection.\n     */\n    async connect(): Promise<any> {\n        if (this.session) {\n            return Promise.resolve(this.session)\n        }\n\n        const [session] = await this.driver.instanceDatabase.createSession({})\n        this.session = session\n        this.sessionTransaction = await session.transaction()\n        return this.session\n    }\n\n    /**\n     * Releases used database connection.\n     * You cannot use query runner methods once its released.\n     */\n    async release(): Promise<void> {\n        this.isReleased = true\n        if (this.session) {\n            await this.session.delete()\n        }\n        this.session = undefined\n        return Promise.resolve()\n    }\n\n    /**\n     * Starts transaction.\n     */\n    async startTransaction(isolationLevel?: IsolationLevel): Promise<void> {\n        this.isTransactionActive = true\n        try {\n            await this.broadcaster.broadcast(\"BeforeTransactionStart\")\n        } catch (err) {\n            this.isTransactionActive = false\n            throw err\n        }\n\n        await this.connect()\n        await this.sessionTransaction.begin()\n        this.connection.logger.logQuery(\"START TRANSACTION\")\n\n        await this.broadcaster.broadcast(\"AfterTransactionStart\")\n    }\n\n    /**\n     * Commits transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async commitTransaction(): Promise<void> {\n        if (!this.isTransactionActive || !this.sessionTransaction)\n            throw new TransactionNotStartedError()\n\n        await this.broadcaster.broadcast(\"BeforeTransactionCommit\")\n\n        await this.sessionTransaction.commit()\n        this.connection.logger.logQuery(\"COMMIT\")\n        this.isTransactionActive = false\n\n        await this.broadcaster.broadcast(\"AfterTransactionCommit\")\n    }\n\n    /**\n     * Rollbacks transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async rollbackTransaction(): Promise<void> {\n        if (!this.isTransactionActive || !this.sessionTransaction)\n            throw new TransactionNotStartedError()\n\n        await this.broadcaster.broadcast(\"BeforeTransactionRollback\")\n\n        await this.sessionTransaction.rollback()\n        this.connection.logger.logQuery(\"ROLLBACK\")\n        this.isTransactionActive = false\n\n        await this.broadcaster.broadcast(\"AfterTransactionRollback\")\n    }\n\n    /**\n     * Executes a given SQL query.\n     */\n    async query(\n        query: string,\n        parameters?: any[],\n        useStructuredResult: boolean = false,\n    ): Promise<any> {\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        const broadcasterResult = new BroadcasterResult()\n\n        try {\n            const queryStartTime = +new Date()\n            await this.connect()\n            let rawResult:\n                | [\n                      any[],\n                      {\n                          queryPlan: null\n                          queryStats: null\n                          rowCountExact: string\n                          rowCount: string\n                      },\n                      { rowType: { fields: [] }; transaction: null },\n                  ]\n                | undefined = undefined\n            const isSelect = query.startsWith(\"SELECT\")\n            const executor =\n                isSelect && !this.isTransactionActive\n                    ? this.driver.instanceDatabase\n                    : this.sessionTransaction\n\n            if (!this.isTransactionActive && !isSelect) {\n                await this.sessionTransaction.begin()\n            }\n\n            try {\n                this.driver.connection.logger.logQuery(query, parameters, this)\n                this.broadcaster.broadcastBeforeQueryEvent(\n                    broadcasterResult,\n                    query,\n                    parameters,\n                )\n\n                rawResult = await executor.run({\n                    sql: query,\n                    params: parameters\n                        ? parameters.reduce((params, value, index) => {\n                              params[\"param\" + index] = value\n                              return params\n                          }, {} as ObjectLiteral)\n                        : undefined,\n                    json: true,\n                })\n                if (!this.isTransactionActive && !isSelect) {\n                    await this.sessionTransaction.commit()\n                }\n            } catch (error) {\n                try {\n                    // we throw original error even if rollback thrown an error\n                    if (!this.isTransactionActive && !isSelect)\n                        await this.sessionTransaction.rollback()\n                } catch (rollbackError) {}\n                throw error\n            }\n\n            // log slow queries if maxQueryExecution time is set\n            const maxQueryExecutionTime =\n                this.driver.options.maxQueryExecutionTime\n            const queryEndTime = +new Date()\n            const queryExecutionTime = queryEndTime - queryStartTime\n\n            this.broadcaster.broadcastAfterQueryEvent(\n                broadcasterResult,\n                query,\n                parameters,\n                true,\n                queryExecutionTime,\n                rawResult,\n                undefined,\n            )\n\n            if (\n                maxQueryExecutionTime &&\n                queryExecutionTime > maxQueryExecutionTime\n            )\n                this.driver.connection.logger.logQuerySlow(\n                    queryExecutionTime,\n                    query,\n                    parameters,\n                    this,\n                )\n\n            const result = new QueryResult()\n\n            result.raw = rawResult\n            result.records = rawResult ? rawResult[0] : []\n            if (rawResult && rawResult[1] && rawResult[1].rowCountExact) {\n                result.affected = parseInt(rawResult[1].rowCountExact)\n            }\n\n            if (!useStructuredResult) {\n                return result.records\n            }\n\n            return result\n        } catch (err) {\n            this.driver.connection.logger.logQueryError(\n                err,\n                query,\n                parameters,\n                this,\n            )\n            this.broadcaster.broadcastAfterQueryEvent(\n                broadcasterResult,\n                query,\n                parameters,\n                false,\n                undefined,\n                undefined,\n                err,\n            )\n            throw new QueryFailedError(query, parameters, err)\n        } finally {\n            await broadcasterResult.wait()\n        }\n    }\n\n    /**\n     * Update database schema.\n     * Used for creating/altering/dropping tables, columns, indexes, etc.\n     *\n     * DDL changing queries should be executed by `updateSchema()` method.\n     */\n    async updateDDL(query: string, parameters?: any[]): Promise<void> {\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        this.driver.connection.logger.logQuery(query, parameters, this)\n        try {\n            const queryStartTime = +new Date()\n            const [operation] = await this.driver.instanceDatabase.updateSchema(\n                query,\n            )\n            await operation.promise()\n            // log slow queries if maxQueryExecution time is set\n            const maxQueryExecutionTime =\n                this.driver.options.maxQueryExecutionTime\n            const queryEndTime = +new Date()\n            const queryExecutionTime = queryEndTime - queryStartTime\n            if (\n                maxQueryExecutionTime &&\n                queryExecutionTime > maxQueryExecutionTime\n            )\n                this.driver.connection.logger.logQuerySlow(\n                    queryExecutionTime,\n                    query,\n                    parameters,\n                    this,\n                )\n        } catch (err) {\n            this.driver.connection.logger.logQueryError(\n                err,\n                query,\n                parameters,\n                this,\n            )\n            throw new QueryFailedError(query, parameters, err)\n        }\n    }\n\n    /**\n     * Returns raw data stream.\n     */\n    async stream(\n        query: string,\n        parameters?: any[],\n        onEnd?: Function,\n        onError?: Function,\n    ): Promise<ReadStream> {\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        try {\n            this.driver.connection.logger.logQuery(query, parameters, this)\n            const request = {\n                sql: query,\n                params: parameters\n                    ? parameters.reduce((params, value, index) => {\n                          params[\"param\" + index] = value\n                          return params\n                      }, {} as ObjectLiteral)\n                    : undefined,\n                json: true,\n            }\n            const stream = this.driver.instanceDatabase.runStream(request)\n\n            if (onEnd) {\n                stream.on(\"end\", onEnd)\n            }\n\n            if (onError) {\n                stream.on(\"error\", onError)\n            }\n\n            return stream\n        } catch (err) {\n            this.driver.connection.logger.logQueryError(\n                err,\n                query,\n                parameters,\n                this,\n            )\n            throw new QueryFailedError(query, parameters, err)\n        }\n    }\n\n    /**\n     * Returns all available database names including system databases.\n     */\n    async getDatabases(): Promise<string[]> {\n        return Promise.resolve([])\n    }\n\n    /**\n     * Returns all available schema names including system schemas.\n     * If database parameter specified, returns schemas of that database.\n     */\n    async getSchemas(database?: string): Promise<string[]> {\n        return Promise.resolve([])\n    }\n\n    /**\n     * Checks if database with the given name exist.\n     */\n    async hasDatabase(database: string): Promise<boolean> {\n        throw new TypeORMError(\n            `Check database queries are not supported by Spanner driver.`,\n        )\n    }\n\n    /**\n     * Loads currently using database\n     */\n    async getCurrentDatabase(): Promise<string> {\n        throw new TypeORMError(\n            `Check database queries are not supported by Spanner driver.`,\n        )\n    }\n\n    /**\n     * Checks if schema with the given name exist.\n     */\n    async hasSchema(schema: string): Promise<boolean> {\n        const result = await this.query(\n            `SELECT * FROM \"information_schema\".\"schemata\" WHERE \"schema_name\" = '${schema}'`,\n        )\n        return result.length ? true : false\n    }\n\n    /**\n     * Loads currently using database schema\n     */\n    async getCurrentSchema(): Promise<string> {\n        throw new TypeORMError(\n            `Check schema queries are not supported by Spanner driver.`,\n        )\n    }\n\n    /**\n     * Checks if table with the given name exist in the database.\n     */\n    async hasTable(tableOrName: Table | string): Promise<boolean> {\n        const tableName =\n            tableOrName instanceof Table ? tableOrName.name : tableOrName\n        const sql =\n            `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` ` +\n            `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_TYPE\\` = 'BASE TABLE' ` +\n            `AND \\`TABLE_NAME\\` = '${tableName}'`\n        const result = await this.query(sql)\n        return result.length ? true : false\n    }\n\n    /**\n     * Checks if column with the given name exist in the given table.\n     */\n    async hasColumn(\n        tableOrName: Table | string,\n        columnName: string,\n    ): Promise<boolean> {\n        const tableName =\n            tableOrName instanceof Table ? tableOrName.name : tableOrName\n        const sql =\n            `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`COLUMNS\\` ` +\n            `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' ` +\n            `AND \\`TABLE_NAME\\` = '${tableName}' AND \\`COLUMN_NAME\\` = '${columnName}'`\n        const result = await this.query(sql)\n        return result.length ? true : false\n    }\n\n    /**\n     * Creates a new database.\n     * Note: Spanner does not support database creation inside a transaction block.\n     */\n    async createDatabase(\n        database: string,\n        ifNotExist?: boolean,\n    ): Promise<void> {\n        if (ifNotExist) {\n            const databaseAlreadyExists = await this.hasDatabase(database)\n\n            if (databaseAlreadyExists) return Promise.resolve()\n        }\n\n        const up = `CREATE DATABASE \"${database}\"`\n        const down = `DROP DATABASE \"${database}\"`\n        await this.executeQueries(new Query(up), new Query(down))\n    }\n\n    /**\n     * Drops database.\n     * Note: Spanner does not support database dropping inside a transaction block.\n     */\n    async dropDatabase(database: string, ifExist?: boolean): Promise<void> {\n        const up = ifExist\n            ? `DROP DATABASE IF EXISTS \"${database}\"`\n            : `DROP DATABASE \"${database}\"`\n        const down = `CREATE DATABASE \"${database}\"`\n        await this.executeQueries(new Query(up), new Query(down))\n    }\n\n    /**\n     * Creates a new table schema.\n     */\n    async createSchema(\n        schemaPath: string,\n        ifNotExist?: boolean,\n    ): Promise<void> {\n        return Promise.resolve()\n    }\n\n    /**\n     * Drops table schema.\n     */\n    async dropSchema(\n        schemaPath: string,\n        ifExist?: boolean,\n        isCascade?: boolean,\n    ): Promise<void> {\n        return Promise.resolve()\n    }\n\n    /**\n     * Creates a new table.\n     */\n    async createTable(\n        table: Table,\n        ifNotExist: boolean = false,\n        createForeignKeys: boolean = true,\n        createIndices: boolean = true,\n    ): Promise<void> {\n        if (ifNotExist) {\n            const isTableExist = await this.hasTable(table)\n            if (isTableExist) return Promise.resolve()\n        }\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        upQueries.push(this.createTableSql(table, createForeignKeys))\n        downQueries.push(this.dropTableSql(table))\n\n        // if createForeignKeys is true, we must drop created foreign keys in down query.\n        // createTable does not need separate method to create foreign keys, because it create fk's in the same query with table creation.\n        if (createForeignKeys)\n            table.foreignKeys.forEach((foreignKey) =>\n                downQueries.push(this.dropForeignKeySql(table, foreignKey)),\n            )\n\n        if (createIndices) {\n            table.indices.forEach((index) => {\n                // new index may be passed without name. In this case we generate index name manually.\n                if (!index.name)\n                    index.name = this.connection.namingStrategy.indexName(\n                        table,\n                        index.columnNames,\n                        index.where,\n                    )\n                upQueries.push(this.createIndexSql(table, index))\n                downQueries.push(this.dropIndexSql(table, index))\n            })\n        }\n\n        // if table has column with generated type, we must add the expression to the metadata table\n        const generatedColumns = table.columns.filter(\n            (column) => column.generatedType && column.asExpression,\n        )\n\n        for (const column of generatedColumns) {\n            const insertQuery = this.insertTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            })\n\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            })\n\n            upQueries.push(insertQuery)\n            downQueries.push(deleteQuery)\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Drops the table.\n     */\n    async dropTable(\n        target: Table | string,\n        ifExist?: boolean,\n        dropForeignKeys: boolean = true,\n        dropIndices: boolean = true,\n    ): Promise<void> {\n        // It needs because if table does not exist and dropForeignKeys or dropIndices is true, we don't need\n        // to perform drop queries for foreign keys and indices.\n        if (ifExist) {\n            const isTableExist = await this.hasTable(target)\n            if (!isTableExist) return Promise.resolve()\n        }\n\n        // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.\n        const createForeignKeys: boolean = dropForeignKeys\n        const tablePath = this.getTablePath(target)\n        const table = await this.getCachedTable(tablePath)\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        if (dropIndices) {\n            table.indices.forEach((index) => {\n                upQueries.push(this.dropIndexSql(table, index))\n                downQueries.push(this.createIndexSql(table, index))\n            })\n        }\n\n        if (dropForeignKeys)\n            table.foreignKeys.forEach((foreignKey) =>\n                upQueries.push(this.dropForeignKeySql(table, foreignKey)),\n            )\n\n        upQueries.push(this.dropTableSql(table))\n        downQueries.push(this.createTableSql(table, createForeignKeys))\n\n        // if table had columns with generated type, we must remove the expression from the metadata table\n        const generatedColumns = table.columns.filter(\n            (column) => column.generatedType && column.asExpression,\n        )\n\n        for (const column of generatedColumns) {\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            })\n\n            const insertQuery = this.insertTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            })\n\n            upQueries.push(deleteQuery)\n            downQueries.push(insertQuery)\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Creates a new view.\n     */\n    async createView(view: View): Promise<void> {\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n        upQueries.push(this.createViewSql(view))\n        upQueries.push(await this.insertViewDefinitionSql(view))\n        downQueries.push(this.dropViewSql(view))\n        downQueries.push(await this.deleteViewDefinitionSql(view))\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Drops the view.\n     */\n    async dropView(target: View | string): Promise<void> {\n        const viewName = target instanceof View ? target.name : target\n        const view = await this.getCachedView(viewName)\n\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n        upQueries.push(await this.deleteViewDefinitionSql(view))\n        upQueries.push(this.dropViewSql(view))\n        downQueries.push(await this.insertViewDefinitionSql(view))\n        downQueries.push(this.createViewSql(view))\n        await this.executeQueries(upQueries, downQueries)\n    }\n\n    /**\n     * Renames the given table.\n     */\n    async renameTable(\n        oldTableOrName: Table | string,\n        newTableName: string,\n    ): Promise<void> {\n        throw new TypeORMError(\n            `Rename table queries are not supported by Spanner driver.`,\n        )\n    }\n\n    /**\n     * Creates a new column from the column in the table.\n     */\n    async addColumn(\n        tableOrName: Table | string,\n        column: TableColumn,\n    ): Promise<void> {\n        const table =\n            tableOrName instanceof Table\n                ? tableOrName\n                : await this.getCachedTable(tableOrName)\n        const clonedTable = table.clone()\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        upQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    table,\n                )} ADD ${this.buildCreateColumnSql(column)}`,\n            ),\n        )\n        downQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    table,\n                )} DROP COLUMN ${this.driver.escape(column.name)}`,\n            ),\n        )\n\n        // create column index\n        const columnIndex = clonedTable.indices.find(\n            (index) =>\n                index.columnNames.length === 1 &&\n                index.columnNames[0] === column.name,\n        )\n        if (columnIndex) {\n            upQueries.push(this.createIndexSql(table, columnIndex))\n            downQueries.push(this.dropIndexSql(table, columnIndex))\n        } else if (column.isUnique) {\n            const uniqueIndex = new TableIndex({\n                name: this.connection.namingStrategy.indexName(table, [\n                    column.name,\n                ]),\n                columnNames: [column.name],\n                isUnique: true,\n            })\n            clonedTable.indices.push(uniqueIndex)\n            clonedTable.uniques.push(\n                new TableUnique({\n                    name: uniqueIndex.name,\n                    columnNames: uniqueIndex.columnNames,\n                }),\n            )\n\n            upQueries.push(this.createIndexSql(table, uniqueIndex))\n            downQueries.push(this.dropIndexSql(table, uniqueIndex))\n        }\n\n        if (column.generatedType && column.asExpression) {\n            const insertQuery = this.insertTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            })\n\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            })\n\n            upQueries.push(insertQuery)\n            downQueries.push(deleteQuery)\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n\n        clonedTable.addColumn(column)\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Creates a new columns from the column in the table.\n     */\n    async addColumns(\n        tableOrName: Table | string,\n        columns: TableColumn[],\n    ): Promise<void> {\n        for (const column of columns) {\n            await this.addColumn(tableOrName, column)\n        }\n    }\n\n    /**\n     * Renames column in the given table.\n     */\n    async renameColumn(\n        tableOrName: Table | string,\n        oldTableColumnOrName: TableColumn | string,\n        newTableColumnOrName: TableColumn | string,\n    ): Promise<void> {\n        const table =\n            tableOrName instanceof Table\n                ? tableOrName\n                : await this.getCachedTable(tableOrName)\n        const oldColumn =\n            oldTableColumnOrName instanceof TableColumn\n                ? oldTableColumnOrName\n                : table.columns.find((c) => c.name === oldTableColumnOrName)\n        if (!oldColumn)\n            throw new TypeORMError(\n                `Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`,\n            )\n\n        let newColumn\n        if (newTableColumnOrName instanceof TableColumn) {\n            newColumn = newTableColumnOrName\n        } else {\n            newColumn = oldColumn.clone()\n            newColumn.name = newTableColumnOrName\n        }\n\n        return this.changeColumn(table, oldColumn, newColumn)\n    }\n\n    /**\n     * Changes a column in the table.\n     */\n    async changeColumn(\n        tableOrName: Table | string,\n        oldTableColumnOrName: TableColumn | string,\n        newColumn: TableColumn,\n    ): Promise<void> {\n        const table =\n            tableOrName instanceof Table\n                ? tableOrName\n                : await this.getCachedTable(tableOrName)\n        let clonedTable = table.clone()\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        const oldColumn =\n            oldTableColumnOrName instanceof TableColumn\n                ? oldTableColumnOrName\n                : table.columns.find(\n                      (column) => column.name === oldTableColumnOrName,\n                  )\n        if (!oldColumn)\n            throw new TypeORMError(\n                `Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`,\n            )\n\n        if (\n            oldColumn.name !== newColumn.name ||\n            oldColumn.type !== newColumn.type ||\n            oldColumn.length !== newColumn.length ||\n            oldColumn.isArray !== newColumn.isArray ||\n            oldColumn.generatedType !== newColumn.generatedType ||\n            oldColumn.asExpression !== newColumn.asExpression\n        ) {\n            // To avoid data conversion, we just recreate column\n            await this.dropColumn(table, oldColumn)\n            await this.addColumn(table, newColumn)\n\n            // update cloned table\n            clonedTable = table.clone()\n        } else {\n            if (\n                newColumn.precision !== oldColumn.precision ||\n                newColumn.scale !== oldColumn.scale\n            ) {\n                upQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${\n                            newColumn.name\n                        }\" TYPE ${this.driver.createFullType(newColumn)}`,\n                    ),\n                )\n                downQueries.push(\n                    new Query(\n                        `ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${\n                            newColumn.name\n                        }\" TYPE ${this.driver.createFullType(oldColumn)}`,\n                    ),\n                )\n            }\n\n            if (oldColumn.isNullable !== newColumn.isNullable) {\n                if (newColumn.isNullable) {\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${oldColumn.name}\" DROP NOT NULL`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${oldColumn.name}\" SET NOT NULL`,\n                        ),\n                    )\n                } else {\n                    upQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${oldColumn.name}\" SET NOT NULL`,\n                        ),\n                    )\n                    downQueries.push(\n                        new Query(\n                            `ALTER TABLE ${this.escapePath(\n                                table,\n                            )} ALTER COLUMN \"${oldColumn.name}\" DROP NOT NULL`,\n                        ),\n                    )\n                }\n            }\n\n            if (newColumn.isUnique !== oldColumn.isUnique) {\n                if (newColumn.isUnique === true) {\n                    const uniqueIndex = new TableIndex({\n                        name: this.connection.namingStrategy.indexName(table, [\n                            newColumn.name,\n                        ]),\n                        columnNames: [newColumn.name],\n                        isUnique: true,\n                    })\n                    clonedTable.indices.push(uniqueIndex)\n                    clonedTable.uniques.push(\n                        new TableUnique({\n                            name: uniqueIndex.name,\n                            columnNames: uniqueIndex.columnNames,\n                        }),\n                    )\n\n                    upQueries.push(this.createIndexSql(table, uniqueIndex))\n                    downQueries.push(this.dropIndexSql(table, uniqueIndex))\n                } else {\n                    const uniqueIndex = clonedTable.indices.find((index) => {\n                        return (\n                            index.columnNames.length === 1 &&\n                            index.isUnique === true &&\n                            !!index.columnNames.find(\n                                (columnName) => columnName === newColumn.name,\n                            )\n                        )\n                    })\n                    clonedTable.indices.splice(\n                        clonedTable.indices.indexOf(uniqueIndex!),\n                        1,\n                    )\n\n                    const tableUnique = clonedTable.uniques.find(\n                        (unique) => unique.name === uniqueIndex!.name,\n                    )\n                    clonedTable.uniques.splice(\n                        clonedTable.uniques.indexOf(tableUnique!),\n                        1,\n                    )\n\n                    upQueries.push(this.dropIndexSql(table, uniqueIndex!))\n                    downQueries.push(this.createIndexSql(table, uniqueIndex!))\n                }\n            }\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Changes a column in the table.\n     */\n    async changeColumns(\n        tableOrName: Table | string,\n        changedColumns: { newColumn: TableColumn; oldColumn: TableColumn }[],\n    ): Promise<void> {\n        for (const { oldColumn, newColumn } of changedColumns) {\n            await this.changeColumn(tableOrName, oldColumn, newColumn)\n        }\n    }\n\n    /**\n     * Drops column in the table.\n     */\n    async dropColumn(\n        tableOrName: Table | string,\n        columnOrName: TableColumn | string,\n    ): Promise<void> {\n        const table =\n            tableOrName instanceof Table\n                ? tableOrName\n                : await this.getCachedTable(tableOrName)\n        const column =\n            columnOrName instanceof TableColumn\n                ? columnOrName\n                : table.findColumnByName(columnOrName)\n        if (!column)\n            throw new TypeORMError(\n                `Column \"${columnOrName}\" was not found in table \"${table.name}\"`,\n            )\n\n        const clonedTable = table.clone()\n        const upQueries: Query[] = []\n        const downQueries: Query[] = []\n\n        // drop column index\n        const columnIndex = clonedTable.indices.find(\n            (index) =>\n                index.columnNames.length === 1 &&\n                index.columnNames[0] === column.name,\n        )\n        if (columnIndex) {\n            clonedTable.indices.splice(\n                clonedTable.indices.indexOf(columnIndex),\n                1,\n            )\n            upQueries.push(this.dropIndexSql(table, columnIndex))\n            downQueries.push(this.createIndexSql(table, columnIndex))\n        }\n\n        // drop column check\n        const columnCheck = clonedTable.checks.find(\n            (check) =>\n                !!check.columnNames &&\n                check.columnNames.length === 1 &&\n                check.columnNames[0] === column.name,\n        )\n        if (columnCheck) {\n            clonedTable.checks.splice(\n                clonedTable.checks.indexOf(columnCheck),\n                1,\n            )\n            upQueries.push(this.dropCheckConstraintSql(table, columnCheck))\n            downQueries.push(this.createCheckConstraintSql(table, columnCheck))\n        }\n\n        upQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    table,\n                )} DROP COLUMN ${this.driver.escape(column.name)}`,\n            ),\n        )\n        downQueries.push(\n            new Query(\n                `ALTER TABLE ${this.escapePath(\n                    table,\n                )} ADD ${this.buildCreateColumnSql(column)}`,\n            ),\n        )\n\n        if (column.generatedType && column.asExpression) {\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            })\n            const insertQuery = this.insertTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            })\n\n            upQueries.push(deleteQuery)\n            downQueries.push(insertQuery)\n        }\n\n        await this.executeQueries(upQueries, downQueries)\n\n        clonedTable.removeColumn(column)\n        this.replaceCachedTable(table, clonedTable)\n    }\n\n    /**\n     * Drops the columns in the table.\n     */\n    async dropColumns(\n        tableOrName: Table | string,\n        columns: TableColumn[] | string[],\n    ): Promise<void> {\n        for (const column of columns) {\n            await this.dropColumn(tableOrName, column)\n        }\n    }\n\n    /**\n     * Creates a new primary key.\n     *\n     * Not supported in Spanner.\n     * @see https://cloud.google.com/spanner/docs/schema-and-data-model#notes_about_key_columns\n     */\n    async createPrimaryKey(\n        tableOrName: Table | string,\n        columnNames: string[],\n    ): Promise<void> {\n        throw new Error(\n            \"The keys of a table can't change; you can't add a key column to an existing table or remove a key column from an existing table.\",\n        )\n    }\n\n    /**\n     * Updates composite primary keys.\n     */\n    async updatePrimaryKeys(\n        tableOrName: Table | string,\n        columns: TableColumn[],\n    ): Promise<void> {\n        throw new Error(\n            \"The keys of a table can't change; you can't add a key column to an existing table or remove a key column from an existing table.\",\n        )\n    }\n\n    /**\n     * Creates a new primary key.\n     *\n     * Not supported in Spanner.\n     * @see https://cloud.google.com/spanner/docs/schema-and-data-model#notes_about_key_columns\n     */\n    async dropPrimaryKey(tableOrName: Table | string): Promise<void> {\n        throw new Error(\n            \"The keys of a table can't change; you can't add a key column to an existing table or remove a key column from an existing table.\",\n        )\n    }\n\n    /**\n     * Creates new unique constraint.\n     */\n    async createUniqueConstraint(\n        tableOrName: Table | string,\n        uniqueConstraint: TableUnique,\n    ): Promise<void> {\n        throw new TypeORMError(\n            `Spanner does not support unique constraints. Use unique index instead.`,\n        )\n    }\n\n    /**\n     * Creates new unique constraints.\n     */\n    async createUniqueConstraints(\n        tableOrName: Table | string,\n        uniqueConstraints: TableUnique[],\n    ): Promise<void> {\n        throw new TypeORMError(\n            `Spanner does not support unique constraints. Use unique index instead.`,\n        )\n    }\n\n    /**\n     * Drops unique constraint.\n     */\n    async dropUniqueConstraint(\n        tableOrName: Table | string,\n        uniqueOrName: TableUnique | string,\n    ): Promise<void> {\n        throw new TypeORMError(\n            `Spanner does not support unique constraints. Use unique index instead.`,\n        )\n    }\n\n    /**\n     * Drops unique constraints.\n     */\n    async dropUniqueConstraints(\n        tableOrName: Table | string,\n        uniqueConstraints: TableUnique[],\n    ): Promise<void> {\n        throw new TypeORMError(\n            `Spanner does not support unique constraints. Use unique index instead.`,\n        )\n    }\n\n    /**\n     * Creates new check constraint.\n     */\n    async createCheckConstraint(\n        tableOrName: Table | string,\n        checkConstraint: TableCheck,\n    ): Promise<void> {\n        const table =\n            tableOrName instanceof Table\n                ? tableOrName\n                : await this.getCachedTable(tableOrName)\n\n        // new check constraint may be passed without name. In this case we generate unique name manually.\n        if (!checkConstraint.name)\n            checkConstraint.name =\n                this.connection.namingStrategy.checkConstraintName(\n                    table,\n                    checkConstraint.expression!,\n                )\n\n        const up = this.createCheckConstraintSql(table, checkConstraint)\n        const down = this.dropCheckConstraintSql(table, checkConstraint)\n        await this.executeQueries(up, down)\n        table.addCheckConstraint(checkConstraint)\n    }\n\n    /**\n     * Creates new check constraints.\n     */\n    async createCheckConstraints(\n        tableOrName: Table | string,\n        checkConstraints: TableCheck[],\n    ): Promise<void> {\n        const promises = checkConstraints.map((checkConstraint) =>\n            this.createCheckConstraint(tableOrName, checkConstraint),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Drops check constraint.\n     */\n    async dropCheckConstraint(\n        tableOrName: Table | string,\n        checkOrName: TableCheck | string,\n    ): Promise<void> {\n        const table =\n            tableOrName instanceof Table\n                ? tableOrName\n                : await this.getCachedTable(tableOrName)\n        const checkConstraint =\n            checkOrName instanceof TableCheck\n                ? checkOrName\n                : table.checks.find((c) => c.name === checkOrName)\n        if (!checkConstraint)\n            throw new TypeORMError(\n                `Supplied check constraint was not found in table ${table.name}`,\n            )\n\n        const up = this.dropCheckConstraintSql(table, checkConstraint)\n        const down = this.createCheckConstraintSql(table, checkConstraint)\n        await this.executeQueries(up, down)\n        table.removeCheckConstraint(checkConstraint)\n    }\n\n    /**\n     * Drops check constraints.\n     */\n    async dropCheckConstraints(\n        tableOrName: Table | string,\n        checkConstraints: TableCheck[],\n    ): Promise<void> {\n        const promises = checkConstraints.map((checkConstraint) =>\n            this.dropCheckConstraint(tableOrName, checkConstraint),\n        )\n        await Promise.all(promises)\n    }\n\n    /**\n     * Creates new exclusion constraint.\n     */\n    async createExclusionConstraint(\n        tableOrName: Table | string,\n        exclusionConstraint: TableExclusion,\n    ): Promise<void> {\n        throw new TypeORMError(\n            `Spanner does not support exclusion constraints.`,\n        )\n    }\n\n    /**\n     * Creates new exclusion constraints.\n     */\n    async createExclusionConstraints(\n        tableOrName: Table | string,\n        exclusionConstraints: TableExclusion[],\n    ): Promise<void> {\n        throw new TypeORMError(\n            `Spanner does not support exclusion constraints.`,\n        )\n    }\n\n    /**\n     * Drops exclusion constraint.\n     */\n    async dropExclusionConstraint(\n        tableOrName: Table | string,\n        exclusionOrName: TableExclusion | string,\n    ): Promise<void> {\n        throw new TypeORMError(\n            `Spanner does not support exclusion constraints.`,\n        )\n    }\n\n    /**\n     * Drops exclusion constraints.\n     */\n    async dropExclusionConstraints(\n        tableOrName: Table | string,\n        exclusionConstraints: TableExclusion[],\n    ): Promise<void> {\n        throw new TypeORMError(\n            `Spanner does not support exclusion constraints.`,\n        )\n    }\n\n    /**\n     * Creates a new foreign key.\n     */\n    async createForeignKey(\n        tableOrName: Table | string,\n        foreignKey: TableForeignKey,\n    ): Promise<void> {\n        const table =\n            tableOrName instanceof Table\n                ? tableOrName\n                : await this.getCachedTable(tableOrName)\n\n        // new FK may be passed without name. In this case we generate FK name manually.\n        if (!foreignKey.name)\n            foreignKey.name = this.connection.namingStrategy.foreignKeyName(\n                table,\n                foreignKey.columnNames,\n                this.getTablePath(foreignKey),\n                foreignKey.referencedColumnNames,\n            )\n\n        const up = this.createForeignKeySql(table, foreignKey)\n        const down = this.dropForeignKeySql(table, foreignKey)\n        await this.executeQueries(up, down)\n        table.addForeignKey(foreignKey)\n    }\n\n    /**\n     * Creates a new foreign keys.\n     */\n    async createForeignKeys(\n        tableOrName: Table | string,\n        foreignKeys: TableForeignKey[],\n    ): Promise<void> {\n        for (const foreignKey of foreignKeys) {\n            await this.createForeignKey(tableOrName, foreignKey)\n        }\n    }\n\n    /**\n     * Drops a foreign key from the table.\n     */\n    async dropForeignKey(\n        tableOrName: Table | string,\n        foreignKeyOrName: TableForeignKey | string,\n    ): Promise<void> {\n        const table =\n            tableOrName instanceof Table\n                ? tableOrName\n                : await this.getCachedTable(tableOrName)\n        const foreignKey =\n            foreignKeyOrName instanceof TableForeignKey\n                ? foreignKeyOrName\n                : table.foreignKeys.find((fk) => fk.name === foreignKeyOrName)\n        if (!foreignKey)\n            throw new TypeORMError(\n                `Supplied foreign key was not found in table ${table.name}`,\n            )\n\n        const up = this.dropForeignKeySql(table, foreignKey)\n        const down = this.createForeignKeySql(table, foreignKey)\n        await this.executeQueries(up, down)\n        table.removeForeignKey(foreignKey)\n    }\n\n    /**\n     * Drops a foreign keys from the table.\n     */\n    async dropForeignKeys(\n        tableOrName: Table | string,\n        foreignKeys: TableForeignKey[],\n    ): Promise<void> {\n        for (const foreignKey of foreignKeys) {\n            await this.dropForeignKey(tableOrName, foreignKey)\n        }\n    }\n\n    /**\n     * Creates a new index.\n     */\n    async createIndex(\n        tableOrName: Table | string,\n        index: TableIndex,\n    ): Promise<void> {\n        const table =\n            tableOrName instanceof Table\n                ? tableOrName\n                : await this.getCachedTable(tableOrName)\n\n        // new index may be passed without name. In this case we generate index name manually.\n        if (!index.name) index.name = this.generateIndexName(table, index)\n\n        const up = this.createIndexSql(table, index)\n        const down = this.dropIndexSql(table, index)\n        await this.executeQueries(up, down)\n        table.addIndex(index)\n    }\n\n    /**\n     * Creates a new indices\n     */\n    async createIndices(\n        tableOrName: Table | string,\n        indices: TableIndex[],\n    ): Promise<void> {\n        for (const index of indices) {\n            await this.createIndex(tableOrName, index)\n        }\n    }\n\n    /**\n     * Drops an index from the table.\n     */\n    async dropIndex(\n        tableOrName: Table | string,\n        indexOrName: TableIndex | string,\n    ): Promise<void> {\n        const table =\n            tableOrName instanceof Table\n                ? tableOrName\n                : await this.getCachedTable(tableOrName)\n        const index =\n            indexOrName instanceof TableIndex\n                ? indexOrName\n                : table.indices.find((i) => i.name === indexOrName)\n        if (!index)\n            throw new TypeORMError(\n                `Supplied index ${indexOrName} was not found in table ${table.name}`,\n            )\n\n        // new index may be passed without name. In this case we generate index name manually.\n        if (!index.name) index.name = this.generateIndexName(table, index)\n\n        const up = this.dropIndexSql(table, index)\n        const down = this.createIndexSql(table, index)\n        await this.executeQueries(up, down)\n        table.removeIndex(index)\n    }\n\n    /**\n     * Drops an indices from the table.\n     */\n    async dropIndices(\n        tableOrName: Table | string,\n        indices: TableIndex[],\n    ): Promise<void> {\n        for (const index of indices) {\n            await this.dropIndex(tableOrName, index)\n        }\n    }\n\n    /**\n     * Clears all table contents.\n     * Spanner does not support TRUNCATE TABLE statement, so we use DELETE FROM.\n     */\n    async clearTable(tableName: string): Promise<void> {\n        await this.query(`DELETE FROM ${this.escapePath(tableName)} WHERE true`)\n    }\n\n    /**\n     * Removes all tables from the currently connected database.\n     */\n    async clearDatabase(): Promise<void> {\n        // drop index queries\n        const selectIndexDropsQuery =\n            `SELECT concat('DROP INDEX \\`', INDEX_NAME, '\\`') AS \\`query\\` ` +\n            `FROM \\`INFORMATION_SCHEMA\\`.\\`INDEXES\\` ` +\n            `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`INDEX_TYPE\\` = 'INDEX' AND \\`SPANNER_IS_MANAGED\\` = false`\n        const dropIndexQueries: ObjectLiteral[] = await this.query(\n            selectIndexDropsQuery,\n        )\n\n        // drop foreign key queries\n        const selectFKDropsQuery =\n            `SELECT concat('ALTER TABLE \\`', TABLE_NAME, '\\`', ' DROP CONSTRAINT \\`', CONSTRAINT_NAME, '\\`') AS \\`query\\` ` +\n            `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLE_CONSTRAINTS\\` ` +\n            `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`CONSTRAINT_TYPE\\` = 'FOREIGN KEY'`\n        const dropFKQueries: ObjectLiteral[] = await this.query(\n            selectFKDropsQuery,\n        )\n\n        // drop view queries\n        // const selectViewDropsQuery = `SELECT concat('DROP VIEW \\`', TABLE_NAME, '\\`') AS \\`query\\` FROM \\`INFORMATION_SCHEMA\\`.\\`VIEWS\\``\n        // const dropViewQueries: ObjectLiteral[] = await this.query(\n        //     selectViewDropsQuery,\n        // )\n\n        // drop table queries\n        const dropTablesQuery =\n            `SELECT concat('DROP TABLE \\`', TABLE_NAME, '\\`') AS \\`query\\` ` +\n            `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` ` +\n            `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_TYPE\\` = 'BASE TABLE'`\n        const dropTableQueries: ObjectLiteral[] = await this.query(\n            dropTablesQuery,\n        )\n\n        if (\n            !dropIndexQueries.length &&\n            !dropFKQueries.length &&\n            // !dropViewQueries.length &&\n            !dropTableQueries.length\n        )\n            return\n\n        const isAnotherTransactionActive = this.isTransactionActive\n        if (!isAnotherTransactionActive) await this.startTransaction()\n        try {\n            for (let query of dropIndexQueries) {\n                await this.updateDDL(query[\"query\"])\n            }\n            for (let query of dropFKQueries) {\n                await this.updateDDL(query[\"query\"])\n            }\n\n            // for (let query of dropViewQueries) {\n            //     await this.updateDDL(query[\"query\"])\n            // }\n\n            for (let query of dropTableQueries) {\n                await this.updateDDL(query[\"query\"])\n            }\n\n            await this.commitTransaction()\n        } catch (error) {\n            try {\n                // we throw original error even if rollback thrown an error\n                if (!isAnotherTransactionActive)\n                    await this.rollbackTransaction()\n            } catch (rollbackError) {}\n            throw error\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Override Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes up sql queries.\n     */\n    async executeMemoryUpSql(): Promise<void> {\n        for (const { query, parameters } of this.sqlInMemory.upQueries) {\n            if (this.isDMLQuery(query)) {\n                await this.query(query, parameters)\n            } else {\n                await this.updateDDL(query, parameters)\n            }\n        }\n    }\n\n    /**\n     * Executes down sql queries.\n     */\n    async executeMemoryDownSql(): Promise<void> {\n        for (const {\n            query,\n            parameters,\n        } of this.sqlInMemory.downQueries.reverse()) {\n            if (this.isDMLQuery(query)) {\n                await this.query(query, parameters)\n            } else {\n                await this.updateDDL(query, parameters)\n            }\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    protected async loadViews(viewNames?: string[]): Promise<View[]> {\n        // const hasTable = await this.hasTable(this.getTypeormMetadataTableName())\n        // if (!hasTable) {\n        //     return []\n        // }\n        //\n        // if (!viewNames) {\n        //     viewNames = []\n        // }\n        //\n        // const escapedViewNames = viewNames\n        //     .map((viewName) => `'${viewName}'`)\n        //     .join(\", \")\n        //\n        // const query =\n        //     `SELECT \\`T\\`.*, \\`V\\`.\\`VIEW_DEFINITION\\` FROM ${this.escapePath(\n        //         this.getTypeormMetadataTableName(),\n        //     )} \\`T\\` ` +\n        //     `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`VIEWS\\` \\`V\\` ON \\`V\\`.\\`TABLE_NAME\\` = \\`T\\`.\\`NAME\\` ` +\n        //     `WHERE \\`T\\`.\\`TYPE\\` = '${MetadataTableType.VIEW}' ${\n        //         viewNames.length\n        //             ? ` AND \\`T\\`.\\`NAME\\` IN (${escapedViewNames})`\n        //             : \"\"\n        //     }`\n        // const dbViews = await this.query(query)\n        // return dbViews.map((dbView: any) => {\n        //     const view = new View()\n        //     view.database = dbView[\"NAME\"]\n        //     view.name = this.driver.buildTableName(dbView[\"NAME\"])\n        //     view.expression = dbView[\"NAME\"]\n        //     return view\n        // })\n\n        return Promise.resolve([])\n    }\n\n    /**\n     * Loads all tables (with given names) from the database and creates a Table from them.\n     */\n    protected async loadTables(tableNames?: string[]): Promise<Table[]> {\n        if (tableNames && tableNames.length === 0) {\n            return []\n        }\n\n        const dbTables: { TABLE_NAME: string }[] = []\n\n        if (!tableNames || !tableNames.length) {\n            // Since we don't have any of this data we have to do a scan\n            const tablesSql =\n                `SELECT \\`TABLE_NAME\\` ` +\n                `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` ` +\n                `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_TYPE\\` = 'BASE TABLE'`\n            dbTables.push(...(await this.query(tablesSql)))\n        } else {\n            const tablesSql =\n                `SELECT \\`TABLE_NAME\\` ` +\n                `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` ` +\n                `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_TYPE\\` = 'BASE TABLE' ` +\n                `AND \\`TABLE_NAME\\` IN (${tableNames\n                    .map((tableName) => `'${tableName}'`)\n                    .join(\", \")})`\n\n            dbTables.push(...(await this.query(tablesSql)))\n        }\n\n        // if tables were not found in the db, no need to proceed\n        if (!dbTables.length) return []\n\n        const loadedTableNames = dbTables\n            .map((dbTable) => `'${dbTable.TABLE_NAME}'`)\n            .join(\", \")\n\n        const columnsSql = `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`COLUMNS\\` WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_NAME\\` IN (${loadedTableNames})`\n\n        const primaryKeySql =\n            `SELECT \\`KCU\\`.\\`TABLE_NAME\\`, \\`KCU\\`.\\`COLUMN_NAME\\` ` +\n            `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLE_CONSTRAINTS\\` \\`TC\\` ` +\n            `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`KEY_COLUMN_USAGE\\` \\`KCU\\` ON \\`KCU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` +\n            `WHERE \\`TC\\`.\\`TABLE_CATALOG\\` = '' AND \\`TC\\`.\\`TABLE_SCHEMA\\` = '' AND \\`TC\\`.\\`CONSTRAINT_TYPE\\` = 'PRIMARY KEY' ` +\n            `AND \\`TC\\`.\\`TABLE_NAME\\` IN (${loadedTableNames})`\n\n        const indicesSql =\n            `SELECT \\`I\\`.\\`TABLE_NAME\\`, \\`I\\`.\\`INDEX_NAME\\`, \\`I\\`.\\`IS_UNIQUE\\`, \\`I\\`.\\`IS_NULL_FILTERED\\`, \\`IC\\`.\\`COLUMN_NAME\\` ` +\n            `FROM \\`INFORMATION_SCHEMA\\`.\\`INDEXES\\` \\`I\\` ` +\n            `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`INDEX_COLUMNS\\` \\`IC\\` ON \\`IC\\`.\\`INDEX_NAME\\` = \\`I\\`.\\`INDEX_NAME\\` ` +\n            `AND \\`IC\\`.\\`TABLE_NAME\\` = \\`I\\`.\\`TABLE_NAME\\` ` +\n            `WHERE \\`I\\`.\\`TABLE_CATALOG\\` = '' AND \\`I\\`.\\`TABLE_SCHEMA\\` = '' AND \\`I\\`.\\`TABLE_NAME\\` IN (${loadedTableNames}) ` +\n            `AND \\`I\\`.\\`INDEX_TYPE\\` = 'INDEX' AND \\`I\\`.\\`SPANNER_IS_MANAGED\\` = false`\n\n        const checksSql =\n            `SELECT \\`TC\\`.\\`TABLE_NAME\\`, \\`TC\\`.\\`CONSTRAINT_NAME\\`, \\`CC\\`.\\`CHECK_CLAUSE\\`, \\`CCU\\`.\\`COLUMN_NAME\\`` +\n            `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLE_CONSTRAINTS\\` \\`TC\\` ` +\n            `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`CONSTRAINT_COLUMN_USAGE\\` \\`CCU\\` ON \\`CCU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` +\n            `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`CHECK_CONSTRAINTS\\` \\`CC\\` ON \\`CC\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` +\n            `WHERE \\`TC\\`.\\`TABLE_CATALOG\\` = '' AND \\`TC\\`.\\`TABLE_SCHEMA\\` = '' AND \\`TC\\`.\\`CONSTRAINT_TYPE\\` = 'CHECK' ` +\n            `AND \\`TC\\`.\\`TABLE_NAME\\` IN (${loadedTableNames}) AND \\`TC\\`.\\`CONSTRAINT_NAME\\` NOT LIKE 'CK_IS_NOT_NULL%'`\n\n        const foreignKeysSql =\n            `SELECT \\`TC\\`.\\`TABLE_NAME\\`, \\`TC\\`.\\`CONSTRAINT_NAME\\`, \\`KCU\\`.\\`COLUMN_NAME\\`, ` +\n            `\\`CTU\\`.\\`TABLE_NAME\\` AS \\`REFERENCED_TABLE_NAME\\`, \\`CCU\\`.\\`COLUMN_NAME\\` AS \\`REFERENCED_COLUMN_NAME\\`, ` +\n            `\\`RC\\`.\\`UPDATE_RULE\\`, \\`RC\\`.\\`DELETE_RULE\\` ` +\n            `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLE_CONSTRAINTS\\` \\`TC\\` ` +\n            `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`KEY_COLUMN_USAGE\\` \\`KCU\\` ON \\`KCU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` +\n            `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`CONSTRAINT_TABLE_USAGE\\` \\`CTU\\` ON \\`CTU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` +\n            `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`REFERENTIAL_CONSTRAINTS\\` \\`RC\\` ON \\`RC\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` +\n            `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`CONSTRAINT_COLUMN_USAGE\\` \\`CCU\\` ON \\`CCU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` +\n            `WHERE \\`TC\\`.\\`TABLE_CATALOG\\` = '' AND \\`TC\\`.\\`TABLE_SCHEMA\\` = '' AND \\`TC\\`.\\`CONSTRAINT_TYPE\\` = 'FOREIGN KEY' ` +\n            `AND \\`TC\\`.\\`TABLE_NAME\\` IN (${loadedTableNames})`\n\n        const [\n            dbColumns,\n            dbPrimaryKeys,\n            dbIndices,\n            dbChecks,\n            dbForeignKeys,\n        ]: ObjectLiteral[][] = await Promise.all([\n            this.query(columnsSql),\n            this.query(primaryKeySql),\n            this.query(indicesSql),\n            this.query(checksSql),\n            this.query(foreignKeysSql),\n        ])\n\n        // create tables for loaded tables\n        return Promise.all(\n            dbTables.map(async (dbTable) => {\n                const table = new Table()\n\n                table.name = this.driver.buildTableName(dbTable[\"TABLE_NAME\"])\n\n                // create columns from the loaded columns\n                table.columns = await Promise.all(\n                    dbColumns\n                        .filter(\n                            (dbColumn) =>\n                                dbColumn[\"TABLE_NAME\"] ===\n                                dbTable[\"TABLE_NAME\"],\n                        )\n                        .map(async (dbColumn) => {\n                            const columnUniqueIndices = dbIndices.filter(\n                                (dbIndex) => {\n                                    return (\n                                        dbIndex[\"TABLE_NAME\"] ===\n                                            dbTable[\"TABLE_NAME\"] &&\n                                        dbIndex[\"COLUMN_NAME\"] ===\n                                            dbColumn[\"COLUMN_NAME\"] &&\n                                        dbIndex[\"IS_UNIQUE\"] === true\n                                    )\n                                },\n                            )\n\n                            const tableMetadata =\n                                this.connection.entityMetadatas.find(\n                                    (metadata) =>\n                                        this.getTablePath(table) ===\n                                        this.getTablePath(metadata),\n                                )\n                            const hasIgnoredIndex =\n                                columnUniqueIndices.length > 0 &&\n                                tableMetadata &&\n                                tableMetadata.indices.some((index) => {\n                                    return columnUniqueIndices.some(\n                                        (uniqueIndex) => {\n                                            return (\n                                                index.name ===\n                                                    uniqueIndex[\"INDEX_NAME\"] &&\n                                                index.synchronize === false\n                                            )\n                                        },\n                                    )\n                                })\n\n                            const isConstraintComposite =\n                                columnUniqueIndices.every((uniqueIndex) => {\n                                    return dbIndices.some(\n                                        (dbIndex) =>\n                                            dbIndex[\"INDEX_NAME\"] ===\n                                                uniqueIndex[\"INDEX_NAME\"] &&\n                                            dbIndex[\"COLUMN_NAME\"] !==\n                                                dbColumn[\"COLUMN_NAME\"],\n                                    )\n                                })\n\n                            const tableColumn = new TableColumn()\n                            tableColumn.name = dbColumn[\"COLUMN_NAME\"]\n\n                            let fullType =\n                                dbColumn[\"SPANNER_TYPE\"].toLowerCase()\n                            if (fullType.indexOf(\"array\") !== -1) {\n                                tableColumn.isArray = true\n                                fullType = fullType.substring(\n                                    fullType.indexOf(\"<\") + 1,\n                                    fullType.indexOf(\">\"),\n                                )\n                            }\n\n                            if (fullType.indexOf(\"(\") !== -1) {\n                                tableColumn.type = fullType.substring(\n                                    0,\n                                    fullType.indexOf(\"(\"),\n                                )\n                            } else {\n                                tableColumn.type = fullType\n                            }\n\n                            if (\n                                this.driver.withLengthColumnTypes.indexOf(\n                                    tableColumn.type as ColumnType,\n                                ) !== -1\n                            ) {\n                                tableColumn.length = fullType.substring(\n                                    fullType.indexOf(\"(\") + 1,\n                                    fullType.indexOf(\")\"),\n                                )\n                            }\n\n                            if (dbColumn[\"IS_GENERATED\"] === \"ALWAYS\") {\n                                tableColumn.asExpression =\n                                    dbColumn[\"GENERATION_EXPRESSION\"]\n                                tableColumn.generatedType = \"STORED\"\n\n                                // We cannot relay on information_schema.columns.generation_expression, because it is formatted different.\n                                const asExpressionQuery =\n                                    this.selectTypeormMetadataSql({\n                                        table: dbTable[\"TABLE_NAME\"],\n                                        type: MetadataTableType.GENERATED_COLUMN,\n                                        name: tableColumn.name,\n                                    })\n\n                                const results = await this.query(\n                                    asExpressionQuery.query,\n                                    asExpressionQuery.parameters,\n                                )\n\n                                if (results[0] && results[0].value) {\n                                    tableColumn.asExpression = results[0].value\n                                } else {\n                                    tableColumn.asExpression = \"\"\n                                }\n                            }\n\n                            tableColumn.isUnique =\n                                columnUniqueIndices.length > 0 &&\n                                !hasIgnoredIndex &&\n                                !isConstraintComposite\n                            tableColumn.isNullable =\n                                dbColumn[\"IS_NULLABLE\"] === \"YES\"\n                            tableColumn.isPrimary = dbPrimaryKeys.some(\n                                (dbPrimaryKey) => {\n                                    return (\n                                        dbPrimaryKey[\"TABLE_NAME\"] ===\n                                            dbColumn[\"TABLE_NAME\"] &&\n                                        dbPrimaryKey[\"COLUMN_NAME\"] ===\n                                            dbColumn[\"COLUMN_NAME\"]\n                                    )\n                                },\n                            )\n\n                            return tableColumn\n                        }),\n                )\n\n                const tableForeignKeys = dbForeignKeys.filter(\n                    (dbForeignKey) => {\n                        return (\n                            dbForeignKey[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"]\n                        )\n                    },\n                )\n\n                table.foreignKeys = OrmUtils.uniq(\n                    tableForeignKeys,\n                    (dbForeignKey) => dbForeignKey[\"CONSTRAINT_NAME\"],\n                ).map((dbForeignKey) => {\n                    const foreignKeys = tableForeignKeys.filter(\n                        (dbFk) =>\n                            dbFk[\"CONSTRAINT_NAME\"] ===\n                            dbForeignKey[\"CONSTRAINT_NAME\"],\n                    )\n                    return new TableForeignKey({\n                        name: dbForeignKey[\"CONSTRAINT_NAME\"],\n                        columnNames: OrmUtils.uniq(\n                            foreignKeys.map((dbFk) => dbFk[\"COLUMN_NAME\"]),\n                        ),\n                        referencedDatabase:\n                            dbForeignKey[\"REFERENCED_TABLE_SCHEMA\"],\n                        referencedTableName:\n                            dbForeignKey[\"REFERENCED_TABLE_NAME\"],\n                        referencedColumnNames: OrmUtils.uniq(\n                            foreignKeys.map(\n                                (dbFk) => dbFk[\"REFERENCED_COLUMN_NAME\"],\n                            ),\n                        ),\n                        onDelete: dbForeignKey[\"DELETE_RULE\"],\n                        onUpdate: dbForeignKey[\"UPDATE_RULE\"],\n                    })\n                })\n\n                const tableIndices = dbIndices.filter(\n                    (dbIndex) =>\n                        dbIndex[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"],\n                )\n\n                table.indices = OrmUtils.uniq(\n                    tableIndices,\n                    (dbIndex) => dbIndex[\"INDEX_NAME\"],\n                ).map((constraint) => {\n                    const indices = tableIndices.filter((index) => {\n                        return index[\"INDEX_NAME\"] === constraint[\"INDEX_NAME\"]\n                    })\n\n                    return new TableIndex(<TableIndexOptions>{\n                        table: table,\n                        name: constraint[\"INDEX_NAME\"],\n                        columnNames: indices.map((i) => i[\"COLUMN_NAME\"]),\n                        isUnique: constraint[\"IS_UNIQUE\"],\n                        isNullFiltered: constraint[\"IS_NULL_FILTERED\"],\n                    })\n                })\n\n                const tableChecks = dbChecks.filter(\n                    (dbCheck) =>\n                        dbCheck[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"],\n                )\n\n                table.checks = OrmUtils.uniq(\n                    tableChecks,\n                    (dbIndex) => dbIndex[\"CONSTRAINT_NAME\"],\n                ).map((constraint) => {\n                    const checks = tableChecks.filter(\n                        (dbC) =>\n                            dbC[\"CONSTRAINT_NAME\"] ===\n                            constraint[\"CONSTRAINT_NAME\"],\n                    )\n                    return new TableCheck({\n                        name: constraint[\"CONSTRAINT_NAME\"],\n                        columnNames: checks.map((c) => c[\"COLUMN_NAME\"]),\n                        expression: constraint[\"CHECK_CLAUSE\"],\n                    })\n                })\n\n                return table\n            }),\n        )\n    }\n\n    /**\n     * Builds create table sql.\n     */\n    protected createTableSql(table: Table, createForeignKeys?: boolean): Query {\n        const columnDefinitions = table.columns\n            .map((column) => this.buildCreateColumnSql(column))\n            .join(\", \")\n        let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`\n\n        // we create unique indexes instead of unique constraints, because Spanner does not have unique constraints.\n        // if we mark column as Unique, it means that we create UNIQUE INDEX.\n        table.columns\n            .filter((column) => column.isUnique)\n            .forEach((column) => {\n                const isUniqueIndexExist = table.indices.some((index) => {\n                    return (\n                        index.columnNames.length === 1 &&\n                        !!index.isUnique &&\n                        index.columnNames.indexOf(column.name) !== -1\n                    )\n                })\n                const isUniqueConstraintExist = table.uniques.some((unique) => {\n                    return (\n                        unique.columnNames.length === 1 &&\n                        unique.columnNames.indexOf(column.name) !== -1\n                    )\n                })\n                if (!isUniqueIndexExist && !isUniqueConstraintExist)\n                    table.indices.push(\n                        new TableIndex({\n                            name: this.connection.namingStrategy.uniqueConstraintName(\n                                table,\n                                [column.name],\n                            ),\n                            columnNames: [column.name],\n                            isUnique: true,\n                        }),\n                    )\n            })\n\n        // as Spanner does not have unique constraints, we must create table indices from table uniques and mark them as unique.\n        if (table.uniques.length > 0) {\n            table.uniques.forEach((unique) => {\n                const uniqueExist = table.indices.some(\n                    (index) => index.name === unique.name,\n                )\n                if (!uniqueExist) {\n                    table.indices.push(\n                        new TableIndex({\n                            name: unique.name,\n                            columnNames: unique.columnNames,\n                            isUnique: true,\n                        }),\n                    )\n                }\n            })\n        }\n\n        if (table.checks.length > 0) {\n            const checksSql = table.checks\n                .map((check) => {\n                    const checkName = check.name\n                        ? check.name\n                        : this.connection.namingStrategy.checkConstraintName(\n                              table,\n                              check.expression!,\n                          )\n                    return `CONSTRAINT \\`${checkName}\\` CHECK (${check.expression})`\n                })\n                .join(\", \")\n\n            sql += `, ${checksSql}`\n        }\n\n        if (table.foreignKeys.length > 0 && createForeignKeys) {\n            const foreignKeysSql = table.foreignKeys\n                .map((fk) => {\n                    const columnNames = fk.columnNames\n                        .map((columnName) => `\\`${columnName}\\``)\n                        .join(\", \")\n                    if (!fk.name)\n                        fk.name = this.connection.namingStrategy.foreignKeyName(\n                            table,\n                            fk.columnNames,\n                            this.getTablePath(fk),\n                            fk.referencedColumnNames,\n                        )\n                    const referencedColumnNames = fk.referencedColumnNames\n                        .map((columnName) => `\\`${columnName}\\``)\n                        .join(\", \")\n\n                    return `CONSTRAINT \\`${\n                        fk.name\n                    }\\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(\n                        this.getTablePath(fk),\n                    )} (${referencedColumnNames})`\n                })\n                .join(\", \")\n\n            sql += `, ${foreignKeysSql}`\n        }\n\n        sql += `)`\n\n        const primaryColumns = table.columns.filter(\n            (column) => column.isPrimary,\n        )\n        if (primaryColumns.length > 0) {\n            const columnNames = primaryColumns\n                .map((column) => this.driver.escape(column.name))\n                .join(\", \")\n            sql += ` PRIMARY KEY (${columnNames})`\n        }\n\n        return new Query(sql)\n    }\n\n    /**\n     * Builds drop table sql.\n     */\n    protected dropTableSql(tableOrPath: Table | string): Query {\n        return new Query(`DROP TABLE ${this.escapePath(tableOrPath)}`)\n    }\n\n    protected createViewSql(view: View): Query {\n        const materializedClause = view.materialized ? \"MATERIALIZED \" : \"\"\n        const viewName = this.escapePath(view)\n\n        const expression =\n            typeof view.expression === \"string\"\n                ? view.expression\n                : view.expression(this.connection).getQuery()\n        return new Query(\n            `CREATE ${materializedClause}VIEW ${viewName} SQL SECURITY INVOKER AS ${expression}`,\n        )\n    }\n\n    protected async insertViewDefinitionSql(view: View): Promise<Query> {\n        let { schema, tableName: name } = this.driver.parseTableName(view)\n\n        const type = view.materialized\n            ? MetadataTableType.MATERIALIZED_VIEW\n            : MetadataTableType.VIEW\n        const expression =\n            typeof view.expression === \"string\"\n                ? view.expression.trim()\n                : view.expression(this.connection).getQuery()\n        return this.insertTypeormMetadataSql({\n            type,\n            schema,\n            name,\n            value: expression,\n        })\n    }\n\n    /**\n     * Builds drop view sql.\n     */\n    protected dropViewSql(view: View): Query {\n        const materializedClause = view.materialized ? \"MATERIALIZED \" : \"\"\n        return new Query(\n            `DROP ${materializedClause}VIEW ${this.escapePath(view)}`,\n        )\n    }\n\n    /**\n     * Builds remove view sql.\n     */\n    protected async deleteViewDefinitionSql(view: View): Promise<Query> {\n        let { schema, tableName: name } = this.driver.parseTableName(view)\n\n        const type = view.materialized\n            ? MetadataTableType.MATERIALIZED_VIEW\n            : MetadataTableType.VIEW\n        return this.deleteTypeormMetadataSql({ type, schema, name })\n    }\n\n    /**\n     * Builds create index sql.\n     */\n    protected createIndexSql(table: Table, index: TableIndex): Query {\n        const columns = index.columnNames\n            .map((columnName) => this.driver.escape(columnName))\n            .join(\", \")\n        let indexType = \"\"\n        if (index.isUnique) indexType += \"UNIQUE \"\n        if (index.isNullFiltered) indexType += \"NULL_FILTERED \"\n\n        return new Query(\n            `CREATE ${indexType}INDEX \\`${index.name}\\` ON ${this.escapePath(\n                table,\n            )} (${columns})`,\n        )\n    }\n\n    /**\n     * Builds drop index sql.\n     */\n    protected dropIndexSql(\n        table: Table,\n        indexOrName: TableIndex | string,\n    ): Query {\n        let indexName =\n            indexOrName instanceof TableIndex ? indexOrName.name : indexOrName\n        return new Query(`DROP INDEX \\`${indexName}\\``)\n    }\n\n    /**\n     * Builds create check constraint sql.\n     */\n    protected createCheckConstraintSql(\n        table: Table,\n        checkConstraint: TableCheck,\n    ): Query {\n        return new Query(\n            `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \\`${\n                checkConstraint.name\n            }\\` CHECK (${checkConstraint.expression})`,\n        )\n    }\n\n    /**\n     * Builds drop check constraint sql.\n     */\n    protected dropCheckConstraintSql(\n        table: Table,\n        checkOrName: TableCheck | string,\n    ): Query {\n        const checkName =\n            checkOrName instanceof TableCheck ? checkOrName.name : checkOrName\n        return new Query(\n            `ALTER TABLE ${this.escapePath(\n                table,\n            )} DROP CONSTRAINT \\`${checkName}\\``,\n        )\n    }\n\n    /**\n     * Builds create foreign key sql.\n     */\n    protected createForeignKeySql(\n        table: Table,\n        foreignKey: TableForeignKey,\n    ): Query {\n        const columnNames = foreignKey.columnNames\n            .map((column) => this.driver.escape(column))\n            .join(\", \")\n        const referencedColumnNames = foreignKey.referencedColumnNames\n            .map((column) => this.driver.escape(column))\n            .join(\",\")\n        let sql =\n            `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \\`${\n                foreignKey.name\n            }\\` FOREIGN KEY (${columnNames}) ` +\n            `REFERENCES ${this.escapePath(\n                this.getTablePath(foreignKey),\n            )} (${referencedColumnNames})`\n\n        return new Query(sql)\n    }\n\n    /**\n     * Builds drop foreign key sql.\n     */\n    protected dropForeignKeySql(\n        table: Table,\n        foreignKeyOrName: TableForeignKey | string,\n    ): Query {\n        const foreignKeyName =\n            foreignKeyOrName instanceof TableForeignKey\n                ? foreignKeyOrName.name\n                : foreignKeyOrName\n        return new Query(\n            `ALTER TABLE ${this.escapePath(\n                table,\n            )} DROP CONSTRAINT \\`${foreignKeyName}\\``,\n        )\n    }\n\n    /**\n     * Escapes given table or view path.\n     */\n    protected escapePath(target: Table | View | string): string {\n        const { tableName } = this.driver.parseTableName(target)\n        return `\\`${tableName}\\``\n    }\n\n    /**\n     * Builds a part of query to create/change a column.\n     */\n    protected buildCreateColumnSql(column: TableColumn) {\n        let c = `${this.driver.escape(\n            column.name,\n        )} ${this.connection.driver.createFullType(column)}`\n\n        // Spanner supports only STORED generated column type\n        if (column.generatedType === \"STORED\" && column.asExpression) {\n            c += ` AS (${column.asExpression}) STORED`\n        } else {\n            if (!column.isNullable) c += \" NOT NULL\"\n        }\n\n        return c\n    }\n\n    /**\n     * Executes sql used special for schema build.\n     */\n    protected async executeQueries(\n        upQueries: Query | Query[],\n        downQueries: Query | Query[],\n    ): Promise<void> {\n        if (upQueries instanceof Query) upQueries = [upQueries]\n        if (downQueries instanceof Query) downQueries = [downQueries]\n\n        this.sqlInMemory.upQueries.push(...upQueries)\n        this.sqlInMemory.downQueries.push(...downQueries)\n\n        // if sql-in-memory mode is enabled then simply store sql in memory and return\n        if (this.sqlMemoryMode === true)\n            return Promise.resolve() as Promise<any>\n\n        for (const { query, parameters } of upQueries) {\n            if (this.isDMLQuery(query)) {\n                await this.query(query, parameters)\n            } else {\n                await this.updateDDL(query, parameters)\n            }\n        }\n    }\n\n    protected isDMLQuery(query: string): boolean {\n        return (\n            query.startsWith(\"INSERT\") ||\n            query.startsWith(\"UPDATE\") ||\n            query.startsWith(\"DELETE\")\n        )\n    }\n\n    /**\n     * Change table comment.\n     */\n    changeTableComment(\n        tableOrName: Table | string,\n        comment?: string,\n    ): Promise<void> {\n        throw new TypeORMError(\n            `spanner driver does not support change table comment.`,\n        )\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}