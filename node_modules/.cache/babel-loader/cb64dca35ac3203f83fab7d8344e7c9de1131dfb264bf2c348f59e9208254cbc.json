{"ast":null,"code":"import { DriverUtils } from \"../driver/DriverUtils\";\nimport { TypeORMError } from \"../error/TypeORMError\";\nimport { FindOptionsUtils } from \"../find-options/FindOptionsUtils\";\nimport { TreeRepositoryUtils } from \"../util/TreeRepositoryUtils\";\nimport { Repository } from \"./Repository\";\n/**\n * Repository with additional functions to work with trees.\n *\n * @see Repository\n */\nexport class TreeRepository extends Repository {\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Gets complete trees for all roots in the table.\n   */\n  async findTrees(options) {\n    const roots = await this.findRoots(options);\n    await Promise.all(roots.map(root => this.findDescendantsTree(root, options)));\n    return roots;\n  }\n  /**\n   * Roots are entities that have no ancestors. Finds them all.\n   */\n  findRoots(options) {\n    const escapeAlias = alias => this.manager.connection.driver.escape(alias);\n    const escapeColumn = column => this.manager.connection.driver.escape(column);\n    const joinColumn = this.metadata.treeParentRelation.joinColumns[0];\n    const parentPropertyName = joinColumn.givenDatabaseName || joinColumn.databaseName;\n    const qb = this.createQueryBuilder(\"treeEntity\");\n    FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);\n    return qb.where(`${escapeAlias(\"treeEntity\")}.${escapeColumn(parentPropertyName)} IS NULL`).getMany();\n  }\n  /**\n   * Gets all children (descendants) of the given entity. Returns them all in a flat array.\n   */\n  findDescendants(entity, options) {\n    const qb = this.createDescendantsQueryBuilder(\"treeEntity\", \"treeClosure\", entity);\n    FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);\n    return qb.getMany();\n  }\n  /**\n   * Gets all children (descendants) of the given entity. Returns them in a tree - nested into each other.\n   */\n  async findDescendantsTree(entity, options) {\n    // todo: throw exception if there is no column of this relation?\n    const qb = this.createDescendantsQueryBuilder(\"treeEntity\", \"treeClosure\", entity);\n    FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);\n    const entities = await qb.getRawAndEntities();\n    const relationMaps = TreeRepositoryUtils.createRelationMaps(this.manager, this.metadata, \"treeEntity\", entities.raw);\n    TreeRepositoryUtils.buildChildrenEntityTree(this.metadata, entity, entities.entities, relationMaps, {\n      depth: -1,\n      ...options\n    });\n    return entity;\n  }\n  /**\n   * Gets number of descendants of the entity.\n   */\n  countDescendants(entity) {\n    return this.createDescendantsQueryBuilder(\"treeEntity\", \"treeClosure\", entity).getCount();\n  }\n  /**\n   * Creates a query builder used to get descendants of the entities in a tree.\n   */\n  createDescendantsQueryBuilder(alias, closureTableAlias, entity) {\n    // create shortcuts for better readability\n    const escape = alias => this.manager.connection.driver.escape(alias);\n    if (this.metadata.treeType === \"closure-table\") {\n      const joinCondition = this.metadata.closureJunctionTable.descendantColumns.map(column => {\n        return escape(closureTableAlias) + \".\" + escape(column.propertyPath) + \" = \" + escape(alias) + \".\" + escape(column.referencedColumn.propertyPath);\n      }).join(\" AND \");\n      const parameters = {};\n      const whereCondition = this.metadata.closureJunctionTable.ancestorColumns.map(column => {\n        parameters[column.referencedColumn.propertyName] = column.referencedColumn.getEntityValue(entity);\n        return escape(closureTableAlias) + \".\" + escape(column.propertyPath) + \" = :\" + column.referencedColumn.propertyName;\n      }).join(\" AND \");\n      return this.createQueryBuilder(alias).innerJoin(this.metadata.closureJunctionTable.tableName, closureTableAlias, joinCondition).where(whereCondition).setParameters(parameters);\n    } else if (this.metadata.treeType === \"nested-set\") {\n      const whereCondition = alias + \".\" + this.metadata.nestedSetLeftColumn.propertyPath + \" BETWEEN \" + \"joined.\" + this.metadata.nestedSetLeftColumn.propertyPath + \" AND joined.\" + this.metadata.nestedSetRightColumn.propertyPath;\n      const parameters = {};\n      const joinCondition = this.metadata.treeParentRelation.joinColumns.map(joinColumn => {\n        const parameterName = joinColumn.referencedColumn.propertyPath.replace(\".\", \"_\");\n        parameters[parameterName] = joinColumn.referencedColumn.getEntityValue(entity);\n        return \"joined.\" + joinColumn.referencedColumn.propertyPath + \" = :\" + parameterName;\n      }).join(\" AND \");\n      return this.createQueryBuilder(alias).innerJoin(this.metadata.targetName, \"joined\", whereCondition).where(joinCondition, parameters);\n    } else if (this.metadata.treeType === \"materialized-path\") {\n      return this.createQueryBuilder(alias).where(qb => {\n        const subQuery = qb.subQuery().select(`${this.metadata.targetName}.${this.metadata.materializedPathColumn.propertyPath}`, \"path\").from(this.metadata.target, this.metadata.targetName).whereInIds(this.metadata.getEntityIdMap(entity));\n        if (DriverUtils.isSQLiteFamily(this.manager.connection.driver)) {\n          return `${alias}.${this.metadata.materializedPathColumn.propertyPath} LIKE ${subQuery.getQuery()} || '%'`;\n        } else {\n          return `${alias}.${this.metadata.materializedPathColumn.propertyPath} LIKE NULLIF(CONCAT(${subQuery.getQuery()}, '%'), '%')`;\n        }\n      });\n    }\n    throw new TypeORMError(`Supported only in tree entities`);\n  }\n  /**\n   * Gets all parents (ancestors) of the given entity. Returns them all in a flat array.\n   */\n  findAncestors(entity, options) {\n    const qb = this.createAncestorsQueryBuilder(\"treeEntity\", \"treeClosure\", entity);\n    FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);\n    return qb.getMany();\n  }\n  /**\n   * Gets all parents (ancestors) of the given entity. Returns them in a tree - nested into each other.\n   */\n  async findAncestorsTree(entity, options) {\n    // todo: throw exception if there is no column of this relation?\n    const qb = this.createAncestorsQueryBuilder(\"treeEntity\", \"treeClosure\", entity);\n    FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);\n    const entities = await qb.getRawAndEntities();\n    const relationMaps = TreeRepositoryUtils.createRelationMaps(this.manager, this.metadata, \"treeEntity\", entities.raw);\n    TreeRepositoryUtils.buildParentEntityTree(this.metadata, entity, entities.entities, relationMaps);\n    return entity;\n  }\n  /**\n   * Gets number of ancestors of the entity.\n   */\n  countAncestors(entity) {\n    return this.createAncestorsQueryBuilder(\"treeEntity\", \"treeClosure\", entity).getCount();\n  }\n  /**\n   * Creates a query builder used to get ancestors of the entities in the tree.\n   */\n  createAncestorsQueryBuilder(alias, closureTableAlias, entity) {\n    // create shortcuts for better readability\n    // const escape = (alias: string) => this.manager.connection.driver.escape(alias);\n    if (this.metadata.treeType === \"closure-table\") {\n      const joinCondition = this.metadata.closureJunctionTable.ancestorColumns.map(column => {\n        return closureTableAlias + \".\" + column.propertyPath + \" = \" + alias + \".\" + column.referencedColumn.propertyPath;\n      }).join(\" AND \");\n      const parameters = {};\n      const whereCondition = this.metadata.closureJunctionTable.descendantColumns.map(column => {\n        parameters[column.referencedColumn.propertyName] = column.referencedColumn.getEntityValue(entity);\n        return closureTableAlias + \".\" + column.propertyPath + \" = :\" + column.referencedColumn.propertyName;\n      }).join(\" AND \");\n      return this.createQueryBuilder(alias).innerJoin(this.metadata.closureJunctionTable.tableName, closureTableAlias, joinCondition).where(whereCondition).setParameters(parameters);\n    } else if (this.metadata.treeType === \"nested-set\") {\n      const joinCondition = \"joined.\" + this.metadata.nestedSetLeftColumn.propertyPath + \" BETWEEN \" + alias + \".\" + this.metadata.nestedSetLeftColumn.propertyPath + \" AND \" + alias + \".\" + this.metadata.nestedSetRightColumn.propertyPath;\n      const parameters = {};\n      const whereCondition = this.metadata.treeParentRelation.joinColumns.map(joinColumn => {\n        const parameterName = joinColumn.referencedColumn.propertyPath.replace(\".\", \"_\");\n        parameters[parameterName] = joinColumn.referencedColumn.getEntityValue(entity);\n        return \"joined.\" + joinColumn.referencedColumn.propertyPath + \" = :\" + parameterName;\n      }).join(\" AND \");\n      return this.createQueryBuilder(alias).innerJoin(this.metadata.targetName, \"joined\", joinCondition).where(whereCondition, parameters);\n    } else if (this.metadata.treeType === \"materialized-path\") {\n      // example: SELECT * FROM category category WHERE (SELECT mpath FROM `category` WHERE id = 2) LIKE CONCAT(category.mpath, '%');\n      return this.createQueryBuilder(alias).where(qb => {\n        const subQuery = qb.subQuery().select(`${this.metadata.targetName}.${this.metadata.materializedPathColumn.propertyPath}`, \"path\").from(this.metadata.target, this.metadata.targetName).whereInIds(this.metadata.getEntityIdMap(entity));\n        if (DriverUtils.isSQLiteFamily(this.manager.connection.driver)) {\n          return `${subQuery.getQuery()} LIKE ${alias}.${this.metadata.materializedPathColumn.propertyPath} || '%'`;\n        } else {\n          return `${subQuery.getQuery()} LIKE CONCAT(${alias}.${this.metadata.materializedPathColumn.propertyPath}, '%')`;\n        }\n      });\n    }\n    throw new TypeORMError(`Supported only in tree entities`);\n  }\n}","map":{"version":3,"names":["DriverUtils","TypeORMError","FindOptionsUtils","TreeRepositoryUtils","Repository","TreeRepository","findTrees","options","roots","findRoots","Promise","all","map","root","findDescendantsTree","escapeAlias","alias","manager","connection","driver","escape","escapeColumn","column","joinColumn","metadata","treeParentRelation","joinColumns","parentPropertyName","givenDatabaseName","databaseName","qb","createQueryBuilder","applyOptionsToTreeQueryBuilder","where","getMany","findDescendants","entity","createDescendantsQueryBuilder","entities","getRawAndEntities","relationMaps","createRelationMaps","raw","buildChildrenEntityTree","depth","countDescendants","getCount","closureTableAlias","treeType","joinCondition","closureJunctionTable","descendantColumns","propertyPath","referencedColumn","join","parameters","whereCondition","ancestorColumns","propertyName","getEntityValue","innerJoin","tableName","setParameters","nestedSetLeftColumn","nestedSetRightColumn","parameterName","replace","targetName","subQuery","select","materializedPathColumn","from","target","whereInIds","getEntityIdMap","isSQLiteFamily","getQuery","findAncestors","createAncestorsQueryBuilder","findAncestorsTree","buildParentEntityTree","countAncestors"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\repository\\TreeRepository.ts"],"sourcesContent":["import { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\nimport { TypeORMError } from \"../error/TypeORMError\"\nimport { FindOptionsUtils } from \"../find-options/FindOptionsUtils\"\nimport { FindTreeOptions } from \"../find-options/FindTreeOptions\"\nimport { SelectQueryBuilder } from \"../query-builder/SelectQueryBuilder\"\nimport { TreeRepositoryUtils } from \"../util/TreeRepositoryUtils\"\nimport { Repository } from \"./Repository\"\n\n/**\n * Repository with additional functions to work with trees.\n *\n * @see Repository\n */\nexport class TreeRepository<\n    Entity extends ObjectLiteral,\n> extends Repository<Entity> {\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets complete trees for all roots in the table.\n     */\n    async findTrees(options?: FindTreeOptions): Promise<Entity[]> {\n        const roots = await this.findRoots(options)\n        await Promise.all(\n            roots.map((root) => this.findDescendantsTree(root, options)),\n        )\n        return roots\n    }\n\n    /**\n     * Roots are entities that have no ancestors. Finds them all.\n     */\n    findRoots(options?: FindTreeOptions): Promise<Entity[]> {\n        const escapeAlias = (alias: string) =>\n            this.manager.connection.driver.escape(alias)\n        const escapeColumn = (column: string) =>\n            this.manager.connection.driver.escape(column)\n\n        const joinColumn = this.metadata.treeParentRelation!.joinColumns[0]\n        const parentPropertyName =\n            joinColumn.givenDatabaseName || joinColumn.databaseName\n\n        const qb = this.createQueryBuilder(\"treeEntity\")\n        FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options)\n\n        return qb\n            .where(\n                `${escapeAlias(\"treeEntity\")}.${escapeColumn(\n                    parentPropertyName,\n                )} IS NULL`,\n            )\n            .getMany()\n    }\n\n    /**\n     * Gets all children (descendants) of the given entity. Returns them all in a flat array.\n     */\n    findDescendants(\n        entity: Entity,\n        options?: FindTreeOptions,\n    ): Promise<Entity[]> {\n        const qb = this.createDescendantsQueryBuilder(\n            \"treeEntity\",\n            \"treeClosure\",\n            entity,\n        )\n        FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options)\n        return qb.getMany()\n    }\n\n    /**\n     * Gets all children (descendants) of the given entity. Returns them in a tree - nested into each other.\n     */\n    async findDescendantsTree(\n        entity: Entity,\n        options?: FindTreeOptions,\n    ): Promise<Entity> {\n        // todo: throw exception if there is no column of this relation?\n\n        const qb: SelectQueryBuilder<Entity> =\n            this.createDescendantsQueryBuilder(\n                \"treeEntity\",\n                \"treeClosure\",\n                entity,\n            )\n        FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options)\n\n        const entities = await qb.getRawAndEntities()\n        const relationMaps = TreeRepositoryUtils.createRelationMaps(\n            this.manager,\n            this.metadata,\n            \"treeEntity\",\n            entities.raw,\n        )\n        TreeRepositoryUtils.buildChildrenEntityTree(\n            this.metadata,\n            entity,\n            entities.entities,\n            relationMaps,\n            {\n                depth: -1,\n                ...options,\n            },\n        )\n\n        return entity\n    }\n\n    /**\n     * Gets number of descendants of the entity.\n     */\n    countDescendants(entity: Entity): Promise<number> {\n        return this.createDescendantsQueryBuilder(\n            \"treeEntity\",\n            \"treeClosure\",\n            entity,\n        ).getCount()\n    }\n\n    /**\n     * Creates a query builder used to get descendants of the entities in a tree.\n     */\n    createDescendantsQueryBuilder(\n        alias: string,\n        closureTableAlias: string,\n        entity: Entity,\n    ): SelectQueryBuilder<Entity> {\n        // create shortcuts for better readability\n        const escape = (alias: string) =>\n            this.manager.connection.driver.escape(alias)\n\n        if (this.metadata.treeType === \"closure-table\") {\n            const joinCondition =\n                this.metadata.closureJunctionTable.descendantColumns\n                    .map((column) => {\n                        return (\n                            escape(closureTableAlias) +\n                            \".\" +\n                            escape(column.propertyPath) +\n                            \" = \" +\n                            escape(alias) +\n                            \".\" +\n                            escape(column.referencedColumn!.propertyPath)\n                        )\n                    })\n                    .join(\" AND \")\n\n            const parameters: ObjectLiteral = {}\n            const whereCondition =\n                this.metadata.closureJunctionTable.ancestorColumns\n                    .map((column) => {\n                        parameters[column.referencedColumn!.propertyName] =\n                            column.referencedColumn!.getEntityValue(entity)\n                        return (\n                            escape(closureTableAlias) +\n                            \".\" +\n                            escape(column.propertyPath) +\n                            \" = :\" +\n                            column.referencedColumn!.propertyName\n                        )\n                    })\n                    .join(\" AND \")\n\n            return this.createQueryBuilder(alias)\n                .innerJoin(\n                    this.metadata.closureJunctionTable.tableName,\n                    closureTableAlias,\n                    joinCondition,\n                )\n                .where(whereCondition)\n                .setParameters(parameters)\n        } else if (this.metadata.treeType === \"nested-set\") {\n            const whereCondition =\n                alias +\n                \".\" +\n                this.metadata.nestedSetLeftColumn!.propertyPath +\n                \" BETWEEN \" +\n                \"joined.\" +\n                this.metadata.nestedSetLeftColumn!.propertyPath +\n                \" AND joined.\" +\n                this.metadata.nestedSetRightColumn!.propertyPath\n            const parameters: ObjectLiteral = {}\n            const joinCondition = this.metadata\n                .treeParentRelation!.joinColumns.map((joinColumn) => {\n                    const parameterName =\n                        joinColumn.referencedColumn!.propertyPath.replace(\n                            \".\",\n                            \"_\",\n                        )\n                    parameters[parameterName] =\n                        joinColumn.referencedColumn!.getEntityValue(entity)\n                    return (\n                        \"joined.\" +\n                        joinColumn.referencedColumn!.propertyPath +\n                        \" = :\" +\n                        parameterName\n                    )\n                })\n                .join(\" AND \")\n\n            return this.createQueryBuilder(alias)\n                .innerJoin(this.metadata.targetName, \"joined\", whereCondition)\n                .where(joinCondition, parameters)\n        } else if (this.metadata.treeType === \"materialized-path\") {\n            return this.createQueryBuilder(alias).where((qb) => {\n                const subQuery = qb\n                    .subQuery()\n                    .select(\n                        `${this.metadata.targetName}.${\n                            this.metadata.materializedPathColumn!.propertyPath\n                        }`,\n                        \"path\",\n                    )\n                    .from(this.metadata.target, this.metadata.targetName)\n                    .whereInIds(this.metadata.getEntityIdMap(entity))\n\n                if (\n                    DriverUtils.isSQLiteFamily(this.manager.connection.driver)\n                ) {\n                    return `${alias}.${\n                        this.metadata.materializedPathColumn!.propertyPath\n                    } LIKE ${subQuery.getQuery()} || '%'`\n                } else {\n                    return `${alias}.${\n                        this.metadata.materializedPathColumn!.propertyPath\n                    } LIKE NULLIF(CONCAT(${subQuery.getQuery()}, '%'), '%')`\n                }\n            })\n        }\n\n        throw new TypeORMError(`Supported only in tree entities`)\n    }\n\n    /**\n     * Gets all parents (ancestors) of the given entity. Returns them all in a flat array.\n     */\n    findAncestors(\n        entity: Entity,\n        options?: FindTreeOptions,\n    ): Promise<Entity[]> {\n        const qb = this.createAncestorsQueryBuilder(\n            \"treeEntity\",\n            \"treeClosure\",\n            entity,\n        )\n        FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options)\n        return qb.getMany()\n    }\n\n    /**\n     * Gets all parents (ancestors) of the given entity. Returns them in a tree - nested into each other.\n     */\n    async findAncestorsTree(\n        entity: Entity,\n        options?: FindTreeOptions,\n    ): Promise<Entity> {\n        // todo: throw exception if there is no column of this relation?\n        const qb = this.createAncestorsQueryBuilder(\n            \"treeEntity\",\n            \"treeClosure\",\n            entity,\n        )\n        FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options)\n\n        const entities = await qb.getRawAndEntities()\n        const relationMaps = TreeRepositoryUtils.createRelationMaps(\n            this.manager,\n            this.metadata,\n            \"treeEntity\",\n            entities.raw,\n        )\n        TreeRepositoryUtils.buildParentEntityTree(\n            this.metadata,\n            entity,\n            entities.entities,\n            relationMaps,\n        )\n        return entity\n    }\n\n    /**\n     * Gets number of ancestors of the entity.\n     */\n    countAncestors(entity: Entity): Promise<number> {\n        return this.createAncestorsQueryBuilder(\n            \"treeEntity\",\n            \"treeClosure\",\n            entity,\n        ).getCount()\n    }\n\n    /**\n     * Creates a query builder used to get ancestors of the entities in the tree.\n     */\n    createAncestorsQueryBuilder(\n        alias: string,\n        closureTableAlias: string,\n        entity: Entity,\n    ): SelectQueryBuilder<Entity> {\n        // create shortcuts for better readability\n        // const escape = (alias: string) => this.manager.connection.driver.escape(alias);\n\n        if (this.metadata.treeType === \"closure-table\") {\n            const joinCondition =\n                this.metadata.closureJunctionTable.ancestorColumns\n                    .map((column) => {\n                        return (\n                            closureTableAlias +\n                            \".\" +\n                            column.propertyPath +\n                            \" = \" +\n                            alias +\n                            \".\" +\n                            column.referencedColumn!.propertyPath\n                        )\n                    })\n                    .join(\" AND \")\n\n            const parameters: ObjectLiteral = {}\n            const whereCondition =\n                this.metadata.closureJunctionTable.descendantColumns\n                    .map((column) => {\n                        parameters[column.referencedColumn!.propertyName] =\n                            column.referencedColumn!.getEntityValue(entity)\n                        return (\n                            closureTableAlias +\n                            \".\" +\n                            column.propertyPath +\n                            \" = :\" +\n                            column.referencedColumn!.propertyName\n                        )\n                    })\n                    .join(\" AND \")\n\n            return this.createQueryBuilder(alias)\n                .innerJoin(\n                    this.metadata.closureJunctionTable.tableName,\n                    closureTableAlias,\n                    joinCondition,\n                )\n                .where(whereCondition)\n                .setParameters(parameters)\n        } else if (this.metadata.treeType === \"nested-set\") {\n            const joinCondition =\n                \"joined.\" +\n                this.metadata.nestedSetLeftColumn!.propertyPath +\n                \" BETWEEN \" +\n                alias +\n                \".\" +\n                this.metadata.nestedSetLeftColumn!.propertyPath +\n                \" AND \" +\n                alias +\n                \".\" +\n                this.metadata.nestedSetRightColumn!.propertyPath\n            const parameters: ObjectLiteral = {}\n            const whereCondition = this.metadata\n                .treeParentRelation!.joinColumns.map((joinColumn) => {\n                    const parameterName =\n                        joinColumn.referencedColumn!.propertyPath.replace(\n                            \".\",\n                            \"_\",\n                        )\n                    parameters[parameterName] =\n                        joinColumn.referencedColumn!.getEntityValue(entity)\n                    return (\n                        \"joined.\" +\n                        joinColumn.referencedColumn!.propertyPath +\n                        \" = :\" +\n                        parameterName\n                    )\n                })\n                .join(\" AND \")\n\n            return this.createQueryBuilder(alias)\n                .innerJoin(this.metadata.targetName, \"joined\", joinCondition)\n                .where(whereCondition, parameters)\n        } else if (this.metadata.treeType === \"materialized-path\") {\n            // example: SELECT * FROM category category WHERE (SELECT mpath FROM `category` WHERE id = 2) LIKE CONCAT(category.mpath, '%');\n            return this.createQueryBuilder(alias).where((qb) => {\n                const subQuery = qb\n                    .subQuery()\n                    .select(\n                        `${this.metadata.targetName}.${\n                            this.metadata.materializedPathColumn!.propertyPath\n                        }`,\n                        \"path\",\n                    )\n                    .from(this.metadata.target, this.metadata.targetName)\n                    .whereInIds(this.metadata.getEntityIdMap(entity))\n\n                if (\n                    DriverUtils.isSQLiteFamily(this.manager.connection.driver)\n                ) {\n                    return `${subQuery.getQuery()} LIKE ${alias}.${\n                        this.metadata.materializedPathColumn!.propertyPath\n                    } || '%'`\n                } else {\n                    return `${subQuery.getQuery()} LIKE CONCAT(${alias}.${\n                        this.metadata.materializedPathColumn!.propertyPath\n                    }, '%')`\n                }\n            })\n        }\n\n        throw new TypeORMError(`Supported only in tree entities`)\n    }\n\n    /**\n     * Moves entity to the children of then given entity.\n     *\n    move(entity: Entity, to: Entity): Promise<void> {\n        return Promise.resolve();\n    } */\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}