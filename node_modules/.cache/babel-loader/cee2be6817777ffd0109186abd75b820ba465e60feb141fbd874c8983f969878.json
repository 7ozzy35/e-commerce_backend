{"ast":null,"code":"import { EntityNotFoundError } from \"../error/EntityNotFoundError\";\nimport { QueryRunnerProviderAlreadyReleasedError } from \"../error/QueryRunnerProviderAlreadyReleasedError\";\nimport { NoNeedToReleaseEntityManagerError } from \"../error/NoNeedToReleaseEntityManagerError\";\nimport { MongoRepository } from \"../repository/MongoRepository\";\nimport { TreeRepository } from \"../repository/TreeRepository\";\nimport { Repository } from \"../repository/Repository\";\nimport { FindOptionsUtils } from \"../find-options/FindOptionsUtils\";\nimport { PlainObjectToNewEntityTransformer } from \"../query-builder/transformer/PlainObjectToNewEntityTransformer\";\nimport { PlainObjectToDatabaseEntityTransformer } from \"../query-builder/transformer/PlainObjectToDatabaseEntityTransformer\";\nimport { CustomRepositoryCannotInheritRepositoryError, CustomRepositoryNotFoundError, TreeRepositoryNotSupportedError, TypeORMError } from \"../error\";\nimport { AbstractRepository } from \"../repository/AbstractRepository\";\nimport { EntityPersistExecutor } from \"../persistence/EntityPersistExecutor\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { getMetadataArgsStorage } from \"../globals\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\n/**\n * Entity manager supposed to work with any entity, automatically find its repository and call its methods,\n * whatever entity type are you passing.\n */\nexport class EntityManager {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection, queryRunner) {\n    this[\"@instanceof\"] = Symbol.for(\"EntityManager\");\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n    /**\n     * Once created and then reused by repositories.\n     * Created as a future replacement for the #repositories to provide a bit more perf optimization.\n     */\n    this.repositories = new Map();\n    /**\n     * Once created and then reused by repositories.\n     */\n    this.treeRepositories = [];\n    /**\n     * Plain to object transformer used in create and merge operations.\n     */\n    this.plainObjectToEntityTransformer = new PlainObjectToNewEntityTransformer();\n    this.connection = connection;\n    if (queryRunner) {\n      this.queryRunner = queryRunner;\n      // dynamic: this.queryRunner = manager;\n      ObjectUtils.assign(this.queryRunner, {\n        manager: this\n      });\n    }\n  }\n  /**\n   * Wraps given function execution (and all operations made there) in a transaction.\n   * All database operations must be executed using provided entity manager.\n   */\n  async transaction(isolationOrRunInTransaction, runInTransactionParam) {\n    const isolation = typeof isolationOrRunInTransaction === \"string\" ? isolationOrRunInTransaction : undefined;\n    const runInTransaction = typeof isolationOrRunInTransaction === \"function\" ? isolationOrRunInTransaction : runInTransactionParam;\n    if (!runInTransaction) {\n      throw new TypeORMError(`Transaction method requires callback in second parameter if isolation level is supplied.`);\n    }\n    if (this.queryRunner && this.queryRunner.isReleased) throw new QueryRunnerProviderAlreadyReleasedError();\n    // if query runner is already defined in this class, it means this entity manager was already created for a single connection\n    // if its not defined we create a new query runner - single connection where we'll execute all our operations\n    const queryRunner = this.queryRunner || this.connection.createQueryRunner();\n    try {\n      await queryRunner.startTransaction(isolation);\n      const result = await runInTransaction(queryRunner.manager);\n      await queryRunner.commitTransaction();\n      return result;\n    } catch (err) {\n      try {\n        // we throw original error even if rollback thrown an error\n        await queryRunner.rollbackTransaction();\n      } catch (rollbackError) {}\n      throw err;\n    } finally {\n      if (!this.queryRunner)\n        // if we used a new query runner provider then release it\n        await queryRunner.release();\n    }\n  }\n  /**\n   * Executes raw SQL query and returns raw database results.\n   */\n  async query(query, parameters) {\n    return this.connection.query(query, parameters, this.queryRunner);\n  }\n  /**\n   * Creates a new query builder that can be used to build a SQL query.\n   */\n  createQueryBuilder(entityClass, alias, queryRunner) {\n    if (alias) {\n      return this.connection.createQueryBuilder(entityClass, alias, queryRunner || this.queryRunner);\n    } else {\n      return this.connection.createQueryBuilder(entityClass || queryRunner || this.queryRunner);\n    }\n  }\n  /**\n   * Checks if entity has an id by its Function type or schema name.\n   */\n  hasId(targetOrEntity, maybeEntity) {\n    const target = arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor;\n    const entity = arguments.length === 2 ? maybeEntity : targetOrEntity;\n    const metadata = this.connection.getMetadata(target);\n    return metadata.hasId(entity);\n  }\n  /**\n   * Gets entity mixed id.\n   */\n  getId(targetOrEntity, maybeEntity) {\n    const target = arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor;\n    const entity = arguments.length === 2 ? maybeEntity : targetOrEntity;\n    const metadata = this.connection.getMetadata(target);\n    return metadata.getEntityIdMixedMap(entity);\n  }\n  /**\n   * Creates a new entity instance or instances.\n   * Can copy properties from the given object into new entities.\n   */\n  create(entityClass, plainObjectOrObjects) {\n    const metadata = this.connection.getMetadata(entityClass);\n    if (!plainObjectOrObjects) return metadata.create(this.queryRunner);\n    if (Array.isArray(plainObjectOrObjects)) return plainObjectOrObjects.map(plainEntityLike => this.create(entityClass, plainEntityLike));\n    const mergeIntoEntity = metadata.create(this.queryRunner);\n    this.plainObjectToEntityTransformer.transform(mergeIntoEntity, plainObjectOrObjects, metadata, true);\n    return mergeIntoEntity;\n  }\n  /**\n   * Merges two entities into one new entity.\n   */\n  merge(entityClass, mergeIntoEntity, ...entityLikes) {\n    // todo: throw exception if entity manager is released\n    const metadata = this.connection.getMetadata(entityClass);\n    entityLikes.forEach(object => this.plainObjectToEntityTransformer.transform(mergeIntoEntity, object, metadata));\n    return mergeIntoEntity;\n  }\n  /**\n   * Creates a new entity from the given plain javascript object. If entity already exist in the database, then\n   * it loads it (and everything related to it), replaces all values with the new ones from the given object\n   * and returns this new entity. This new entity is actually a loaded from the db entity with all properties\n   * replaced from the new object.\n   */\n  async preload(entityClass, entityLike) {\n    const metadata = this.connection.getMetadata(entityClass);\n    const plainObjectToDatabaseEntityTransformer = new PlainObjectToDatabaseEntityTransformer(this.connection.manager);\n    const transformedEntity = await plainObjectToDatabaseEntityTransformer.transform(entityLike, metadata);\n    if (transformedEntity) return this.merge(entityClass, transformedEntity, entityLike);\n    return undefined;\n  }\n  /**\n   * Saves a given entity in the database.\n   */\n  save(targetOrEntity, maybeEntityOrOptions, maybeOptions) {\n    // normalize mixed parameters\n    let target = arguments.length > 1 && (typeof targetOrEntity === \"function\" || InstanceChecker.isEntitySchema(targetOrEntity) || typeof targetOrEntity === \"string\") ? targetOrEntity : undefined;\n    const entity = target ? maybeEntityOrOptions : targetOrEntity;\n    const options = target ? maybeOptions : maybeEntityOrOptions;\n    if (InstanceChecker.isEntitySchema(target)) target = target.options.name;\n    // if user passed empty array of entities then we don't need to do anything\n    if (Array.isArray(entity) && entity.length === 0) return Promise.resolve(entity);\n    // execute save operation\n    return new EntityPersistExecutor(this.connection, this.queryRunner, \"save\", target, entity, options).execute().then(() => entity);\n  }\n  /**\n   * Removes a given entity from the database.\n   */\n  remove(targetOrEntity, maybeEntityOrOptions, maybeOptions) {\n    // normalize mixed parameters\n    const target = arguments.length > 1 && (typeof targetOrEntity === \"function\" || InstanceChecker.isEntitySchema(targetOrEntity) || typeof targetOrEntity === \"string\") ? targetOrEntity : undefined;\n    const entity = target ? maybeEntityOrOptions : targetOrEntity;\n    const options = target ? maybeOptions : maybeEntityOrOptions;\n    // if user passed empty array of entities then we don't need to do anything\n    if (Array.isArray(entity) && entity.length === 0) return Promise.resolve(entity);\n    // execute save operation\n    return new EntityPersistExecutor(this.connection, this.queryRunner, \"remove\", target, entity, options).execute().then(() => entity);\n  }\n  /**\n   * Records the delete date of one or many given entities.\n   */\n  softRemove(targetOrEntity, maybeEntityOrOptions, maybeOptions) {\n    // normalize mixed parameters\n    let target = arguments.length > 1 && (typeof targetOrEntity === \"function\" || InstanceChecker.isEntitySchema(targetOrEntity) || typeof targetOrEntity === \"string\") ? targetOrEntity : undefined;\n    const entity = target ? maybeEntityOrOptions : targetOrEntity;\n    const options = target ? maybeOptions : maybeEntityOrOptions;\n    if (InstanceChecker.isEntitySchema(target)) target = target.options.name;\n    // if user passed empty array of entities then we don't need to do anything\n    if (Array.isArray(entity) && entity.length === 0) return Promise.resolve(entity);\n    // execute soft-remove operation\n    return new EntityPersistExecutor(this.connection, this.queryRunner, \"soft-remove\", target, entity, options).execute().then(() => entity);\n  }\n  /**\n   * Recovers one or many given entities.\n   */\n  recover(targetOrEntity, maybeEntityOrOptions, maybeOptions) {\n    // normalize mixed parameters\n    let target = arguments.length > 1 && (typeof targetOrEntity === \"function\" || InstanceChecker.isEntitySchema(targetOrEntity) || typeof targetOrEntity === \"string\") ? targetOrEntity : undefined;\n    const entity = target ? maybeEntityOrOptions : targetOrEntity;\n    const options = target ? maybeOptions : maybeEntityOrOptions;\n    if (InstanceChecker.isEntitySchema(target)) target = target.options.name;\n    // if user passed empty array of entities then we don't need to do anything\n    if (Array.isArray(entity) && entity.length === 0) return Promise.resolve(entity);\n    // execute recover operation\n    return new EntityPersistExecutor(this.connection, this.queryRunner, \"recover\", target, entity, options).execute().then(() => entity);\n  }\n  /**\n   * Inserts a given entity into the database.\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient INSERT query.\n   * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.\n   * You can execute bulk inserts using this method.\n   */\n  async insert(target, entity) {\n    return this.createQueryBuilder().insert().into(target).values(entity).execute();\n  }\n  async upsert(target, entityOrEntities, conflictPathsOrOptions) {\n    const metadata = this.connection.getMetadata(target);\n    let options;\n    if (Array.isArray(conflictPathsOrOptions)) {\n      options = {\n        conflictPaths: conflictPathsOrOptions\n      };\n    } else {\n      options = conflictPathsOrOptions;\n    }\n    let entities;\n    if (!Array.isArray(entityOrEntities)) {\n      entities = [entityOrEntities];\n    } else {\n      entities = entityOrEntities;\n    }\n    const conflictColumns = metadata.mapPropertyPathsToColumns(Array.isArray(options.conflictPaths) ? options.conflictPaths : Object.keys(options.conflictPaths));\n    const overwriteColumns = metadata.columns.filter(col => !conflictColumns.includes(col) && entities.some(entity => typeof col.getEntityValue(entity) !== \"undefined\"));\n    return this.createQueryBuilder().insert().into(target).values(entities).orUpdate([...conflictColumns, ...overwriteColumns].map(col => col.databaseName), conflictColumns.map(col => col.databaseName), {\n      skipUpdateIfNoValuesChanged: options.skipUpdateIfNoValuesChanged,\n      indexPredicate: options.indexPredicate,\n      upsertType: options.upsertType || this.connection.driver.supportedUpsertTypes[0]\n    }).execute();\n  }\n  /**\n   * Updates entity partially. Entity can be found by a given condition(s).\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient UPDATE query.\n   * Does not check if entity exist in the database.\n   * Condition(s) cannot be empty.\n   */\n  update(target, criteria, partialEntity) {\n    // if user passed empty criteria or empty list of criterias, then throw an error\n    if (criteria === undefined || criteria === null || criteria === \"\" || Array.isArray(criteria) && criteria.length === 0) {\n      return Promise.reject(new TypeORMError(`Empty criteria(s) are not allowed for the update method.`));\n    }\n    if (typeof criteria === \"string\" || typeof criteria === \"number\" || criteria instanceof Date || Array.isArray(criteria)) {\n      return this.createQueryBuilder().update(target).set(partialEntity).whereInIds(criteria).execute();\n    } else {\n      return this.createQueryBuilder().update(target).set(partialEntity).where(criteria).execute();\n    }\n  }\n  /**\n   * Deletes entities by a given condition(s).\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient DELETE query.\n   * Does not check if entity exist in the database.\n   * Condition(s) cannot be empty.\n   */\n  delete(targetOrEntity, criteria) {\n    // if user passed empty criteria or empty list of criterias, then throw an error\n    if (criteria === undefined || criteria === null || criteria === \"\" || Array.isArray(criteria) && criteria.length === 0) {\n      return Promise.reject(new TypeORMError(`Empty criteria(s) are not allowed for the delete method.`));\n    }\n    if (typeof criteria === \"string\" || typeof criteria === \"number\" || criteria instanceof Date || Array.isArray(criteria)) {\n      return this.createQueryBuilder().delete().from(targetOrEntity).whereInIds(criteria).execute();\n    } else {\n      return this.createQueryBuilder().delete().from(targetOrEntity).where(criteria).execute();\n    }\n  }\n  /**\n   * Records the delete date of entities by a given condition(s).\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient DELETE query.\n   * Does not check if entity exist in the database.\n   * Condition(s) cannot be empty.\n   */\n  softDelete(targetOrEntity, criteria) {\n    // if user passed empty criteria or empty list of criterias, then throw an error\n    if (criteria === undefined || criteria === null || criteria === \"\" || Array.isArray(criteria) && criteria.length === 0) {\n      return Promise.reject(new TypeORMError(`Empty criteria(s) are not allowed for the delete method.`));\n    }\n    if (typeof criteria === \"string\" || typeof criteria === \"number\" || criteria instanceof Date || Array.isArray(criteria)) {\n      return this.createQueryBuilder().softDelete().from(targetOrEntity).whereInIds(criteria).execute();\n    } else {\n      return this.createQueryBuilder().softDelete().from(targetOrEntity).where(criteria).execute();\n    }\n  }\n  /**\n   * Restores entities by a given condition(s).\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient DELETE query.\n   * Does not check if entity exist in the database.\n   * Condition(s) cannot be empty.\n   */\n  restore(targetOrEntity, criteria) {\n    // if user passed empty criteria or empty list of criterias, then throw an error\n    if (criteria === undefined || criteria === null || criteria === \"\" || Array.isArray(criteria) && criteria.length === 0) {\n      return Promise.reject(new TypeORMError(`Empty criteria(s) are not allowed for the delete method.`));\n    }\n    if (typeof criteria === \"string\" || typeof criteria === \"number\" || criteria instanceof Date || Array.isArray(criteria)) {\n      return this.createQueryBuilder().restore().from(targetOrEntity).whereInIds(criteria).execute();\n    } else {\n      return this.createQueryBuilder().restore().from(targetOrEntity).where(criteria).execute();\n    }\n  }\n  /**\n   * Checks whether any entity exists with the given options.\n   */\n  exists(entityClass, options) {\n    const metadata = this.connection.getMetadata(entityClass);\n    return this.createQueryBuilder(entityClass, FindOptionsUtils.extractFindManyOptionsAlias(options) || metadata.name).setFindOptions(options || {}).getExists();\n  }\n  /**\n   * Checks whether any entity exists with the given conditions.\n   */\n  async existsBy(entityClass, where) {\n    const metadata = this.connection.getMetadata(entityClass);\n    return this.createQueryBuilder(entityClass, metadata.name).setFindOptions({\n      where\n    }).getExists();\n  }\n  /**\n   * Counts entities that match given options.\n   * Useful for pagination.\n   */\n  count(entityClass, options) {\n    const metadata = this.connection.getMetadata(entityClass);\n    return this.createQueryBuilder(entityClass, FindOptionsUtils.extractFindManyOptionsAlias(options) || metadata.name).setFindOptions(options || {}).getCount();\n  }\n  /**\n   * Counts entities that match given conditions.\n   * Useful for pagination.\n   */\n  countBy(entityClass, where) {\n    const metadata = this.connection.getMetadata(entityClass);\n    return this.createQueryBuilder(entityClass, metadata.name).setFindOptions({\n      where\n    }).getCount();\n  }\n  /**\n   * Return the SUM of a column\n   */\n  sum(entityClass, columnName, where) {\n    return this.callAggregateFun(entityClass, \"SUM\", columnName, where);\n  }\n  /**\n   * Return the AVG of a column\n   */\n  average(entityClass, columnName, where) {\n    return this.callAggregateFun(entityClass, \"AVG\", columnName, where);\n  }\n  /**\n   * Return the MIN of a column\n   */\n  minimum(entityClass, columnName, where) {\n    return this.callAggregateFun(entityClass, \"MIN\", columnName, where);\n  }\n  /**\n   * Return the MAX of a column\n   */\n  maximum(entityClass, columnName, where) {\n    return this.callAggregateFun(entityClass, \"MAX\", columnName, where);\n  }\n  async callAggregateFun(entityClass, fnName, columnName, where = {}) {\n    const metadata = this.connection.getMetadata(entityClass);\n    const column = metadata.columns.find(item => item.propertyPath === columnName);\n    if (!column) {\n      throw new TypeORMError(`Column \"${columnName}\" was not found in table \"${metadata.name}\"`);\n    }\n    const result = await this.createQueryBuilder(entityClass, metadata.name).setFindOptions({\n      where\n    }).select(`${fnName}(${this.connection.driver.escape(column.databaseName)})`, fnName).getRawOne();\n    return result[fnName] === null ? null : parseFloat(result[fnName]);\n  }\n  /**\n   * Finds entities that match given find options.\n   */\n  async find(entityClass, options) {\n    const metadata = this.connection.getMetadata(entityClass);\n    return this.createQueryBuilder(entityClass, FindOptionsUtils.extractFindManyOptionsAlias(options) || metadata.name).setFindOptions(options || {}).getMany();\n  }\n  /**\n   * Finds entities that match given find options.\n   */\n  async findBy(entityClass, where) {\n    const metadata = this.connection.getMetadata(entityClass);\n    return this.createQueryBuilder(entityClass, metadata.name).setFindOptions({\n      where: where\n    }).getMany();\n  }\n  /**\n   * Finds entities that match given find options.\n   * Also counts all entities that match given conditions,\n   * but ignores pagination settings (from and take options).\n   */\n  findAndCount(entityClass, options) {\n    const metadata = this.connection.getMetadata(entityClass);\n    return this.createQueryBuilder(entityClass, FindOptionsUtils.extractFindManyOptionsAlias(options) || metadata.name).setFindOptions(options || {}).getManyAndCount();\n  }\n  /**\n   * Finds entities that match given WHERE conditions.\n   * Also counts all entities that match given conditions,\n   * but ignores pagination settings (from and take options).\n   */\n  findAndCountBy(entityClass, where) {\n    const metadata = this.connection.getMetadata(entityClass);\n    return this.createQueryBuilder(entityClass, metadata.name).setFindOptions({\n      where\n    }).getManyAndCount();\n  }\n  /**\n   * Finds entities with ids.\n   * Optionally find options or conditions can be applied.\n   *\n   * @deprecated use `findBy` method instead in conjunction with `In` operator, for example:\n   *\n   * .findBy({\n   *     id: In([1, 2, 3])\n   * })\n   */\n  async findByIds(entityClass, ids) {\n    // if no ids passed, no need to execute a query - just return an empty array of values\n    if (!ids.length) return Promise.resolve([]);\n    const metadata = this.connection.getMetadata(entityClass);\n    return this.createQueryBuilder(entityClass, metadata.name).andWhereInIds(ids).getMany();\n  }\n  /**\n   * Finds first entity by a given find options.\n   * If entity was not found in the database - returns null.\n   */\n  async findOne(entityClass, options) {\n    const metadata = this.connection.getMetadata(entityClass);\n    // prepare alias for built query\n    let alias = metadata.name;\n    if (options && options.join) {\n      alias = options.join.alias;\n    }\n    if (!options.where) {\n      throw new Error(`You must provide selection conditions in order to find a single row.`);\n    }\n    // create query builder and apply find options\n    return this.createQueryBuilder(entityClass, alias).setFindOptions({\n      ...options,\n      take: 1\n    }).getOne();\n  }\n  /**\n   * Finds first entity that matches given where condition.\n   * If entity was not found in the database - returns null.\n   */\n  async findOneBy(entityClass, where) {\n    const metadata = this.connection.getMetadata(entityClass);\n    // create query builder and apply find options\n    return this.createQueryBuilder(entityClass, metadata.name).setFindOptions({\n      where,\n      take: 1\n    }).getOne();\n  }\n  /**\n   * Finds first entity that matches given id.\n   * If entity was not found in the database - returns null.\n   *\n   * @deprecated use `findOneBy` method instead in conjunction with `In` operator, for example:\n   *\n   * .findOneBy({\n   *     id: 1 // where \"id\" is your primary column name\n   * })\n   */\n  async findOneById(entityClass, id) {\n    const metadata = this.connection.getMetadata(entityClass);\n    // create query builder and apply find options\n    return this.createQueryBuilder(entityClass, metadata.name).setFindOptions({\n      take: 1\n    }).whereInIds(metadata.ensureEntityIdMap(id)).getOne();\n  }\n  /**\n   * Finds first entity by a given find options.\n   * If entity was not found in the database - rejects with error.\n   */\n  async findOneOrFail(entityClass, options) {\n    return this.findOne(entityClass, options).then(value => {\n      if (value === null) {\n        return Promise.reject(new EntityNotFoundError(entityClass, options));\n      }\n      return Promise.resolve(value);\n    });\n  }\n  /**\n   * Finds first entity that matches given where condition.\n   * If entity was not found in the database - rejects with error.\n   */\n  async findOneByOrFail(entityClass, where) {\n    return this.findOneBy(entityClass, where).then(value => {\n      if (value === null) {\n        return Promise.reject(new EntityNotFoundError(entityClass, where));\n      }\n      return Promise.resolve(value);\n    });\n  }\n  /**\n   * Clears all the data from the given table (truncates/drops it).\n   *\n   * Note: this method uses TRUNCATE and may not work as you expect in transactions on some platforms.\n   * @see https://stackoverflow.com/a/5972738/925151\n   */\n  async clear(entityClass) {\n    const metadata = this.connection.getMetadata(entityClass);\n    const queryRunner = this.queryRunner || this.connection.createQueryRunner();\n    try {\n      return await queryRunner.clearTable(metadata.tablePath); // await is needed here because we are using finally\n    } finally {\n      if (!this.queryRunner) await queryRunner.release();\n    }\n  }\n  /**\n   * Increments some column by provided value of the entities matched given conditions.\n   */\n  async increment(entityClass, conditions, propertyPath, value) {\n    const metadata = this.connection.getMetadata(entityClass);\n    const column = metadata.findColumnWithPropertyPath(propertyPath);\n    if (!column) throw new TypeORMError(`Column ${propertyPath} was not found in ${metadata.targetName} entity.`);\n    if (isNaN(Number(value))) throw new TypeORMError(`Value \"${value}\" is not a number.`);\n    // convert possible embeded path \"social.likes\" into object { social: { like: () => value } }\n    const values = propertyPath.split(\".\").reduceRight((value, key) => ({\n      [key]: value\n    }), () => this.connection.driver.escape(column.databaseName) + \" + \" + value);\n    return this.createQueryBuilder(entityClass, \"entity\").update(entityClass).set(values).where(conditions).execute();\n  }\n  /**\n   * Decrements some column by provided value of the entities matched given conditions.\n   */\n  async decrement(entityClass, conditions, propertyPath, value) {\n    const metadata = this.connection.getMetadata(entityClass);\n    const column = metadata.findColumnWithPropertyPath(propertyPath);\n    if (!column) throw new TypeORMError(`Column ${propertyPath} was not found in ${metadata.targetName} entity.`);\n    if (isNaN(Number(value))) throw new TypeORMError(`Value \"${value}\" is not a number.`);\n    // convert possible embeded path \"social.likes\" into object { social: { like: () => value } }\n    const values = propertyPath.split(\".\").reduceRight((value, key) => ({\n      [key]: value\n    }), () => this.connection.driver.escape(column.databaseName) + \" - \" + value);\n    return this.createQueryBuilder(entityClass, \"entity\").update(entityClass).set(values).where(conditions).execute();\n  }\n  /**\n   * Gets repository for the given entity class or name.\n   * If single database connection mode is used, then repository is obtained from the\n   * repository aggregator, where each repository is individually created for this entity manager.\n   * When single database connection is not used, repository is being obtained from the connection.\n   */\n  getRepository(target) {\n    // find already created repository instance and return it if found\n    const repoFromMap = this.repositories.get(target);\n    if (repoFromMap) return repoFromMap;\n    // if repository was not found then create it, store its instance and return it\n    if (this.connection.driver.options.type === \"mongodb\") {\n      const newRepository = new MongoRepository(target, this, this.queryRunner);\n      this.repositories.set(target, newRepository);\n      return newRepository;\n    } else {\n      const newRepository = new Repository(target, this, this.queryRunner);\n      this.repositories.set(target, newRepository);\n      return newRepository;\n    }\n  }\n  /**\n   * Gets tree repository for the given entity class or name.\n   * If single database connection mode is used, then repository is obtained from the\n   * repository aggregator, where each repository is individually created for this entity manager.\n   * When single database connection is not used, repository is being obtained from the connection.\n   */\n  getTreeRepository(target) {\n    // tree tables aren't supported by some drivers (mongodb)\n    if (this.connection.driver.treeSupport === false) throw new TreeRepositoryNotSupportedError(this.connection.driver);\n    // find already created repository instance and return it if found\n    const repository = this.treeRepositories.find(repository => repository.target === target);\n    if (repository) return repository;\n    // check if repository is real tree repository\n    const newRepository = new TreeRepository(target, this, this.queryRunner);\n    this.treeRepositories.push(newRepository);\n    return newRepository;\n  }\n  /**\n   * Gets mongodb repository for the given entity class.\n   */\n  getMongoRepository(target) {\n    return this.connection.getMongoRepository(target);\n  }\n  /**\n   * Creates a new repository instance out of a given Repository and\n   * sets current EntityManager instance to it. Used to work with custom repositories\n   * in transactions.\n   */\n  withRepository(repository) {\n    const repositoryConstructor = repository.constructor;\n    const {\n      target,\n      manager,\n      queryRunner,\n      ...otherRepositoryProperties\n    } = repository;\n    return Object.assign(new repositoryConstructor(repository.target, this), {\n      ...otherRepositoryProperties\n    });\n  }\n  /**\n   * Gets custom entity repository marked with @EntityRepository decorator.\n   *\n   * @deprecated use Repository.extend to create custom repositories\n   */\n  getCustomRepository(customRepository) {\n    const entityRepositoryMetadataArgs = getMetadataArgsStorage().entityRepositories.find(repository => {\n      return repository.target === (typeof customRepository === \"function\" ? customRepository : customRepository.constructor);\n    });\n    if (!entityRepositoryMetadataArgs) throw new CustomRepositoryNotFoundError(customRepository);\n    const entityMetadata = entityRepositoryMetadataArgs.entity ? this.connection.getMetadata(entityRepositoryMetadataArgs.entity) : undefined;\n    const entityRepositoryInstance = new entityRepositoryMetadataArgs.target(this, entityMetadata);\n    // NOTE: dynamic access to protected properties. We need this to prevent unwanted properties in those classes to be exposed,\n    // however we need these properties for internal work of the class\n    if (entityRepositoryInstance instanceof AbstractRepository) {\n      if (!entityRepositoryInstance[\"manager\"]) entityRepositoryInstance[\"manager\"] = this;\n    } else {\n      if (!entityMetadata) throw new CustomRepositoryCannotInheritRepositoryError(customRepository);\n      entityRepositoryInstance[\"manager\"] = this;\n      entityRepositoryInstance[\"metadata\"] = entityMetadata;\n    }\n    return entityRepositoryInstance;\n  }\n  /**\n   * Releases all resources used by entity manager.\n   * This is used when entity manager is created with a single query runner,\n   * and this single query runner needs to be released after job with entity manager is done.\n   */\n  async release() {\n    if (!this.queryRunner) throw new NoNeedToReleaseEntityManagerError();\n    return this.queryRunner.release();\n  }\n}","map":{"version":3,"names":["EntityNotFoundError","QueryRunnerProviderAlreadyReleasedError","NoNeedToReleaseEntityManagerError","MongoRepository","TreeRepository","Repository","FindOptionsUtils","PlainObjectToNewEntityTransformer","PlainObjectToDatabaseEntityTransformer","CustomRepositoryCannotInheritRepositoryError","CustomRepositoryNotFoundError","TreeRepositoryNotSupportedError","TypeORMError","AbstractRepository","EntityPersistExecutor","ObjectUtils","getMetadataArgsStorage","InstanceChecker","EntityManager","constructor","connection","queryRunner","Symbol","for","repositories","Map","treeRepositories","plainObjectToEntityTransformer","assign","manager","transaction","isolationOrRunInTransaction","runInTransactionParam","isolation","undefined","runInTransaction","isReleased","createQueryRunner","startTransaction","result","commitTransaction","err","rollbackTransaction","rollbackError","release","query","parameters","createQueryBuilder","entityClass","alias","hasId","targetOrEntity","maybeEntity","target","arguments","length","entity","metadata","getMetadata","getId","getEntityIdMixedMap","create","plainObjectOrObjects","Array","isArray","map","plainEntityLike","mergeIntoEntity","transform","merge","entityLikes","forEach","object","preload","entityLike","plainObjectToDatabaseEntityTransformer","transformedEntity","save","maybeEntityOrOptions","maybeOptions","isEntitySchema","options","name","Promise","resolve","execute","then","remove","softRemove","recover","insert","into","values","upsert","entityOrEntities","conflictPathsOrOptions","conflictPaths","entities","conflictColumns","mapPropertyPathsToColumns","Object","keys","overwriteColumns","columns","filter","col","includes","some","getEntityValue","orUpdate","databaseName","skipUpdateIfNoValuesChanged","indexPredicate","upsertType","driver","supportedUpsertTypes","update","criteria","partialEntity","reject","Date","set","whereInIds","where","delete","from","softDelete","restore","exists","extractFindManyOptionsAlias","setFindOptions","getExists","existsBy","count","getCount","countBy","sum","columnName","callAggregateFun","average","minimum","maximum","fnName","column","find","item","propertyPath","select","escape","getRawOne","parseFloat","getMany","findBy","findAndCount","getManyAndCount","findAndCountBy","findByIds","ids","andWhereInIds","findOne","join","Error","take","getOne","findOneBy","findOneById","id","ensureEntityIdMap","findOneOrFail","value","findOneByOrFail","clear","clearTable","tablePath","increment","conditions","findColumnWithPropertyPath","targetName","isNaN","Number","split","reduceRight","key","decrement","getRepository","repoFromMap","get","type","newRepository","getTreeRepository","treeSupport","repository","push","getMongoRepository","withRepository","repositoryConstructor","otherRepositoryProperties","getCustomRepository","customRepository","entityRepositoryMetadataArgs","entityRepositories","entityMetadata","entityRepositoryInstance"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\entity-manager\\EntityManager.ts"],"sourcesContent":["import { DataSource } from \"../data-source/DataSource\"\nimport { FindManyOptions } from \"../find-options/FindManyOptions\"\nimport { EntityTarget } from \"../common/EntityTarget\"\nimport { ObjectType } from \"../common/ObjectType\"\nimport { EntityNotFoundError } from \"../error/EntityNotFoundError\"\nimport { QueryRunnerProviderAlreadyReleasedError } from \"../error/QueryRunnerProviderAlreadyReleasedError\"\nimport { FindOneOptions } from \"../find-options/FindOneOptions\"\nimport { DeepPartial } from \"../common/DeepPartial\"\nimport { RemoveOptions } from \"../repository/RemoveOptions\"\nimport { SaveOptions } from \"../repository/SaveOptions\"\nimport { NoNeedToReleaseEntityManagerError } from \"../error/NoNeedToReleaseEntityManagerError\"\nimport { MongoRepository } from \"../repository/MongoRepository\"\nimport { TreeRepository } from \"../repository/TreeRepository\"\nimport { Repository } from \"../repository/Repository\"\nimport { FindOptionsUtils } from \"../find-options/FindOptionsUtils\"\nimport { PlainObjectToNewEntityTransformer } from \"../query-builder/transformer/PlainObjectToNewEntityTransformer\"\nimport { PlainObjectToDatabaseEntityTransformer } from \"../query-builder/transformer/PlainObjectToDatabaseEntityTransformer\"\nimport {\n    CustomRepositoryCannotInheritRepositoryError,\n    CustomRepositoryNotFoundError,\n    TreeRepositoryNotSupportedError,\n    TypeORMError,\n} from \"../error\"\nimport { AbstractRepository } from \"../repository/AbstractRepository\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { SelectQueryBuilder } from \"../query-builder/SelectQueryBuilder\"\nimport { QueryDeepPartialEntity } from \"../query-builder/QueryPartialEntity\"\nimport { EntityPersistExecutor } from \"../persistence/EntityPersistExecutor\"\nimport { ObjectId } from \"../driver/mongodb/typings\"\nimport { InsertResult } from \"../query-builder/result/InsertResult\"\nimport { UpdateResult } from \"../query-builder/result/UpdateResult\"\nimport { DeleteResult } from \"../query-builder/result/DeleteResult\"\nimport { FindOptionsWhere } from \"../find-options/FindOptionsWhere\"\nimport { IsolationLevel } from \"../driver/types/IsolationLevel\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { getMetadataArgsStorage } from \"../globals\"\nimport { UpsertOptions } from \"../repository/UpsertOptions\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { PickKeysByType } from \"../common/PickKeysByType\"\n\n/**\n * Entity manager supposed to work with any entity, automatically find its repository and call its methods,\n * whatever entity type are you passing.\n */\nexport class EntityManager {\n    readonly \"@instanceof\" = Symbol.for(\"EntityManager\")\n\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection used by this entity manager.\n     */\n    readonly connection: DataSource\n\n    /**\n     * Custom query runner to be used for operations in this entity manager.\n     * Used only in non-global entity manager.\n     */\n    readonly queryRunner?: QueryRunner\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Once created and then reused by repositories.\n     * Created as a future replacement for the #repositories to provide a bit more perf optimization.\n     */\n    protected repositories = new Map<EntityTarget<any>, Repository<any>>()\n\n    /**\n     * Once created and then reused by repositories.\n     */\n    protected treeRepositories: TreeRepository<any>[] = []\n\n    /**\n     * Plain to object transformer used in create and merge operations.\n     */\n    protected plainObjectToEntityTransformer =\n        new PlainObjectToNewEntityTransformer()\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(connection: DataSource, queryRunner?: QueryRunner) {\n        this.connection = connection\n        if (queryRunner) {\n            this.queryRunner = queryRunner\n            // dynamic: this.queryRunner = manager;\n            ObjectUtils.assign(this.queryRunner, { manager: this })\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Wraps given function execution (and all operations made there) in a transaction.\n     * All database operations must be executed using provided entity manager.\n     */\n    async transaction<T>(\n        runInTransaction: (entityManager: EntityManager) => Promise<T>,\n    ): Promise<T>\n\n    /**\n     * Wraps given function execution (and all operations made there) in a transaction.\n     * All database operations must be executed using provided entity manager.\n     */\n    async transaction<T>(\n        isolationLevel: IsolationLevel,\n        runInTransaction: (entityManager: EntityManager) => Promise<T>,\n    ): Promise<T>\n\n    /**\n     * Wraps given function execution (and all operations made there) in a transaction.\n     * All database operations must be executed using provided entity manager.\n     */\n    async transaction<T>(\n        isolationOrRunInTransaction:\n            | IsolationLevel\n            | ((entityManager: EntityManager) => Promise<T>),\n        runInTransactionParam?: (entityManager: EntityManager) => Promise<T>,\n    ): Promise<T> {\n        const isolation =\n            typeof isolationOrRunInTransaction === \"string\"\n                ? isolationOrRunInTransaction\n                : undefined\n        const runInTransaction =\n            typeof isolationOrRunInTransaction === \"function\"\n                ? isolationOrRunInTransaction\n                : runInTransactionParam\n\n        if (!runInTransaction) {\n            throw new TypeORMError(\n                `Transaction method requires callback in second parameter if isolation level is supplied.`,\n            )\n        }\n\n        if (this.queryRunner && this.queryRunner.isReleased)\n            throw new QueryRunnerProviderAlreadyReleasedError()\n\n        // if query runner is already defined in this class, it means this entity manager was already created for a single connection\n        // if its not defined we create a new query runner - single connection where we'll execute all our operations\n        const queryRunner =\n            this.queryRunner || this.connection.createQueryRunner()\n\n        try {\n            await queryRunner.startTransaction(isolation)\n            const result = await runInTransaction(queryRunner.manager)\n            await queryRunner.commitTransaction()\n            return result\n        } catch (err) {\n            try {\n                // we throw original error even if rollback thrown an error\n                await queryRunner.rollbackTransaction()\n            } catch (rollbackError) {}\n            throw err\n        } finally {\n            if (!this.queryRunner)\n                // if we used a new query runner provider then release it\n                await queryRunner.release()\n        }\n    }\n\n    /**\n     * Executes raw SQL query and returns raw database results.\n     */\n    async query<T = any>(query: string, parameters?: any[]): Promise<T> {\n        return this.connection.query(query, parameters, this.queryRunner)\n    }\n\n    /**\n     * Creates a new query builder that can be used to build a SQL query.\n     */\n    createQueryBuilder<Entity extends ObjectLiteral>(\n        entityClass: EntityTarget<Entity>,\n        alias: string,\n        queryRunner?: QueryRunner,\n    ): SelectQueryBuilder<Entity>\n\n    /**\n     * Creates a new query builder that can be used to build a SQL query.\n     */\n    createQueryBuilder(queryRunner?: QueryRunner): SelectQueryBuilder<any>\n\n    /**\n     * Creates a new query builder that can be used to build a SQL query.\n     */\n    createQueryBuilder<Entity extends ObjectLiteral>(\n        entityClass?: EntityTarget<Entity> | QueryRunner,\n        alias?: string,\n        queryRunner?: QueryRunner,\n    ): SelectQueryBuilder<Entity> {\n        if (alias) {\n            return this.connection.createQueryBuilder(\n                entityClass as EntityTarget<Entity>,\n                alias,\n                queryRunner || this.queryRunner,\n            )\n        } else {\n            return this.connection.createQueryBuilder(\n                (entityClass as QueryRunner | undefined) ||\n                    queryRunner ||\n                    this.queryRunner,\n            )\n        }\n    }\n\n    /**\n     * Checks if entity has an id.\n     */\n    hasId(entity: any): boolean\n\n    /**\n     * Checks if entity of given schema name has an id.\n     */\n    hasId(target: Function | string, entity: any): boolean\n\n    /**\n     * Checks if entity has an id by its Function type or schema name.\n     */\n    hasId(targetOrEntity: any | Function | string, maybeEntity?: any): boolean {\n        const target =\n            arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor\n        const entity = arguments.length === 2 ? maybeEntity : targetOrEntity\n        const metadata = this.connection.getMetadata(target)\n        return metadata.hasId(entity)\n    }\n\n    /**\n     * Gets entity mixed id.\n     */\n    getId(entity: any): any\n\n    /**\n     * Gets entity mixed id.\n     */\n    getId(target: EntityTarget<any>, entity: any): any\n\n    /**\n     * Gets entity mixed id.\n     */\n    getId(targetOrEntity: any | EntityTarget<any>, maybeEntity?: any): any {\n        const target =\n            arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor\n        const entity = arguments.length === 2 ? maybeEntity : targetOrEntity\n        const metadata = this.connection.getMetadata(target)\n        return metadata.getEntityIdMixedMap(entity)\n    }\n\n    /**\n     * Creates a new entity instance and copies all entity properties from this object into a new entity.\n     * Note that it copies only properties that present in entity schema.\n     */\n    create<Entity, EntityLike extends DeepPartial<Entity>>(\n        entityClass: EntityTarget<Entity>,\n        plainObject?: EntityLike,\n    ): Entity\n\n    /**\n     * Creates a new entities and copies all entity properties from given objects into their new entities.\n     * Note that it copies only properties that present in entity schema.\n     */\n    create<Entity, EntityLike extends DeepPartial<Entity>>(\n        entityClass: EntityTarget<Entity>,\n        plainObjects?: EntityLike[],\n    ): Entity[]\n\n    /**\n     * Creates a new entity instance or instances.\n     * Can copy properties from the given object into new entities.\n     */\n    create<Entity, EntityLike extends DeepPartial<Entity>>(\n        entityClass: EntityTarget<Entity>,\n        plainObjectOrObjects?: EntityLike | EntityLike[],\n    ): Entity | Entity[] {\n        const metadata = this.connection.getMetadata(entityClass)\n\n        if (!plainObjectOrObjects) return metadata.create(this.queryRunner)\n\n        if (Array.isArray(plainObjectOrObjects))\n            return (plainObjectOrObjects as EntityLike[]).map(\n                (plainEntityLike) => this.create(entityClass, plainEntityLike),\n            )\n\n        const mergeIntoEntity = metadata.create(this.queryRunner)\n        this.plainObjectToEntityTransformer.transform(\n            mergeIntoEntity,\n            plainObjectOrObjects,\n            metadata,\n            true,\n        )\n        return mergeIntoEntity\n    }\n\n    /**\n     * Merges two entities into one new entity.\n     */\n    merge<Entity extends ObjectLiteral>(\n        entityClass: EntityTarget<Entity>,\n        mergeIntoEntity: Entity,\n        ...entityLikes: DeepPartial<Entity>[]\n    ): Entity {\n        // todo: throw exception if entity manager is released\n        const metadata = this.connection.getMetadata(entityClass)\n        entityLikes.forEach((object) =>\n            this.plainObjectToEntityTransformer.transform(\n                mergeIntoEntity,\n                object,\n                metadata,\n            ),\n        )\n        return mergeIntoEntity\n    }\n\n    /**\n     * Creates a new entity from the given plain javascript object. If entity already exist in the database, then\n     * it loads it (and everything related to it), replaces all values with the new ones from the given object\n     * and returns this new entity. This new entity is actually a loaded from the db entity with all properties\n     * replaced from the new object.\n     */\n    async preload<Entity extends ObjectLiteral>(\n        entityClass: EntityTarget<Entity>,\n        entityLike: DeepPartial<Entity>,\n    ): Promise<Entity | undefined> {\n        const metadata = this.connection.getMetadata(entityClass)\n        const plainObjectToDatabaseEntityTransformer =\n            new PlainObjectToDatabaseEntityTransformer(this.connection.manager)\n        const transformedEntity =\n            await plainObjectToDatabaseEntityTransformer.transform(\n                entityLike,\n                metadata,\n            )\n        if (transformedEntity)\n            return this.merge(\n                entityClass as any,\n                transformedEntity as Entity,\n                entityLike,\n            )\n\n        return undefined\n    }\n\n    /**\n     * Saves all given entities in the database.\n     * If entities do not exist in the database then inserts, otherwise updates.\n     */\n    save<Entity>(entities: Entity[], options?: SaveOptions): Promise<Entity[]>\n\n    /**\n     * Saves all given entities in the database.\n     * If entities do not exist in the database then inserts, otherwise updates.\n     */\n    save<Entity>(entity: Entity, options?: SaveOptions): Promise<Entity>\n\n    /**\n     * Saves all given entities in the database.\n     * If entities do not exist in the database then inserts, otherwise updates.\n     */\n    save<Entity, T extends DeepPartial<Entity>>(\n        targetOrEntity: EntityTarget<Entity>,\n        entities: T[],\n        options: SaveOptions & { reload: false },\n    ): Promise<T[]>\n\n    /**\n     * Saves all given entities in the database.\n     * If entities do not exist in the database then inserts, otherwise updates.\n     */\n    save<Entity, T extends DeepPartial<Entity>>(\n        targetOrEntity: EntityTarget<Entity>,\n        entities: T[],\n        options?: SaveOptions,\n    ): Promise<(T & Entity)[]>\n\n    /**\n     * Saves a given entity in the database.\n     * If entity does not exist in the database then inserts, otherwise updates.\n     */\n    save<Entity, T extends DeepPartial<Entity>>(\n        targetOrEntity: EntityTarget<Entity>,\n        entity: T,\n        options: SaveOptions & { reload: false },\n    ): Promise<T>\n\n    /**\n     * Saves a given entity in the database.\n     * If entity does not exist in the database then inserts, otherwise updates.\n     */\n    save<Entity, T extends DeepPartial<Entity>>(\n        targetOrEntity: EntityTarget<Entity>,\n        entity: T,\n        options?: SaveOptions,\n    ): Promise<T & Entity>\n\n    /**\n     * Saves a given entity in the database.\n     */\n    save<Entity extends ObjectLiteral, T extends DeepPartial<Entity>>(\n        targetOrEntity: (T | T[]) | EntityTarget<Entity>,\n        maybeEntityOrOptions?: T | T[],\n        maybeOptions?: SaveOptions,\n    ): Promise<T | T[]> {\n        // normalize mixed parameters\n        let target =\n            arguments.length > 1 &&\n            (typeof targetOrEntity === \"function\" ||\n                InstanceChecker.isEntitySchema(targetOrEntity) ||\n                typeof targetOrEntity === \"string\")\n                ? (targetOrEntity as Function | string)\n                : undefined\n        const entity: T | T[] = target\n            ? (maybeEntityOrOptions as T | T[])\n            : (targetOrEntity as T | T[])\n        const options = target\n            ? maybeOptions\n            : (maybeEntityOrOptions as SaveOptions)\n\n        if (InstanceChecker.isEntitySchema(target)) target = target.options.name\n\n        // if user passed empty array of entities then we don't need to do anything\n        if (Array.isArray(entity) && entity.length === 0)\n            return Promise.resolve(entity)\n\n        // execute save operation\n        return new EntityPersistExecutor(\n            this.connection,\n            this.queryRunner,\n            \"save\",\n            target,\n            entity,\n            options,\n        )\n            .execute()\n            .then(() => entity)\n    }\n\n    /**\n     * Removes a given entity from the database.\n     */\n    remove<Entity>(entity: Entity, options?: RemoveOptions): Promise<Entity>\n\n    /**\n     * Removes a given entity from the database.\n     */\n    remove<Entity>(\n        targetOrEntity: EntityTarget<Entity>,\n        entity: Entity,\n        options?: RemoveOptions,\n    ): Promise<Entity>\n\n    /**\n     * Removes a given entity from the database.\n     */\n    remove<Entity>(entity: Entity[], options?: RemoveOptions): Promise<Entity>\n\n    /**\n     * Removes a given entity from the database.\n     */\n    remove<Entity>(\n        targetOrEntity: EntityTarget<Entity>,\n        entity: Entity[],\n        options?: RemoveOptions,\n    ): Promise<Entity[]>\n\n    /**\n     * Removes a given entity from the database.\n     */\n    remove<Entity extends ObjectLiteral>(\n        targetOrEntity: (Entity | Entity[]) | EntityTarget<Entity>,\n        maybeEntityOrOptions?: Entity | Entity[],\n        maybeOptions?: RemoveOptions,\n    ): Promise<Entity | Entity[]> {\n        // normalize mixed parameters\n        const target =\n            arguments.length > 1 &&\n            (typeof targetOrEntity === \"function\" ||\n                InstanceChecker.isEntitySchema(targetOrEntity) ||\n                typeof targetOrEntity === \"string\")\n                ? (targetOrEntity as Function | string)\n                : undefined\n        const entity: Entity | Entity[] = target\n            ? (maybeEntityOrOptions as Entity | Entity[])\n            : (targetOrEntity as Entity | Entity[])\n        const options = target\n            ? maybeOptions\n            : (maybeEntityOrOptions as SaveOptions)\n\n        // if user passed empty array of entities then we don't need to do anything\n        if (Array.isArray(entity) && entity.length === 0)\n            return Promise.resolve(entity)\n\n        // execute save operation\n        return new EntityPersistExecutor(\n            this.connection,\n            this.queryRunner,\n            \"remove\",\n            target,\n            entity,\n            options,\n        )\n            .execute()\n            .then(() => entity)\n    }\n\n    /**\n     * Records the delete date of all given entities.\n     */\n    softRemove<Entity>(\n        entities: Entity[],\n        options?: SaveOptions,\n    ): Promise<Entity[]>\n\n    /**\n     * Records the delete date of a given entity.\n     */\n    softRemove<Entity>(entity: Entity, options?: SaveOptions): Promise<Entity>\n\n    /**\n     * Records the delete date of all given entities.\n     */\n    softRemove<Entity, T extends DeepPartial<Entity>>(\n        targetOrEntity: EntityTarget<Entity>,\n        entities: T[],\n        options?: SaveOptions,\n    ): Promise<T[]>\n\n    /**\n     * Records the delete date of a given entity.\n     */\n    softRemove<Entity, T extends DeepPartial<Entity>>(\n        targetOrEntity: EntityTarget<Entity>,\n        entity: T,\n        options?: SaveOptions,\n    ): Promise<T>\n\n    /**\n     * Records the delete date of one or many given entities.\n     */\n    softRemove<Entity extends ObjectLiteral, T extends DeepPartial<Entity>>(\n        targetOrEntity: (T | T[]) | EntityTarget<Entity>,\n        maybeEntityOrOptions?: T | T[],\n        maybeOptions?: SaveOptions,\n    ): Promise<T | T[]> {\n        // normalize mixed parameters\n        let target =\n            arguments.length > 1 &&\n            (typeof targetOrEntity === \"function\" ||\n                InstanceChecker.isEntitySchema(targetOrEntity) ||\n                typeof targetOrEntity === \"string\")\n                ? (targetOrEntity as Function | string)\n                : undefined\n        const entity: T | T[] = target\n            ? (maybeEntityOrOptions as T | T[])\n            : (targetOrEntity as T | T[])\n        const options = target\n            ? maybeOptions\n            : (maybeEntityOrOptions as SaveOptions)\n\n        if (InstanceChecker.isEntitySchema(target)) target = target.options.name\n\n        // if user passed empty array of entities then we don't need to do anything\n        if (Array.isArray(entity) && entity.length === 0)\n            return Promise.resolve(entity)\n\n        // execute soft-remove operation\n        return new EntityPersistExecutor(\n            this.connection,\n            this.queryRunner,\n            \"soft-remove\",\n            target,\n            entity,\n            options,\n        )\n            .execute()\n            .then(() => entity)\n    }\n\n    /**\n     * Recovers all given entities.\n     */\n    recover<Entity>(\n        entities: Entity[],\n        options?: SaveOptions,\n    ): Promise<Entity[]>\n\n    /**\n     * Recovers a given entity.\n     */\n    recover<Entity>(entity: Entity, options?: SaveOptions): Promise<Entity>\n\n    /**\n     * Recovers all given entities.\n     */\n    recover<Entity, T extends DeepPartial<Entity>>(\n        targetOrEntity: EntityTarget<Entity>,\n        entities: T[],\n        options?: SaveOptions,\n    ): Promise<T[]>\n\n    /**\n     * Recovers a given entity.\n     */\n    recover<Entity, T extends DeepPartial<Entity>>(\n        targetOrEntity: EntityTarget<Entity>,\n        entity: T,\n        options?: SaveOptions,\n    ): Promise<T>\n\n    /**\n     * Recovers one or many given entities.\n     */\n    recover<Entity extends ObjectLiteral, T extends DeepPartial<Entity>>(\n        targetOrEntity: (T | T[]) | EntityTarget<Entity>,\n        maybeEntityOrOptions?: T | T[],\n        maybeOptions?: SaveOptions,\n    ): Promise<T | T[]> {\n        // normalize mixed parameters\n        let target =\n            arguments.length > 1 &&\n            (typeof targetOrEntity === \"function\" ||\n                InstanceChecker.isEntitySchema(targetOrEntity) ||\n                typeof targetOrEntity === \"string\")\n                ? (targetOrEntity as Function | string)\n                : undefined\n        const entity: T | T[] = target\n            ? (maybeEntityOrOptions as T | T[])\n            : (targetOrEntity as T | T[])\n        const options = target\n            ? maybeOptions\n            : (maybeEntityOrOptions as SaveOptions)\n\n        if (InstanceChecker.isEntitySchema(target)) target = target.options.name\n\n        // if user passed empty array of entities then we don't need to do anything\n        if (Array.isArray(entity) && entity.length === 0)\n            return Promise.resolve(entity)\n\n        // execute recover operation\n        return new EntityPersistExecutor(\n            this.connection,\n            this.queryRunner,\n            \"recover\",\n            target,\n            entity,\n            options,\n        )\n            .execute()\n            .then(() => entity)\n    }\n\n    /**\n     * Inserts a given entity into the database.\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient INSERT query.\n     * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.\n     * You can execute bulk inserts using this method.\n     */\n    async insert<Entity extends ObjectLiteral>(\n        target: EntityTarget<Entity>,\n        entity:\n            | QueryDeepPartialEntity<Entity>\n            | QueryDeepPartialEntity<Entity>[],\n    ): Promise<InsertResult> {\n        return this.createQueryBuilder()\n            .insert()\n            .into(target)\n            .values(entity)\n            .execute()\n    }\n\n    async upsert<Entity extends ObjectLiteral>(\n        target: EntityTarget<Entity>,\n        entityOrEntities:\n            | QueryDeepPartialEntity<Entity>\n            | QueryDeepPartialEntity<Entity>[],\n        conflictPathsOrOptions: string[] | UpsertOptions<Entity>,\n    ): Promise<InsertResult> {\n        const metadata = this.connection.getMetadata(target)\n\n        let options: UpsertOptions<Entity>\n\n        if (Array.isArray(conflictPathsOrOptions)) {\n            options = {\n                conflictPaths: conflictPathsOrOptions,\n            }\n        } else {\n            options = conflictPathsOrOptions\n        }\n\n        let entities: QueryDeepPartialEntity<Entity>[]\n\n        if (!Array.isArray(entityOrEntities)) {\n            entities = [entityOrEntities]\n        } else {\n            entities = entityOrEntities\n        }\n\n        const conflictColumns = metadata.mapPropertyPathsToColumns(\n            Array.isArray(options.conflictPaths)\n                ? options.conflictPaths\n                : Object.keys(options.conflictPaths),\n        )\n\n        const overwriteColumns = metadata.columns.filter(\n            (col) =>\n                !conflictColumns.includes(col) &&\n                entities.some(\n                    (entity) =>\n                        typeof col.getEntityValue(entity) !== \"undefined\",\n                ),\n        )\n\n        return this.createQueryBuilder()\n            .insert()\n            .into(target)\n            .values(entities)\n            .orUpdate(\n                [...conflictColumns, ...overwriteColumns].map(\n                    (col) => col.databaseName,\n                ),\n                conflictColumns.map((col) => col.databaseName),\n                {\n                    skipUpdateIfNoValuesChanged:\n                        options.skipUpdateIfNoValuesChanged,\n                    indexPredicate: options.indexPredicate,\n                    upsertType:\n                        options.upsertType ||\n                        this.connection.driver.supportedUpsertTypes[0],\n                },\n            )\n            .execute()\n    }\n\n    /**\n     * Updates entity partially. Entity can be found by a given condition(s).\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient UPDATE query.\n     * Does not check if entity exist in the database.\n     * Condition(s) cannot be empty.\n     */\n    update<Entity extends ObjectLiteral>(\n        target: EntityTarget<Entity>,\n        criteria:\n            | string\n            | string[]\n            | number\n            | number[]\n            | Date\n            | Date[]\n            | ObjectId\n            | ObjectId[]\n            | any,\n        partialEntity: QueryDeepPartialEntity<Entity>,\n    ): Promise<UpdateResult> {\n        // if user passed empty criteria or empty list of criterias, then throw an error\n        if (\n            criteria === undefined ||\n            criteria === null ||\n            criteria === \"\" ||\n            (Array.isArray(criteria) && criteria.length === 0)\n        ) {\n            return Promise.reject(\n                new TypeORMError(\n                    `Empty criteria(s) are not allowed for the update method.`,\n                ),\n            )\n        }\n\n        if (\n            typeof criteria === \"string\" ||\n            typeof criteria === \"number\" ||\n            criteria instanceof Date ||\n            Array.isArray(criteria)\n        ) {\n            return this.createQueryBuilder()\n                .update(target)\n                .set(partialEntity)\n                .whereInIds(criteria)\n                .execute()\n        } else {\n            return this.createQueryBuilder()\n                .update(target)\n                .set(partialEntity)\n                .where(criteria)\n                .execute()\n        }\n    }\n\n    /**\n     * Deletes entities by a given condition(s).\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient DELETE query.\n     * Does not check if entity exist in the database.\n     * Condition(s) cannot be empty.\n     */\n    delete<Entity extends ObjectLiteral>(\n        targetOrEntity: EntityTarget<Entity>,\n        criteria:\n            | string\n            | string[]\n            | number\n            | number[]\n            | Date\n            | Date[]\n            | ObjectId\n            | ObjectId[]\n            | any,\n    ): Promise<DeleteResult> {\n        // if user passed empty criteria or empty list of criterias, then throw an error\n        if (\n            criteria === undefined ||\n            criteria === null ||\n            criteria === \"\" ||\n            (Array.isArray(criteria) && criteria.length === 0)\n        ) {\n            return Promise.reject(\n                new TypeORMError(\n                    `Empty criteria(s) are not allowed for the delete method.`,\n                ),\n            )\n        }\n\n        if (\n            typeof criteria === \"string\" ||\n            typeof criteria === \"number\" ||\n            criteria instanceof Date ||\n            Array.isArray(criteria)\n        ) {\n            return this.createQueryBuilder()\n                .delete()\n                .from(targetOrEntity)\n                .whereInIds(criteria)\n                .execute()\n        } else {\n            return this.createQueryBuilder()\n                .delete()\n                .from(targetOrEntity)\n                .where(criteria)\n                .execute()\n        }\n    }\n\n    /**\n     * Records the delete date of entities by a given condition(s).\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient DELETE query.\n     * Does not check if entity exist in the database.\n     * Condition(s) cannot be empty.\n     */\n    softDelete<Entity extends ObjectLiteral>(\n        targetOrEntity: EntityTarget<Entity>,\n        criteria:\n            | string\n            | string[]\n            | number\n            | number[]\n            | Date\n            | Date[]\n            | ObjectId\n            | ObjectId[]\n            | any,\n    ): Promise<UpdateResult> {\n        // if user passed empty criteria or empty list of criterias, then throw an error\n        if (\n            criteria === undefined ||\n            criteria === null ||\n            criteria === \"\" ||\n            (Array.isArray(criteria) && criteria.length === 0)\n        ) {\n            return Promise.reject(\n                new TypeORMError(\n                    `Empty criteria(s) are not allowed for the delete method.`,\n                ),\n            )\n        }\n\n        if (\n            typeof criteria === \"string\" ||\n            typeof criteria === \"number\" ||\n            criteria instanceof Date ||\n            Array.isArray(criteria)\n        ) {\n            return this.createQueryBuilder()\n                .softDelete()\n                .from(targetOrEntity)\n                .whereInIds(criteria)\n                .execute()\n        } else {\n            return this.createQueryBuilder()\n                .softDelete()\n                .from(targetOrEntity)\n                .where(criteria)\n                .execute()\n        }\n    }\n\n    /**\n     * Restores entities by a given condition(s).\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient DELETE query.\n     * Does not check if entity exist in the database.\n     * Condition(s) cannot be empty.\n     */\n    restore<Entity extends ObjectLiteral>(\n        targetOrEntity: EntityTarget<Entity>,\n        criteria:\n            | string\n            | string[]\n            | number\n            | number[]\n            | Date\n            | Date[]\n            | ObjectId\n            | ObjectId[]\n            | any,\n    ): Promise<UpdateResult> {\n        // if user passed empty criteria or empty list of criterias, then throw an error\n        if (\n            criteria === undefined ||\n            criteria === null ||\n            criteria === \"\" ||\n            (Array.isArray(criteria) && criteria.length === 0)\n        ) {\n            return Promise.reject(\n                new TypeORMError(\n                    `Empty criteria(s) are not allowed for the delete method.`,\n                ),\n            )\n        }\n\n        if (\n            typeof criteria === \"string\" ||\n            typeof criteria === \"number\" ||\n            criteria instanceof Date ||\n            Array.isArray(criteria)\n        ) {\n            return this.createQueryBuilder()\n                .restore()\n                .from(targetOrEntity)\n                .whereInIds(criteria)\n                .execute()\n        } else {\n            return this.createQueryBuilder()\n                .restore()\n                .from(targetOrEntity)\n                .where(criteria)\n                .execute()\n        }\n    }\n\n    /**\n     * Checks whether any entity exists with the given options.\n     */\n    exists<Entity extends ObjectLiteral>(\n        entityClass: EntityTarget<Entity>,\n        options?: FindManyOptions<Entity>,\n    ): Promise<boolean> {\n        const metadata = this.connection.getMetadata(entityClass)\n        return this.createQueryBuilder(\n            entityClass,\n            FindOptionsUtils.extractFindManyOptionsAlias(options) ||\n                metadata.name,\n        )\n            .setFindOptions(options || {})\n            .getExists()\n    }\n\n    /**\n     * Checks whether any entity exists with the given conditions.\n     */\n    async existsBy<Entity extends ObjectLiteral>(\n        entityClass: EntityTarget<Entity>,\n        where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    ): Promise<boolean> {\n        const metadata = this.connection.getMetadata(entityClass)\n        return this.createQueryBuilder(entityClass, metadata.name)\n            .setFindOptions({ where })\n            .getExists()\n    }\n\n    /**\n     * Counts entities that match given options.\n     * Useful for pagination.\n     */\n    count<Entity extends ObjectLiteral>(\n        entityClass: EntityTarget<Entity>,\n        options?: FindManyOptions<Entity>,\n    ): Promise<number> {\n        const metadata = this.connection.getMetadata(entityClass)\n        return this.createQueryBuilder(\n            entityClass,\n            FindOptionsUtils.extractFindManyOptionsAlias(options) ||\n                metadata.name,\n        )\n            .setFindOptions(options || {})\n            .getCount()\n    }\n\n    /**\n     * Counts entities that match given conditions.\n     * Useful for pagination.\n     */\n    countBy<Entity extends ObjectLiteral>(\n        entityClass: EntityTarget<Entity>,\n        where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    ): Promise<number> {\n        const metadata = this.connection.getMetadata(entityClass)\n        return this.createQueryBuilder(entityClass, metadata.name)\n            .setFindOptions({ where })\n            .getCount()\n    }\n\n    /**\n     * Return the SUM of a column\n     */\n    sum<Entity extends ObjectLiteral>(\n        entityClass: EntityTarget<Entity>,\n        columnName: PickKeysByType<Entity, number>,\n        where?: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    ): Promise<number | null> {\n        return this.callAggregateFun(entityClass, \"SUM\", columnName, where)\n    }\n\n    /**\n     * Return the AVG of a column\n     */\n    average<Entity extends ObjectLiteral>(\n        entityClass: EntityTarget<Entity>,\n        columnName: PickKeysByType<Entity, number>,\n        where?: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    ): Promise<number | null> {\n        return this.callAggregateFun(entityClass, \"AVG\", columnName, where)\n    }\n\n    /**\n     * Return the MIN of a column\n     */\n    minimum<Entity extends ObjectLiteral>(\n        entityClass: EntityTarget<Entity>,\n        columnName: PickKeysByType<Entity, number>,\n        where?: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    ): Promise<number | null> {\n        return this.callAggregateFun(entityClass, \"MIN\", columnName, where)\n    }\n\n    /**\n     * Return the MAX of a column\n     */\n    maximum<Entity extends ObjectLiteral>(\n        entityClass: EntityTarget<Entity>,\n        columnName: PickKeysByType<Entity, number>,\n        where?: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    ): Promise<number | null> {\n        return this.callAggregateFun(entityClass, \"MAX\", columnName, where)\n    }\n\n    private async callAggregateFun<Entity extends ObjectLiteral>(\n        entityClass: EntityTarget<Entity>,\n        fnName: \"SUM\" | \"AVG\" | \"MIN\" | \"MAX\",\n        columnName: PickKeysByType<Entity, number>,\n        where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[] = {},\n    ): Promise<number | null> {\n        const metadata = this.connection.getMetadata(entityClass)\n        const column = metadata.columns.find(\n            (item) => item.propertyPath === columnName,\n        )\n        if (!column) {\n            throw new TypeORMError(\n                `Column \"${columnName}\" was not found in table \"${metadata.name}\"`,\n            )\n        }\n\n        const result = await this.createQueryBuilder(entityClass, metadata.name)\n            .setFindOptions({ where })\n            .select(\n                `${fnName}(${this.connection.driver.escape(\n                    column.databaseName,\n                )})`,\n                fnName,\n            )\n            .getRawOne()\n        return result[fnName] === null ? null : parseFloat(result[fnName])\n    }\n\n    /**\n     * Finds entities that match given find options.\n     */\n    async find<Entity extends ObjectLiteral>(\n        entityClass: EntityTarget<Entity>,\n        options?: FindManyOptions<Entity>,\n    ): Promise<Entity[]> {\n        const metadata = this.connection.getMetadata(entityClass)\n        return this.createQueryBuilder<Entity>(\n            entityClass as any,\n            FindOptionsUtils.extractFindManyOptionsAlias(options) ||\n                metadata.name,\n        )\n            .setFindOptions(options || {})\n            .getMany()\n    }\n\n    /**\n     * Finds entities that match given find options.\n     */\n    async findBy<Entity extends ObjectLiteral>(\n        entityClass: EntityTarget<Entity>,\n        where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    ): Promise<Entity[]> {\n        const metadata = this.connection.getMetadata(entityClass)\n        return this.createQueryBuilder<Entity>(\n            entityClass as any,\n            metadata.name,\n        )\n            .setFindOptions({ where: where })\n            .getMany()\n    }\n\n    /**\n     * Finds entities that match given find options.\n     * Also counts all entities that match given conditions,\n     * but ignores pagination settings (from and take options).\n     */\n    findAndCount<Entity extends ObjectLiteral>(\n        entityClass: EntityTarget<Entity>,\n        options?: FindManyOptions<Entity>,\n    ): Promise<[Entity[], number]> {\n        const metadata = this.connection.getMetadata(entityClass)\n        return this.createQueryBuilder<Entity>(\n            entityClass as any,\n            FindOptionsUtils.extractFindManyOptionsAlias(options) ||\n                metadata.name,\n        )\n            .setFindOptions(options || {})\n            .getManyAndCount()\n    }\n\n    /**\n     * Finds entities that match given WHERE conditions.\n     * Also counts all entities that match given conditions,\n     * but ignores pagination settings (from and take options).\n     */\n    findAndCountBy<Entity extends ObjectLiteral>(\n        entityClass: EntityTarget<Entity>,\n        where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    ): Promise<[Entity[], number]> {\n        const metadata = this.connection.getMetadata(entityClass)\n        return this.createQueryBuilder<Entity>(\n            entityClass as any,\n            metadata.name,\n        )\n            .setFindOptions({ where })\n            .getManyAndCount()\n    }\n\n    /**\n     * Finds entities with ids.\n     * Optionally find options or conditions can be applied.\n     *\n     * @deprecated use `findBy` method instead in conjunction with `In` operator, for example:\n     *\n     * .findBy({\n     *     id: In([1, 2, 3])\n     * })\n     */\n    async findByIds<Entity extends ObjectLiteral>(\n        entityClass: EntityTarget<Entity>,\n        ids: any[],\n    ): Promise<Entity[]> {\n        // if no ids passed, no need to execute a query - just return an empty array of values\n        if (!ids.length) return Promise.resolve([])\n\n        const metadata = this.connection.getMetadata(entityClass)\n        return this.createQueryBuilder<Entity>(\n            entityClass as any,\n            metadata.name,\n        )\n            .andWhereInIds(ids)\n            .getMany()\n    }\n\n    /**\n     * Finds first entity by a given find options.\n     * If entity was not found in the database - returns null.\n     */\n    async findOne<Entity extends ObjectLiteral>(\n        entityClass: EntityTarget<Entity>,\n        options: FindOneOptions<Entity>,\n    ): Promise<Entity | null> {\n        const metadata = this.connection.getMetadata(entityClass)\n\n        // prepare alias for built query\n        let alias: string = metadata.name\n        if (options && options.join) {\n            alias = options.join.alias\n        }\n\n        if (!options.where) {\n            throw new Error(\n                `You must provide selection conditions in order to find a single row.`,\n            )\n        }\n\n        // create query builder and apply find options\n        return this.createQueryBuilder<Entity>(entityClass, alias)\n            .setFindOptions({\n                ...options,\n                take: 1,\n            })\n            .getOne()\n    }\n\n    /**\n     * Finds first entity that matches given where condition.\n     * If entity was not found in the database - returns null.\n     */\n    async findOneBy<Entity extends ObjectLiteral>(\n        entityClass: EntityTarget<Entity>,\n        where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    ): Promise<Entity | null> {\n        const metadata = this.connection.getMetadata(entityClass)\n\n        // create query builder and apply find options\n        return this.createQueryBuilder<Entity>(entityClass, metadata.name)\n            .setFindOptions({\n                where,\n                take: 1,\n            })\n            .getOne()\n    }\n\n    /**\n     * Finds first entity that matches given id.\n     * If entity was not found in the database - returns null.\n     *\n     * @deprecated use `findOneBy` method instead in conjunction with `In` operator, for example:\n     *\n     * .findOneBy({\n     *     id: 1 // where \"id\" is your primary column name\n     * })\n     */\n    async findOneById<Entity extends ObjectLiteral>(\n        entityClass: EntityTarget<Entity>,\n        id: number | string | Date | ObjectId,\n    ): Promise<Entity | null> {\n        const metadata = this.connection.getMetadata(entityClass)\n\n        // create query builder and apply find options\n        return this.createQueryBuilder<Entity>(entityClass, metadata.name)\n            .setFindOptions({\n                take: 1,\n            })\n            .whereInIds(metadata.ensureEntityIdMap(id))\n            .getOne()\n    }\n\n    /**\n     * Finds first entity by a given find options.\n     * If entity was not found in the database - rejects with error.\n     */\n    async findOneOrFail<Entity extends ObjectLiteral>(\n        entityClass: EntityTarget<Entity>,\n        options: FindOneOptions<Entity>,\n    ): Promise<Entity> {\n        return this.findOne<Entity>(entityClass as any, options).then(\n            (value) => {\n                if (value === null) {\n                    return Promise.reject(\n                        new EntityNotFoundError(entityClass, options),\n                    )\n                }\n                return Promise.resolve(value)\n            },\n        )\n    }\n\n    /**\n     * Finds first entity that matches given where condition.\n     * If entity was not found in the database - rejects with error.\n     */\n    async findOneByOrFail<Entity extends ObjectLiteral>(\n        entityClass: EntityTarget<Entity>,\n        where: FindOptionsWhere<Entity> | FindOptionsWhere<Entity>[],\n    ): Promise<Entity> {\n        return this.findOneBy<Entity>(entityClass as any, where).then(\n            (value) => {\n                if (value === null) {\n                    return Promise.reject(\n                        new EntityNotFoundError(entityClass, where),\n                    )\n                }\n                return Promise.resolve(value)\n            },\n        )\n    }\n\n    /**\n     * Clears all the data from the given table (truncates/drops it).\n     *\n     * Note: this method uses TRUNCATE and may not work as you expect in transactions on some platforms.\n     * @see https://stackoverflow.com/a/5972738/925151\n     */\n    async clear<Entity>(entityClass: EntityTarget<Entity>): Promise<void> {\n        const metadata = this.connection.getMetadata(entityClass)\n        const queryRunner =\n            this.queryRunner || this.connection.createQueryRunner()\n        try {\n            return await queryRunner.clearTable(metadata.tablePath) // await is needed here because we are using finally\n        } finally {\n            if (!this.queryRunner) await queryRunner.release()\n        }\n    }\n\n    /**\n     * Increments some column by provided value of the entities matched given conditions.\n     */\n    async increment<Entity extends ObjectLiteral>(\n        entityClass: EntityTarget<Entity>,\n        conditions: any,\n        propertyPath: string,\n        value: number | string,\n    ): Promise<UpdateResult> {\n        const metadata = this.connection.getMetadata(entityClass)\n        const column = metadata.findColumnWithPropertyPath(propertyPath)\n        if (!column)\n            throw new TypeORMError(\n                `Column ${propertyPath} was not found in ${metadata.targetName} entity.`,\n            )\n\n        if (isNaN(Number(value)))\n            throw new TypeORMError(`Value \"${value}\" is not a number.`)\n\n        // convert possible embeded path \"social.likes\" into object { social: { like: () => value } }\n        const values: QueryDeepPartialEntity<Entity> = propertyPath\n            .split(\".\")\n            .reduceRight(\n                (value, key) => ({ [key]: value } as any),\n                () =>\n                    this.connection.driver.escape(column.databaseName) +\n                    \" + \" +\n                    value,\n            )\n\n        return this.createQueryBuilder<Entity>(entityClass as any, \"entity\")\n            .update(entityClass)\n            .set(values)\n            .where(conditions)\n            .execute()\n    }\n\n    /**\n     * Decrements some column by provided value of the entities matched given conditions.\n     */\n    async decrement<Entity extends ObjectLiteral>(\n        entityClass: EntityTarget<Entity>,\n        conditions: any,\n        propertyPath: string,\n        value: number | string,\n    ): Promise<UpdateResult> {\n        const metadata = this.connection.getMetadata(entityClass)\n        const column = metadata.findColumnWithPropertyPath(propertyPath)\n        if (!column)\n            throw new TypeORMError(\n                `Column ${propertyPath} was not found in ${metadata.targetName} entity.`,\n            )\n\n        if (isNaN(Number(value)))\n            throw new TypeORMError(`Value \"${value}\" is not a number.`)\n\n        // convert possible embeded path \"social.likes\" into object { social: { like: () => value } }\n        const values: QueryDeepPartialEntity<Entity> = propertyPath\n            .split(\".\")\n            .reduceRight(\n                (value, key) => ({ [key]: value } as any),\n                () =>\n                    this.connection.driver.escape(column.databaseName) +\n                    \" - \" +\n                    value,\n            )\n\n        return this.createQueryBuilder<Entity>(entityClass as any, \"entity\")\n            .update(entityClass)\n            .set(values)\n            .where(conditions)\n            .execute()\n    }\n\n    /**\n     * Gets repository for the given entity class or name.\n     * If single database connection mode is used, then repository is obtained from the\n     * repository aggregator, where each repository is individually created for this entity manager.\n     * When single database connection is not used, repository is being obtained from the connection.\n     */\n    getRepository<Entity extends ObjectLiteral>(\n        target: EntityTarget<Entity>,\n    ): Repository<Entity> {\n        // find already created repository instance and return it if found\n        const repoFromMap = this.repositories.get(target)\n        if (repoFromMap) return repoFromMap\n\n        // if repository was not found then create it, store its instance and return it\n        if (this.connection.driver.options.type === \"mongodb\") {\n            const newRepository = new MongoRepository(\n                target,\n                this,\n                this.queryRunner,\n            )\n            this.repositories.set(target, newRepository)\n            return newRepository\n        } else {\n            const newRepository = new Repository<any>(\n                target,\n                this,\n                this.queryRunner,\n            )\n            this.repositories.set(target, newRepository)\n            return newRepository\n        }\n    }\n\n    /**\n     * Gets tree repository for the given entity class or name.\n     * If single database connection mode is used, then repository is obtained from the\n     * repository aggregator, where each repository is individually created for this entity manager.\n     * When single database connection is not used, repository is being obtained from the connection.\n     */\n    getTreeRepository<Entity extends ObjectLiteral>(\n        target: EntityTarget<Entity>,\n    ): TreeRepository<Entity> {\n        // tree tables aren't supported by some drivers (mongodb)\n        if (this.connection.driver.treeSupport === false)\n            throw new TreeRepositoryNotSupportedError(this.connection.driver)\n\n        // find already created repository instance and return it if found\n        const repository = this.treeRepositories.find(\n            (repository) => repository.target === target,\n        )\n        if (repository) return repository\n\n        // check if repository is real tree repository\n        const newRepository = new TreeRepository(target, this, this.queryRunner)\n        this.treeRepositories.push(newRepository)\n        return newRepository\n    }\n\n    /**\n     * Gets mongodb repository for the given entity class.\n     */\n    getMongoRepository<Entity extends ObjectLiteral>(\n        target: EntityTarget<Entity>,\n    ): MongoRepository<Entity> {\n        return this.connection.getMongoRepository<Entity>(target)\n    }\n\n    /**\n     * Creates a new repository instance out of a given Repository and\n     * sets current EntityManager instance to it. Used to work with custom repositories\n     * in transactions.\n     */\n    withRepository<Entity extends ObjectLiteral, R extends Repository<any>>(\n        repository: R & Repository<Entity>,\n    ): R {\n        const repositoryConstructor =\n            repository.constructor as typeof Repository\n        const { target, manager, queryRunner, ...otherRepositoryProperties } =\n            repository\n        return Object.assign(\n            new repositoryConstructor(repository.target, this) as R,\n            {\n                ...otherRepositoryProperties,\n            },\n        )\n    }\n\n    /**\n     * Gets custom entity repository marked with @EntityRepository decorator.\n     *\n     * @deprecated use Repository.extend to create custom repositories\n     */\n    getCustomRepository<T>(customRepository: ObjectType<T>): T {\n        const entityRepositoryMetadataArgs =\n            getMetadataArgsStorage().entityRepositories.find((repository) => {\n                return (\n                    repository.target ===\n                    (typeof customRepository === \"function\"\n                        ? customRepository\n                        : (customRepository as any).constructor)\n                )\n            })\n        if (!entityRepositoryMetadataArgs)\n            throw new CustomRepositoryNotFoundError(customRepository)\n\n        const entityMetadata = entityRepositoryMetadataArgs.entity\n            ? this.connection.getMetadata(entityRepositoryMetadataArgs.entity)\n            : undefined\n        const entityRepositoryInstance =\n            new (entityRepositoryMetadataArgs.target as any)(\n                this,\n                entityMetadata,\n            )\n\n        // NOTE: dynamic access to protected properties. We need this to prevent unwanted properties in those classes to be exposed,\n        // however we need these properties for internal work of the class\n        if (entityRepositoryInstance instanceof AbstractRepository) {\n            if (!(entityRepositoryInstance as any)[\"manager\"])\n                (entityRepositoryInstance as any)[\"manager\"] = this\n        } else {\n            if (!entityMetadata)\n                throw new CustomRepositoryCannotInheritRepositoryError(\n                    customRepository,\n                )\n            ;(entityRepositoryInstance as any)[\"manager\"] = this\n            ;(entityRepositoryInstance as any)[\"metadata\"] = entityMetadata\n        }\n\n        return entityRepositoryInstance\n    }\n\n    /**\n     * Releases all resources used by entity manager.\n     * This is used when entity manager is created with a single query runner,\n     * and this single query runner needs to be released after job with entity manager is done.\n     */\n    async release(): Promise<void> {\n        if (!this.queryRunner) throw new NoNeedToReleaseEntityManagerError()\n\n        return this.queryRunner.release()\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}