{"ast":null,"code":"import { QueryBuilderUtils } from \"../QueryBuilderUtils\";\nimport { ObjectUtils } from \"../../util/ObjectUtils\";\nimport { TypeORMError } from \"../../error/TypeORMError\";\n/**\n * Stores all join relation id attributes which will be used to build a JOIN query.\n */\nexport class RelationIdAttribute {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(queryExpressionMap, relationIdAttribute) {\n    this.queryExpressionMap = queryExpressionMap;\n    /**\n     * Indicates if relation id should NOT be loaded as id map.\n     */\n    this.disableMixedMap = false;\n    ObjectUtils.assign(this, relationIdAttribute || {});\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  get joinInverseSideMetadata() {\n    return this.relation.inverseEntityMetadata;\n  }\n  /**\n   * Alias of the parent of this join.\n   * For example, if we join (\"post.category\", \"categoryAlias\") then \"post\" is a parent alias.\n   * This value is extracted from entityOrProperty value.\n   * This is available when join was made using \"post.category\" syntax.\n   */\n  get parentAlias() {\n    if (!QueryBuilderUtils.isAliasProperty(this.relationName)) throw new TypeORMError(`Given value must be a string representation of alias property`);\n    return this.relationName.substr(0, this.relationName.indexOf(\".\"));\n  }\n  /**\n   * Relation property name of the parent.\n   * This is used to understand what is joined.\n   * For example, if we join (\"post.category\", \"categoryAlias\") then \"category\" is a relation property.\n   * This value is extracted from entityOrProperty value.\n   * This is available when join was made using \"post.category\" syntax.\n   */\n  get relationPropertyPath() {\n    if (!QueryBuilderUtils.isAliasProperty(this.relationName)) throw new TypeORMError(`Given value must be a string representation of alias property`);\n    return this.relationName.substr(this.relationName.indexOf(\".\") + 1);\n  }\n  /**\n   * Relation of the parent.\n   * This is used to understand what is joined.\n   * This is available when join was made using \"post.category\" syntax.\n   */\n  get relation() {\n    if (!QueryBuilderUtils.isAliasProperty(this.relationName)) throw new TypeORMError(`Given value must be a string representation of alias property`);\n    const relationOwnerSelection = this.queryExpressionMap.findAliasByName(this.parentAlias);\n    const relation = relationOwnerSelection.metadata.findRelationWithPropertyPath(this.relationPropertyPath);\n    if (!relation) throw new TypeORMError(`Relation with property path ${this.relationPropertyPath} in entity was not found.`);\n    return relation;\n  }\n  /**\n   * Generates alias of junction table, whose ids we get.\n   */\n  get junctionAlias() {\n    const [parentAlias, relationProperty] = this.relationName.split(\".\");\n    return parentAlias + \"_\" + relationProperty + \"_rid\";\n  }\n  /**\n   * Metadata of the joined entity.\n   * If extra condition without entity was joined, then it will return undefined.\n   */\n  get junctionMetadata() {\n    return this.relation.junctionEntityMetadata;\n  }\n  get mapToPropertyParentAlias() {\n    return this.mapToProperty.substr(0, this.mapToProperty.indexOf(\".\"));\n  }\n  get mapToPropertyPropertyPath() {\n    return this.mapToProperty.substr(this.mapToProperty.indexOf(\".\") + 1);\n  }\n}","map":{"version":3,"names":["QueryBuilderUtils","ObjectUtils","TypeORMError","RelationIdAttribute","constructor","queryExpressionMap","relationIdAttribute","disableMixedMap","assign","joinInverseSideMetadata","relation","inverseEntityMetadata","parentAlias","isAliasProperty","relationName","substr","indexOf","relationPropertyPath","relationOwnerSelection","findAliasByName","metadata","findRelationWithPropertyPath","junctionAlias","relationProperty","split","junctionMetadata","junctionEntityMetadata","mapToPropertyParentAlias","mapToProperty","mapToPropertyPropertyPath"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\query-builder\\relation-id\\RelationIdAttribute.ts"],"sourcesContent":["import { RelationMetadata } from \"../../metadata/RelationMetadata\"\nimport { QueryBuilderUtils } from \"../QueryBuilderUtils\"\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\"\nimport { QueryExpressionMap } from \"../QueryExpressionMap\"\nimport { SelectQueryBuilder } from \"../SelectQueryBuilder\"\nimport { ObjectUtils } from \"../../util/ObjectUtils\"\nimport { TypeORMError } from \"../../error/TypeORMError\"\n\n/**\n * Stores all join relation id attributes which will be used to build a JOIN query.\n */\nexport class RelationIdAttribute {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Alias of the joined (destination) table.\n     */\n    alias?: string\n\n    /**\n     * Name of relation.\n     */\n    relationName: string\n\n    /**\n     * Property + alias of the object where to joined data should be mapped.\n     */\n    mapToProperty: string\n\n    /**\n     * Extra condition applied to \"ON\" section of join.\n     */\n    queryBuilderFactory?: (\n        qb: SelectQueryBuilder<any>,\n    ) => SelectQueryBuilder<any>\n\n    /**\n     * Indicates if relation id should NOT be loaded as id map.\n     */\n    disableMixedMap = false\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        private queryExpressionMap: QueryExpressionMap,\n        relationIdAttribute?: Partial<RelationIdAttribute>,\n    ) {\n        ObjectUtils.assign(this, relationIdAttribute || {})\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    get joinInverseSideMetadata(): EntityMetadata {\n        return this.relation.inverseEntityMetadata\n    }\n\n    /**\n     * Alias of the parent of this join.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"post\" is a parent alias.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get parentAlias(): string {\n        if (!QueryBuilderUtils.isAliasProperty(this.relationName))\n            throw new TypeORMError(\n                `Given value must be a string representation of alias property`,\n            )\n\n        return this.relationName.substr(0, this.relationName.indexOf(\".\"))\n    }\n\n    /**\n     * Relation property name of the parent.\n     * This is used to understand what is joined.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"category\" is a relation property.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get relationPropertyPath(): string {\n        if (!QueryBuilderUtils.isAliasProperty(this.relationName))\n            throw new TypeORMError(\n                `Given value must be a string representation of alias property`,\n            )\n\n        return this.relationName.substr(this.relationName.indexOf(\".\") + 1)\n    }\n\n    /**\n     * Relation of the parent.\n     * This is used to understand what is joined.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get relation(): RelationMetadata {\n        if (!QueryBuilderUtils.isAliasProperty(this.relationName))\n            throw new TypeORMError(\n                `Given value must be a string representation of alias property`,\n            )\n\n        const relationOwnerSelection = this.queryExpressionMap.findAliasByName(\n            this.parentAlias!,\n        )\n        const relation =\n            relationOwnerSelection.metadata.findRelationWithPropertyPath(\n                this.relationPropertyPath!,\n            )\n        if (!relation)\n            throw new TypeORMError(\n                `Relation with property path ${this.relationPropertyPath} in entity was not found.`,\n            )\n        return relation\n    }\n\n    /**\n     * Generates alias of junction table, whose ids we get.\n     */\n    get junctionAlias(): string {\n        const [parentAlias, relationProperty] = this.relationName.split(\".\")\n        return parentAlias + \"_\" + relationProperty + \"_rid\"\n    }\n\n    /**\n     * Metadata of the joined entity.\n     * If extra condition without entity was joined, then it will return undefined.\n     */\n    get junctionMetadata(): EntityMetadata {\n        return this.relation.junctionEntityMetadata!\n    }\n\n    get mapToPropertyParentAlias(): string {\n        return this.mapToProperty.substr(0, this.mapToProperty.indexOf(\".\"))\n    }\n\n    get mapToPropertyPropertyPath(): string {\n        return this.mapToProperty.substr(this.mapToProperty.indexOf(\".\") + 1)\n    }\n}\n"],"mappings":"AACA,SAASA,iBAAiB,QAAQ,sBAAsB;AAIxD,SAASC,WAAW,QAAQ,wBAAwB;AACpD,SAASC,YAAY,QAAQ,0BAA0B;AAEvD;;;AAGA,OAAM,MAAOC,mBAAmB;EAgC5B;EACA;EACA;EAEAC,YACYC,kBAAsC,EAC9CC,mBAAkD;IAD1C,KAAAD,kBAAkB,GAAlBA,kBAAkB;IAV9B;;;IAGA,KAAAE,eAAe,GAAG,KAAK;IAUnBN,WAAW,CAACO,MAAM,CAAC,IAAI,EAAEF,mBAAmB,IAAI,EAAE,CAAC;EACvD;EAEA;EACA;EACA;EAEA,IAAIG,uBAAuBA,CAAA;IACvB,OAAO,IAAI,CAACC,QAAQ,CAACC,qBAAqB;EAC9C;EAEA;;;;;;EAMA,IAAIC,WAAWA,CAAA;IACX,IAAI,CAACZ,iBAAiB,CAACa,eAAe,CAAC,IAAI,CAACC,YAAY,CAAC,EACrD,MAAM,IAAIZ,YAAY,CAClB,+DAA+D,CAClE;IAEL,OAAO,IAAI,CAACY,YAAY,CAACC,MAAM,CAAC,CAAC,EAAE,IAAI,CAACD,YAAY,CAACE,OAAO,CAAC,GAAG,CAAC,CAAC;EACtE;EAEA;;;;;;;EAOA,IAAIC,oBAAoBA,CAAA;IACpB,IAAI,CAACjB,iBAAiB,CAACa,eAAe,CAAC,IAAI,CAACC,YAAY,CAAC,EACrD,MAAM,IAAIZ,YAAY,CAClB,+DAA+D,CAClE;IAEL,OAAO,IAAI,CAACY,YAAY,CAACC,MAAM,CAAC,IAAI,CAACD,YAAY,CAACE,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EACvE;EAEA;;;;;EAKA,IAAIN,QAAQA,CAAA;IACR,IAAI,CAACV,iBAAiB,CAACa,eAAe,CAAC,IAAI,CAACC,YAAY,CAAC,EACrD,MAAM,IAAIZ,YAAY,CAClB,+DAA+D,CAClE;IAEL,MAAMgB,sBAAsB,GAAG,IAAI,CAACb,kBAAkB,CAACc,eAAe,CAClE,IAAI,CAACP,WAAY,CACpB;IACD,MAAMF,QAAQ,GACVQ,sBAAsB,CAACE,QAAQ,CAACC,4BAA4B,CACxD,IAAI,CAACJ,oBAAqB,CAC7B;IACL,IAAI,CAACP,QAAQ,EACT,MAAM,IAAIR,YAAY,CAClB,+BAA+B,IAAI,CAACe,oBAAoB,2BAA2B,CACtF;IACL,OAAOP,QAAQ;EACnB;EAEA;;;EAGA,IAAIY,aAAaA,CAAA;IACb,MAAM,CAACV,WAAW,EAAEW,gBAAgB,CAAC,GAAG,IAAI,CAACT,YAAY,CAACU,KAAK,CAAC,GAAG,CAAC;IACpE,OAAOZ,WAAW,GAAG,GAAG,GAAGW,gBAAgB,GAAG,MAAM;EACxD;EAEA;;;;EAIA,IAAIE,gBAAgBA,CAAA;IAChB,OAAO,IAAI,CAACf,QAAQ,CAACgB,sBAAuB;EAChD;EAEA,IAAIC,wBAAwBA,CAAA;IACxB,OAAO,IAAI,CAACC,aAAa,CAACb,MAAM,CAAC,CAAC,EAAE,IAAI,CAACa,aAAa,CAACZ,OAAO,CAAC,GAAG,CAAC,CAAC;EACxE;EAEA,IAAIa,yBAAyBA,CAAA;IACzB,OAAO,IAAI,CAACD,aAAa,CAACb,MAAM,CAAC,IAAI,CAACa,aAAa,CAACZ,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EACzE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}