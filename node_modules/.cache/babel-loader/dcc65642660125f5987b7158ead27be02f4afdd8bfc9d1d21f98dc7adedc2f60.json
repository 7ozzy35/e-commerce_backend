{"ast":null,"code":"import { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\";\nimport { QueryFailedError } from \"../../error/QueryFailedError\";\nimport { AbstractSqliteQueryRunner } from \"../sqlite-abstract/AbstractSqliteQueryRunner\";\nimport { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\";\nimport { Broadcaster } from \"../../subscriber/Broadcaster\";\nimport { QueryResult } from \"../../query-runner/QueryResult\";\nimport { BroadcasterResult } from \"../../subscriber/BroadcasterResult\";\n/**\n * Runs queries on a single sqlite database connection.\n */\nexport class ExpoQueryRunner extends AbstractSqliteQueryRunner {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(driver) {\n    super();\n    this.driver = driver;\n    this.connection = driver.connection;\n    this.broadcaster = new Broadcaster(this);\n  }\n  /**\n   * Starts transaction. Within Expo, all database operations happen in a\n   * transaction context, so issuing a `BEGIN TRANSACTION` command is\n   * redundant and will result in the following error:\n   *\n   * `Error: Error code 1: cannot start a transaction within a transaction`\n   *\n   * Instead, we keep track of a `Transaction` object in `this.transaction`\n   * and continue using the same object until we wish to commit the\n   * transaction.\n   */\n  async startTransaction() {\n    this.isTransactionActive = true;\n    try {\n      await this.broadcaster.broadcast(\"BeforeTransactionStart\");\n    } catch (err) {\n      this.isTransactionActive = false;\n      throw err;\n    }\n    this.transactionDepth += 1;\n    await this.broadcaster.broadcast(\"AfterTransactionStart\");\n  }\n  /**\n   * Commits transaction.\n   * Error will be thrown if transaction was not started.\n   * Since Expo will automatically commit the transaction once all the\n   * callbacks of the transaction object have been completed, \"committing\" a\n   * transaction in this driver's context means that we delete the transaction\n   * object and set the stage for the next transaction.\n   */\n  async commitTransaction() {\n    if (!this.isTransactionActive && typeof this.transaction === \"undefined\") throw new TransactionNotStartedError();\n    await this.broadcaster.broadcast(\"BeforeTransactionCommit\");\n    this.transaction = undefined;\n    this.isTransactionActive = false;\n    this.transactionDepth -= 1;\n    await this.broadcaster.broadcast(\"AfterTransactionCommit\");\n  }\n  /**\n   * Rollbacks transaction.\n   * Error will be thrown if transaction was not started.\n   * This method's functionality is identical to `commitTransaction()` because\n   * the transaction lifecycle is handled within the Expo transaction object.\n   * Issuing separate statements for `COMMIT` or `ROLLBACK` aren't necessary.\n   */\n  async rollbackTransaction() {\n    if (!this.isTransactionActive && typeof this.transaction === \"undefined\") throw new TransactionNotStartedError();\n    await this.broadcaster.broadcast(\"BeforeTransactionRollback\");\n    this.transaction = undefined;\n    this.isTransactionActive = false;\n    this.transactionDepth -= 1;\n    await this.broadcaster.broadcast(\"AfterTransactionRollback\");\n  }\n  /**\n   * Called before migrations are run.\n   */\n  async beforeMigration() {\n    const databaseConnection = await this.connect();\n    return new Promise((ok, fail) => {\n      databaseConnection.exec([{\n        sql: \"PRAGMA foreign_keys = OFF\",\n        args: []\n      }], false, err => err ? fail(err) : ok());\n    });\n  }\n  /**\n   * Called after migrations are run.\n   */\n  async afterMigration() {\n    const databaseConnection = await this.connect();\n    return new Promise((ok, fail) => {\n      databaseConnection.exec([{\n        sql: \"PRAGMA foreign_keys = ON\",\n        args: []\n      }], false, err => err ? fail(err) : ok());\n    });\n  }\n  /**\n   * Executes a given SQL query.\n   */\n  async query(query, parameters, useStructuredResult = false) {\n    if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();\n    return new Promise(async (ok, fail) => {\n      const databaseConnection = await this.connect();\n      const broadcasterResult = new BroadcasterResult();\n      this.driver.connection.logger.logQuery(query, parameters, this);\n      this.broadcaster.broadcastBeforeQueryEvent(broadcasterResult, query, parameters);\n      const queryStartTime = +new Date();\n      // All Expo SQL queries are executed in a transaction context\n      databaseConnection.transaction(async transaction => {\n        if (typeof this.transaction === \"undefined\") {\n          await this.startTransaction();\n          this.transaction = transaction;\n        }\n        this.transaction.executeSql(query, parameters, async (t, raw) => {\n          // log slow queries if maxQueryExecution time is set\n          const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;\n          const queryEndTime = +new Date();\n          const queryExecutionTime = queryEndTime - queryStartTime;\n          this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, raw, undefined);\n          await broadcasterResult.wait();\n          if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) {\n            this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);\n          }\n          const result = new QueryResult();\n          if (raw?.hasOwnProperty(\"rowsAffected\")) {\n            result.affected = raw.rowsAffected;\n          }\n          if (raw?.hasOwnProperty(\"rows\")) {\n            let resultSet = [];\n            for (let i = 0; i < raw.rows.length; i++) {\n              resultSet.push(raw.rows.item(i));\n            }\n            result.raw = resultSet;\n            result.records = resultSet;\n          }\n          // return id of inserted row, if query was insert statement.\n          if (query.startsWith(\"INSERT INTO\")) {\n            result.raw = raw.insertId;\n          }\n          if (useStructuredResult) {\n            ok(result);\n          } else {\n            ok(result.raw);\n          }\n        }, async (t, err) => {\n          this.driver.connection.logger.logQueryError(err, query, parameters, this);\n          this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, undefined, undefined, err);\n          await broadcasterResult.wait();\n          fail(new QueryFailedError(query, parameters, err));\n        });\n      }, async err => {\n        await this.rollbackTransaction();\n        fail(err);\n      }, () => {\n        this.isTransactionActive = false;\n        this.transaction = undefined;\n      });\n    });\n  }\n}","map":{"version":3,"names":["QueryRunnerAlreadyReleasedError","QueryFailedError","AbstractSqliteQueryRunner","TransactionNotStartedError","Broadcaster","QueryResult","BroadcasterResult","ExpoQueryRunner","constructor","driver","connection","broadcaster","startTransaction","isTransactionActive","broadcast","err","transactionDepth","commitTransaction","transaction","undefined","rollbackTransaction","beforeMigration","databaseConnection","connect","Promise","ok","fail","exec","sql","args","afterMigration","query","parameters","useStructuredResult","isReleased","broadcasterResult","logger","logQuery","broadcastBeforeQueryEvent","queryStartTime","Date","executeSql","t","raw","maxQueryExecutionTime","options","queryEndTime","queryExecutionTime","broadcastAfterQueryEvent","wait","logQuerySlow","result","hasOwnProperty","affected","rowsAffected","resultSet","i","rows","length","push","item","records","startsWith","insertId","logQueryError"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\driver\\expo\\ExpoQueryRunner.ts"],"sourcesContent":["import { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\"\nimport { QueryFailedError } from \"../../error/QueryFailedError\"\nimport { AbstractSqliteQueryRunner } from \"../sqlite-abstract/AbstractSqliteQueryRunner\"\nimport { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\"\nimport { ExpoDriver } from \"./ExpoDriver\"\nimport { Broadcaster } from \"../../subscriber/Broadcaster\"\nimport { QueryResult } from \"../../query-runner/QueryResult\"\nimport { BroadcasterResult } from \"../../subscriber/BroadcasterResult\"\n\n// Needed to satisfy the Typescript compiler\ninterface IResultSet {\n    insertId: number | undefined\n    rowsAffected: number\n    rows: {\n        length: number\n        item: (idx: number) => any\n        _array: any[]\n    }\n}\ninterface ITransaction {\n    executeSql: (\n        sql: string,\n        args: any[] | undefined,\n        ok: (tsx: ITransaction, resultSet: IResultSet) => void,\n        fail: (tsx: ITransaction, err: any) => void,\n    ) => void\n}\n\n/**\n * Runs queries on a single sqlite database connection.\n */\nexport class ExpoQueryRunner extends AbstractSqliteQueryRunner {\n    /**\n     * Database driver used by connection.\n     */\n    driver: ExpoDriver\n\n    /**\n     * Database transaction object\n     */\n    private transaction?: ITransaction\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(driver: ExpoDriver) {\n        super()\n        this.driver = driver\n        this.connection = driver.connection\n        this.broadcaster = new Broadcaster(this)\n    }\n\n    /**\n     * Starts transaction. Within Expo, all database operations happen in a\n     * transaction context, so issuing a `BEGIN TRANSACTION` command is\n     * redundant and will result in the following error:\n     *\n     * `Error: Error code 1: cannot start a transaction within a transaction`\n     *\n     * Instead, we keep track of a `Transaction` object in `this.transaction`\n     * and continue using the same object until we wish to commit the\n     * transaction.\n     */\n    async startTransaction(): Promise<void> {\n        this.isTransactionActive = true\n        try {\n            await this.broadcaster.broadcast(\"BeforeTransactionStart\")\n        } catch (err) {\n            this.isTransactionActive = false\n            throw err\n        }\n\n        this.transactionDepth += 1\n\n        await this.broadcaster.broadcast(\"AfterTransactionStart\")\n    }\n\n    /**\n     * Commits transaction.\n     * Error will be thrown if transaction was not started.\n     * Since Expo will automatically commit the transaction once all the\n     * callbacks of the transaction object have been completed, \"committing\" a\n     * transaction in this driver's context means that we delete the transaction\n     * object and set the stage for the next transaction.\n     */\n    async commitTransaction(): Promise<void> {\n        if (\n            !this.isTransactionActive &&\n            typeof this.transaction === \"undefined\"\n        )\n            throw new TransactionNotStartedError()\n\n        await this.broadcaster.broadcast(\"BeforeTransactionCommit\")\n\n        this.transaction = undefined\n        this.isTransactionActive = false\n\n        this.transactionDepth -= 1\n\n        await this.broadcaster.broadcast(\"AfterTransactionCommit\")\n    }\n\n    /**\n     * Rollbacks transaction.\n     * Error will be thrown if transaction was not started.\n     * This method's functionality is identical to `commitTransaction()` because\n     * the transaction lifecycle is handled within the Expo transaction object.\n     * Issuing separate statements for `COMMIT` or `ROLLBACK` aren't necessary.\n     */\n    async rollbackTransaction(): Promise<void> {\n        if (\n            !this.isTransactionActive &&\n            typeof this.transaction === \"undefined\"\n        )\n            throw new TransactionNotStartedError()\n\n        await this.broadcaster.broadcast(\"BeforeTransactionRollback\")\n\n        this.transaction = undefined\n        this.isTransactionActive = false\n\n        this.transactionDepth -= 1\n\n        await this.broadcaster.broadcast(\"AfterTransactionRollback\")\n    }\n\n    /**\n     * Called before migrations are run.\n     */\n    async beforeMigration(): Promise<void> {\n        const databaseConnection = await this.connect()\n        return new Promise((ok, fail) => {\n            databaseConnection.exec(\n                [{ sql: \"PRAGMA foreign_keys = OFF\", args: [] }],\n                false,\n                (err: any) => (err ? fail(err) : ok()),\n            )\n        })\n    }\n\n    /**\n     * Called after migrations are run.\n     */\n    async afterMigration(): Promise<void> {\n        const databaseConnection = await this.connect()\n        return new Promise((ok, fail) => {\n            databaseConnection.exec(\n                [{ sql: \"PRAGMA foreign_keys = ON\", args: [] }],\n                false,\n                (err: any) => (err ? fail(err) : ok()),\n            )\n        })\n    }\n\n    /**\n     * Executes a given SQL query.\n     */\n    async query(\n        query: string,\n        parameters?: any[],\n        useStructuredResult = false,\n    ): Promise<any> {\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        return new Promise<any>(async (ok, fail) => {\n            const databaseConnection = await this.connect()\n            const broadcasterResult = new BroadcasterResult()\n\n            this.driver.connection.logger.logQuery(query, parameters, this)\n            this.broadcaster.broadcastBeforeQueryEvent(\n                broadcasterResult,\n                query,\n                parameters,\n            )\n\n            const queryStartTime = +new Date()\n            // All Expo SQL queries are executed in a transaction context\n            databaseConnection.transaction(\n                async (transaction: ITransaction) => {\n                    if (typeof this.transaction === \"undefined\") {\n                        await this.startTransaction()\n                        this.transaction = transaction\n                    }\n                    this.transaction.executeSql(\n                        query,\n                        parameters,\n                        async (t: ITransaction, raw: IResultSet) => {\n                            // log slow queries if maxQueryExecution time is set\n                            const maxQueryExecutionTime =\n                                this.driver.options.maxQueryExecutionTime\n                            const queryEndTime = +new Date()\n                            const queryExecutionTime =\n                                queryEndTime - queryStartTime\n\n                            this.broadcaster.broadcastAfterQueryEvent(\n                                broadcasterResult,\n                                query,\n                                parameters,\n                                true,\n                                queryExecutionTime,\n                                raw,\n                                undefined,\n                            )\n                            await broadcasterResult.wait()\n\n                            if (\n                                maxQueryExecutionTime &&\n                                queryExecutionTime > maxQueryExecutionTime\n                            ) {\n                                this.driver.connection.logger.logQuerySlow(\n                                    queryExecutionTime,\n                                    query,\n                                    parameters,\n                                    this,\n                                )\n                            }\n\n                            const result = new QueryResult()\n\n                            if (raw?.hasOwnProperty(\"rowsAffected\")) {\n                                result.affected = raw.rowsAffected\n                            }\n\n                            if (raw?.hasOwnProperty(\"rows\")) {\n                                let resultSet = []\n                                for (let i = 0; i < raw.rows.length; i++) {\n                                    resultSet.push(raw.rows.item(i))\n                                }\n\n                                result.raw = resultSet\n                                result.records = resultSet\n                            }\n\n                            // return id of inserted row, if query was insert statement.\n                            if (query.startsWith(\"INSERT INTO\")) {\n                                result.raw = raw.insertId\n                            }\n\n                            if (useStructuredResult) {\n                                ok(result)\n                            } else {\n                                ok(result.raw)\n                            }\n                        },\n                        async (t: ITransaction, err: any) => {\n                            this.driver.connection.logger.logQueryError(\n                                err,\n                                query,\n                                parameters,\n                                this,\n                            )\n                            this.broadcaster.broadcastAfterQueryEvent(\n                                broadcasterResult,\n                                query,\n                                parameters,\n                                false,\n                                undefined,\n                                undefined,\n                                err,\n                            )\n                            await broadcasterResult.wait()\n\n                            fail(new QueryFailedError(query, parameters, err))\n                        },\n                    )\n                },\n                async (err: any) => {\n                    await this.rollbackTransaction()\n                    fail(err)\n                },\n                () => {\n                    this.isTransactionActive = false\n                    this.transaction = undefined\n                },\n            )\n        })\n    }\n}\n"],"mappings":"AAAA,SAASA,+BAA+B,QAAQ,6CAA6C;AAC7F,SAASC,gBAAgB,QAAQ,8BAA8B;AAC/D,SAASC,yBAAyB,QAAQ,8CAA8C;AACxF,SAASC,0BAA0B,QAAQ,wCAAwC;AAEnF,SAASC,WAAW,QAAQ,8BAA8B;AAC1D,SAASC,WAAW,QAAQ,gCAAgC;AAC5D,SAASC,iBAAiB,QAAQ,oCAAoC;AAqBtE;;;AAGA,OAAM,MAAOC,eAAgB,SAAQL,yBAAyB;EAW1D;EACA;EACA;EAEAM,YAAYC,MAAkB;IAC1B,KAAK,EAAE;IACP,IAAI,CAACA,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,UAAU,GAAGD,MAAM,CAACC,UAAU;IACnC,IAAI,CAACC,WAAW,GAAG,IAAIP,WAAW,CAAC,IAAI,CAAC;EAC5C;EAEA;;;;;;;;;;;EAWA,MAAMQ,gBAAgBA,CAAA;IAClB,IAAI,CAACC,mBAAmB,GAAG,IAAI;IAC/B,IAAI;MACA,MAAM,IAAI,CAACF,WAAW,CAACG,SAAS,CAAC,wBAAwB,CAAC;IAC9D,CAAC,CAAC,OAAOC,GAAG,EAAE;MACV,IAAI,CAACF,mBAAmB,GAAG,KAAK;MAChC,MAAME,GAAG;IACb;IAEA,IAAI,CAACC,gBAAgB,IAAI,CAAC;IAE1B,MAAM,IAAI,CAACL,WAAW,CAACG,SAAS,CAAC,uBAAuB,CAAC;EAC7D;EAEA;;;;;;;;EAQA,MAAMG,iBAAiBA,CAAA;IACnB,IACI,CAAC,IAAI,CAACJ,mBAAmB,IACzB,OAAO,IAAI,CAACK,WAAW,KAAK,WAAW,EAEvC,MAAM,IAAIf,0BAA0B,EAAE;IAE1C,MAAM,IAAI,CAACQ,WAAW,CAACG,SAAS,CAAC,yBAAyB,CAAC;IAE3D,IAAI,CAACI,WAAW,GAAGC,SAAS;IAC5B,IAAI,CAACN,mBAAmB,GAAG,KAAK;IAEhC,IAAI,CAACG,gBAAgB,IAAI,CAAC;IAE1B,MAAM,IAAI,CAACL,WAAW,CAACG,SAAS,CAAC,wBAAwB,CAAC;EAC9D;EAEA;;;;;;;EAOA,MAAMM,mBAAmBA,CAAA;IACrB,IACI,CAAC,IAAI,CAACP,mBAAmB,IACzB,OAAO,IAAI,CAACK,WAAW,KAAK,WAAW,EAEvC,MAAM,IAAIf,0BAA0B,EAAE;IAE1C,MAAM,IAAI,CAACQ,WAAW,CAACG,SAAS,CAAC,2BAA2B,CAAC;IAE7D,IAAI,CAACI,WAAW,GAAGC,SAAS;IAC5B,IAAI,CAACN,mBAAmB,GAAG,KAAK;IAEhC,IAAI,CAACG,gBAAgB,IAAI,CAAC;IAE1B,MAAM,IAAI,CAACL,WAAW,CAACG,SAAS,CAAC,0BAA0B,CAAC;EAChE;EAEA;;;EAGA,MAAMO,eAAeA,CAAA;IACjB,MAAMC,kBAAkB,GAAG,MAAM,IAAI,CAACC,OAAO,EAAE;IAC/C,OAAO,IAAIC,OAAO,CAAC,CAACC,EAAE,EAAEC,IAAI,KAAI;MAC5BJ,kBAAkB,CAACK,IAAI,CACnB,CAAC;QAAEC,GAAG,EAAE,2BAA2B;QAAEC,IAAI,EAAE;MAAE,CAAE,CAAC,EAChD,KAAK,EACJd,GAAQ,IAAMA,GAAG,GAAGW,IAAI,CAACX,GAAG,CAAC,GAAGU,EAAE,EAAG,CACzC;IACL,CAAC,CAAC;EACN;EAEA;;;EAGA,MAAMK,cAAcA,CAAA;IAChB,MAAMR,kBAAkB,GAAG,MAAM,IAAI,CAACC,OAAO,EAAE;IAC/C,OAAO,IAAIC,OAAO,CAAC,CAACC,EAAE,EAAEC,IAAI,KAAI;MAC5BJ,kBAAkB,CAACK,IAAI,CACnB,CAAC;QAAEC,GAAG,EAAE,0BAA0B;QAAEC,IAAI,EAAE;MAAE,CAAE,CAAC,EAC/C,KAAK,EACJd,GAAQ,IAAMA,GAAG,GAAGW,IAAI,CAACX,GAAG,CAAC,GAAGU,EAAE,EAAG,CACzC;IACL,CAAC,CAAC;EACN;EAEA;;;EAGA,MAAMM,KAAKA,CACPA,KAAa,EACbC,UAAkB,EAClBC,mBAAmB,GAAG,KAAK;IAE3B,IAAI,IAAI,CAACC,UAAU,EAAE,MAAM,IAAIlC,+BAA+B,EAAE;IAEhE,OAAO,IAAIwB,OAAO,CAAM,OAAOC,EAAE,EAAEC,IAAI,KAAI;MACvC,MAAMJ,kBAAkB,GAAG,MAAM,IAAI,CAACC,OAAO,EAAE;MAC/C,MAAMY,iBAAiB,GAAG,IAAI7B,iBAAiB,EAAE;MAEjD,IAAI,CAACG,MAAM,CAACC,UAAU,CAAC0B,MAAM,CAACC,QAAQ,CAACN,KAAK,EAAEC,UAAU,EAAE,IAAI,CAAC;MAC/D,IAAI,CAACrB,WAAW,CAAC2B,yBAAyB,CACtCH,iBAAiB,EACjBJ,KAAK,EACLC,UAAU,CACb;MAED,MAAMO,cAAc,GAAG,CAAC,IAAIC,IAAI,EAAE;MAClC;MACAlB,kBAAkB,CAACJ,WAAW,CAC1B,MAAOA,WAAyB,IAAI;QAChC,IAAI,OAAO,IAAI,CAACA,WAAW,KAAK,WAAW,EAAE;UACzC,MAAM,IAAI,CAACN,gBAAgB,EAAE;UAC7B,IAAI,CAACM,WAAW,GAAGA,WAAW;QAClC;QACA,IAAI,CAACA,WAAW,CAACuB,UAAU,CACvBV,KAAK,EACLC,UAAU,EACV,OAAOU,CAAe,EAAEC,GAAe,KAAI;UACvC;UACA,MAAMC,qBAAqB,GACvB,IAAI,CAACnC,MAAM,CAACoC,OAAO,CAACD,qBAAqB;UAC7C,MAAME,YAAY,GAAG,CAAC,IAAIN,IAAI,EAAE;UAChC,MAAMO,kBAAkB,GACpBD,YAAY,GAAGP,cAAc;UAEjC,IAAI,CAAC5B,WAAW,CAACqC,wBAAwB,CACrCb,iBAAiB,EACjBJ,KAAK,EACLC,UAAU,EACV,IAAI,EACJe,kBAAkB,EAClBJ,GAAG,EACHxB,SAAS,CACZ;UACD,MAAMgB,iBAAiB,CAACc,IAAI,EAAE;UAE9B,IACIL,qBAAqB,IACrBG,kBAAkB,GAAGH,qBAAqB,EAC5C;YACE,IAAI,CAACnC,MAAM,CAACC,UAAU,CAAC0B,MAAM,CAACc,YAAY,CACtCH,kBAAkB,EAClBhB,KAAK,EACLC,UAAU,EACV,IAAI,CACP;UACL;UAEA,MAAMmB,MAAM,GAAG,IAAI9C,WAAW,EAAE;UAEhC,IAAIsC,GAAG,EAAES,cAAc,CAAC,cAAc,CAAC,EAAE;YACrCD,MAAM,CAACE,QAAQ,GAAGV,GAAG,CAACW,YAAY;UACtC;UAEA,IAAIX,GAAG,EAAES,cAAc,CAAC,MAAM,CAAC,EAAE;YAC7B,IAAIG,SAAS,GAAG,EAAE;YAClB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGb,GAAG,CAACc,IAAI,CAACC,MAAM,EAAEF,CAAC,EAAE,EAAE;cACtCD,SAAS,CAACI,IAAI,CAAChB,GAAG,CAACc,IAAI,CAACG,IAAI,CAACJ,CAAC,CAAC,CAAC;YACpC;YAEAL,MAAM,CAACR,GAAG,GAAGY,SAAS;YACtBJ,MAAM,CAACU,OAAO,GAAGN,SAAS;UAC9B;UAEA;UACA,IAAIxB,KAAK,CAAC+B,UAAU,CAAC,aAAa,CAAC,EAAE;YACjCX,MAAM,CAACR,GAAG,GAAGA,GAAG,CAACoB,QAAQ;UAC7B;UAEA,IAAI9B,mBAAmB,EAAE;YACrBR,EAAE,CAAC0B,MAAM,CAAC;UACd,CAAC,MAAM;YACH1B,EAAE,CAAC0B,MAAM,CAACR,GAAG,CAAC;UAClB;QACJ,CAAC,EACD,OAAOD,CAAe,EAAE3B,GAAQ,KAAI;UAChC,IAAI,CAACN,MAAM,CAACC,UAAU,CAAC0B,MAAM,CAAC4B,aAAa,CACvCjD,GAAG,EACHgB,KAAK,EACLC,UAAU,EACV,IAAI,CACP;UACD,IAAI,CAACrB,WAAW,CAACqC,wBAAwB,CACrCb,iBAAiB,EACjBJ,KAAK,EACLC,UAAU,EACV,KAAK,EACLb,SAAS,EACTA,SAAS,EACTJ,GAAG,CACN;UACD,MAAMoB,iBAAiB,CAACc,IAAI,EAAE;UAE9BvB,IAAI,CAAC,IAAIzB,gBAAgB,CAAC8B,KAAK,EAAEC,UAAU,EAAEjB,GAAG,CAAC,CAAC;QACtD,CAAC,CACJ;MACL,CAAC,EACD,MAAOA,GAAQ,IAAI;QACf,MAAM,IAAI,CAACK,mBAAmB,EAAE;QAChCM,IAAI,CAACX,GAAG,CAAC;MACb,CAAC,EACD,MAAK;QACD,IAAI,CAACF,mBAAmB,GAAG,KAAK;QAChC,IAAI,CAACK,WAAW,GAAGC,SAAS;MAChC,CAAC,CACJ;IACL,CAAC,CAAC;EACN","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}