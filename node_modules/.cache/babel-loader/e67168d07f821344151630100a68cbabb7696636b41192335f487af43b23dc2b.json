{"ast":null,"code":"import { RandomGenerator } from \"../util/RandomGenerator\";\nimport { camelCase, snakeCase, titleCase } from \"../util/StringUtils\";\n/**\n * Naming strategy that is used by default.\n */\nexport class DefaultNamingStrategy {\n  constructor() {\n    this.nestedSetColumnNames = {\n      left: \"nsleft\",\n      right: \"nsright\"\n    };\n    this.materializedPathColumnName = \"mpath\";\n  }\n  getTableName(tableOrName) {\n    if (typeof tableOrName !== \"string\") {\n      tableOrName = tableOrName.name;\n    }\n    return tableOrName.split(\".\").pop();\n  }\n  /**\n   * Normalizes table name.\n   *\n   * @param targetName Name of the target entity that can be used to generate a table name.\n   * @param userSpecifiedName For example if user specified a table name in a decorator, e.g. @Entity(\"name\")\n   */\n  tableName(targetName, userSpecifiedName) {\n    return userSpecifiedName ? userSpecifiedName : snakeCase(targetName);\n  }\n  /**\n   * Creates a table name for a junction table of a closure table.\n   *\n   * @param originalClosureTableName Name of the closure table which owns this junction table.\n   */\n  closureJunctionTableName(originalClosureTableName) {\n    return originalClosureTableName + \"_closure\";\n  }\n  columnName(propertyName, customName, embeddedPrefixes) {\n    const name = customName || propertyName;\n    if (embeddedPrefixes.length) return camelCase(embeddedPrefixes.join(\"_\")) + titleCase(name);\n    return name;\n  }\n  relationName(propertyName) {\n    return propertyName;\n  }\n  primaryKeyName(tableOrName, columnNames) {\n    // sort incoming column names to avoid issue when [\"id\", \"name\"] and [\"name\", \"id\"] arrays\n    const clonedColumnNames = [...columnNames];\n    clonedColumnNames.sort();\n    const tableName = this.getTableName(tableOrName);\n    const replacedTableName = tableName.replace(\".\", \"_\");\n    const key = `${replacedTableName}_${clonedColumnNames.join(\"_\")}`;\n    return \"PK_\" + RandomGenerator.sha1(key).substr(0, 27);\n  }\n  uniqueConstraintName(tableOrName, columnNames) {\n    // sort incoming column names to avoid issue when [\"id\", \"name\"] and [\"name\", \"id\"] arrays\n    const clonedColumnNames = [...columnNames];\n    clonedColumnNames.sort();\n    const tableName = this.getTableName(tableOrName);\n    const replacedTableName = tableName.replace(\".\", \"_\");\n    const key = `${replacedTableName}_${clonedColumnNames.join(\"_\")}`;\n    return \"UQ_\" + RandomGenerator.sha1(key).substr(0, 27);\n  }\n  relationConstraintName(tableOrName, columnNames, where) {\n    // sort incoming column names to avoid issue when [\"id\", \"name\"] and [\"name\", \"id\"] arrays\n    const clonedColumnNames = [...columnNames];\n    clonedColumnNames.sort();\n    const tableName = this.getTableName(tableOrName);\n    const replacedTableName = tableName.replace(\".\", \"_\");\n    let key = `${replacedTableName}_${clonedColumnNames.join(\"_\")}`;\n    if (where) key += `_${where}`;\n    return \"REL_\" + RandomGenerator.sha1(key).substr(0, 26);\n  }\n  defaultConstraintName(tableOrName, columnName) {\n    const tableName = this.getTableName(tableOrName);\n    const replacedTableName = tableName.replace(\".\", \"_\");\n    const key = `${replacedTableName}_${columnName}`;\n    return \"DF_\" + RandomGenerator.sha1(key).substr(0, 27);\n  }\n  foreignKeyName(tableOrName, columnNames, _referencedTablePath, _referencedColumnNames) {\n    // sort incoming column names to avoid issue when [\"id\", \"name\"] and [\"name\", \"id\"] arrays\n    const clonedColumnNames = [...columnNames];\n    clonedColumnNames.sort();\n    const tableName = this.getTableName(tableOrName);\n    const replacedTableName = tableName.replace(\".\", \"_\");\n    const key = `${replacedTableName}_${clonedColumnNames.join(\"_\")}`;\n    return \"FK_\" + RandomGenerator.sha1(key).substr(0, 27);\n  }\n  indexName(tableOrName, columnNames, where) {\n    // sort incoming column names to avoid issue when [\"id\", \"name\"] and [\"name\", \"id\"] arrays\n    const clonedColumnNames = [...columnNames];\n    clonedColumnNames.sort();\n    const tableName = this.getTableName(tableOrName);\n    const replacedTableName = tableName.replace(\".\", \"_\");\n    let key = `${replacedTableName}_${clonedColumnNames.join(\"_\")}`;\n    if (where) key += `_${where}`;\n    return \"IDX_\" + RandomGenerator.sha1(key).substr(0, 26);\n  }\n  checkConstraintName(tableOrName, expression, isEnum) {\n    const tableName = this.getTableName(tableOrName);\n    const replacedTableName = tableName.replace(\".\", \"_\");\n    const key = `${replacedTableName}_${expression}`;\n    const name = \"CHK_\" + RandomGenerator.sha1(key).substr(0, 26);\n    return isEnum ? `${name}_ENUM` : name;\n  }\n  exclusionConstraintName(tableOrName, expression) {\n    const tableName = this.getTableName(tableOrName);\n    const replacedTableName = tableName.replace(\".\", \"_\");\n    const key = `${replacedTableName}_${expression}`;\n    return \"XCL_\" + RandomGenerator.sha1(key).substr(0, 26);\n  }\n  joinColumnName(relationName, referencedColumnName) {\n    return camelCase(relationName + \"_\" + referencedColumnName);\n  }\n  joinTableName(firstTableName, secondTableName, firstPropertyName, secondPropertyName) {\n    return snakeCase(firstTableName + \"_\" + firstPropertyName.replace(/\\./gi, \"_\") + \"_\" + secondTableName);\n  }\n  joinTableColumnDuplicationPrefix(columnName, index) {\n    return columnName + \"_\" + index;\n  }\n  joinTableColumnName(tableName, propertyName, columnName) {\n    return camelCase(tableName + \"_\" + (columnName ? columnName : propertyName));\n  }\n  joinTableInverseColumnName(tableName, propertyName, columnName) {\n    return this.joinTableColumnName(tableName, propertyName, columnName);\n  }\n  /**\n   * Adds globally set prefix to the table name.\n   * This method is executed no matter if prefix was set or not.\n   * Table name is either user's given table name, either name generated from entity target.\n   * Note that table name comes here already normalized by #tableName method.\n   */\n  prefixTableName(prefix, tableName) {\n    return prefix + tableName;\n  }\n}","map":{"version":3,"names":["RandomGenerator","camelCase","snakeCase","titleCase","DefaultNamingStrategy","constructor","nestedSetColumnNames","left","right","materializedPathColumnName","getTableName","tableOrName","name","split","pop","tableName","targetName","userSpecifiedName","closureJunctionTableName","originalClosureTableName","columnName","propertyName","customName","embeddedPrefixes","length","join","relationName","primaryKeyName","columnNames","clonedColumnNames","sort","replacedTableName","replace","key","sha1","substr","uniqueConstraintName","relationConstraintName","where","defaultConstraintName","foreignKeyName","_referencedTablePath","_referencedColumnNames","indexName","checkConstraintName","expression","isEnum","exclusionConstraintName","joinColumnName","referencedColumnName","joinTableName","firstTableName","secondTableName","firstPropertyName","secondPropertyName","joinTableColumnDuplicationPrefix","index","joinTableColumnName","joinTableInverseColumnName","prefixTableName","prefix"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\naming-strategy\\DefaultNamingStrategy.ts"],"sourcesContent":["import { NamingStrategyInterface } from \"./NamingStrategyInterface\"\nimport { RandomGenerator } from \"../util/RandomGenerator\"\nimport { camelCase, snakeCase, titleCase } from \"../util/StringUtils\"\nimport { Table } from \"../schema-builder/table/Table\"\n\n/**\n * Naming strategy that is used by default.\n */\nexport class DefaultNamingStrategy implements NamingStrategyInterface {\n    protected getTableName(tableOrName: Table | string): string {\n        if (typeof tableOrName !== \"string\") {\n            tableOrName = tableOrName.name\n        }\n\n        return tableOrName.split(\".\").pop()!\n    }\n    /**\n     * Normalizes table name.\n     *\n     * @param targetName Name of the target entity that can be used to generate a table name.\n     * @param userSpecifiedName For example if user specified a table name in a decorator, e.g. @Entity(\"name\")\n     */\n    tableName(\n        targetName: string,\n        userSpecifiedName: string | undefined,\n    ): string {\n        return userSpecifiedName ? userSpecifiedName : snakeCase(targetName)\n    }\n\n    /**\n     * Creates a table name for a junction table of a closure table.\n     *\n     * @param originalClosureTableName Name of the closure table which owns this junction table.\n     */\n    closureJunctionTableName(originalClosureTableName: string): string {\n        return originalClosureTableName + \"_closure\"\n    }\n\n    columnName(\n        propertyName: string,\n        customName: string,\n        embeddedPrefixes: string[],\n    ): string {\n        const name = customName || propertyName\n\n        if (embeddedPrefixes.length)\n            return camelCase(embeddedPrefixes.join(\"_\")) + titleCase(name)\n\n        return name\n    }\n\n    relationName(propertyName: string): string {\n        return propertyName\n    }\n\n    primaryKeyName(tableOrName: Table | string, columnNames: string[]): string {\n        // sort incoming column names to avoid issue when [\"id\", \"name\"] and [\"name\", \"id\"] arrays\n        const clonedColumnNames = [...columnNames]\n        clonedColumnNames.sort()\n        const tableName = this.getTableName(tableOrName)\n        const replacedTableName = tableName.replace(\".\", \"_\")\n        const key = `${replacedTableName}_${clonedColumnNames.join(\"_\")}`\n        return \"PK_\" + RandomGenerator.sha1(key).substr(0, 27)\n    }\n\n    uniqueConstraintName(\n        tableOrName: Table | string,\n        columnNames: string[],\n    ): string {\n        // sort incoming column names to avoid issue when [\"id\", \"name\"] and [\"name\", \"id\"] arrays\n        const clonedColumnNames = [...columnNames]\n        clonedColumnNames.sort()\n        const tableName = this.getTableName(tableOrName)\n        const replacedTableName = tableName.replace(\".\", \"_\")\n        const key = `${replacedTableName}_${clonedColumnNames.join(\"_\")}`\n        return \"UQ_\" + RandomGenerator.sha1(key).substr(0, 27)\n    }\n\n    relationConstraintName(\n        tableOrName: Table | string,\n        columnNames: string[],\n        where?: string,\n    ): string {\n        // sort incoming column names to avoid issue when [\"id\", \"name\"] and [\"name\", \"id\"] arrays\n        const clonedColumnNames = [...columnNames]\n        clonedColumnNames.sort()\n        const tableName = this.getTableName(tableOrName)\n        const replacedTableName = tableName.replace(\".\", \"_\")\n        let key = `${replacedTableName}_${clonedColumnNames.join(\"_\")}`\n        if (where) key += `_${where}`\n\n        return \"REL_\" + RandomGenerator.sha1(key).substr(0, 26)\n    }\n\n    defaultConstraintName(\n        tableOrName: Table | string,\n        columnName: string,\n    ): string {\n        const tableName = this.getTableName(tableOrName)\n        const replacedTableName = tableName.replace(\".\", \"_\")\n        const key = `${replacedTableName}_${columnName}`\n        return \"DF_\" + RandomGenerator.sha1(key).substr(0, 27)\n    }\n\n    foreignKeyName(\n        tableOrName: Table | string,\n        columnNames: string[],\n        _referencedTablePath?: string,\n        _referencedColumnNames?: string[],\n    ): string {\n        // sort incoming column names to avoid issue when [\"id\", \"name\"] and [\"name\", \"id\"] arrays\n        const clonedColumnNames = [...columnNames]\n        clonedColumnNames.sort()\n        const tableName = this.getTableName(tableOrName)\n        const replacedTableName = tableName.replace(\".\", \"_\")\n        const key = `${replacedTableName}_${clonedColumnNames.join(\"_\")}`\n        return \"FK_\" + RandomGenerator.sha1(key).substr(0, 27)\n    }\n\n    indexName(\n        tableOrName: Table | string,\n        columnNames: string[],\n        where?: string,\n    ): string {\n        // sort incoming column names to avoid issue when [\"id\", \"name\"] and [\"name\", \"id\"] arrays\n        const clonedColumnNames = [...columnNames]\n        clonedColumnNames.sort()\n        const tableName = this.getTableName(tableOrName)\n        const replacedTableName = tableName.replace(\".\", \"_\")\n        let key = `${replacedTableName}_${clonedColumnNames.join(\"_\")}`\n        if (where) key += `_${where}`\n\n        return \"IDX_\" + RandomGenerator.sha1(key).substr(0, 26)\n    }\n\n    checkConstraintName(\n        tableOrName: Table | string,\n        expression: string,\n        isEnum?: boolean,\n    ): string {\n        const tableName = this.getTableName(tableOrName)\n        const replacedTableName = tableName.replace(\".\", \"_\")\n        const key = `${replacedTableName}_${expression}`\n        const name = \"CHK_\" + RandomGenerator.sha1(key).substr(0, 26)\n        return isEnum ? `${name}_ENUM` : name\n    }\n\n    exclusionConstraintName(\n        tableOrName: Table | string,\n        expression: string,\n    ): string {\n        const tableName = this.getTableName(tableOrName)\n        const replacedTableName = tableName.replace(\".\", \"_\")\n        const key = `${replacedTableName}_${expression}`\n        return \"XCL_\" + RandomGenerator.sha1(key).substr(0, 26)\n    }\n\n    joinColumnName(relationName: string, referencedColumnName: string): string {\n        return camelCase(relationName + \"_\" + referencedColumnName)\n    }\n\n    joinTableName(\n        firstTableName: string,\n        secondTableName: string,\n        firstPropertyName: string,\n        secondPropertyName: string,\n    ): string {\n        return snakeCase(\n            firstTableName +\n                \"_\" +\n                firstPropertyName.replace(/\\./gi, \"_\") +\n                \"_\" +\n                secondTableName,\n        )\n    }\n\n    joinTableColumnDuplicationPrefix(\n        columnName: string,\n        index: number,\n    ): string {\n        return columnName + \"_\" + index\n    }\n\n    joinTableColumnName(\n        tableName: string,\n        propertyName: string,\n        columnName?: string,\n    ): string {\n        return camelCase(\n            tableName + \"_\" + (columnName ? columnName : propertyName),\n        )\n    }\n\n    joinTableInverseColumnName(\n        tableName: string,\n        propertyName: string,\n        columnName?: string,\n    ): string {\n        return this.joinTableColumnName(tableName, propertyName, columnName)\n    }\n\n    /**\n     * Adds globally set prefix to the table name.\n     * This method is executed no matter if prefix was set or not.\n     * Table name is either user's given table name, either name generated from entity target.\n     * Note that table name comes here already normalized by #tableName method.\n     */\n    prefixTableName(prefix: string, tableName: string): string {\n        return prefix + tableName\n    }\n\n    nestedSetColumnNames = { left: \"nsleft\", right: \"nsright\" }\n    materializedPathColumnName = \"mpath\"\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}