{"ast":null,"code":"import { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\";\nimport { AbstractSqliteQueryRunner } from \"../sqlite-abstract/AbstractSqliteQueryRunner\";\nimport { Broadcaster } from \"../../subscriber/Broadcaster\";\nimport { QueryFailedError } from \"../../error/QueryFailedError\";\nimport { QueryResult } from \"../../query-runner/QueryResult\";\nimport { BroadcasterResult } from \"../../subscriber/BroadcasterResult\";\n/**\n * Runs queries on a single sqlite database connection.\n */\nexport class SqljsQueryRunner extends AbstractSqliteQueryRunner {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(driver) {\n    super();\n    /**\n     * Flag to determine if a modification has happened since the last time this query runner has requested a save.\n     */\n    this.isDirty = false;\n    this.driver = driver;\n    this.connection = driver.connection;\n    this.broadcaster = new Broadcaster(this);\n  }\n  // -------------------------------------------------------------------------\n  // Public methods\n  // -------------------------------------------------------------------------\n  /**\n   * Called before migrations are run.\n   */\n  async beforeMigration() {\n    await this.query(`PRAGMA foreign_keys = OFF`);\n  }\n  /**\n   * Called after migrations are run.\n   */\n  async afterMigration() {\n    await this.query(`PRAGMA foreign_keys = ON`);\n  }\n  async flush() {\n    if (this.isDirty) {\n      await this.driver.autoSave();\n      this.isDirty = false;\n    }\n  }\n  async release() {\n    await this.flush();\n    return super.release();\n  }\n  /**\n   * Commits transaction.\n   * Error will be thrown if transaction was not started.\n   */\n  async commitTransaction() {\n    await super.commitTransaction();\n    if (!this.isTransactionActive) {\n      await this.flush();\n    }\n  }\n  /**\n   * Executes a given SQL query.\n   */\n  async query(query, parameters = [], useStructuredResult = false) {\n    if (this.isReleased) throw new QueryRunnerAlreadyReleasedError();\n    const command = query.trim().split(\" \", 1)[0];\n    const databaseConnection = this.driver.databaseConnection;\n    const broadcasterResult = new BroadcasterResult();\n    this.driver.connection.logger.logQuery(query, parameters, this);\n    this.broadcaster.broadcastBeforeQueryEvent(broadcasterResult, query, parameters);\n    const queryStartTime = +new Date();\n    let statement;\n    try {\n      statement = databaseConnection.prepare(query);\n      if (parameters) {\n        parameters = parameters.map(p => typeof p !== \"undefined\" ? p : null);\n        statement.bind(parameters);\n      }\n      // log slow queries if maxQueryExecution time is set\n      const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;\n      const queryEndTime = +new Date();\n      const queryExecutionTime = queryEndTime - queryStartTime;\n      if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);\n      const records = [];\n      while (statement.step()) {\n        records.push(statement.getAsObject());\n      }\n      this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, records, undefined);\n      const result = new QueryResult();\n      result.affected = databaseConnection.getRowsModified();\n      result.records = records;\n      result.raw = records;\n      statement.free();\n      if (command !== \"SELECT\") {\n        this.isDirty = true;\n      }\n      if (useStructuredResult) {\n        return result;\n      } else {\n        return result.raw;\n      }\n    } catch (err) {\n      if (statement) {\n        statement.free();\n      }\n      this.driver.connection.logger.logQueryError(err, query, parameters, this);\n      this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, undefined, undefined, err);\n      throw new QueryFailedError(query, parameters, err);\n    } finally {\n      await broadcasterResult.wait();\n    }\n  }\n}","map":{"version":3,"names":["QueryRunnerAlreadyReleasedError","AbstractSqliteQueryRunner","Broadcaster","QueryFailedError","QueryResult","BroadcasterResult","SqljsQueryRunner","constructor","driver","isDirty","connection","broadcaster","beforeMigration","query","afterMigration","flush","autoSave","release","commitTransaction","isTransactionActive","parameters","useStructuredResult","isReleased","command","trim","split","databaseConnection","broadcasterResult","logger","logQuery","broadcastBeforeQueryEvent","queryStartTime","Date","statement","prepare","map","p","bind","maxQueryExecutionTime","options","queryEndTime","queryExecutionTime","logQuerySlow","records","step","push","getAsObject","broadcastAfterQueryEvent","undefined","result","affected","getRowsModified","raw","free","err","logQueryError","wait"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\driver\\sqljs\\SqljsQueryRunner.ts"],"sourcesContent":["import { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\"\nimport { AbstractSqliteQueryRunner } from \"../sqlite-abstract/AbstractSqliteQueryRunner\"\nimport { SqljsDriver } from \"./SqljsDriver\"\nimport { Broadcaster } from \"../../subscriber/Broadcaster\"\nimport { QueryFailedError } from \"../../error/QueryFailedError\"\nimport { QueryResult } from \"../../query-runner/QueryResult\"\nimport { BroadcasterResult } from \"../../subscriber/BroadcasterResult\"\n\n/**\n * Runs queries on a single sqlite database connection.\n */\nexport class SqljsQueryRunner extends AbstractSqliteQueryRunner {\n    /**\n     * Flag to determine if a modification has happened since the last time this query runner has requested a save.\n     */\n    private isDirty = false\n\n    /**\n     * Database driver used by connection.\n     */\n    driver: SqljsDriver\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(driver: SqljsDriver) {\n        super()\n        this.driver = driver\n        this.connection = driver.connection\n        this.broadcaster = new Broadcaster(this)\n    }\n\n    // -------------------------------------------------------------------------\n    // Public methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Called before migrations are run.\n     */\n    async beforeMigration(): Promise<void> {\n        await this.query(`PRAGMA foreign_keys = OFF`)\n    }\n\n    /**\n     * Called after migrations are run.\n     */\n    async afterMigration(): Promise<void> {\n        await this.query(`PRAGMA foreign_keys = ON`)\n    }\n\n    private async flush() {\n        if (this.isDirty) {\n            await this.driver.autoSave()\n            this.isDirty = false\n        }\n    }\n\n    async release(): Promise<void> {\n        await this.flush()\n        return super.release()\n    }\n\n    /**\n     * Commits transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async commitTransaction(): Promise<void> {\n        await super.commitTransaction()\n        if (!this.isTransactionActive) {\n            await this.flush()\n        }\n    }\n\n    /**\n     * Executes a given SQL query.\n     */\n    async query(\n        query: string,\n        parameters: any[] = [],\n        useStructuredResult = false,\n    ): Promise<any> {\n        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError()\n\n        const command = query.trim().split(\" \", 1)[0]\n\n        const databaseConnection = this.driver.databaseConnection\n        const broadcasterResult = new BroadcasterResult()\n\n        this.driver.connection.logger.logQuery(query, parameters, this)\n        this.broadcaster.broadcastBeforeQueryEvent(\n            broadcasterResult,\n            query,\n            parameters,\n        )\n\n        const queryStartTime = +new Date()\n        let statement: any\n        try {\n            statement = databaseConnection.prepare(query)\n            if (parameters) {\n                parameters = parameters.map((p) =>\n                    typeof p !== \"undefined\" ? p : null,\n                )\n\n                statement.bind(parameters)\n            }\n\n            // log slow queries if maxQueryExecution time is set\n            const maxQueryExecutionTime =\n                this.driver.options.maxQueryExecutionTime\n            const queryEndTime = +new Date()\n            const queryExecutionTime = queryEndTime - queryStartTime\n\n            if (\n                maxQueryExecutionTime &&\n                queryExecutionTime > maxQueryExecutionTime\n            )\n                this.driver.connection.logger.logQuerySlow(\n                    queryExecutionTime,\n                    query,\n                    parameters,\n                    this,\n                )\n\n            const records: any[] = []\n\n            while (statement.step()) {\n                records.push(statement.getAsObject())\n            }\n\n            this.broadcaster.broadcastAfterQueryEvent(\n                broadcasterResult,\n                query,\n                parameters,\n                true,\n                queryExecutionTime,\n                records,\n                undefined,\n            )\n\n            const result = new QueryResult()\n\n            result.affected = databaseConnection.getRowsModified()\n            result.records = records\n            result.raw = records\n\n            statement.free()\n\n            if (command !== \"SELECT\") {\n                this.isDirty = true\n            }\n\n            if (useStructuredResult) {\n                return result\n            } else {\n                return result.raw\n            }\n        } catch (err) {\n            if (statement) {\n                statement.free()\n            }\n\n            this.driver.connection.logger.logQueryError(\n                err,\n                query,\n                parameters,\n                this,\n            )\n            this.broadcaster.broadcastAfterQueryEvent(\n                broadcasterResult,\n                query,\n                parameters,\n                false,\n                undefined,\n                undefined,\n                err,\n            )\n\n            throw new QueryFailedError(query, parameters, err)\n        } finally {\n            await broadcasterResult.wait()\n        }\n    }\n}\n"],"mappings":"AAAA,SAASA,+BAA+B,QAAQ,6CAA6C;AAC7F,SAASC,yBAAyB,QAAQ,8CAA8C;AAExF,SAASC,WAAW,QAAQ,8BAA8B;AAC1D,SAASC,gBAAgB,QAAQ,8BAA8B;AAC/D,SAASC,WAAW,QAAQ,gCAAgC;AAC5D,SAASC,iBAAiB,QAAQ,oCAAoC;AAEtE;;;AAGA,OAAM,MAAOC,gBAAiB,SAAQL,yBAAyB;EAW3D;EACA;EACA;EAEAM,YAAYC,MAAmB;IAC3B,KAAK,EAAE;IAfX;;;IAGQ,KAAAC,OAAO,GAAG,KAAK;IAanB,IAAI,CAACD,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACE,UAAU,GAAGF,MAAM,CAACE,UAAU;IACnC,IAAI,CAACC,WAAW,GAAG,IAAIT,WAAW,CAAC,IAAI,CAAC;EAC5C;EAEA;EACA;EACA;EAEA;;;EAGA,MAAMU,eAAeA,CAAA;IACjB,MAAM,IAAI,CAACC,KAAK,CAAC,2BAA2B,CAAC;EACjD;EAEA;;;EAGA,MAAMC,cAAcA,CAAA;IAChB,MAAM,IAAI,CAACD,KAAK,CAAC,0BAA0B,CAAC;EAChD;EAEQ,MAAME,KAAKA,CAAA;IACf,IAAI,IAAI,CAACN,OAAO,EAAE;MACd,MAAM,IAAI,CAACD,MAAM,CAACQ,QAAQ,EAAE;MAC5B,IAAI,CAACP,OAAO,GAAG,KAAK;IACxB;EACJ;EAEA,MAAMQ,OAAOA,CAAA;IACT,MAAM,IAAI,CAACF,KAAK,EAAE;IAClB,OAAO,KAAK,CAACE,OAAO,EAAE;EAC1B;EAEA;;;;EAIA,MAAMC,iBAAiBA,CAAA;IACnB,MAAM,KAAK,CAACA,iBAAiB,EAAE;IAC/B,IAAI,CAAC,IAAI,CAACC,mBAAmB,EAAE;MAC3B,MAAM,IAAI,CAACJ,KAAK,EAAE;IACtB;EACJ;EAEA;;;EAGA,MAAMF,KAAKA,CACPA,KAAa,EACbO,UAAA,GAAoB,EAAE,EACtBC,mBAAmB,GAAG,KAAK;IAE3B,IAAI,IAAI,CAACC,UAAU,EAAE,MAAM,IAAItB,+BAA+B,EAAE;IAEhE,MAAMuB,OAAO,GAAGV,KAAK,CAACW,IAAI,EAAE,CAACC,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IAE7C,MAAMC,kBAAkB,GAAG,IAAI,CAAClB,MAAM,CAACkB,kBAAkB;IACzD,MAAMC,iBAAiB,GAAG,IAAItB,iBAAiB,EAAE;IAEjD,IAAI,CAACG,MAAM,CAACE,UAAU,CAACkB,MAAM,CAACC,QAAQ,CAAChB,KAAK,EAAEO,UAAU,EAAE,IAAI,CAAC;IAC/D,IAAI,CAACT,WAAW,CAACmB,yBAAyB,CACtCH,iBAAiB,EACjBd,KAAK,EACLO,UAAU,CACb;IAED,MAAMW,cAAc,GAAG,CAAC,IAAIC,IAAI,EAAE;IAClC,IAAIC,SAAc;IAClB,IAAI;MACAA,SAAS,GAAGP,kBAAkB,CAACQ,OAAO,CAACrB,KAAK,CAAC;MAC7C,IAAIO,UAAU,EAAE;QACZA,UAAU,GAAGA,UAAU,CAACe,GAAG,CAAEC,CAAC,IAC1B,OAAOA,CAAC,KAAK,WAAW,GAAGA,CAAC,GAAG,IAAI,CACtC;QAEDH,SAAS,CAACI,IAAI,CAACjB,UAAU,CAAC;MAC9B;MAEA;MACA,MAAMkB,qBAAqB,GACvB,IAAI,CAAC9B,MAAM,CAAC+B,OAAO,CAACD,qBAAqB;MAC7C,MAAME,YAAY,GAAG,CAAC,IAAIR,IAAI,EAAE;MAChC,MAAMS,kBAAkB,GAAGD,YAAY,GAAGT,cAAc;MAExD,IACIO,qBAAqB,IACrBG,kBAAkB,GAAGH,qBAAqB,EAE1C,IAAI,CAAC9B,MAAM,CAACE,UAAU,CAACkB,MAAM,CAACc,YAAY,CACtCD,kBAAkB,EAClB5B,KAAK,EACLO,UAAU,EACV,IAAI,CACP;MAEL,MAAMuB,OAAO,GAAU,EAAE;MAEzB,OAAOV,SAAS,CAACW,IAAI,EAAE,EAAE;QACrBD,OAAO,CAACE,IAAI,CAACZ,SAAS,CAACa,WAAW,EAAE,CAAC;MACzC;MAEA,IAAI,CAACnC,WAAW,CAACoC,wBAAwB,CACrCpB,iBAAiB,EACjBd,KAAK,EACLO,UAAU,EACV,IAAI,EACJqB,kBAAkB,EAClBE,OAAO,EACPK,SAAS,CACZ;MAED,MAAMC,MAAM,GAAG,IAAI7C,WAAW,EAAE;MAEhC6C,MAAM,CAACC,QAAQ,GAAGxB,kBAAkB,CAACyB,eAAe,EAAE;MACtDF,MAAM,CAACN,OAAO,GAAGA,OAAO;MACxBM,MAAM,CAACG,GAAG,GAAGT,OAAO;MAEpBV,SAAS,CAACoB,IAAI,EAAE;MAEhB,IAAI9B,OAAO,KAAK,QAAQ,EAAE;QACtB,IAAI,CAACd,OAAO,GAAG,IAAI;MACvB;MAEA,IAAIY,mBAAmB,EAAE;QACrB,OAAO4B,MAAM;MACjB,CAAC,MAAM;QACH,OAAOA,MAAM,CAACG,GAAG;MACrB;IACJ,CAAC,CAAC,OAAOE,GAAG,EAAE;MACV,IAAIrB,SAAS,EAAE;QACXA,SAAS,CAACoB,IAAI,EAAE;MACpB;MAEA,IAAI,CAAC7C,MAAM,CAACE,UAAU,CAACkB,MAAM,CAAC2B,aAAa,CACvCD,GAAG,EACHzC,KAAK,EACLO,UAAU,EACV,IAAI,CACP;MACD,IAAI,CAACT,WAAW,CAACoC,wBAAwB,CACrCpB,iBAAiB,EACjBd,KAAK,EACLO,UAAU,EACV,KAAK,EACL4B,SAAS,EACTA,SAAS,EACTM,GAAG,CACN;MAED,MAAM,IAAInD,gBAAgB,CAACU,KAAK,EAAEO,UAAU,EAAEkC,GAAG,CAAC;IACtD,CAAC,SAAS;MACN,MAAM3B,iBAAiB,CAAC6B,IAAI,EAAE;IAClC;EACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}