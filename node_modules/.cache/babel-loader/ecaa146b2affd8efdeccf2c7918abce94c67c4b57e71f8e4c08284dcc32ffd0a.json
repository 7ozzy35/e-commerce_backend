{"ast":null,"code":"export class ObjectUtils {\n  /**\n   * Checks if given value is an object.\n   * We cannot use instanceof because it has problems when running on different contexts.\n   * And we don't simply use typeof because typeof null === \"object\".\n   */\n  static isObject(val) {\n    return val !== null && typeof val === \"object\";\n  }\n  /**\n   * Checks if given value is an object.\n   * We cannot use instanceof because it has problems when running on different contexts.\n   * And we don't simply use typeof because typeof null === \"object\".\n   */\n  static isObjectWithName(val) {\n    return val !== null && typeof val === \"object\" && val[\"name\"] !== undefined;\n  }\n  /**\n   * Copy the values of all of the enumerable own properties from one or more source objects to a\n   * target object.\n   * @param target The target object to copy to.\n   * @param sources One or more source objects from which to copy properties\n   */\n  static assign(target, ...sources) {\n    for (const source of sources) {\n      for (const prop of Object.getOwnPropertyNames(source)) {\n        ;\n        target[prop] = source[prop];\n      }\n    }\n  }\n  /**\n   * Converts MixedList<T> to strictly an array of its T items.\n   */\n  static mixedListToArray(list) {\n    if (list !== null && typeof list === \"object\") {\n      return Object.keys(list).map(key => list[key]);\n    } else {\n      return list;\n    }\n  }\n}","map":{"version":3,"names":["ObjectUtils","isObject","val","isObjectWithName","undefined","assign","target","sources","source","prop","Object","getOwnPropertyNames","mixedListToArray","list","keys","map","key"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\util\\ObjectUtils.ts"],"sourcesContent":["import { MixedList } from \"../common/MixedList\"\n\nexport class ObjectUtils {\n    /**\n     * Checks if given value is an object.\n     * We cannot use instanceof because it has problems when running on different contexts.\n     * And we don't simply use typeof because typeof null === \"object\".\n     */\n    static isObject(val: any): val is Object {\n        return val !== null && typeof val === \"object\"\n    }\n\n    /**\n     * Checks if given value is an object.\n     * We cannot use instanceof because it has problems when running on different contexts.\n     * And we don't simply use typeof because typeof null === \"object\".\n     */\n    static isObjectWithName(val: any): val is Object & { name: string } {\n        return (\n            val !== null && typeof val === \"object\" && val[\"name\"] !== undefined\n        )\n    }\n\n    /**\n     * Copy the values of all of the enumerable own properties from one or more source objects to a\n     * target object.\n     * @param target The target object to copy to.\n     * @param source The source object from which to copy properties.\n     */\n    static assign<T, U>(target: T, source: U): void\n\n    /**\n     * Copy the values of all of the enumerable own properties from one or more source objects to a\n     * target object.\n     * @param target The target object to copy to.\n     * @param source1 The first source object from which to copy properties.\n     * @param source2 The second source object from which to copy properties.\n     */\n    static assign<T, U, V>(target: T, source1: U, source2: V): void\n\n    /**\n     * Copy the values of all of the enumerable own properties from one or more source objects to a\n     * target object.\n     * @param target The target object to copy to.\n     * @param source1 The first source object from which to copy properties.\n     * @param source2 The second source object from which to copy properties.\n     * @param source3 The third source object from which to copy properties.\n     */\n    static assign<T, U, V, W>(\n        target: T,\n        source1: U,\n        source2: V,\n        source3: W,\n    ): void\n\n    /**\n     * Copy the values of all of the enumerable own properties from one or more source objects to a\n     * target object.\n     * @param target The target object to copy to.\n     * @param sources One or more source objects from which to copy properties\n     */\n    static assign(target: object, ...sources: any[]): void {\n        for (const source of sources) {\n            for (const prop of Object.getOwnPropertyNames(source)) {\n                ;(target as any)[prop] = source[prop]\n            }\n        }\n    }\n\n    /**\n     * Converts MixedList<T> to strictly an array of its T items.\n     */\n    static mixedListToArray<T>(list: MixedList<T>): T[] {\n        if (list !== null && typeof list === \"object\") {\n            return Object.keys(list).map(\n                (key) => (list as { [key: string]: T })[key],\n            )\n        } else {\n            return list\n        }\n    }\n}\n"],"mappings":"AAEA,OAAM,MAAOA,WAAW;EACpB;;;;;EAKA,OAAOC,QAAQA,CAACC,GAAQ;IACpB,OAAOA,GAAG,KAAK,IAAI,IAAI,OAAOA,GAAG,KAAK,QAAQ;EAClD;EAEA;;;;;EAKA,OAAOC,gBAAgBA,CAACD,GAAQ;IAC5B,OACIA,GAAG,KAAK,IAAI,IAAI,OAAOA,GAAG,KAAK,QAAQ,IAAIA,GAAG,CAAC,MAAM,CAAC,KAAKE,SAAS;EAE5E;EAkCA;;;;;;EAMA,OAAOC,MAAMA,CAACC,MAAc,EAAE,GAAGC,OAAc;IAC3C,KAAK,MAAMC,MAAM,IAAID,OAAO,EAAE;MAC1B,KAAK,MAAME,IAAI,IAAIC,MAAM,CAACC,mBAAmB,CAACH,MAAM,CAAC,EAAE;QACnD;QAAEF,MAAc,CAACG,IAAI,CAAC,GAAGD,MAAM,CAACC,IAAI,CAAC;MACzC;IACJ;EACJ;EAEA;;;EAGA,OAAOG,gBAAgBA,CAAIC,IAAkB;IACzC,IAAIA,IAAI,KAAK,IAAI,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;MAC3C,OAAOH,MAAM,CAACI,IAAI,CAACD,IAAI,CAAC,CAACE,GAAG,CACvBC,GAAG,IAAMH,IAA6B,CAACG,GAAG,CAAC,CAC/C;IACL,CAAC,MAAM;MACH,OAAOH,IAAI;IACf;EACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}