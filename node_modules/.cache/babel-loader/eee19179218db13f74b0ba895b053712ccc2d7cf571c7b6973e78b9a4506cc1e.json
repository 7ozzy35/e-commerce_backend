{"ast":null,"code":"import { ColumnMetadata } from \"../metadata/ColumnMetadata\";\nimport { UniqueMetadata } from \"../metadata/UniqueMetadata\";\nimport { ForeignKeyMetadata } from \"../metadata/ForeignKeyMetadata\";\nimport { TypeORMError } from \"../error\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Builds join column for the many-to-one and one-to-one owner relations.\n *\n * Cases it should cover:\n * 1. when join column is set with custom name and without referenced column name\n * we need automatically set referenced column name - primary ids by default\n * @JoinColumn({ name: \"custom_name\" })\n *\n * 2. when join column is set with only referenced column name\n * we need automatically set join column name - relation name + referenced column name\n * @JoinColumn({ referencedColumnName: \"title\" })\n *\n * 3. when join column is set without both referenced column name and join column name\n * we need to automatically set both of them\n * @JoinColumn()\n *\n * 4. when join column is not set at all (as in case of @ManyToOne relation)\n * we need to create join column for it with proper referenced column name and join column name\n *\n * 5. when multiple join columns set none of referencedColumnName and name can be optional\n * both options are required\n * @JoinColumn([\n *      { name: \"category_title\", referencedColumnName: \"type\" },\n *      { name: \"category_title\", referencedColumnName: \"name\" },\n * ])\n *\n * Since for many-to-one relations having JoinColumn decorator is not required,\n * we need to go through each many-to-one relation without join column decorator set\n * and create join column metadata args for them.\n */\nexport class RelationJoinColumnBuilder {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    this.connection = connection;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Builds a foreign key of the many-to-one or one-to-one owner relations.\n   */\n  build(joinColumns, relation) {\n    const referencedColumns = this.collectReferencedColumns(joinColumns, relation);\n    const columns = this.collectColumns(joinColumns, relation, referencedColumns);\n    if (!referencedColumns.length || !relation.createForeignKeyConstraints) return {\n      foreignKey: undefined,\n      columns,\n      uniqueConstraint: undefined\n    }; // this case is possible for one-to-one non owning side and relations with createForeignKeyConstraints = false\n    const foreignKey = new ForeignKeyMetadata({\n      name: joinColumns[0]?.foreignKeyConstraintName,\n      entityMetadata: relation.entityMetadata,\n      referencedEntityMetadata: relation.inverseEntityMetadata,\n      namingStrategy: this.connection.namingStrategy,\n      columns,\n      referencedColumns,\n      onDelete: relation.onDelete,\n      onUpdate: relation.onUpdate,\n      deferrable: relation.deferrable\n    });\n    // SQL requires UNIQUE/PK constraints on columns referenced by a FK\n    // Skip creating the unique constraint for the referenced columns if\n    // they are already contained in the PK of the referenced entity\n    if (columns.every(column => column.isPrimary) || !relation.isOneToOne) {\n      return {\n        foreignKey,\n        columns,\n        uniqueConstraint: undefined\n      };\n    }\n    const uniqueConstraint = new UniqueMetadata({\n      entityMetadata: relation.entityMetadata,\n      columns: foreignKey.columns,\n      args: {\n        name: this.connection.namingStrategy.relationConstraintName(relation.entityMetadata.tableName, foreignKey.columns.map(column => column.databaseName)),\n        target: relation.entityMetadata.target\n      }\n    });\n    uniqueConstraint.build(this.connection.namingStrategy);\n    return {\n      foreignKey,\n      columns,\n      uniqueConstraint\n    };\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Collects referenced columns from the given join column args.\n   */\n  collectReferencedColumns(joinColumns, relation) {\n    const hasAnyReferencedColumnName = joinColumns.find(joinColumnArgs => !!joinColumnArgs.referencedColumnName);\n    const manyToOneWithoutJoinColumn = joinColumns.length === 0 && relation.isManyToOne;\n    const hasJoinColumnWithoutAnyReferencedColumnName = joinColumns.length > 0 && !hasAnyReferencedColumnName;\n    if (manyToOneWithoutJoinColumn || hasJoinColumnWithoutAnyReferencedColumnName) {\n      // covers case3 and case1\n      return relation.inverseEntityMetadata.primaryColumns;\n    } else {\n      // cases with referenced columns defined\n      return joinColumns.map(joinColumn => {\n        const referencedColumn = relation.inverseEntityMetadata.ownColumns.find(column => column.propertyName === joinColumn.referencedColumnName); // todo: can we also search in relations?\n        if (!referencedColumn) throw new TypeORMError(`Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.inverseEntityMetadata.name}`);\n        return referencedColumn;\n      });\n    }\n  }\n  /**\n   * Collects columns from the given join column args.\n   */\n  collectColumns(joinColumns, relation, referencedColumns) {\n    return referencedColumns.map(referencedColumn => {\n      // in the case if relation has join column with only name set we need this check\n      const joinColumnMetadataArg = joinColumns.find(joinColumn => {\n        return (!joinColumn.referencedColumnName || joinColumn.referencedColumnName === referencedColumn.propertyName) && !!joinColumn.name;\n      });\n      const joinColumnName = joinColumnMetadataArg ? joinColumnMetadataArg.name : this.connection.namingStrategy.joinColumnName(relation.propertyName, referencedColumn.propertyName);\n      const relationalColumns = relation.embeddedMetadata ? relation.embeddedMetadata.columns : relation.entityMetadata.ownColumns;\n      let relationalColumn = relationalColumns.find(column => column.databaseNameWithoutPrefixes === joinColumnName);\n      if (!relationalColumn) {\n        relationalColumn = new ColumnMetadata({\n          connection: this.connection,\n          entityMetadata: relation.entityMetadata,\n          embeddedMetadata: relation.embeddedMetadata,\n          args: {\n            target: \"\",\n            mode: \"virtual\",\n            propertyName: relation.propertyName,\n            options: {\n              name: joinColumnName,\n              type: referencedColumn.type,\n              length: !referencedColumn.length && (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\") &&\n              // some versions of mariadb support the column type and should not try to provide the length property\n              this.connection.driver.normalizeType(referencedColumn) !== \"uuid\" && (referencedColumn.generationStrategy === \"uuid\" || referencedColumn.type === \"uuid\") ? \"36\" : referencedColumn.length,\n              // fix https://github.com/typeorm/typeorm/issues/3604\n              width: referencedColumn.width,\n              charset: referencedColumn.charset,\n              collation: referencedColumn.collation,\n              precision: referencedColumn.precision,\n              scale: referencedColumn.scale,\n              zerofill: referencedColumn.zerofill,\n              unsigned: referencedColumn.unsigned,\n              comment: referencedColumn.comment,\n              enum: referencedColumn.enum,\n              enumName: referencedColumn.enumName,\n              primary: relation.isPrimary,\n              nullable: relation.isNullable\n            }\n          }\n        });\n        relation.entityMetadata.registerColumn(relationalColumn);\n      }\n      relationalColumn.referencedColumn = referencedColumn; // its important to set it here because we need to set referenced column for user defined join column\n      relationalColumn.type = referencedColumn.type; // also since types of relational column and join column must be equal we override user defined column type\n      relationalColumn.relationMetadata = relation;\n      relationalColumn.build(this.connection);\n      return relationalColumn;\n    });\n  }\n}","map":{"version":3,"names":["ColumnMetadata","UniqueMetadata","ForeignKeyMetadata","TypeORMError","DriverUtils","RelationJoinColumnBuilder","constructor","connection","build","joinColumns","relation","referencedColumns","collectReferencedColumns","columns","collectColumns","length","createForeignKeyConstraints","foreignKey","undefined","uniqueConstraint","name","foreignKeyConstraintName","entityMetadata","referencedEntityMetadata","inverseEntityMetadata","namingStrategy","onDelete","onUpdate","deferrable","every","column","isPrimary","isOneToOne","args","relationConstraintName","tableName","map","databaseName","target","hasAnyReferencedColumnName","find","joinColumnArgs","referencedColumnName","manyToOneWithoutJoinColumn","isManyToOne","hasJoinColumnWithoutAnyReferencedColumnName","primaryColumns","joinColumn","referencedColumn","ownColumns","propertyName","joinColumnMetadataArg","joinColumnName","relationalColumns","embeddedMetadata","relationalColumn","databaseNameWithoutPrefixes","mode","options","type","isMySQLFamily","driver","normalizeType","generationStrategy","width","charset","collation","precision","scale","zerofill","unsigned","comment","enum","enumName","primary","nullable","isNullable","registerColumn","relationMetadata"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\metadata-builder\\RelationJoinColumnBuilder.ts"],"sourcesContent":["import { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { UniqueMetadata } from \"../metadata/UniqueMetadata\"\nimport { ForeignKeyMetadata } from \"../metadata/ForeignKeyMetadata\"\nimport { RelationMetadata } from \"../metadata/RelationMetadata\"\nimport { JoinColumnMetadataArgs } from \"../metadata-args/JoinColumnMetadataArgs\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { TypeORMError } from \"../error\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\n\n/**\n * Builds join column for the many-to-one and one-to-one owner relations.\n *\n * Cases it should cover:\n * 1. when join column is set with custom name and without referenced column name\n * we need automatically set referenced column name - primary ids by default\n * @JoinColumn({ name: \"custom_name\" })\n *\n * 2. when join column is set with only referenced column name\n * we need automatically set join column name - relation name + referenced column name\n * @JoinColumn({ referencedColumnName: \"title\" })\n *\n * 3. when join column is set without both referenced column name and join column name\n * we need to automatically set both of them\n * @JoinColumn()\n *\n * 4. when join column is not set at all (as in case of @ManyToOne relation)\n * we need to create join column for it with proper referenced column name and join column name\n *\n * 5. when multiple join columns set none of referencedColumnName and name can be optional\n * both options are required\n * @JoinColumn([\n *      { name: \"category_title\", referencedColumnName: \"type\" },\n *      { name: \"category_title\", referencedColumnName: \"name\" },\n * ])\n *\n * Since for many-to-one relations having JoinColumn decorator is not required,\n * we need to go through each many-to-one relation without join column decorator set\n * and create join column metadata args for them.\n */\nexport class RelationJoinColumnBuilder {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private connection: DataSource) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Builds a foreign key of the many-to-one or one-to-one owner relations.\n     */\n    build(\n        joinColumns: JoinColumnMetadataArgs[],\n        relation: RelationMetadata,\n    ): {\n        foreignKey: ForeignKeyMetadata | undefined\n        columns: ColumnMetadata[]\n        uniqueConstraint: UniqueMetadata | undefined\n    } {\n        const referencedColumns = this.collectReferencedColumns(\n            joinColumns,\n            relation,\n        )\n        const columns = this.collectColumns(\n            joinColumns,\n            relation,\n            referencedColumns,\n        )\n        if (!referencedColumns.length || !relation.createForeignKeyConstraints)\n            return {\n                foreignKey: undefined,\n                columns,\n                uniqueConstraint: undefined,\n            } // this case is possible for one-to-one non owning side and relations with createForeignKeyConstraints = false\n\n        const foreignKey = new ForeignKeyMetadata({\n            name: joinColumns[0]?.foreignKeyConstraintName,\n            entityMetadata: relation.entityMetadata,\n            referencedEntityMetadata: relation.inverseEntityMetadata,\n            namingStrategy: this.connection.namingStrategy,\n            columns,\n            referencedColumns,\n            onDelete: relation.onDelete,\n            onUpdate: relation.onUpdate,\n            deferrable: relation.deferrable,\n        })\n\n        // SQL requires UNIQUE/PK constraints on columns referenced by a FK\n        // Skip creating the unique constraint for the referenced columns if\n        // they are already contained in the PK of the referenced entity\n        if (\n            columns.every((column) => column.isPrimary) ||\n            !relation.isOneToOne\n        ) {\n            return { foreignKey, columns, uniqueConstraint: undefined }\n        }\n\n        const uniqueConstraint = new UniqueMetadata({\n            entityMetadata: relation.entityMetadata,\n            columns: foreignKey.columns,\n            args: {\n                name: this.connection.namingStrategy.relationConstraintName(\n                    relation.entityMetadata.tableName,\n                    foreignKey.columns.map((column) => column.databaseName),\n                ),\n                target: relation.entityMetadata.target,\n            },\n        })\n        uniqueConstraint.build(this.connection.namingStrategy)\n\n        return { foreignKey, columns, uniqueConstraint }\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Collects referenced columns from the given join column args.\n     */\n    protected collectReferencedColumns(\n        joinColumns: JoinColumnMetadataArgs[],\n        relation: RelationMetadata,\n    ): ColumnMetadata[] {\n        const hasAnyReferencedColumnName = joinColumns.find(\n            (joinColumnArgs) => !!joinColumnArgs.referencedColumnName,\n        )\n        const manyToOneWithoutJoinColumn =\n            joinColumns.length === 0 && relation.isManyToOne\n        const hasJoinColumnWithoutAnyReferencedColumnName =\n            joinColumns.length > 0 && !hasAnyReferencedColumnName\n\n        if (\n            manyToOneWithoutJoinColumn ||\n            hasJoinColumnWithoutAnyReferencedColumnName\n        ) {\n            // covers case3 and case1\n            return relation.inverseEntityMetadata.primaryColumns\n        } else {\n            // cases with referenced columns defined\n            return joinColumns.map((joinColumn) => {\n                const referencedColumn =\n                    relation.inverseEntityMetadata.ownColumns.find(\n                        (column) =>\n                            column.propertyName ===\n                            joinColumn.referencedColumnName,\n                    ) // todo: can we also search in relations?\n                if (!referencedColumn)\n                    throw new TypeORMError(\n                        `Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.inverseEntityMetadata.name}`,\n                    )\n\n                return referencedColumn\n            })\n        }\n    }\n\n    /**\n     * Collects columns from the given join column args.\n     */\n    private collectColumns(\n        joinColumns: JoinColumnMetadataArgs[],\n        relation: RelationMetadata,\n        referencedColumns: ColumnMetadata[],\n    ): ColumnMetadata[] {\n        return referencedColumns.map((referencedColumn) => {\n            // in the case if relation has join column with only name set we need this check\n            const joinColumnMetadataArg = joinColumns.find((joinColumn) => {\n                return (\n                    (!joinColumn.referencedColumnName ||\n                        joinColumn.referencedColumnName ===\n                            referencedColumn.propertyName) &&\n                    !!joinColumn.name\n                )\n            })\n            const joinColumnName = joinColumnMetadataArg\n                ? joinColumnMetadataArg.name\n                : this.connection.namingStrategy.joinColumnName(\n                      relation.propertyName,\n                      referencedColumn.propertyName,\n                  )\n\n            const relationalColumns = relation.embeddedMetadata\n                ? relation.embeddedMetadata.columns\n                : relation.entityMetadata.ownColumns\n            let relationalColumn = relationalColumns.find(\n                (column) =>\n                    column.databaseNameWithoutPrefixes === joinColumnName,\n            )\n            if (!relationalColumn) {\n                relationalColumn = new ColumnMetadata({\n                    connection: this.connection,\n                    entityMetadata: relation.entityMetadata,\n                    embeddedMetadata: relation.embeddedMetadata,\n                    args: {\n                        target: \"\",\n                        mode: \"virtual\",\n                        propertyName: relation.propertyName,\n                        options: {\n                            name: joinColumnName,\n                            type: referencedColumn.type,\n                            length:\n                                !referencedColumn.length &&\n                                (DriverUtils.isMySQLFamily(\n                                    this.connection.driver,\n                                ) ||\n                                    this.connection.driver.options.type ===\n                                        \"aurora-mysql\") &&\n                                // some versions of mariadb support the column type and should not try to provide the length property\n                                this.connection.driver.normalizeType(\n                                    referencedColumn,\n                                ) !== \"uuid\" &&\n                                (referencedColumn.generationStrategy ===\n                                    \"uuid\" ||\n                                    referencedColumn.type === \"uuid\")\n                                    ? \"36\"\n                                    : referencedColumn.length, // fix https://github.com/typeorm/typeorm/issues/3604\n                            width: referencedColumn.width,\n                            charset: referencedColumn.charset,\n                            collation: referencedColumn.collation,\n                            precision: referencedColumn.precision,\n                            scale: referencedColumn.scale,\n                            zerofill: referencedColumn.zerofill,\n                            unsigned: referencedColumn.unsigned,\n                            comment: referencedColumn.comment,\n                            enum: referencedColumn.enum,\n                            enumName: referencedColumn.enumName,\n                            primary: relation.isPrimary,\n                            nullable: relation.isNullable,\n                        },\n                    },\n                })\n                relation.entityMetadata.registerColumn(relationalColumn)\n            }\n            relationalColumn.referencedColumn = referencedColumn // its important to set it here because we need to set referenced column for user defined join column\n            relationalColumn.type = referencedColumn.type // also since types of relational column and join column must be equal we override user defined column type\n            relationalColumn.relationMetadata = relation\n            relationalColumn.build(this.connection)\n            return relationalColumn\n        })\n    }\n}\n"],"mappings":"AAAA,SAASA,cAAc,QAAQ,4BAA4B;AAC3D,SAASC,cAAc,QAAQ,4BAA4B;AAC3D,SAASC,kBAAkB,QAAQ,gCAAgC;AAInE,SAASC,YAAY,QAAQ,UAAU;AACvC,SAASC,WAAW,QAAQ,uBAAuB;AAEnD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA,OAAM,MAAOC,yBAAyB;EAClC;EACA;EACA;EAEAC,YAAoBC,UAAsB;IAAtB,KAAAA,UAAU,GAAVA,UAAU;EAAe;EAE7C;EACA;EACA;EAEA;;;EAGAC,KAAKA,CACDC,WAAqC,EACrCC,QAA0B;IAM1B,MAAMC,iBAAiB,GAAG,IAAI,CAACC,wBAAwB,CACnDH,WAAW,EACXC,QAAQ,CACX;IACD,MAAMG,OAAO,GAAG,IAAI,CAACC,cAAc,CAC/BL,WAAW,EACXC,QAAQ,EACRC,iBAAiB,CACpB;IACD,IAAI,CAACA,iBAAiB,CAACI,MAAM,IAAI,CAACL,QAAQ,CAACM,2BAA2B,EAClE,OAAO;MACHC,UAAU,EAAEC,SAAS;MACrBL,OAAO;MACPM,gBAAgB,EAAED;KACrB,EAAC;IAEN,MAAMD,UAAU,GAAG,IAAIf,kBAAkB,CAAC;MACtCkB,IAAI,EAAEX,WAAW,CAAC,CAAC,CAAC,EAAEY,wBAAwB;MAC9CC,cAAc,EAAEZ,QAAQ,CAACY,cAAc;MACvCC,wBAAwB,EAAEb,QAAQ,CAACc,qBAAqB;MACxDC,cAAc,EAAE,IAAI,CAAClB,UAAU,CAACkB,cAAc;MAC9CZ,OAAO;MACPF,iBAAiB;MACjBe,QAAQ,EAAEhB,QAAQ,CAACgB,QAAQ;MAC3BC,QAAQ,EAAEjB,QAAQ,CAACiB,QAAQ;MAC3BC,UAAU,EAAElB,QAAQ,CAACkB;KACxB,CAAC;IAEF;IACA;IACA;IACA,IACIf,OAAO,CAACgB,KAAK,CAAEC,MAAM,IAAKA,MAAM,CAACC,SAAS,CAAC,IAC3C,CAACrB,QAAQ,CAACsB,UAAU,EACtB;MACE,OAAO;QAAEf,UAAU;QAAEJ,OAAO;QAAEM,gBAAgB,EAAED;MAAS,CAAE;IAC/D;IAEA,MAAMC,gBAAgB,GAAG,IAAIlB,cAAc,CAAC;MACxCqB,cAAc,EAAEZ,QAAQ,CAACY,cAAc;MACvCT,OAAO,EAAEI,UAAU,CAACJ,OAAO;MAC3BoB,IAAI,EAAE;QACFb,IAAI,EAAE,IAAI,CAACb,UAAU,CAACkB,cAAc,CAACS,sBAAsB,CACvDxB,QAAQ,CAACY,cAAc,CAACa,SAAS,EACjClB,UAAU,CAACJ,OAAO,CAACuB,GAAG,CAAEN,MAAM,IAAKA,MAAM,CAACO,YAAY,CAAC,CAC1D;QACDC,MAAM,EAAE5B,QAAQ,CAACY,cAAc,CAACgB;;KAEvC,CAAC;IACFnB,gBAAgB,CAACX,KAAK,CAAC,IAAI,CAACD,UAAU,CAACkB,cAAc,CAAC;IAEtD,OAAO;MAAER,UAAU;MAAEJ,OAAO;MAAEM;IAAgB,CAAE;EACpD;EAEA;EACA;EACA;EAEA;;;EAGUP,wBAAwBA,CAC9BH,WAAqC,EACrCC,QAA0B;IAE1B,MAAM6B,0BAA0B,GAAG9B,WAAW,CAAC+B,IAAI,CAC9CC,cAAc,IAAK,CAAC,CAACA,cAAc,CAACC,oBAAoB,CAC5D;IACD,MAAMC,0BAA0B,GAC5BlC,WAAW,CAACM,MAAM,KAAK,CAAC,IAAIL,QAAQ,CAACkC,WAAW;IACpD,MAAMC,2CAA2C,GAC7CpC,WAAW,CAACM,MAAM,GAAG,CAAC,IAAI,CAACwB,0BAA0B;IAEzD,IACII,0BAA0B,IAC1BE,2CAA2C,EAC7C;MACE;MACA,OAAOnC,QAAQ,CAACc,qBAAqB,CAACsB,cAAc;IACxD,CAAC,MAAM;MACH;MACA,OAAOrC,WAAW,CAAC2B,GAAG,CAAEW,UAAU,IAAI;QAClC,MAAMC,gBAAgB,GAClBtC,QAAQ,CAACc,qBAAqB,CAACyB,UAAU,CAACT,IAAI,CACzCV,MAAM,IACHA,MAAM,CAACoB,YAAY,KACnBH,UAAU,CAACL,oBAAoB,CACtC,EAAC;QACN,IAAI,CAACM,gBAAgB,EACjB,MAAM,IAAI7C,YAAY,CAClB,qBAAqB4C,UAAU,CAACL,oBAAoB,4BAA4BhC,QAAQ,CAACc,qBAAqB,CAACJ,IAAI,EAAE,CACxH;QAEL,OAAO4B,gBAAgB;MAC3B,CAAC,CAAC;IACN;EACJ;EAEA;;;EAGQlC,cAAcA,CAClBL,WAAqC,EACrCC,QAA0B,EAC1BC,iBAAmC;IAEnC,OAAOA,iBAAiB,CAACyB,GAAG,CAAEY,gBAAgB,IAAI;MAC9C;MACA,MAAMG,qBAAqB,GAAG1C,WAAW,CAAC+B,IAAI,CAAEO,UAAU,IAAI;QAC1D,OACI,CAAC,CAACA,UAAU,CAACL,oBAAoB,IAC7BK,UAAU,CAACL,oBAAoB,KAC3BM,gBAAgB,CAACE,YAAY,KACrC,CAAC,CAACH,UAAU,CAAC3B,IAAI;MAEzB,CAAC,CAAC;MACF,MAAMgC,cAAc,GAAGD,qBAAqB,GACtCA,qBAAqB,CAAC/B,IAAI,GAC1B,IAAI,CAACb,UAAU,CAACkB,cAAc,CAAC2B,cAAc,CACzC1C,QAAQ,CAACwC,YAAY,EACrBF,gBAAgB,CAACE,YAAY,CAChC;MAEP,MAAMG,iBAAiB,GAAG3C,QAAQ,CAAC4C,gBAAgB,GAC7C5C,QAAQ,CAAC4C,gBAAgB,CAACzC,OAAO,GACjCH,QAAQ,CAACY,cAAc,CAAC2B,UAAU;MACxC,IAAIM,gBAAgB,GAAGF,iBAAiB,CAACb,IAAI,CACxCV,MAAM,IACHA,MAAM,CAAC0B,2BAA2B,KAAKJ,cAAc,CAC5D;MACD,IAAI,CAACG,gBAAgB,EAAE;QACnBA,gBAAgB,GAAG,IAAIvD,cAAc,CAAC;UAClCO,UAAU,EAAE,IAAI,CAACA,UAAU;UAC3Be,cAAc,EAAEZ,QAAQ,CAACY,cAAc;UACvCgC,gBAAgB,EAAE5C,QAAQ,CAAC4C,gBAAgB;UAC3CrB,IAAI,EAAE;YACFK,MAAM,EAAE,EAAE;YACVmB,IAAI,EAAE,SAAS;YACfP,YAAY,EAAExC,QAAQ,CAACwC,YAAY;YACnCQ,OAAO,EAAE;cACLtC,IAAI,EAAEgC,cAAc;cACpBO,IAAI,EAAEX,gBAAgB,CAACW,IAAI;cAC3B5C,MAAM,EACF,CAACiC,gBAAgB,CAACjC,MAAM,KACvBX,WAAW,CAACwD,aAAa,CACtB,IAAI,CAACrD,UAAU,CAACsD,MAAM,CACzB,IACG,IAAI,CAACtD,UAAU,CAACsD,MAAM,CAACH,OAAO,CAACC,IAAI,KAC/B,cAAc,CAAC;cACvB;cACA,IAAI,CAACpD,UAAU,CAACsD,MAAM,CAACC,aAAa,CAChCd,gBAAgB,CACnB,KAAK,MAAM,KACXA,gBAAgB,CAACe,kBAAkB,KAChC,MAAM,IACNf,gBAAgB,CAACW,IAAI,KAAK,MAAM,CAAC,GAC/B,IAAI,GACJX,gBAAgB,CAACjC,MAAM;cAAE;cACnCiD,KAAK,EAAEhB,gBAAgB,CAACgB,KAAK;cAC7BC,OAAO,EAAEjB,gBAAgB,CAACiB,OAAO;cACjCC,SAAS,EAAElB,gBAAgB,CAACkB,SAAS;cACrCC,SAAS,EAAEnB,gBAAgB,CAACmB,SAAS;cACrCC,KAAK,EAAEpB,gBAAgB,CAACoB,KAAK;cAC7BC,QAAQ,EAAErB,gBAAgB,CAACqB,QAAQ;cACnCC,QAAQ,EAAEtB,gBAAgB,CAACsB,QAAQ;cACnCC,OAAO,EAAEvB,gBAAgB,CAACuB,OAAO;cACjCC,IAAI,EAAExB,gBAAgB,CAACwB,IAAI;cAC3BC,QAAQ,EAAEzB,gBAAgB,CAACyB,QAAQ;cACnCC,OAAO,EAAEhE,QAAQ,CAACqB,SAAS;cAC3B4C,QAAQ,EAAEjE,QAAQ,CAACkE;;;SAG9B,CAAC;QACFlE,QAAQ,CAACY,cAAc,CAACuD,cAAc,CAACtB,gBAAgB,CAAC;MAC5D;MACAA,gBAAgB,CAACP,gBAAgB,GAAGA,gBAAgB,EAAC;MACrDO,gBAAgB,CAACI,IAAI,GAAGX,gBAAgB,CAACW,IAAI,EAAC;MAC9CJ,gBAAgB,CAACuB,gBAAgB,GAAGpE,QAAQ;MAC5C6C,gBAAgB,CAAC/C,KAAK,CAAC,IAAI,CAACD,UAAU,CAAC;MACvC,OAAOgD,gBAAgB;IAC3B,CAAC,CAAC;EACN","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}