{"ast":null,"code":"import { PlatformTools } from \"../platform/PlatformTools\";\nimport { TypeORMError } from \"../error/TypeORMError\";\n/**\n * Caches query result into Redis database.\n */\nexport class RedisQueryResultCache {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection, clientType) {\n    this.connection = connection;\n    this.clientType = clientType;\n    this.redis = this.loadRedis();\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates a connection with given cache provider.\n   */\n  async connect() {\n    const cacheOptions = this.connection.options.cache;\n    if (this.clientType === \"redis\") {\n      this.client = this.redis.createClient({\n        ...cacheOptions?.options,\n        legacyMode: true\n      });\n      if (typeof this.connection.options.cache === \"object\" && this.connection.options.cache.ignoreErrors) {\n        this.client.on(\"error\", err => {\n          this.connection.logger.log(\"warn\", err);\n        });\n      }\n      if (\"connect\" in this.client) {\n        await this.client.connect();\n      }\n    } else if (this.clientType === \"ioredis\") {\n      if (cacheOptions && cacheOptions.port) {\n        if (cacheOptions.options) {\n          this.client = new this.redis(cacheOptions.port, cacheOptions.options);\n        } else {\n          this.client = new this.redis(cacheOptions.port);\n        }\n      } else if (cacheOptions && cacheOptions.options) {\n        this.client = new this.redis(cacheOptions.options);\n      } else {\n        this.client = new this.redis();\n      }\n    } else if (this.clientType === \"ioredis/cluster\") {\n      if (cacheOptions && cacheOptions.options && Array.isArray(cacheOptions.options)) {\n        this.client = new this.redis.Cluster(cacheOptions.options);\n      } else if (cacheOptions && cacheOptions.options && cacheOptions.options.startupNodes) {\n        this.client = new this.redis.Cluster(cacheOptions.options.startupNodes, cacheOptions.options.options);\n      } else {\n        throw new TypeORMError(`options.startupNodes required for ${this.clientType}.`);\n      }\n    }\n  }\n  /**\n   * Disconnects the connection\n   */\n  async disconnect() {\n    return new Promise((ok, fail) => {\n      this.client.quit((err, result) => {\n        if (err) return fail(err);\n        ok();\n        this.client = undefined;\n      });\n    });\n  }\n  /**\n   * Creates table for storing cache if it does not exist yet.\n   */\n  async synchronize(queryRunner) {}\n  /**\n   * Get data from cache.\n   * Returns cache result if found.\n   * Returns undefined if result is not cached.\n   */\n  getFromCache(options, queryRunner) {\n    return new Promise((ok, fail) => {\n      if (options.identifier) {\n        this.client.get(options.identifier, (err, result) => {\n          if (err) return fail(err);\n          ok(JSON.parse(result));\n        });\n      } else if (options.query) {\n        this.client.get(options.query, (err, result) => {\n          if (err) return fail(err);\n          ok(JSON.parse(result));\n        });\n      } else {\n        ok(undefined);\n      }\n    });\n  }\n  /**\n   * Checks if cache is expired or not.\n   */\n  isExpired(savedCache) {\n    return savedCache.time + savedCache.duration < new Date().getTime();\n  }\n  /**\n   * Stores given query result in the cache.\n   */\n  async storeInCache(options, savedCache, queryRunner) {\n    return new Promise((ok, fail) => {\n      if (options.identifier) {\n        this.client.set(options.identifier, JSON.stringify(options), \"PX\", options.duration, (err, result) => {\n          if (err) return fail(err);\n          ok();\n        });\n      } else if (options.query) {\n        this.client.set(options.query, JSON.stringify(options), \"PX\", options.duration, (err, result) => {\n          if (err) return fail(err);\n          ok();\n        });\n      }\n    });\n  }\n  /**\n   * Clears everything stored in the cache.\n   */\n  async clear(queryRunner) {\n    return new Promise((ok, fail) => {\n      this.client.flushdb((err, result) => {\n        if (err) return fail(err);\n        ok();\n      });\n    });\n  }\n  /**\n   * Removes all cached results by given identifiers from cache.\n   */\n  async remove(identifiers, queryRunner) {\n    await Promise.all(identifiers.map(identifier => {\n      return this.deleteKey(identifier);\n    }));\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Removes a single key from redis database.\n   */\n  deleteKey(key) {\n    return new Promise((ok, fail) => {\n      this.client.del(key, (err, result) => {\n        if (err) return fail(err);\n        ok();\n      });\n    });\n  }\n  /**\n   * Loads redis dependency.\n   */\n  loadRedis() {\n    try {\n      if (this.clientType === \"ioredis/cluster\") {\n        return PlatformTools.load(\"ioredis\");\n      } else {\n        return PlatformTools.load(this.clientType);\n      }\n    } catch (e) {\n      throw new TypeORMError(`Cannot use cache because ${this.clientType} is not installed. Please run \"npm i ${this.clientType} --save\".`);\n    }\n  }\n}","map":{"version":3,"names":["PlatformTools","TypeORMError","RedisQueryResultCache","constructor","connection","clientType","redis","loadRedis","connect","cacheOptions","options","cache","client","createClient","legacyMode","ignoreErrors","on","err","logger","log","port","Array","isArray","Cluster","startupNodes","disconnect","Promise","ok","fail","quit","result","undefined","synchronize","queryRunner","getFromCache","identifier","get","JSON","parse","query","isExpired","savedCache","time","duration","Date","getTime","storeInCache","set","stringify","clear","flushdb","remove","identifiers","all","map","deleteKey","key","del","load","e"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\cache\\RedisQueryResultCache.ts"],"sourcesContent":["import { QueryResultCache } from \"./QueryResultCache\"\nimport { QueryResultCacheOptions } from \"./QueryResultCacheOptions\"\nimport { PlatformTools } from \"../platform/PlatformTools\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { TypeORMError } from \"../error/TypeORMError\"\n\n/**\n * Caches query result into Redis database.\n */\nexport class RedisQueryResultCache implements QueryResultCache {\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Redis module instance loaded dynamically.\n     */\n    protected redis: any\n\n    /**\n     * Connected redis client.\n     */\n    protected client: any\n\n    /**\n     * Type of the Redis Client (redis or ioredis).\n     */\n    protected clientType: \"redis\" | \"ioredis\" | \"ioredis/cluster\"\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        protected connection: DataSource,\n        clientType: \"redis\" | \"ioredis\" | \"ioredis/cluster\",\n    ) {\n        this.clientType = clientType\n        this.redis = this.loadRedis()\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a connection with given cache provider.\n     */\n    async connect(): Promise<void> {\n        const cacheOptions: any = this.connection.options.cache\n        if (this.clientType === \"redis\") {\n            this.client = this.redis.createClient({\n                ...cacheOptions?.options,\n                legacyMode: true,\n            })\n            if (\n                typeof this.connection.options.cache === \"object\" &&\n                this.connection.options.cache.ignoreErrors\n            ) {\n                this.client.on(\"error\", (err: any) => {\n                    this.connection.logger.log(\"warn\", err)\n                })\n            }\n            if (\"connect\" in this.client) {\n                await this.client.connect()\n            }\n        } else if (this.clientType === \"ioredis\") {\n            if (cacheOptions && cacheOptions.port) {\n                if (cacheOptions.options) {\n                    this.client = new this.redis(\n                        cacheOptions.port,\n                        cacheOptions.options,\n                    )\n                } else {\n                    this.client = new this.redis(cacheOptions.port)\n                }\n            } else if (cacheOptions && cacheOptions.options) {\n                this.client = new this.redis(cacheOptions.options)\n            } else {\n                this.client = new this.redis()\n            }\n        } else if (this.clientType === \"ioredis/cluster\") {\n            if (\n                cacheOptions &&\n                cacheOptions.options &&\n                Array.isArray(cacheOptions.options)\n            ) {\n                this.client = new this.redis.Cluster(cacheOptions.options)\n            } else if (\n                cacheOptions &&\n                cacheOptions.options &&\n                cacheOptions.options.startupNodes\n            ) {\n                this.client = new this.redis.Cluster(\n                    cacheOptions.options.startupNodes,\n                    cacheOptions.options.options,\n                )\n            } else {\n                throw new TypeORMError(\n                    `options.startupNodes required for ${this.clientType}.`,\n                )\n            }\n        }\n    }\n\n    /**\n     * Disconnects the connection\n     */\n    async disconnect(): Promise<void> {\n        return new Promise<void>((ok, fail) => {\n            this.client.quit((err: any, result: any) => {\n                if (err) return fail(err)\n                ok()\n                this.client = undefined\n            })\n        })\n    }\n\n    /**\n     * Creates table for storing cache if it does not exist yet.\n     */\n    async synchronize(queryRunner: QueryRunner): Promise<void> {}\n\n    /**\n     * Get data from cache.\n     * Returns cache result if found.\n     * Returns undefined if result is not cached.\n     */\n    getFromCache(\n        options: QueryResultCacheOptions,\n        queryRunner?: QueryRunner,\n    ): Promise<QueryResultCacheOptions | undefined> {\n        return new Promise<QueryResultCacheOptions | undefined>((ok, fail) => {\n            if (options.identifier) {\n                this.client.get(options.identifier, (err: any, result: any) => {\n                    if (err) return fail(err)\n                    ok(JSON.parse(result))\n                })\n            } else if (options.query) {\n                this.client.get(options.query, (err: any, result: any) => {\n                    if (err) return fail(err)\n                    ok(JSON.parse(result))\n                })\n            } else {\n                ok(undefined)\n            }\n        })\n    }\n\n    /**\n     * Checks if cache is expired or not.\n     */\n    isExpired(savedCache: QueryResultCacheOptions): boolean {\n        return savedCache.time! + savedCache.duration < new Date().getTime()\n    }\n\n    /**\n     * Stores given query result in the cache.\n     */\n    async storeInCache(\n        options: QueryResultCacheOptions,\n        savedCache: QueryResultCacheOptions,\n        queryRunner?: QueryRunner,\n    ): Promise<void> {\n        return new Promise<void>((ok, fail) => {\n            if (options.identifier) {\n                this.client.set(\n                    options.identifier,\n                    JSON.stringify(options),\n                    \"PX\",\n                    options.duration,\n                    (err: any, result: any) => {\n                        if (err) return fail(err)\n                        ok()\n                    },\n                )\n            } else if (options.query) {\n                this.client.set(\n                    options.query,\n                    JSON.stringify(options),\n                    \"PX\",\n                    options.duration,\n                    (err: any, result: any) => {\n                        if (err) return fail(err)\n                        ok()\n                    },\n                )\n            }\n        })\n    }\n\n    /**\n     * Clears everything stored in the cache.\n     */\n    async clear(queryRunner?: QueryRunner): Promise<void> {\n        return new Promise<void>((ok, fail) => {\n            this.client.flushdb((err: any, result: any) => {\n                if (err) return fail(err)\n                ok()\n            })\n        })\n    }\n\n    /**\n     * Removes all cached results by given identifiers from cache.\n     */\n    async remove(\n        identifiers: string[],\n        queryRunner?: QueryRunner,\n    ): Promise<void> {\n        await Promise.all(\n            identifiers.map((identifier) => {\n                return this.deleteKey(identifier)\n            }),\n        )\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Removes a single key from redis database.\n     */\n    protected deleteKey(key: string): Promise<void> {\n        return new Promise<void>((ok, fail) => {\n            this.client.del(key, (err: any, result: any) => {\n                if (err) return fail(err)\n                ok()\n            })\n        })\n    }\n\n    /**\n     * Loads redis dependency.\n     */\n    protected loadRedis(): any {\n        try {\n            if (this.clientType === \"ioredis/cluster\") {\n                return PlatformTools.load(\"ioredis\")\n            } else {\n                return PlatformTools.load(this.clientType)\n            }\n        } catch (e) {\n            throw new TypeORMError(\n                `Cannot use cache because ${this.clientType} is not installed. Please run \"npm i ${this.clientType} --save\".`,\n            )\n        }\n    }\n}\n"],"mappings":"AAEA,SAASA,aAAa,QAAQ,2BAA2B;AAGzD,SAASC,YAAY,QAAQ,uBAAuB;AAEpD;;;AAGA,OAAM,MAAOC,qBAAqB;EAoB9B;EACA;EACA;EAEAC,YACcC,UAAsB,EAChCC,UAAmD;IADzC,KAAAD,UAAU,GAAVA,UAAU;IAGpB,IAAI,CAACC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,KAAK,GAAG,IAAI,CAACC,SAAS,EAAE;EACjC;EAEA;EACA;EACA;EAEA;;;EAGA,MAAMC,OAAOA,CAAA;IACT,MAAMC,YAAY,GAAQ,IAAI,CAACL,UAAU,CAACM,OAAO,CAACC,KAAK;IACvD,IAAI,IAAI,CAACN,UAAU,KAAK,OAAO,EAAE;MAC7B,IAAI,CAACO,MAAM,GAAG,IAAI,CAACN,KAAK,CAACO,YAAY,CAAC;QAClC,GAAGJ,YAAY,EAAEC,OAAO;QACxBI,UAAU,EAAE;OACf,CAAC;MACF,IACI,OAAO,IAAI,CAACV,UAAU,CAACM,OAAO,CAACC,KAAK,KAAK,QAAQ,IACjD,IAAI,CAACP,UAAU,CAACM,OAAO,CAACC,KAAK,CAACI,YAAY,EAC5C;QACE,IAAI,CAACH,MAAM,CAACI,EAAE,CAAC,OAAO,EAAGC,GAAQ,IAAI;UACjC,IAAI,CAACb,UAAU,CAACc,MAAM,CAACC,GAAG,CAAC,MAAM,EAAEF,GAAG,CAAC;QAC3C,CAAC,CAAC;MACN;MACA,IAAI,SAAS,IAAI,IAAI,CAACL,MAAM,EAAE;QAC1B,MAAM,IAAI,CAACA,MAAM,CAACJ,OAAO,EAAE;MAC/B;IACJ,CAAC,MAAM,IAAI,IAAI,CAACH,UAAU,KAAK,SAAS,EAAE;MACtC,IAAII,YAAY,IAAIA,YAAY,CAACW,IAAI,EAAE;QACnC,IAAIX,YAAY,CAACC,OAAO,EAAE;UACtB,IAAI,CAACE,MAAM,GAAG,IAAI,IAAI,CAACN,KAAK,CACxBG,YAAY,CAACW,IAAI,EACjBX,YAAY,CAACC,OAAO,CACvB;QACL,CAAC,MAAM;UACH,IAAI,CAACE,MAAM,GAAG,IAAI,IAAI,CAACN,KAAK,CAACG,YAAY,CAACW,IAAI,CAAC;QACnD;MACJ,CAAC,MAAM,IAAIX,YAAY,IAAIA,YAAY,CAACC,OAAO,EAAE;QAC7C,IAAI,CAACE,MAAM,GAAG,IAAI,IAAI,CAACN,KAAK,CAACG,YAAY,CAACC,OAAO,CAAC;MACtD,CAAC,MAAM;QACH,IAAI,CAACE,MAAM,GAAG,IAAI,IAAI,CAACN,KAAK,EAAE;MAClC;IACJ,CAAC,MAAM,IAAI,IAAI,CAACD,UAAU,KAAK,iBAAiB,EAAE;MAC9C,IACII,YAAY,IACZA,YAAY,CAACC,OAAO,IACpBW,KAAK,CAACC,OAAO,CAACb,YAAY,CAACC,OAAO,CAAC,EACrC;QACE,IAAI,CAACE,MAAM,GAAG,IAAI,IAAI,CAACN,KAAK,CAACiB,OAAO,CAACd,YAAY,CAACC,OAAO,CAAC;MAC9D,CAAC,MAAM,IACHD,YAAY,IACZA,YAAY,CAACC,OAAO,IACpBD,YAAY,CAACC,OAAO,CAACc,YAAY,EACnC;QACE,IAAI,CAACZ,MAAM,GAAG,IAAI,IAAI,CAACN,KAAK,CAACiB,OAAO,CAChCd,YAAY,CAACC,OAAO,CAACc,YAAY,EACjCf,YAAY,CAACC,OAAO,CAACA,OAAO,CAC/B;MACL,CAAC,MAAM;QACH,MAAM,IAAIT,YAAY,CAClB,qCAAqC,IAAI,CAACI,UAAU,GAAG,CAC1D;MACL;IACJ;EACJ;EAEA;;;EAGA,MAAMoB,UAAUA,CAAA;IACZ,OAAO,IAAIC,OAAO,CAAO,CAACC,EAAE,EAAEC,IAAI,KAAI;MAClC,IAAI,CAAChB,MAAM,CAACiB,IAAI,CAAC,CAACZ,GAAQ,EAAEa,MAAW,KAAI;QACvC,IAAIb,GAAG,EAAE,OAAOW,IAAI,CAACX,GAAG,CAAC;QACzBU,EAAE,EAAE;QACJ,IAAI,CAACf,MAAM,GAAGmB,SAAS;MAC3B,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EAEA;;;EAGA,MAAMC,WAAWA,CAACC,WAAwB,GAAkB;EAE5D;;;;;EAKAC,YAAYA,CACRxB,OAAgC,EAChCuB,WAAyB;IAEzB,OAAO,IAAIP,OAAO,CAAsC,CAACC,EAAE,EAAEC,IAAI,KAAI;MACjE,IAAIlB,OAAO,CAACyB,UAAU,EAAE;QACpB,IAAI,CAACvB,MAAM,CAACwB,GAAG,CAAC1B,OAAO,CAACyB,UAAU,EAAE,CAAClB,GAAQ,EAAEa,MAAW,KAAI;UAC1D,IAAIb,GAAG,EAAE,OAAOW,IAAI,CAACX,GAAG,CAAC;UACzBU,EAAE,CAACU,IAAI,CAACC,KAAK,CAACR,MAAM,CAAC,CAAC;QAC1B,CAAC,CAAC;MACN,CAAC,MAAM,IAAIpB,OAAO,CAAC6B,KAAK,EAAE;QACtB,IAAI,CAAC3B,MAAM,CAACwB,GAAG,CAAC1B,OAAO,CAAC6B,KAAK,EAAE,CAACtB,GAAQ,EAAEa,MAAW,KAAI;UACrD,IAAIb,GAAG,EAAE,OAAOW,IAAI,CAACX,GAAG,CAAC;UACzBU,EAAE,CAACU,IAAI,CAACC,KAAK,CAACR,MAAM,CAAC,CAAC;QAC1B,CAAC,CAAC;MACN,CAAC,MAAM;QACHH,EAAE,CAACI,SAAS,CAAC;MACjB;IACJ,CAAC,CAAC;EACN;EAEA;;;EAGAS,SAASA,CAACC,UAAmC;IACzC,OAAOA,UAAU,CAACC,IAAK,GAAGD,UAAU,CAACE,QAAQ,GAAG,IAAIC,IAAI,EAAE,CAACC,OAAO,EAAE;EACxE;EAEA;;;EAGA,MAAMC,YAAYA,CACdpC,OAAgC,EAChC+B,UAAmC,EACnCR,WAAyB;IAEzB,OAAO,IAAIP,OAAO,CAAO,CAACC,EAAE,EAAEC,IAAI,KAAI;MAClC,IAAIlB,OAAO,CAACyB,UAAU,EAAE;QACpB,IAAI,CAACvB,MAAM,CAACmC,GAAG,CACXrC,OAAO,CAACyB,UAAU,EAClBE,IAAI,CAACW,SAAS,CAACtC,OAAO,CAAC,EACvB,IAAI,EACJA,OAAO,CAACiC,QAAQ,EAChB,CAAC1B,GAAQ,EAAEa,MAAW,KAAI;UACtB,IAAIb,GAAG,EAAE,OAAOW,IAAI,CAACX,GAAG,CAAC;UACzBU,EAAE,EAAE;QACR,CAAC,CACJ;MACL,CAAC,MAAM,IAAIjB,OAAO,CAAC6B,KAAK,EAAE;QACtB,IAAI,CAAC3B,MAAM,CAACmC,GAAG,CACXrC,OAAO,CAAC6B,KAAK,EACbF,IAAI,CAACW,SAAS,CAACtC,OAAO,CAAC,EACvB,IAAI,EACJA,OAAO,CAACiC,QAAQ,EAChB,CAAC1B,GAAQ,EAAEa,MAAW,KAAI;UACtB,IAAIb,GAAG,EAAE,OAAOW,IAAI,CAACX,GAAG,CAAC;UACzBU,EAAE,EAAE;QACR,CAAC,CACJ;MACL;IACJ,CAAC,CAAC;EACN;EAEA;;;EAGA,MAAMsB,KAAKA,CAAChB,WAAyB;IACjC,OAAO,IAAIP,OAAO,CAAO,CAACC,EAAE,EAAEC,IAAI,KAAI;MAClC,IAAI,CAAChB,MAAM,CAACsC,OAAO,CAAC,CAACjC,GAAQ,EAAEa,MAAW,KAAI;QAC1C,IAAIb,GAAG,EAAE,OAAOW,IAAI,CAACX,GAAG,CAAC;QACzBU,EAAE,EAAE;MACR,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EAEA;;;EAGA,MAAMwB,MAAMA,CACRC,WAAqB,EACrBnB,WAAyB;IAEzB,MAAMP,OAAO,CAAC2B,GAAG,CACbD,WAAW,CAACE,GAAG,CAAEnB,UAAU,IAAI;MAC3B,OAAO,IAAI,CAACoB,SAAS,CAACpB,UAAU,CAAC;IACrC,CAAC,CAAC,CACL;EACL;EAEA;EACA;EACA;EAEA;;;EAGUoB,SAASA,CAACC,GAAW;IAC3B,OAAO,IAAI9B,OAAO,CAAO,CAACC,EAAE,EAAEC,IAAI,KAAI;MAClC,IAAI,CAAChB,MAAM,CAAC6C,GAAG,CAACD,GAAG,EAAE,CAACvC,GAAQ,EAAEa,MAAW,KAAI;QAC3C,IAAIb,GAAG,EAAE,OAAOW,IAAI,CAACX,GAAG,CAAC;QACzBU,EAAE,EAAE;MACR,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EAEA;;;EAGUpB,SAASA,CAAA;IACf,IAAI;MACA,IAAI,IAAI,CAACF,UAAU,KAAK,iBAAiB,EAAE;QACvC,OAAOL,aAAa,CAAC0D,IAAI,CAAC,SAAS,CAAC;MACxC,CAAC,MAAM;QACH,OAAO1D,aAAa,CAAC0D,IAAI,CAAC,IAAI,CAACrD,UAAU,CAAC;MAC9C;IACJ,CAAC,CAAC,OAAOsD,CAAC,EAAE;MACR,MAAM,IAAI1D,YAAY,CAClB,4BAA4B,IAAI,CAACI,UAAU,wCAAwC,IAAI,CAACA,UAAU,WAAW,CAChH;IACL;EACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}