{"ast":null,"code":"import { ObjectUtils } from \"../util/ObjectUtils\";\n/**\n * Allows to work with entity relations and perform specific operations with those relations.\n *\n * todo: add transactions everywhere\n */\nexport class RelationRemover {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(queryBuilder, expressionMap) {\n    this.queryBuilder = queryBuilder;\n    this.expressionMap = expressionMap;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Performs remove operation on a relation.\n   */\n  async remove(value) {\n    const relation = this.expressionMap.relationMetadata;\n    if (relation.isOneToMany) {\n      // if (this.expressionMap.of instanceof Array)\n      //     throw new TypeORMError(`You cannot update relations of multiple entities with the same related object. Provide a single entity into .of method.`);\n      // DELETE FROM post WHERE post.categoryId = of AND post.id = id\n      const ofs = Array.isArray(this.expressionMap.of) ? this.expressionMap.of : [this.expressionMap.of];\n      const values = Array.isArray(value) ? value : [value];\n      const updateSet = {};\n      relation.inverseRelation.joinColumns.forEach(column => {\n        updateSet[column.propertyName] = null;\n      });\n      const parameters = {};\n      const conditions = [];\n      ofs.forEach((of, ofIndex) => {\n        conditions.push(...values.map((value, valueIndex) => {\n          return [...relation.inverseRelation.joinColumns.map((column, columnIndex) => {\n            const parameterName = \"joinColumn_\" + ofIndex + \"_\" + valueIndex + \"_\" + columnIndex;\n            parameters[parameterName] = ObjectUtils.isObject(of) ? column.referencedColumn.getEntityValue(of) : of;\n            return `${column.propertyPath} = :${parameterName}`;\n          }), ...relation.inverseRelation.entityMetadata.primaryColumns.map((column, columnIndex) => {\n            const parameterName = \"primaryColumn_\" + valueIndex + \"_\" + valueIndex + \"_\" + columnIndex;\n            parameters[parameterName] = ObjectUtils.isObject(value) ? column.getEntityValue(value) : value;\n            return `${column.propertyPath} = :${parameterName}`;\n          })].join(\" AND \");\n        }));\n      });\n      const condition = conditions.map(str => \"(\" + str + \")\").join(\" OR \");\n      if (!condition) return;\n      await this.queryBuilder.createQueryBuilder().update(relation.inverseEntityMetadata.target).set(updateSet).where(condition).setParameters(parameters).execute();\n    } else {\n      // many to many\n      const junctionMetadata = relation.junctionEntityMetadata;\n      const ofs = Array.isArray(this.expressionMap.of) ? this.expressionMap.of : [this.expressionMap.of];\n      const values = Array.isArray(value) ? value : [value];\n      const firstColumnValues = relation.isManyToManyOwner ? ofs : values;\n      const secondColumnValues = relation.isManyToManyOwner ? values : ofs;\n      const parameters = {};\n      const conditions = [];\n      firstColumnValues.forEach((firstColumnVal, firstColumnValIndex) => {\n        conditions.push(...secondColumnValues.map((secondColumnVal, secondColumnValIndex) => {\n          return [...junctionMetadata.ownerColumns.map((column, columnIndex) => {\n            const parameterName = \"firstValue_\" + firstColumnValIndex + \"_\" + secondColumnValIndex + \"_\" + columnIndex;\n            parameters[parameterName] = ObjectUtils.isObject(firstColumnVal) ? column.referencedColumn.getEntityValue(firstColumnVal) : firstColumnVal;\n            return `${column.databaseName} = :${parameterName}`;\n          }), ...junctionMetadata.inverseColumns.map((column, columnIndex) => {\n            const parameterName = \"secondValue_\" + firstColumnValIndex + \"_\" + secondColumnValIndex + \"_\" + columnIndex;\n            parameters[parameterName] = ObjectUtils.isObject(secondColumnVal) ? column.referencedColumn.getEntityValue(secondColumnVal) : secondColumnVal;\n            return `${column.databaseName} = :${parameterName}`;\n          })].join(\" AND \");\n        }));\n      });\n      const condition = conditions.map(str => \"(\" + str + \")\").join(\" OR \");\n      await this.queryBuilder.createQueryBuilder().delete().from(junctionMetadata.tableName).where(condition).setParameters(parameters).execute();\n    }\n  }\n}","map":{"version":3,"names":["ObjectUtils","RelationRemover","constructor","queryBuilder","expressionMap","remove","value","relation","relationMetadata","isOneToMany","ofs","Array","isArray","of","values","updateSet","inverseRelation","joinColumns","forEach","column","propertyName","parameters","conditions","ofIndex","push","map","valueIndex","columnIndex","parameterName","isObject","referencedColumn","getEntityValue","propertyPath","entityMetadata","primaryColumns","join","condition","str","createQueryBuilder","update","inverseEntityMetadata","target","set","where","setParameters","execute","junctionMetadata","junctionEntityMetadata","firstColumnValues","isManyToManyOwner","secondColumnValues","firstColumnVal","firstColumnValIndex","secondColumnVal","secondColumnValIndex","ownerColumns","databaseName","inverseColumns","delete","from","tableName"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\query-builder\\RelationRemover.ts"],"sourcesContent":["import { QueryBuilder } from \"./QueryBuilder\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { QueryExpressionMap } from \"./QueryExpressionMap\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\n\n/**\n * Allows to work with entity relations and perform specific operations with those relations.\n *\n * todo: add transactions everywhere\n */\nexport class RelationRemover {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        protected queryBuilder: QueryBuilder<any>,\n        protected expressionMap: QueryExpressionMap,\n    ) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs remove operation on a relation.\n     */\n    async remove(value: any | any[]): Promise<void> {\n        const relation = this.expressionMap.relationMetadata\n\n        if (relation.isOneToMany) {\n            // if (this.expressionMap.of instanceof Array)\n            //     throw new TypeORMError(`You cannot update relations of multiple entities with the same related object. Provide a single entity into .of method.`);\n\n            // DELETE FROM post WHERE post.categoryId = of AND post.id = id\n            const ofs = Array.isArray(this.expressionMap.of)\n                ? this.expressionMap.of\n                : [this.expressionMap.of]\n            const values = Array.isArray(value) ? value : [value]\n\n            const updateSet: ObjectLiteral = {}\n            relation.inverseRelation!.joinColumns.forEach((column) => {\n                updateSet[column.propertyName] = null\n            })\n\n            const parameters: ObjectLiteral = {}\n            const conditions: string[] = []\n            ofs.forEach((of, ofIndex) => {\n                conditions.push(\n                    ...values.map((value, valueIndex) => {\n                        return [\n                            ...relation.inverseRelation!.joinColumns.map(\n                                (column, columnIndex) => {\n                                    const parameterName =\n                                        \"joinColumn_\" +\n                                        ofIndex +\n                                        \"_\" +\n                                        valueIndex +\n                                        \"_\" +\n                                        columnIndex\n                                    parameters[parameterName] =\n                                        ObjectUtils.isObject(of)\n                                            ? column.referencedColumn!.getEntityValue(\n                                                  of,\n                                              )\n                                            : of\n                                    return `${column.propertyPath} = :${parameterName}`\n                                },\n                            ),\n                            ...relation.inverseRelation!.entityMetadata.primaryColumns.map(\n                                (column, columnIndex) => {\n                                    const parameterName =\n                                        \"primaryColumn_\" +\n                                        valueIndex +\n                                        \"_\" +\n                                        valueIndex +\n                                        \"_\" +\n                                        columnIndex\n                                    parameters[parameterName] =\n                                        ObjectUtils.isObject(value)\n                                            ? column.getEntityValue(value)\n                                            : value\n                                    return `${column.propertyPath} = :${parameterName}`\n                                },\n                            ),\n                        ].join(\" AND \")\n                    }),\n                )\n            })\n            const condition = conditions\n                .map((str) => \"(\" + str + \")\")\n                .join(\" OR \")\n            if (!condition) return\n\n            await this.queryBuilder\n                .createQueryBuilder()\n                .update(relation.inverseEntityMetadata.target)\n                .set(updateSet)\n                .where(condition)\n                .setParameters(parameters)\n                .execute()\n        } else {\n            // many to many\n\n            const junctionMetadata = relation.junctionEntityMetadata!\n            const ofs = Array.isArray(this.expressionMap.of)\n                ? this.expressionMap.of\n                : [this.expressionMap.of]\n            const values = Array.isArray(value) ? value : [value]\n            const firstColumnValues = relation.isManyToManyOwner ? ofs : values\n            const secondColumnValues = relation.isManyToManyOwner ? values : ofs\n\n            const parameters: ObjectLiteral = {}\n            const conditions: string[] = []\n            firstColumnValues.forEach((firstColumnVal, firstColumnValIndex) => {\n                conditions.push(\n                    ...secondColumnValues.map(\n                        (secondColumnVal, secondColumnValIndex) => {\n                            return [\n                                ...junctionMetadata.ownerColumns.map(\n                                    (column, columnIndex) => {\n                                        const parameterName =\n                                            \"firstValue_\" +\n                                            firstColumnValIndex +\n                                            \"_\" +\n                                            secondColumnValIndex +\n                                            \"_\" +\n                                            columnIndex\n                                        parameters[parameterName] =\n                                            ObjectUtils.isObject(firstColumnVal)\n                                                ? column.referencedColumn!.getEntityValue(\n                                                      firstColumnVal,\n                                                  )\n                                                : firstColumnVal\n                                        return `${column.databaseName} = :${parameterName}`\n                                    },\n                                ),\n                                ...junctionMetadata.inverseColumns.map(\n                                    (column, columnIndex) => {\n                                        const parameterName =\n                                            \"secondValue_\" +\n                                            firstColumnValIndex +\n                                            \"_\" +\n                                            secondColumnValIndex +\n                                            \"_\" +\n                                            columnIndex\n                                        parameters[parameterName] =\n                                            ObjectUtils.isObject(\n                                                secondColumnVal,\n                                            )\n                                                ? column.referencedColumn!.getEntityValue(\n                                                      secondColumnVal,\n                                                  )\n                                                : secondColumnVal\n                                        return `${column.databaseName} = :${parameterName}`\n                                    },\n                                ),\n                            ].join(\" AND \")\n                        },\n                    ),\n                )\n            })\n            const condition = conditions\n                .map((str) => \"(\" + str + \")\")\n                .join(\" OR \")\n\n            await this.queryBuilder\n                .createQueryBuilder()\n                .delete()\n                .from(junctionMetadata.tableName)\n                .where(condition)\n                .setParameters(parameters)\n                .execute()\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}