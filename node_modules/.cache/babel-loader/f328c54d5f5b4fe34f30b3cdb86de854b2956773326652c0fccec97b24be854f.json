{"ast":null,"code":"import { QueryBuilderUtils } from \"./QueryBuilderUtils\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { TypeORMError } from \"../error\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Stores all join attributes which will be used to build a JOIN query.\n */\nexport class JoinAttribute {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection, queryExpressionMap, joinAttribute) {\n    this.connection = connection;\n    this.queryExpressionMap = queryExpressionMap;\n    this.isSelectedEvaluated = false;\n    this.relationEvaluated = false;\n    if (joinAttribute) {\n      ObjectUtils.assign(this, joinAttribute);\n    }\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  get isMany() {\n    if (this.isMappingMany !== undefined) return this.isMappingMany;\n    if (this.relation) return this.relation.isManyToMany || this.relation.isOneToMany;\n    return false;\n  }\n  /**\n   * Indicates if this join is selected.\n   */\n  get isSelected() {\n    if (!this.isSelectedEvaluated) {\n      let getValue = () => {\n        for (const select of this.queryExpressionMap.selects) {\n          if (select.selection === this.alias.name) return true;\n          if (this.metadata && !!this.metadata.columns.find(column => select.selection === this.alias.name + \".\" + column.propertyPath)) return true;\n        }\n        return false;\n      };\n      this.isSelectedCache = getValue();\n      this.isSelectedEvaluated = true;\n    }\n    return this.isSelectedCache;\n  }\n  /**\n   * Name of the table which we should join.\n   */\n  get tablePath() {\n    return this.metadata ? this.metadata.tablePath : this.entityOrProperty;\n  }\n  /**\n   * Alias of the parent of this join.\n   * For example, if we join (\"post.category\", \"categoryAlias\") then \"post\" is a parent alias.\n   * This value is extracted from entityOrProperty value.\n   * This is available when join was made using \"post.category\" syntax.\n   */\n  get parentAlias() {\n    if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty)) return undefined;\n    return this.entityOrProperty.substr(0, this.entityOrProperty.indexOf(\".\"));\n  }\n  /**\n   * Relation property name of the parent.\n   * This is used to understand what is joined.\n   * For example, if we join (\"post.category\", \"categoryAlias\") then \"category\" is a relation property.\n   * This value is extracted from entityOrProperty value.\n   * This is available when join was made using \"post.category\" syntax.\n   */\n  get relationPropertyPath() {\n    if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty)) return undefined;\n    return this.entityOrProperty.substr(this.entityOrProperty.indexOf(\".\") + 1);\n  }\n  /**\n   * Relation of the parent.\n   * This is used to understand what is joined.\n   * This is available when join was made using \"post.category\" syntax.\n   * Relation can be undefined if entityOrProperty is regular entity or custom table.\n   */\n  get relation() {\n    if (!this.relationEvaluated) {\n      let getValue = () => {\n        if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty)) return undefined;\n        const relationOwnerSelection = this.queryExpressionMap.findAliasByName(this.parentAlias);\n        let relation = relationOwnerSelection.metadata.findRelationWithPropertyPath(this.relationPropertyPath);\n        if (relation) {\n          return relation;\n        }\n        if (relationOwnerSelection.metadata.parentEntityMetadata) {\n          relation = relationOwnerSelection.metadata.parentEntityMetadata.findRelationWithPropertyPath(this.relationPropertyPath);\n          if (relation) {\n            return relation;\n          }\n        }\n        throw new TypeORMError(`Relation with property path ${this.relationPropertyPath} in entity was not found.`);\n      };\n      this.relationCache = getValue.bind(this)();\n      this.relationEvaluated = true;\n    }\n    return this.relationCache;\n  }\n  /**\n   * Metadata of the joined entity.\n   * If table without entity was joined, then it will return undefined.\n   */\n  get metadata() {\n    // entityOrProperty is relation, e.g. \"post.category\"\n    if (this.relation) return this.relation.inverseEntityMetadata;\n    // entityOrProperty is Entity class\n    if (this.connection.hasMetadata(this.entityOrProperty)) return this.connection.getMetadata(this.entityOrProperty);\n    // Overriden mapping entity provided for leftJoinAndMapOne with custom query builder\n    if (this.mapAsEntity && this.connection.hasMetadata(this.mapAsEntity)) {\n      return this.connection.getMetadata(this.mapAsEntity);\n    }\n    return undefined;\n    /*if (typeof this.entityOrProperty === \"string\") { // entityOrProperty is a custom table\n         // first try to find entity with such name, this is needed when entity does not have a target class,\n        // and its target is a string name (scenario when plain old javascript is used or entity schema is loaded from files)\n        const metadata = this.connection.entityMetadatas.find(metadata => metadata.name === this.entityOrProperty);\n        if (metadata)\n            return metadata;\n         // check if we have entity with such table name, and use its metadata if found\n        return this.connection.entityMetadatas.find(metadata => metadata.tableName === this.entityOrProperty);\n    }*/\n  }\n  /**\n   * Generates alias of junction table, whose ids we get.\n   */\n  get junctionAlias() {\n    if (!this.relation) {\n      throw new TypeORMError(`Cannot get junction table for join without relation.`);\n    }\n    if (typeof this.entityOrProperty !== \"string\") {\n      throw new TypeORMError(`Junction property is not defined.`);\n    }\n    const aliasProperty = this.entityOrProperty.substr(0, this.entityOrProperty.indexOf(\".\"));\n    if (this.relation.isOwning) {\n      return DriverUtils.buildAlias(this.connection.driver, undefined, aliasProperty, this.alias.name);\n    } else {\n      return DriverUtils.buildAlias(this.connection.driver, undefined, this.alias.name, aliasProperty);\n    }\n  }\n  get mapToPropertyParentAlias() {\n    if (!this.mapToProperty) return undefined;\n    return this.mapToProperty.split(\".\")[0];\n  }\n  get mapToPropertyPropertyName() {\n    if (!this.mapToProperty) return undefined;\n    return this.mapToProperty.split(\".\")[1];\n  }\n}","map":{"version":3,"names":["QueryBuilderUtils","ObjectUtils","TypeORMError","DriverUtils","JoinAttribute","constructor","connection","queryExpressionMap","joinAttribute","isSelectedEvaluated","relationEvaluated","assign","isMany","isMappingMany","undefined","relation","isManyToMany","isOneToMany","isSelected","getValue","select","selects","selection","alias","name","metadata","columns","find","column","propertyPath","isSelectedCache","tablePath","entityOrProperty","parentAlias","isAliasProperty","substr","indexOf","relationPropertyPath","relationOwnerSelection","findAliasByName","findRelationWithPropertyPath","parentEntityMetadata","relationCache","bind","inverseEntityMetadata","hasMetadata","getMetadata","mapAsEntity","junctionAlias","aliasProperty","isOwning","buildAlias","driver","mapToPropertyParentAlias","mapToProperty","split","mapToPropertyPropertyName"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\query-builder\\JoinAttribute.ts"],"sourcesContent":["import { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { RelationMetadata } from \"../metadata/RelationMetadata\"\nimport { QueryBuilderUtils } from \"./QueryBuilderUtils\"\nimport { QueryExpressionMap } from \"./QueryExpressionMap\"\nimport { Alias } from \"./Alias\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { TypeORMError } from \"../error\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\n\n/**\n * Stores all join attributes which will be used to build a JOIN query.\n */\nexport class JoinAttribute {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Join direction.\n     */\n    direction: \"LEFT\" | \"INNER\"\n\n    /**\n     * Alias of the joined (destination) table.\n     */\n    alias: Alias\n\n    /**\n     * Joined table, entity target, or relation in \"post.category\" format.\n     */\n    entityOrProperty: Function | string\n\n    /**\n     * Extra condition applied to \"ON\" section of join.\n     */\n    condition?: string\n\n    /**\n     * Property + alias of the object where to joined data should be mapped.\n     */\n    mapToProperty?: string\n\n    /**\n     * Indicates if user maps one or many objects from the join.\n     */\n    isMappingMany?: boolean\n\n    /**\n     * Useful when the joined expression is a custom query to support mapping.\n     */\n    mapAsEntity?: Function | string\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        private connection: DataSource,\n        private queryExpressionMap: QueryExpressionMap,\n        joinAttribute?: JoinAttribute,\n    ) {\n        if (joinAttribute) {\n            ObjectUtils.assign(this, joinAttribute)\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    get isMany(): boolean {\n        if (this.isMappingMany !== undefined) return this.isMappingMany\n\n        if (this.relation)\n            return this.relation.isManyToMany || this.relation.isOneToMany\n\n        return false\n    }\n\n    isSelectedCache: boolean\n    isSelectedEvaluated: boolean = false\n    /**\n     * Indicates if this join is selected.\n     */\n    get isSelected(): boolean {\n        if (!this.isSelectedEvaluated) {\n            let getValue = () => {\n                for (const select of this.queryExpressionMap.selects) {\n                    if (select.selection === this.alias.name) return true\n\n                    if (\n                        this.metadata &&\n                        !!this.metadata.columns.find(\n                            (column) =>\n                                select.selection ===\n                                this.alias.name + \".\" + column.propertyPath,\n                        )\n                    )\n                        return true\n                }\n\n                return false\n            }\n            this.isSelectedCache = getValue()\n            this.isSelectedEvaluated = true\n        }\n        return this.isSelectedCache\n    }\n\n    /**\n     * Name of the table which we should join.\n     */\n    get tablePath(): string {\n        return this.metadata\n            ? this.metadata.tablePath\n            : (this.entityOrProperty as string)\n    }\n\n    /**\n     * Alias of the parent of this join.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"post\" is a parent alias.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get parentAlias(): string | undefined {\n        if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty))\n            return undefined\n\n        return this.entityOrProperty.substr(\n            0,\n            this.entityOrProperty.indexOf(\".\"),\n        )\n    }\n\n    /**\n     * Relation property name of the parent.\n     * This is used to understand what is joined.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"category\" is a relation property.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get relationPropertyPath(): string | undefined {\n        if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty))\n            return undefined\n\n        return this.entityOrProperty.substr(\n            this.entityOrProperty.indexOf(\".\") + 1,\n        )\n    }\n\n    relationCache: RelationMetadata | undefined\n    relationEvaluated: boolean = false\n    /**\n     * Relation of the parent.\n     * This is used to understand what is joined.\n     * This is available when join was made using \"post.category\" syntax.\n     * Relation can be undefined if entityOrProperty is regular entity or custom table.\n     */\n    get relation(): RelationMetadata | undefined {\n        if (!this.relationEvaluated) {\n            let getValue = () => {\n                if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty))\n                    return undefined\n\n                const relationOwnerSelection =\n                    this.queryExpressionMap.findAliasByName(this.parentAlias!)\n                let relation =\n                    relationOwnerSelection.metadata.findRelationWithPropertyPath(\n                        this.relationPropertyPath!,\n                    )\n\n                if (relation) {\n                    return relation\n                }\n\n                if (relationOwnerSelection.metadata.parentEntityMetadata) {\n                    relation =\n                        relationOwnerSelection.metadata.parentEntityMetadata.findRelationWithPropertyPath(\n                            this.relationPropertyPath!,\n                        )\n                    if (relation) {\n                        return relation\n                    }\n                }\n\n                throw new TypeORMError(\n                    `Relation with property path ${this.relationPropertyPath} in entity was not found.`,\n                )\n            }\n            this.relationCache = getValue.bind(this)()\n            this.relationEvaluated = true\n        }\n        return this.relationCache\n    }\n\n    /**\n     * Metadata of the joined entity.\n     * If table without entity was joined, then it will return undefined.\n     */\n    get metadata(): EntityMetadata | undefined {\n        // entityOrProperty is relation, e.g. \"post.category\"\n        if (this.relation) return this.relation.inverseEntityMetadata\n\n        // entityOrProperty is Entity class\n        if (this.connection.hasMetadata(this.entityOrProperty))\n            return this.connection.getMetadata(this.entityOrProperty)\n\n        // Overriden mapping entity provided for leftJoinAndMapOne with custom query builder\n        if (this.mapAsEntity && this.connection.hasMetadata(this.mapAsEntity)) {\n            return this.connection.getMetadata(this.mapAsEntity)\n        }\n\n        return undefined\n\n        /*if (typeof this.entityOrProperty === \"string\") { // entityOrProperty is a custom table\n\n            // first try to find entity with such name, this is needed when entity does not have a target class,\n            // and its target is a string name (scenario when plain old javascript is used or entity schema is loaded from files)\n            const metadata = this.connection.entityMetadatas.find(metadata => metadata.name === this.entityOrProperty);\n            if (metadata)\n                return metadata;\n\n            // check if we have entity with such table name, and use its metadata if found\n            return this.connection.entityMetadatas.find(metadata => metadata.tableName === this.entityOrProperty);\n        }*/\n    }\n\n    /**\n     * Generates alias of junction table, whose ids we get.\n     */\n    get junctionAlias(): string {\n        if (!this.relation) {\n            throw new TypeORMError(\n                `Cannot get junction table for join without relation.`,\n            )\n        }\n        if (typeof this.entityOrProperty !== \"string\") {\n            throw new TypeORMError(`Junction property is not defined.`)\n        }\n\n        const aliasProperty = this.entityOrProperty.substr(\n            0,\n            this.entityOrProperty.indexOf(\".\"),\n        )\n\n        if (this.relation.isOwning) {\n            return DriverUtils.buildAlias(\n                this.connection.driver,\n                undefined,\n                aliasProperty,\n                this.alias.name,\n            )\n        } else {\n            return DriverUtils.buildAlias(\n                this.connection.driver,\n                undefined,\n                this.alias.name,\n                aliasProperty,\n            )\n        }\n    }\n\n    get mapToPropertyParentAlias(): string | undefined {\n        if (!this.mapToProperty) return undefined\n\n        return this.mapToProperty!.split(\".\")[0]\n    }\n\n    get mapToPropertyPropertyName(): string | undefined {\n        if (!this.mapToProperty) return undefined\n\n        return this.mapToProperty!.split(\".\")[1]\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}