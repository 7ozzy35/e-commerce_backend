{"ast":null,"code":"import { QueryExpressionMap } from \"./QueryExpressionMap\";\nimport { Brackets } from \"./Brackets\";\nimport { FindOperator } from \"../find-options/FindOperator\";\nimport { In } from \"../find-options/operator/In\";\nimport { TypeORMError } from \"../error\";\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\nimport { escapeRegExp } from \"../util/escapeRegExp\";\n// todo: completely cover query builder with tests\n// todo: entityOrProperty can be target name. implement proper behaviour if it is.\n// todo: check in persistment if id exist on object and throw exception (can be in partial selection?)\n// todo: fix problem with long aliases eg getMaxIdentifierLength\n// todo: fix replacing in .select(\"COUNT(post.id) AS cnt\") statement\n// todo: implement joinAlways in relations and relationId\n// todo: finish partial selection\n// todo: sugar methods like: .addCount and .selectCount, selectCountAndMap, selectSum, selectSumAndMap, ...\n// todo: implement @Select decorator\n// todo: add select and map functions\n// todo: implement relation/entity loading and setting them into properties within a separate query\n// .loadAndMap(\"post.categories\", \"post.categories\", qb => ...)\n// .loadAndMap(\"post.categories\", Category, qb => ...)\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class QueryBuilder {\n  /**\n   * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.\n   */\n  constructor(connectionOrQueryBuilder, queryRunner) {\n    this[\"@instanceof\"] = Symbol.for(\"QueryBuilder\");\n    /**\n     * Memo to help keep place of current parameter index for `createParameter`\n     */\n    this.parameterIndex = 0;\n    if (InstanceChecker.isDataSource(connectionOrQueryBuilder)) {\n      this.connection = connectionOrQueryBuilder;\n      this.queryRunner = queryRunner;\n      this.expressionMap = new QueryExpressionMap(this.connection);\n    } else {\n      this.connection = connectionOrQueryBuilder.connection;\n      this.queryRunner = connectionOrQueryBuilder.queryRunner;\n      this.expressionMap = connectionOrQueryBuilder.expressionMap.clone();\n    }\n  }\n  static registerQueryBuilderClass(name, factory) {\n    QueryBuilder.queryBuilderRegistry[name] = factory;\n  }\n  // -------------------------------------------------------------------------\n  // Accessors\n  // -------------------------------------------------------------------------\n  /**\n   * Gets the main alias string used in this query builder.\n   */\n  get alias() {\n    if (!this.expressionMap.mainAlias) throw new TypeORMError(`Main alias is not set`); // todo: better exception\n    return this.expressionMap.mainAlias.name;\n  }\n  /**\n   * Creates SELECT query and selects given data.\n   * Replaces all previous selections if they exist.\n   */\n  select(selection, selectionAliasName) {\n    this.expressionMap.queryType = \"select\";\n    if (Array.isArray(selection)) {\n      this.expressionMap.selects = selection.map(selection => ({\n        selection: selection\n      }));\n    } else if (selection) {\n      this.expressionMap.selects = [{\n        selection: selection,\n        aliasName: selectionAliasName\n      }];\n    }\n    if (InstanceChecker.isSelectQueryBuilder(this)) return this;\n    return QueryBuilder.queryBuilderRegistry[\"SelectQueryBuilder\"](this);\n  }\n  /**\n   * Creates INSERT query.\n   */\n  insert() {\n    this.expressionMap.queryType = \"insert\";\n    if (InstanceChecker.isInsertQueryBuilder(this)) return this;\n    return QueryBuilder.queryBuilderRegistry[\"InsertQueryBuilder\"](this);\n  }\n  /**\n   * Creates UPDATE query and applies given update values.\n   */\n  update(entityOrTableNameUpdateSet, maybeUpdateSet) {\n    const updateSet = maybeUpdateSet ? maybeUpdateSet : entityOrTableNameUpdateSet;\n    entityOrTableNameUpdateSet = InstanceChecker.isEntitySchema(entityOrTableNameUpdateSet) ? entityOrTableNameUpdateSet.options.name : entityOrTableNameUpdateSet;\n    if (typeof entityOrTableNameUpdateSet === \"function\" || typeof entityOrTableNameUpdateSet === \"string\") {\n      const mainAlias = this.createFromAlias(entityOrTableNameUpdateSet);\n      this.expressionMap.setMainAlias(mainAlias);\n    }\n    this.expressionMap.queryType = \"update\";\n    this.expressionMap.valuesSet = updateSet;\n    if (InstanceChecker.isUpdateQueryBuilder(this)) return this;\n    return QueryBuilder.queryBuilderRegistry[\"UpdateQueryBuilder\"](this);\n  }\n  /**\n   * Creates DELETE query.\n   */\n  delete() {\n    this.expressionMap.queryType = \"delete\";\n    if (InstanceChecker.isDeleteQueryBuilder(this)) return this;\n    return QueryBuilder.queryBuilderRegistry[\"DeleteQueryBuilder\"](this);\n  }\n  softDelete() {\n    this.expressionMap.queryType = \"soft-delete\";\n    if (InstanceChecker.isSoftDeleteQueryBuilder(this)) return this;\n    return QueryBuilder.queryBuilderRegistry[\"SoftDeleteQueryBuilder\"](this);\n  }\n  restore() {\n    this.expressionMap.queryType = \"restore\";\n    if (InstanceChecker.isSoftDeleteQueryBuilder(this)) return this;\n    return QueryBuilder.queryBuilderRegistry[\"SoftDeleteQueryBuilder\"](this);\n  }\n  /**\n   * Sets entity's relation with which this query builder gonna work.\n   */\n  relation(entityTargetOrPropertyPath, maybePropertyPath) {\n    const entityTarget = arguments.length === 2 ? entityTargetOrPropertyPath : undefined;\n    const propertyPath = arguments.length === 2 ? maybePropertyPath : entityTargetOrPropertyPath;\n    this.expressionMap.queryType = \"relation\";\n    this.expressionMap.relationPropertyPath = propertyPath;\n    if (entityTarget) {\n      const mainAlias = this.createFromAlias(entityTarget);\n      this.expressionMap.setMainAlias(mainAlias);\n    }\n    if (InstanceChecker.isRelationQueryBuilder(this)) return this;\n    return QueryBuilder.queryBuilderRegistry[\"RelationQueryBuilder\"](this);\n  }\n  /**\n   * Checks if given relation or relations exist in the entity.\n   * Returns true if relation exists, false otherwise.\n   *\n   * todo: move this method to manager? or create a shortcut?\n   */\n  hasRelation(target, relation) {\n    const entityMetadata = this.connection.getMetadata(target);\n    const relations = Array.isArray(relation) ? relation : [relation];\n    return relations.every(relation => {\n      return !!entityMetadata.findRelationWithPropertyPath(relation);\n    });\n  }\n  /**\n   * Check the existence of a parameter for this query builder.\n   */\n  hasParameter(key) {\n    return this.parentQueryBuilder?.hasParameter(key) || key in this.expressionMap.parameters;\n  }\n  /**\n   * Sets parameter name and its value.\n   *\n   * The key for this parameter may contain numbers, letters, underscores, or periods.\n   */\n  setParameter(key, value) {\n    if (typeof value === \"function\") {\n      throw new TypeORMError(`Function parameter isn't supported in the parameters. Please check \"${key}\" parameter.`);\n    }\n    if (!key.match(/^([A-Za-z0-9_.]+)$/)) {\n      throw new TypeORMError(\"QueryBuilder parameter keys may only contain numbers, letters, underscores, or periods.\");\n    }\n    if (this.parentQueryBuilder) {\n      this.parentQueryBuilder.setParameter(key, value);\n    }\n    this.expressionMap.parameters[key] = value;\n    return this;\n  }\n  /**\n   * Adds all parameters from the given object.\n   */\n  setParameters(parameters) {\n    for (const [key, value] of Object.entries(parameters)) {\n      this.setParameter(key, value);\n    }\n    return this;\n  }\n  createParameter(value) {\n    let parameterName;\n    do {\n      parameterName = `orm_param_${this.parameterIndex++}`;\n    } while (this.hasParameter(parameterName));\n    this.setParameter(parameterName, value);\n    return `:${parameterName}`;\n  }\n  /**\n   * Adds native parameters from the given object.\n   *\n   * @deprecated Use `setParameters` instead\n   */\n  setNativeParameters(parameters) {\n    // set parent query builder parameters as well in sub-query mode\n    if (this.parentQueryBuilder) {\n      this.parentQueryBuilder.setNativeParameters(parameters);\n    }\n    Object.keys(parameters).forEach(key => {\n      this.expressionMap.nativeParameters[key] = parameters[key];\n    });\n    return this;\n  }\n  /**\n   * Gets all parameters.\n   */\n  getParameters() {\n    const parameters = Object.assign({}, this.expressionMap.parameters);\n    // add discriminator column parameter if it exist\n    if (this.expressionMap.mainAlias && this.expressionMap.mainAlias.hasMetadata) {\n      const metadata = this.expressionMap.mainAlias.metadata;\n      if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {\n        const values = metadata.childEntityMetadatas.filter(childMetadata => childMetadata.discriminatorColumn).map(childMetadata => childMetadata.discriminatorValue);\n        values.push(metadata.discriminatorValue);\n        parameters[\"discriminatorColumnValues\"] = values;\n      }\n    }\n    return parameters;\n  }\n  /**\n   * Prints sql to stdout using console.log.\n   */\n  printSql() {\n    // TODO rename to logSql()\n    const [query, parameters] = this.getQueryAndParameters();\n    this.connection.logger.logQuery(query, parameters);\n    return this;\n  }\n  /**\n   * Gets generated sql that will be executed.\n   * Parameters in the query are escaped for the currently used driver.\n   */\n  getSql() {\n    return this.getQueryAndParameters()[0];\n  }\n  /**\n   * Gets query to be executed with all parameters used in it.\n   */\n  getQueryAndParameters() {\n    // this execution order is important because getQuery method generates this.expressionMap.nativeParameters values\n    const query = this.getQuery();\n    const parameters = this.getParameters();\n    return this.connection.driver.escapeQueryWithParameters(query, parameters, this.expressionMap.nativeParameters);\n  }\n  /**\n   * Executes sql generated by query builder and returns raw database results.\n   */\n  async execute() {\n    const [sql, parameters] = this.getQueryAndParameters();\n    const queryRunner = this.obtainQueryRunner();\n    try {\n      return await queryRunner.query(sql, parameters); // await is needed here because we are using finally\n    } finally {\n      if (queryRunner !== this.queryRunner) {\n        // means we created our own query runner\n        await queryRunner.release();\n      }\n    }\n  }\n  /**\n   * Creates a completely new query builder.\n   * Uses same query runner as current QueryBuilder.\n   */\n  createQueryBuilder(queryRunner) {\n    return new this.constructor(this.connection, queryRunner ?? this.queryRunner);\n  }\n  /**\n   * Clones query builder as it is.\n   * Note: it uses new query runner, if you want query builder that uses exactly same query runner,\n   * you can create query builder using its constructor, for example new SelectQueryBuilder(queryBuilder)\n   * where queryBuilder is cloned QueryBuilder.\n   */\n  clone() {\n    return new this.constructor(this);\n  }\n  /**\n   * Includes a Query comment in the query builder.  This is helpful for debugging purposes,\n   * such as finding a specific query in the database server's logs, or for categorization using\n   * an APM product.\n   */\n  comment(comment) {\n    this.expressionMap.comment = comment;\n    return this;\n  }\n  /**\n   * Disables escaping.\n   */\n  disableEscaping() {\n    this.expressionMap.disableEscaping = false;\n    return this;\n  }\n  /**\n   * Escapes table name, column name or alias name using current database's escaping character.\n   */\n  escape(name) {\n    if (!this.expressionMap.disableEscaping) return name;\n    return this.connection.driver.escape(name);\n  }\n  /**\n   * Sets or overrides query builder's QueryRunner.\n   */\n  setQueryRunner(queryRunner) {\n    this.queryRunner = queryRunner;\n    return this;\n  }\n  /**\n   * Indicates if listeners and subscribers must be called before and after query execution.\n   * Enabled by default.\n   */\n  callListeners(enabled) {\n    this.expressionMap.callListeners = enabled;\n    return this;\n  }\n  /**\n   * If set to true the query will be wrapped into a transaction.\n   */\n  useTransaction(enabled) {\n    this.expressionMap.useTransaction = enabled;\n    return this;\n  }\n  /**\n   * Adds CTE to query\n   */\n  addCommonTableExpression(queryBuilder, alias, options) {\n    this.expressionMap.commonTableExpressions.push({\n      queryBuilder,\n      alias,\n      options: options || {}\n    });\n    return this;\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Gets escaped table name with schema name if SqlServer driver used with custom\n   * schema name, otherwise returns escaped table name.\n   */\n  getTableName(tablePath) {\n    return tablePath.split(\".\").map(i => {\n      // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n      if (i === \"\") return i;\n      return this.escape(i);\n    }).join(\".\");\n  }\n  /**\n   * Gets name of the table where insert should be performed.\n   */\n  getMainTableName() {\n    if (!this.expressionMap.mainAlias) throw new TypeORMError(`Entity where values should be inserted is not specified. Call \"qb.into(entity)\" method to specify it.`);\n    if (this.expressionMap.mainAlias.hasMetadata) return this.expressionMap.mainAlias.metadata.tablePath;\n    return this.expressionMap.mainAlias.tablePath;\n  }\n  /**\n   * Specifies FROM which entity's table select/update/delete will be executed.\n   * Also sets a main string alias of the selection data.\n   */\n  createFromAlias(entityTarget, aliasName) {\n    // if table has a metadata then find it to properly escape its properties\n    // const metadata = this.connection.entityMetadatas.find(metadata => metadata.tableName === tableName);\n    if (this.connection.hasMetadata(entityTarget)) {\n      const metadata = this.connection.getMetadata(entityTarget);\n      return this.expressionMap.createAlias({\n        type: \"from\",\n        name: aliasName,\n        metadata: this.connection.getMetadata(entityTarget),\n        tablePath: metadata.tablePath\n      });\n    } else {\n      if (typeof entityTarget === \"string\") {\n        const isSubquery = entityTarget.substr(0, 1) === \"(\" && entityTarget.substr(-1) === \")\";\n        return this.expressionMap.createAlias({\n          type: \"from\",\n          name: aliasName,\n          tablePath: !isSubquery ? entityTarget : undefined,\n          subQuery: isSubquery ? entityTarget : undefined\n        });\n      }\n      const subQueryBuilder = entityTarget(this.subQuery());\n      this.setParameters(subQueryBuilder.getParameters());\n      const subquery = subQueryBuilder.getQuery();\n      return this.expressionMap.createAlias({\n        type: \"from\",\n        name: aliasName,\n        subQuery: subquery\n      });\n    }\n  }\n  /**\n   * @deprecated this way of replace property names is too slow.\n   *  Instead, we'll replace property names at the end - once query is build.\n   */\n  replacePropertyNames(statement) {\n    return statement;\n  }\n  /**\n   * Replaces all entity's propertyName to name in the given SQL string.\n   */\n  replacePropertyNamesForTheWholeQuery(statement) {\n    const replacements = {};\n    for (const alias of this.expressionMap.aliases) {\n      if (!alias.hasMetadata) continue;\n      const replaceAliasNamePrefix = this.expressionMap.aliasNamePrefixingEnabled && alias.name ? `${alias.name}.` : \"\";\n      if (!replacements[replaceAliasNamePrefix]) {\n        replacements[replaceAliasNamePrefix] = {};\n      }\n      // Insert & overwrite the replacements from least to most relevant in our replacements object.\n      // To do this we iterate and overwrite in the order of relevance.\n      // Least to Most Relevant:\n      // * Relation Property Path to first join column key\n      // * Relation Property Path + Column Path\n      // * Column Database Name\n      // * Column Property Name\n      // * Column Property Path\n      for (const relation of alias.metadata.relations) {\n        if (relation.joinColumns.length > 0) replacements[replaceAliasNamePrefix][relation.propertyPath] = relation.joinColumns[0].databaseName;\n      }\n      for (const relation of alias.metadata.relations) {\n        const allColumns = [...relation.joinColumns, ...relation.inverseJoinColumns];\n        for (const joinColumn of allColumns) {\n          const propertyKey = `${relation.propertyPath}.${joinColumn.referencedColumn.propertyPath}`;\n          replacements[replaceAliasNamePrefix][propertyKey] = joinColumn.databaseName;\n        }\n      }\n      for (const column of alias.metadata.columns) {\n        replacements[replaceAliasNamePrefix][column.databaseName] = column.databaseName;\n      }\n      for (const column of alias.metadata.columns) {\n        replacements[replaceAliasNamePrefix][column.propertyName] = column.databaseName;\n      }\n      for (const column of alias.metadata.columns) {\n        replacements[replaceAliasNamePrefix][column.propertyPath] = column.databaseName;\n      }\n    }\n    const replacementKeys = Object.keys(replacements);\n    const replaceAliasNamePrefixes = replacementKeys.map(key => escapeRegExp(key)).join(\"|\");\n    if (replacementKeys.length > 0) {\n      statement = statement.replace(new RegExp(\n      // Avoid a lookbehind here since it's not well supported\n      `([ =(]|^.{0})` +\n      // any of ' =(' or start of line\n      // followed by our prefix, e.g. 'tablename.' or ''\n      `${replaceAliasNamePrefixes ? \"(\" + replaceAliasNamePrefixes + \")\" : \"\"}([^ =(),]+)` +\n      // a possible property name: sequence of anything but ' =(),'\n      // terminated by ' =),' or end of line\n      `(?=[ =),]|.{0}$)`, \"gm\"), (...matches) => {\n        let match, pre, p;\n        if (replaceAliasNamePrefixes) {\n          match = matches[0];\n          pre = matches[1];\n          p = matches[3];\n          if (replacements[matches[2]][p]) {\n            return `${pre}${this.escape(matches[2].substring(0, matches[2].length - 1))}.${this.escape(replacements[matches[2]][p])}`;\n          }\n        } else {\n          match = matches[0];\n          pre = matches[1];\n          p = matches[2];\n          if (replacements[\"\"][p]) {\n            return `${pre}${this.escape(replacements[\"\"][p])}`;\n          }\n        }\n        return match;\n      });\n    }\n    return statement;\n  }\n  createComment() {\n    if (!this.expressionMap.comment) {\n      return \"\";\n    }\n    // ANSI SQL 2003 support C style comments - comments that start with `/*` and end with `*/`\n    // In some dialects query nesting is available - but not all.  Because of this, we'll need\n    // to scrub \"ending\" characters from the SQL but otherwise we can leave everything else\n    // as-is and it should be valid.\n    return `/* ${this.expressionMap.comment.replace(/\\*\\//g, \"\")} */ `;\n  }\n  /**\n   * Time travel queries for CockroachDB\n   */\n  createTimeTravelQuery() {\n    if (this.expressionMap.queryType === \"select\" && this.expressionMap.timeTravel) {\n      return ` AS OF SYSTEM TIME ${this.expressionMap.timeTravel}`;\n    }\n    return \"\";\n  }\n  /**\n   * Creates \"WHERE\" expression.\n   */\n  createWhereExpression() {\n    const conditionsArray = [];\n    const whereExpression = this.createWhereClausesExpression(this.expressionMap.wheres);\n    if (whereExpression.length > 0 && whereExpression !== \"1=1\") {\n      conditionsArray.push(this.replacePropertyNames(whereExpression));\n    }\n    if (this.expressionMap.mainAlias.hasMetadata) {\n      const metadata = this.expressionMap.mainAlias.metadata;\n      // Adds the global condition of \"non-deleted\" for the entity with delete date columns in select query.\n      if (this.expressionMap.queryType === \"select\" && !this.expressionMap.withDeleted && metadata.deleteDateColumn) {\n        const column = this.expressionMap.aliasNamePrefixingEnabled ? this.expressionMap.mainAlias.name + \".\" + metadata.deleteDateColumn.propertyName : metadata.deleteDateColumn.propertyName;\n        const condition = `${this.replacePropertyNames(column)} IS NULL`;\n        conditionsArray.push(condition);\n      }\n      if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {\n        const column = this.expressionMap.aliasNamePrefixingEnabled ? this.expressionMap.mainAlias.name + \".\" + metadata.discriminatorColumn.databaseName : metadata.discriminatorColumn.databaseName;\n        const condition = `${this.replacePropertyNames(column)} IN (:...discriminatorColumnValues)`;\n        conditionsArray.push(condition);\n      }\n    }\n    if (this.expressionMap.extraAppendedAndWhereCondition) {\n      const condition = this.replacePropertyNames(this.expressionMap.extraAppendedAndWhereCondition);\n      conditionsArray.push(condition);\n    }\n    let condition = \"\";\n    // time travel\n    condition += this.createTimeTravelQuery();\n    if (!conditionsArray.length) {\n      condition += \"\";\n    } else if (conditionsArray.length === 1) {\n      condition += ` WHERE ${conditionsArray[0]}`;\n    } else {\n      condition += ` WHERE ( ${conditionsArray.join(\" ) AND ( \")} )`;\n    }\n    return condition;\n  }\n  /**\n   * Creates \"RETURNING\" / \"OUTPUT\" expression.\n   */\n  createReturningExpression(returningType) {\n    const columns = this.getReturningColumns();\n    const driver = this.connection.driver;\n    // also add columns we must auto-return to perform entity updation\n    // if user gave his own returning\n    if (typeof this.expressionMap.returning !== \"string\" && this.expressionMap.extraReturningColumns.length > 0 && driver.isReturningSqlSupported(returningType)) {\n      columns.push(...this.expressionMap.extraReturningColumns.filter(column => {\n        return columns.indexOf(column) === -1;\n      }));\n    }\n    if (columns.length) {\n      let columnsExpression = columns.map(column => {\n        const name = this.escape(column.databaseName);\n        if (driver.options.type === \"mssql\") {\n          if (this.expressionMap.queryType === \"insert\" || this.expressionMap.queryType === \"update\" || this.expressionMap.queryType === \"soft-delete\" || this.expressionMap.queryType === \"restore\") {\n            return \"INSERTED.\" + name;\n          } else {\n            return this.escape(this.getMainTableName()) + \".\" + name;\n          }\n        } else {\n          return name;\n        }\n      }).join(\", \");\n      if (driver.options.type === \"oracle\") {\n        columnsExpression += \" INTO \" + columns.map(column => {\n          return this.createParameter({\n            type: driver.columnTypeToNativeParameter(column.type),\n            dir: driver.oracle.BIND_OUT\n          });\n        }).join(\", \");\n      }\n      if (driver.options.type === \"mssql\") {\n        if (this.expressionMap.queryType === \"insert\" || this.expressionMap.queryType === \"update\") {\n          columnsExpression += \" INTO @OutputTable\";\n        }\n      }\n      return columnsExpression;\n    } else if (typeof this.expressionMap.returning === \"string\") {\n      return this.expressionMap.returning;\n    }\n    return \"\";\n  }\n  /**\n   * If returning / output cause is set to array of column names,\n   * then this method will return all column metadatas of those column names.\n   */\n  getReturningColumns() {\n    const columns = [];\n    if (Array.isArray(this.expressionMap.returning)) {\n      ;\n      this.expressionMap.returning.forEach(columnName => {\n        if (this.expressionMap.mainAlias.hasMetadata) {\n          columns.push(...this.expressionMap.mainAlias.metadata.findColumnsWithPropertyPath(columnName));\n        }\n      });\n    }\n    return columns;\n  }\n  createWhereClausesExpression(clauses) {\n    return clauses.map((clause, index) => {\n      const expression = this.createWhereConditionExpression(clause.condition);\n      switch (clause.type) {\n        case \"and\":\n          return (index > 0 ? \"AND \" : \"\") + `${this.connection.options.isolateWhereStatements ? \"(\" : \"\"}${expression}${this.connection.options.isolateWhereStatements ? \")\" : \"\"}`;\n        case \"or\":\n          return (index > 0 ? \"OR \" : \"\") + `${this.connection.options.isolateWhereStatements ? \"(\" : \"\"}${expression}${this.connection.options.isolateWhereStatements ? \")\" : \"\"}`;\n      }\n      return expression;\n    }).join(\" \").trim();\n  }\n  /**\n   * Computes given where argument - transforms to a where string all forms it can take.\n   */\n  createWhereConditionExpression(condition, alwaysWrap = false) {\n    if (typeof condition === \"string\") return condition;\n    if (Array.isArray(condition)) {\n      if (condition.length === 0) {\n        return \"1=1\";\n      }\n      // In the future we should probably remove this entire condition\n      // but for now to prevent any breaking changes it exists.\n      if (condition.length === 1 && !alwaysWrap) {\n        return this.createWhereClausesExpression(condition);\n      }\n      return \"(\" + this.createWhereClausesExpression(condition) + \")\";\n    }\n    const {\n      driver\n    } = this.connection;\n    switch (condition.operator) {\n      case \"lessThan\":\n        return `${condition.parameters[0]} < ${condition.parameters[1]}`;\n      case \"lessThanOrEqual\":\n        return `${condition.parameters[0]} <= ${condition.parameters[1]}`;\n      case \"arrayContains\":\n        return `${condition.parameters[0]} @> ${condition.parameters[1]}`;\n      case \"jsonContains\":\n        return `${condition.parameters[0]} ::jsonb @> ${condition.parameters[1]}`;\n      case \"arrayContainedBy\":\n        return `${condition.parameters[0]} <@ ${condition.parameters[1]}`;\n      case \"arrayOverlap\":\n        return `${condition.parameters[0]} && ${condition.parameters[1]}`;\n      case \"moreThan\":\n        return `${condition.parameters[0]} > ${condition.parameters[1]}`;\n      case \"moreThanOrEqual\":\n        return `${condition.parameters[0]} >= ${condition.parameters[1]}`;\n      case \"notEqual\":\n        return `${condition.parameters[0]} != ${condition.parameters[1]}`;\n      case \"equal\":\n        return `${condition.parameters[0]} = ${condition.parameters[1]}`;\n      case \"ilike\":\n        if (driver.options.type === \"postgres\" || driver.options.type === \"cockroachdb\") {\n          return `${condition.parameters[0]} ILIKE ${condition.parameters[1]}`;\n        }\n        return `UPPER(${condition.parameters[0]}) LIKE UPPER(${condition.parameters[1]})`;\n      case \"like\":\n        return `${condition.parameters[0]} LIKE ${condition.parameters[1]}`;\n      case \"between\":\n        return `${condition.parameters[0]} BETWEEN ${condition.parameters[1]} AND ${condition.parameters[2]}`;\n      case \"in\":\n        if (condition.parameters.length <= 1) {\n          return \"0=1\";\n        }\n        return `${condition.parameters[0]} IN (${condition.parameters.slice(1).join(\", \")})`;\n      case \"any\":\n        if (driver.options.type === \"cockroachdb\") {\n          return `${condition.parameters[0]}::STRING = ANY(${condition.parameters[1]}::STRING[])`;\n        }\n        return `${condition.parameters[0]} = ANY(${condition.parameters[1]})`;\n      case \"isNull\":\n        return `${condition.parameters[0]} IS NULL`;\n      case \"not\":\n        return `NOT(${this.createWhereConditionExpression(condition.condition)})`;\n      case \"brackets\":\n        return `${this.createWhereConditionExpression(condition.condition, true)}`;\n      case \"and\":\n        return \"(\" + condition.parameters.join(\" AND \") + \")\";\n      case \"or\":\n        return \"(\" + condition.parameters.join(\" OR \") + \")\";\n    }\n    throw new TypeError(`Unsupported FindOperator ${FindOperator.constructor.name}`);\n  }\n  createCteExpression() {\n    if (!this.hasCommonTableExpressions()) {\n      return \"\";\n    }\n    const databaseRequireRecusiveHint = this.connection.driver.cteCapabilities.requiresRecursiveHint;\n    const cteStrings = this.expressionMap.commonTableExpressions.map(cte => {\n      const cteBodyExpression = typeof cte.queryBuilder === \"string\" ? cte.queryBuilder : cte.queryBuilder.getQuery();\n      if (typeof cte.queryBuilder !== \"string\") {\n        if (cte.queryBuilder.hasCommonTableExpressions()) {\n          throw new TypeORMError(`Nested CTEs aren't supported (CTE: ${cte.alias})`);\n        }\n        if (!this.connection.driver.cteCapabilities.writable && !InstanceChecker.isSelectQueryBuilder(cte.queryBuilder)) {\n          throw new TypeORMError(`Only select queries are supported in CTEs in ${this.connection.options.type} (CTE: ${cte.alias})`);\n        }\n        this.setParameters(cte.queryBuilder.getParameters());\n      }\n      let cteHeader = this.escape(cte.alias);\n      if (cte.options.columnNames) {\n        const escapedColumnNames = cte.options.columnNames.map(column => this.escape(column));\n        if (InstanceChecker.isSelectQueryBuilder(cte.queryBuilder)) {\n          if (cte.queryBuilder.expressionMap.selects.length && cte.options.columnNames.length !== cte.queryBuilder.expressionMap.selects.length) {\n            throw new TypeORMError(`cte.options.columnNames length (${cte.options.columnNames.length}) doesn't match subquery select list length ${cte.queryBuilder.expressionMap.selects.length} (CTE: ${cte.alias})`);\n          }\n        }\n        cteHeader += `(${escapedColumnNames.join(\", \")})`;\n      }\n      const recursiveClause = cte.options.recursive && databaseRequireRecusiveHint ? \"RECURSIVE\" : \"\";\n      let materializeClause = \"\";\n      if (this.connection.driver.cteCapabilities.materializedHint && cte.options.materialized !== undefined) {\n        materializeClause = cte.options.materialized ? \"MATERIALIZED\" : \"NOT MATERIALIZED\";\n      }\n      return [recursiveClause, cteHeader, \"AS\", materializeClause, `(${cteBodyExpression})`].filter(Boolean).join(\" \");\n    });\n    return \"WITH \" + cteStrings.join(\", \") + \" \";\n  }\n  /**\n   * Creates \"WHERE\" condition for an in-ids condition.\n   */\n  getWhereInIdsCondition(ids) {\n    const metadata = this.expressionMap.mainAlias.metadata;\n    const normalized = (Array.isArray(ids) ? ids : [ids]).map(id => metadata.ensureEntityIdMap(id));\n    // using in(...ids) for single primary key entities\n    if (!metadata.hasMultiplePrimaryKeys) {\n      const primaryColumn = metadata.primaryColumns[0];\n      // getEntityValue will try to transform `In`, it is a bug\n      // todo: remove this transformer check after #2390 is fixed\n      // This also fails for embedded & relation, so until that is fixed skip it.\n      if (!primaryColumn.transformer && !primaryColumn.relationMetadata && !primaryColumn.embeddedMetadata) {\n        return {\n          [primaryColumn.propertyName]: In(normalized.map(id => primaryColumn.getEntityValue(id, false)))\n        };\n      }\n    }\n    return new Brackets(qb => {\n      for (const data of normalized) {\n        qb.orWhere(new Brackets(qb => qb.where(data)));\n      }\n    });\n  }\n  getExistsCondition(subQuery) {\n    const query = subQuery.clone().orderBy().groupBy().offset(undefined).limit(undefined).skip(undefined).take(undefined).select(\"1\").setOption(\"disable-global-order\");\n    return [`EXISTS (${query.getQuery()})`, query.getParameters()];\n  }\n  findColumnsForPropertyPath(propertyPath) {\n    // Make a helper to iterate the entity & relations?\n    // Use that to set the correct alias?  Or the other way around?\n    // Start with the main alias with our property paths\n    let alias = this.expressionMap.mainAlias;\n    const root = [];\n    const propertyPathParts = propertyPath.split(\".\");\n    while (propertyPathParts.length > 1) {\n      const part = propertyPathParts[0];\n      if (!alias?.hasMetadata) {\n        // If there's no metadata, we're wasting our time\n        // and can't actually look any of this up.\n        break;\n      }\n      if (alias.metadata.hasEmbeddedWithPropertyPath(part)) {\n        // If this is an embedded then we should combine the two as part of our lookup.\n        // Instead of just breaking, we keep going with this in case there's an embedded/relation\n        // inside an embedded.\n        propertyPathParts.unshift(`${propertyPathParts.shift()}.${propertyPathParts.shift()}`);\n        continue;\n      }\n      if (alias.metadata.hasRelationWithPropertyPath(part)) {\n        // If this is a relation then we should find the aliases\n        // that match the relation & then continue further down\n        // the property path\n        const joinAttr = this.expressionMap.joinAttributes.find(joinAttr => joinAttr.relationPropertyPath === part);\n        if (!joinAttr?.alias) {\n          const fullRelationPath = root.length > 0 ? `${root.join(\".\")}.${part}` : part;\n          throw new Error(`Cannot find alias for relation at ${fullRelationPath}`);\n        }\n        alias = joinAttr.alias;\n        root.push(...part.split(\".\"));\n        propertyPathParts.shift();\n        continue;\n      }\n      break;\n    }\n    if (!alias) {\n      throw new Error(`Cannot find alias for property ${propertyPath}`);\n    }\n    // Remaining parts are combined back and used to find the actual property path\n    const aliasPropertyPath = propertyPathParts.join(\".\");\n    const columns = alias.metadata.findColumnsWithPropertyPath(aliasPropertyPath);\n    if (!columns.length) {\n      throw new EntityPropertyNotFoundError(propertyPath, alias.metadata);\n    }\n    return [alias, root, columns];\n  }\n  /**\n   * Creates a property paths for a given ObjectLiteral.\n   */\n  createPropertyPath(metadata, entity, prefix = \"\") {\n    const paths = [];\n    for (const key of Object.keys(entity)) {\n      const path = prefix ? `${prefix}.${key}` : key;\n      // There's times where we don't actually want to traverse deeper.\n      // If the value is a `FindOperator`, or null, or not an object, then we don't, for example.\n      if (entity[key] === null || typeof entity[key] !== \"object\" || InstanceChecker.isFindOperator(entity[key])) {\n        paths.push(path);\n        continue;\n      }\n      if (metadata.hasEmbeddedWithPropertyPath(path)) {\n        const subPaths = this.createPropertyPath(metadata, entity[key], path);\n        paths.push(...subPaths);\n        continue;\n      }\n      if (metadata.hasRelationWithPropertyPath(path)) {\n        const relation = metadata.findRelationWithPropertyPath(path);\n        // There's also cases where we don't want to return back all of the properties.\n        // These handles the situation where someone passes the model & we don't need to make\n        // a HUGE `where` to uniquely look up the entity.\n        // In the case of a *-to-one, there's only ever one possible entity on the other side\n        // so if the join columns are all defined we can return just the relation itself\n        // because it will fetch only the join columns and do the lookup.\n        if (relation.relationType === \"one-to-one\" || relation.relationType === \"many-to-one\") {\n          const joinColumns = relation.joinColumns.map(j => j.referencedColumn).filter(j => !!j);\n          const hasAllJoinColumns = joinColumns.length > 0 && joinColumns.every(column => column.getEntityValue(entity[key], false));\n          if (hasAllJoinColumns) {\n            paths.push(path);\n            continue;\n          }\n        }\n        if (relation.relationType === \"one-to-many\" || relation.relationType === \"many-to-many\") {\n          throw new Error(`Cannot query across ${relation.relationType} for property ${path}`);\n        }\n        // For any other case, if the `entity[key]` contains all of the primary keys we can do a\n        // lookup via these.  We don't need to look up via any other values 'cause these are\n        // the unique primary keys.\n        // This handles the situation where someone passes the model & we don't need to make\n        // a HUGE where.\n        const primaryColumns = relation.inverseEntityMetadata.primaryColumns;\n        const hasAllPrimaryKeys = primaryColumns.length > 0 && primaryColumns.every(column => column.getEntityValue(entity[key], false));\n        if (hasAllPrimaryKeys) {\n          const subPaths = primaryColumns.map(column => `${path}.${column.propertyPath}`);\n          paths.push(...subPaths);\n          continue;\n        }\n        // If nothing else, just return every property that's being passed to us.\n        const subPaths = this.createPropertyPath(relation.inverseEntityMetadata, entity[key]).map(p => `${path}.${p}`);\n        paths.push(...subPaths);\n        continue;\n      }\n      paths.push(path);\n    }\n    return paths;\n  }\n  *getPredicates(where) {\n    if (this.expressionMap.mainAlias.hasMetadata) {\n      const propertyPaths = this.createPropertyPath(this.expressionMap.mainAlias.metadata, where);\n      for (const propertyPath of propertyPaths) {\n        const [alias, aliasPropertyPath, columns] = this.findColumnsForPropertyPath(propertyPath);\n        for (const column of columns) {\n          let containedWhere = where;\n          for (const part of aliasPropertyPath) {\n            if (!containedWhere || !(part in containedWhere)) {\n              containedWhere = {};\n              break;\n            }\n            containedWhere = containedWhere[part];\n          }\n          // Use the correct alias & the property path from the column\n          const aliasPath = this.expressionMap.aliasNamePrefixingEnabled ? `${alias.name}.${column.propertyPath}` : column.propertyPath;\n          const parameterValue = column.getEntityValue(containedWhere, true);\n          yield [aliasPath, parameterValue];\n        }\n      }\n    } else {\n      for (const key of Object.keys(where)) {\n        const parameterValue = where[key];\n        const aliasPath = this.expressionMap.aliasNamePrefixingEnabled ? `${this.alias}.${key}` : key;\n        yield [aliasPath, parameterValue];\n      }\n    }\n  }\n  getWherePredicateCondition(aliasPath, parameterValue) {\n    if (InstanceChecker.isFindOperator(parameterValue)) {\n      let parameters = [];\n      if (parameterValue.useParameter) {\n        if (parameterValue.objectLiteralParameters) {\n          this.setParameters(parameterValue.objectLiteralParameters);\n        } else if (parameterValue.multipleParameters) {\n          for (const v of parameterValue.value) {\n            parameters.push(this.createParameter(v));\n          }\n        } else {\n          parameters.push(this.createParameter(parameterValue.value));\n        }\n      }\n      if (parameterValue.type === \"raw\") {\n        if (parameterValue.getSql) {\n          return parameterValue.getSql(aliasPath);\n        } else {\n          return {\n            operator: \"equal\",\n            parameters: [aliasPath, parameterValue.value]\n          };\n        }\n      } else if (parameterValue.type === \"not\") {\n        if (parameterValue.child) {\n          return {\n            operator: parameterValue.type,\n            condition: this.getWherePredicateCondition(aliasPath, parameterValue.child)\n          };\n        } else {\n          return {\n            operator: \"notEqual\",\n            parameters: [aliasPath, ...parameters]\n          };\n        }\n      } else if (parameterValue.type === \"and\") {\n        const values = parameterValue.value;\n        return {\n          operator: parameterValue.type,\n          parameters: values.map(operator => this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, operator)))\n        };\n      } else if (parameterValue.type === \"or\") {\n        const values = parameterValue.value;\n        return {\n          operator: parameterValue.type,\n          parameters: values.map(operator => this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, operator)))\n        };\n      } else {\n        return {\n          operator: parameterValue.type,\n          parameters: [aliasPath, ...parameters]\n        };\n      }\n      // } else if (parameterValue === null) {\n      //     return {\n      //         operator: \"isNull\",\n      //         parameters: [\n      //             aliasPath,\n      //         ]\n      //     };\n    } else {\n      return {\n        operator: \"equal\",\n        parameters: [aliasPath, this.createParameter(parameterValue)]\n      };\n    }\n  }\n  getWhereCondition(where) {\n    if (typeof where === \"string\") {\n      return where;\n    }\n    if (InstanceChecker.isBrackets(where)) {\n      const whereQueryBuilder = this.createQueryBuilder();\n      whereQueryBuilder.parentQueryBuilder = this;\n      whereQueryBuilder.expressionMap.mainAlias = this.expressionMap.mainAlias;\n      whereQueryBuilder.expressionMap.aliasNamePrefixingEnabled = this.expressionMap.aliasNamePrefixingEnabled;\n      whereQueryBuilder.expressionMap.parameters = this.expressionMap.parameters;\n      whereQueryBuilder.expressionMap.nativeParameters = this.expressionMap.nativeParameters;\n      whereQueryBuilder.expressionMap.wheres = [];\n      where.whereFactory(whereQueryBuilder);\n      return {\n        operator: InstanceChecker.isNotBrackets(where) ? \"not\" : \"brackets\",\n        condition: whereQueryBuilder.expressionMap.wheres\n      };\n    }\n    if (typeof where === \"function\") {\n      return where(this);\n    }\n    const wheres = Array.isArray(where) ? where : [where];\n    const clauses = [];\n    for (const where of wheres) {\n      const conditions = [];\n      // Filter the conditions and set up the parameter values\n      for (const [aliasPath, parameterValue] of this.getPredicates(where)) {\n        conditions.push({\n          type: \"and\",\n          condition: this.getWherePredicateCondition(aliasPath, parameterValue)\n        });\n      }\n      clauses.push({\n        type: \"or\",\n        condition: conditions\n      });\n    }\n    if (clauses.length === 1) {\n      return clauses[0].condition;\n    }\n    return clauses;\n  }\n  /**\n   * Creates a query builder used to execute sql queries inside this query builder.\n   */\n  obtainQueryRunner() {\n    return this.queryRunner || this.connection.createQueryRunner();\n  }\n  hasCommonTableExpressions() {\n    return this.expressionMap.commonTableExpressions.length > 0;\n  }\n}\n/**\n * Contains all registered query builder classes.\n */\nQueryBuilder.queryBuilderRegistry = {};","map":{"version":3,"names":["QueryExpressionMap","Brackets","FindOperator","In","TypeORMError","EntityPropertyNotFoundError","InstanceChecker","escapeRegExp","QueryBuilder","constructor","connectionOrQueryBuilder","queryRunner","Symbol","for","parameterIndex","isDataSource","connection","expressionMap","clone","registerQueryBuilderClass","name","factory","queryBuilderRegistry","alias","mainAlias","select","selection","selectionAliasName","queryType","Array","isArray","selects","map","aliasName","isSelectQueryBuilder","insert","isInsertQueryBuilder","update","entityOrTableNameUpdateSet","maybeUpdateSet","updateSet","isEntitySchema","options","createFromAlias","setMainAlias","valuesSet","isUpdateQueryBuilder","delete","isDeleteQueryBuilder","softDelete","isSoftDeleteQueryBuilder","restore","relation","entityTargetOrPropertyPath","maybePropertyPath","entityTarget","arguments","length","undefined","propertyPath","relationPropertyPath","isRelationQueryBuilder","hasRelation","target","entityMetadata","getMetadata","relations","every","findRelationWithPropertyPath","hasParameter","key","parentQueryBuilder","parameters","setParameter","value","match","setParameters","Object","entries","createParameter","parameterName","setNativeParameters","keys","forEach","nativeParameters","getParameters","assign","hasMetadata","metadata","discriminatorColumn","parentEntityMetadata","values","childEntityMetadatas","filter","childMetadata","discriminatorValue","push","printSql","query","getQueryAndParameters","logger","logQuery","getSql","getQuery","driver","escapeQueryWithParameters","execute","sql","obtainQueryRunner","release","createQueryBuilder","comment","disableEscaping","escape","setQueryRunner","callListeners","enabled","useTransaction","addCommonTableExpression","queryBuilder","commonTableExpressions","getTableName","tablePath","split","i","join","getMainTableName","createAlias","type","isSubquery","substr","subQuery","subQueryBuilder","subquery","replacePropertyNames","statement","replacePropertyNamesForTheWholeQuery","replacements","aliases","replaceAliasNamePrefix","aliasNamePrefixingEnabled","joinColumns","databaseName","allColumns","inverseJoinColumns","joinColumn","propertyKey","referencedColumn","column","columns","propertyName","replacementKeys","replaceAliasNamePrefixes","replace","RegExp","matches","pre","p","substring","createComment","createTimeTravelQuery","timeTravel","createWhereExpression","conditionsArray","whereExpression","createWhereClausesExpression","wheres","withDeleted","deleteDateColumn","condition","extraAppendedAndWhereCondition","createReturningExpression","returningType","getReturningColumns","returning","extraReturningColumns","isReturningSqlSupported","indexOf","columnsExpression","columnTypeToNativeParameter","dir","oracle","BIND_OUT","columnName","findColumnsWithPropertyPath","clauses","clause","index","expression","createWhereConditionExpression","isolateWhereStatements","trim","alwaysWrap","operator","slice","TypeError","createCteExpression","hasCommonTableExpressions","databaseRequireRecusiveHint","cteCapabilities","requiresRecursiveHint","cteStrings","cte","cteBodyExpression","writable","cteHeader","columnNames","escapedColumnNames","recursiveClause","recursive","materializeClause","materializedHint","materialized","Boolean","getWhereInIdsCondition","ids","normalized","id","ensureEntityIdMap","hasMultiplePrimaryKeys","primaryColumn","primaryColumns","transformer","relationMetadata","embeddedMetadata","getEntityValue","qb","data","orWhere","where","getExistsCondition","orderBy","groupBy","offset","limit","skip","take","setOption","findColumnsForPropertyPath","root","propertyPathParts","part","hasEmbeddedWithPropertyPath","unshift","shift","hasRelationWithPropertyPath","joinAttr","joinAttributes","find","fullRelationPath","Error","aliasPropertyPath","createPropertyPath","entity","prefix","paths","path","isFindOperator","subPaths","relationType","j","hasAllJoinColumns","inverseEntityMetadata","hasAllPrimaryKeys","getPredicates","propertyPaths","containedWhere","aliasPath","parameterValue","getWherePredicateCondition","useParameter","objectLiteralParameters","multipleParameters","v","child","getWhereCondition","isBrackets","whereQueryBuilder","whereFactory","isNotBrackets","conditions","createQueryRunner"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\query-builder\\QueryBuilder.ts"],"sourcesContent":["import { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { QueryBuilderCteOptions } from \"./QueryBuilderCte\"\nimport { QueryExpressionMap } from \"./QueryExpressionMap\"\nimport { SelectQueryBuilder } from \"./SelectQueryBuilder\"\nimport { UpdateQueryBuilder } from \"./UpdateQueryBuilder\"\nimport { DeleteQueryBuilder } from \"./DeleteQueryBuilder\"\nimport { SoftDeleteQueryBuilder } from \"./SoftDeleteQueryBuilder\"\nimport { InsertQueryBuilder } from \"./InsertQueryBuilder\"\nimport { RelationQueryBuilder } from \"./RelationQueryBuilder\"\nimport { EntityTarget } from \"../common/EntityTarget\"\nimport { Alias } from \"./Alias\"\nimport { Brackets } from \"./Brackets\"\nimport { QueryDeepPartialEntity } from \"./QueryPartialEntity\"\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { FindOperator } from \"../find-options/FindOperator\"\nimport { In } from \"../find-options/operator/In\"\nimport { TypeORMError } from \"../error\"\nimport { WhereClause, WhereClauseCondition } from \"./WhereClause\"\nimport { NotBrackets } from \"./NotBrackets\"\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\"\nimport { ReturningType } from \"../driver/Driver\"\nimport { OracleDriver } from \"../driver/oracle/OracleDriver\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\nimport { escapeRegExp } from \"../util/escapeRegExp\"\n\n// todo: completely cover query builder with tests\n// todo: entityOrProperty can be target name. implement proper behaviour if it is.\n// todo: check in persistment if id exist on object and throw exception (can be in partial selection?)\n// todo: fix problem with long aliases eg getMaxIdentifierLength\n// todo: fix replacing in .select(\"COUNT(post.id) AS cnt\") statement\n// todo: implement joinAlways in relations and relationId\n// todo: finish partial selection\n// todo: sugar methods like: .addCount and .selectCount, selectCountAndMap, selectSum, selectSumAndMap, ...\n// todo: implement @Select decorator\n// todo: add select and map functions\n\n// todo: implement relation/entity loading and setting them into properties within a separate query\n// .loadAndMap(\"post.categories\", \"post.categories\", qb => ...)\n// .loadAndMap(\"post.categories\", Category, qb => ...)\n\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport abstract class QueryBuilder<Entity extends ObjectLiteral> {\n    readonly \"@instanceof\" = Symbol.for(\"QueryBuilder\")\n\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection on which QueryBuilder was created.\n     */\n    readonly connection: DataSource\n\n    /**\n     * Contains all properties of the QueryBuilder that needs to be build a final query.\n     */\n    readonly expressionMap: QueryExpressionMap\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Query runner used to execute query builder query.\n     */\n    protected queryRunner?: QueryRunner\n\n    /**\n     * If QueryBuilder was created in a subquery mode then its parent QueryBuilder (who created subquery) will be stored here.\n     */\n    protected parentQueryBuilder: QueryBuilder<any>\n\n    /**\n     * Memo to help keep place of current parameter index for `createParameter`\n     */\n    private parameterIndex = 0\n\n    /**\n     * Contains all registered query builder classes.\n     */\n    private static queryBuilderRegistry: Record<string, any> = {}\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    /**\n     * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.\n     */\n    constructor(queryBuilder: QueryBuilder<any>)\n\n    /**\n     * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.\n     */\n    constructor(connection: DataSource, queryRunner?: QueryRunner)\n\n    /**\n     * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.\n     */\n    constructor(\n        connectionOrQueryBuilder: DataSource | QueryBuilder<any>,\n        queryRunner?: QueryRunner,\n    ) {\n        if (InstanceChecker.isDataSource(connectionOrQueryBuilder)) {\n            this.connection = connectionOrQueryBuilder\n            this.queryRunner = queryRunner\n            this.expressionMap = new QueryExpressionMap(this.connection)\n        } else {\n            this.connection = connectionOrQueryBuilder.connection\n            this.queryRunner = connectionOrQueryBuilder.queryRunner\n            this.expressionMap = connectionOrQueryBuilder.expressionMap.clone()\n        }\n    }\n\n    static registerQueryBuilderClass(name: string, factory: any) {\n        QueryBuilder.queryBuilderRegistry[name] = factory\n    }\n\n    // -------------------------------------------------------------------------\n    // Abstract Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets generated SQL query without parameters being replaced.\n     */\n    abstract getQuery(): string\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets the main alias string used in this query builder.\n     */\n    get alias(): string {\n        if (!this.expressionMap.mainAlias)\n            throw new TypeORMError(`Main alias is not set`) // todo: better exception\n\n        return this.expressionMap.mainAlias.name\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates SELECT query.\n     * Replaces all previous selections if they exist.\n     */\n    select(): SelectQueryBuilder<Entity>\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(\n        selection: string,\n        selectionAliasName?: string,\n    ): SelectQueryBuilder<Entity>\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(selection: string[]): SelectQueryBuilder<Entity>\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(\n        selection?: string | string[],\n        selectionAliasName?: string,\n    ): SelectQueryBuilder<Entity> {\n        this.expressionMap.queryType = \"select\"\n        if (Array.isArray(selection)) {\n            this.expressionMap.selects = selection.map((selection) => ({\n                selection: selection,\n            }))\n        } else if (selection) {\n            this.expressionMap.selects = [\n                { selection: selection, aliasName: selectionAliasName },\n            ]\n        }\n\n        if (InstanceChecker.isSelectQueryBuilder(this)) return this as any\n\n        return QueryBuilder.queryBuilderRegistry[\"SelectQueryBuilder\"](this)\n    }\n\n    /**\n     * Creates INSERT query.\n     */\n    insert(): InsertQueryBuilder<Entity> {\n        this.expressionMap.queryType = \"insert\"\n\n        if (InstanceChecker.isInsertQueryBuilder(this)) return this as any\n\n        return QueryBuilder.queryBuilderRegistry[\"InsertQueryBuilder\"](this)\n    }\n\n    /**\n     * Creates UPDATE query and applies given update values.\n     */\n    update(): UpdateQueryBuilder<Entity>\n\n    /**\n     * Creates UPDATE query and applies given update values.\n     */\n    update(\n        updateSet: QueryDeepPartialEntity<Entity>,\n    ): UpdateQueryBuilder<Entity>\n\n    /**\n     * Creates UPDATE query for the given entity and applies given update values.\n     */\n    update<Entity extends ObjectLiteral>(\n        entity: EntityTarget<Entity>,\n        updateSet?: QueryDeepPartialEntity<Entity>,\n    ): UpdateQueryBuilder<Entity>\n\n    /**\n     * Creates UPDATE query for the given table name and applies given update values.\n     */\n    update(\n        tableName: string,\n        updateSet?: QueryDeepPartialEntity<Entity>,\n    ): UpdateQueryBuilder<Entity>\n\n    /**\n     * Creates UPDATE query and applies given update values.\n     */\n    update(\n        entityOrTableNameUpdateSet?: EntityTarget<any> | ObjectLiteral,\n        maybeUpdateSet?: ObjectLiteral,\n    ): UpdateQueryBuilder<any> {\n        const updateSet = maybeUpdateSet\n            ? maybeUpdateSet\n            : (entityOrTableNameUpdateSet as ObjectLiteral | undefined)\n        entityOrTableNameUpdateSet = InstanceChecker.isEntitySchema(\n            entityOrTableNameUpdateSet,\n        )\n            ? entityOrTableNameUpdateSet.options.name\n            : entityOrTableNameUpdateSet\n\n        if (\n            typeof entityOrTableNameUpdateSet === \"function\" ||\n            typeof entityOrTableNameUpdateSet === \"string\"\n        ) {\n            const mainAlias = this.createFromAlias(entityOrTableNameUpdateSet)\n            this.expressionMap.setMainAlias(mainAlias)\n        }\n\n        this.expressionMap.queryType = \"update\"\n        this.expressionMap.valuesSet = updateSet\n\n        if (InstanceChecker.isUpdateQueryBuilder(this)) return this as any\n\n        return QueryBuilder.queryBuilderRegistry[\"UpdateQueryBuilder\"](this)\n    }\n\n    /**\n     * Creates DELETE query.\n     */\n    delete(): DeleteQueryBuilder<Entity> {\n        this.expressionMap.queryType = \"delete\"\n\n        if (InstanceChecker.isDeleteQueryBuilder(this)) return this as any\n\n        return QueryBuilder.queryBuilderRegistry[\"DeleteQueryBuilder\"](this)\n    }\n\n    softDelete(): SoftDeleteQueryBuilder<any> {\n        this.expressionMap.queryType = \"soft-delete\"\n\n        if (InstanceChecker.isSoftDeleteQueryBuilder(this)) return this as any\n\n        return QueryBuilder.queryBuilderRegistry[\"SoftDeleteQueryBuilder\"](this)\n    }\n\n    restore(): SoftDeleteQueryBuilder<any> {\n        this.expressionMap.queryType = \"restore\"\n\n        if (InstanceChecker.isSoftDeleteQueryBuilder(this)) return this as any\n\n        return QueryBuilder.queryBuilderRegistry[\"SoftDeleteQueryBuilder\"](this)\n    }\n\n    /**\n     * Sets entity's relation with which this query builder gonna work.\n     */\n    relation(propertyPath: string): RelationQueryBuilder<Entity>\n\n    /**\n     * Sets entity's relation with which this query builder gonna work.\n     */\n    relation<T extends ObjectLiteral>(\n        entityTarget: EntityTarget<T>,\n        propertyPath: string,\n    ): RelationQueryBuilder<T>\n\n    /**\n     * Sets entity's relation with which this query builder gonna work.\n     */\n    relation(\n        entityTargetOrPropertyPath: Function | string,\n        maybePropertyPath?: string,\n    ): RelationQueryBuilder<Entity> {\n        const entityTarget =\n            arguments.length === 2 ? entityTargetOrPropertyPath : undefined\n        const propertyPath =\n            arguments.length === 2\n                ? (maybePropertyPath as string)\n                : (entityTargetOrPropertyPath as string)\n\n        this.expressionMap.queryType = \"relation\"\n        this.expressionMap.relationPropertyPath = propertyPath\n\n        if (entityTarget) {\n            const mainAlias = this.createFromAlias(entityTarget)\n            this.expressionMap.setMainAlias(mainAlias)\n        }\n\n        if (InstanceChecker.isRelationQueryBuilder(this)) return this as any\n\n        return QueryBuilder.queryBuilderRegistry[\"RelationQueryBuilder\"](this)\n    }\n\n    /**\n     * Checks if given relation exists in the entity.\n     * Returns true if relation exists, false otherwise.\n     *\n     * todo: move this method to manager? or create a shortcut?\n     */\n    hasRelation<T>(target: EntityTarget<T>, relation: string): boolean\n\n    /**\n     * Checks if given relations exist in the entity.\n     * Returns true if relation exists, false otherwise.\n     *\n     * todo: move this method to manager? or create a shortcut?\n     */\n    hasRelation<T>(target: EntityTarget<T>, relation: string[]): boolean\n\n    /**\n     * Checks if given relation or relations exist in the entity.\n     * Returns true if relation exists, false otherwise.\n     *\n     * todo: move this method to manager? or create a shortcut?\n     */\n    hasRelation<T>(\n        target: EntityTarget<T>,\n        relation: string | string[],\n    ): boolean {\n        const entityMetadata = this.connection.getMetadata(target)\n        const relations = Array.isArray(relation) ? relation : [relation]\n        return relations.every((relation) => {\n            return !!entityMetadata.findRelationWithPropertyPath(relation)\n        })\n    }\n\n    /**\n     * Check the existence of a parameter for this query builder.\n     */\n    hasParameter(key: string): boolean {\n        return (\n            this.parentQueryBuilder?.hasParameter(key) ||\n            key in this.expressionMap.parameters\n        )\n    }\n\n    /**\n     * Sets parameter name and its value.\n     *\n     * The key for this parameter may contain numbers, letters, underscores, or periods.\n     */\n    setParameter(key: string, value: any): this {\n        if (typeof value === \"function\") {\n            throw new TypeORMError(\n                `Function parameter isn't supported in the parameters. Please check \"${key}\" parameter.`,\n            )\n        }\n\n        if (!key.match(/^([A-Za-z0-9_.]+)$/)) {\n            throw new TypeORMError(\n                \"QueryBuilder parameter keys may only contain numbers, letters, underscores, or periods.\",\n            )\n        }\n\n        if (this.parentQueryBuilder) {\n            this.parentQueryBuilder.setParameter(key, value)\n        }\n\n        this.expressionMap.parameters[key] = value\n        return this\n    }\n\n    /**\n     * Adds all parameters from the given object.\n     */\n    setParameters(parameters: ObjectLiteral): this {\n        for (const [key, value] of Object.entries(parameters)) {\n            this.setParameter(key, value)\n        }\n\n        return this\n    }\n\n    protected createParameter(value: any): string {\n        let parameterName\n\n        do {\n            parameterName = `orm_param_${this.parameterIndex++}`\n        } while (this.hasParameter(parameterName))\n\n        this.setParameter(parameterName, value)\n\n        return `:${parameterName}`\n    }\n\n    /**\n     * Adds native parameters from the given object.\n     *\n     * @deprecated Use `setParameters` instead\n     */\n    setNativeParameters(parameters: ObjectLiteral): this {\n        // set parent query builder parameters as well in sub-query mode\n        if (this.parentQueryBuilder) {\n            this.parentQueryBuilder.setNativeParameters(parameters)\n        }\n\n        Object.keys(parameters).forEach((key) => {\n            this.expressionMap.nativeParameters[key] = parameters[key]\n        })\n        return this\n    }\n\n    /**\n     * Gets all parameters.\n     */\n    getParameters(): ObjectLiteral {\n        const parameters: ObjectLiteral = Object.assign(\n            {},\n            this.expressionMap.parameters,\n        )\n\n        // add discriminator column parameter if it exist\n        if (\n            this.expressionMap.mainAlias &&\n            this.expressionMap.mainAlias.hasMetadata\n        ) {\n            const metadata = this.expressionMap.mainAlias!.metadata\n            if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {\n                const values = metadata.childEntityMetadatas\n                    .filter(\n                        (childMetadata) => childMetadata.discriminatorColumn,\n                    )\n                    .map((childMetadata) => childMetadata.discriminatorValue)\n                values.push(metadata.discriminatorValue)\n                parameters[\"discriminatorColumnValues\"] = values\n            }\n        }\n\n        return parameters\n    }\n\n    /**\n     * Prints sql to stdout using console.log.\n     */\n    printSql(): this {\n        // TODO rename to logSql()\n        const [query, parameters] = this.getQueryAndParameters()\n        this.connection.logger.logQuery(query, parameters)\n        return this\n    }\n\n    /**\n     * Gets generated sql that will be executed.\n     * Parameters in the query are escaped for the currently used driver.\n     */\n    getSql(): string {\n        return this.getQueryAndParameters()[0]\n    }\n\n    /**\n     * Gets query to be executed with all parameters used in it.\n     */\n    getQueryAndParameters(): [string, any[]] {\n        // this execution order is important because getQuery method generates this.expressionMap.nativeParameters values\n        const query = this.getQuery()\n        const parameters = this.getParameters()\n        return this.connection.driver.escapeQueryWithParameters(\n            query,\n            parameters,\n            this.expressionMap.nativeParameters,\n        )\n    }\n\n    /**\n     * Executes sql generated by query builder and returns raw database results.\n     */\n    async execute(): Promise<any> {\n        const [sql, parameters] = this.getQueryAndParameters()\n        const queryRunner = this.obtainQueryRunner()\n        try {\n            return await queryRunner.query(sql, parameters) // await is needed here because we are using finally\n        } finally {\n            if (queryRunner !== this.queryRunner) {\n                // means we created our own query runner\n                await queryRunner.release()\n            }\n        }\n    }\n\n    /**\n     * Creates a completely new query builder.\n     * Uses same query runner as current QueryBuilder.\n     */\n    createQueryBuilder(queryRunner?: QueryRunner): this {\n        return new (this.constructor as any)(this.connection, queryRunner ?? this.queryRunner)\n    }\n\n    /**\n     * Clones query builder as it is.\n     * Note: it uses new query runner, if you want query builder that uses exactly same query runner,\n     * you can create query builder using its constructor, for example new SelectQueryBuilder(queryBuilder)\n     * where queryBuilder is cloned QueryBuilder.\n     */\n    clone(): this {\n        return new (this.constructor as any)(this)\n    }\n\n    /**\n     * Includes a Query comment in the query builder.  This is helpful for debugging purposes,\n     * such as finding a specific query in the database server's logs, or for categorization using\n     * an APM product.\n     */\n    comment(comment: string): this {\n        this.expressionMap.comment = comment\n        return this\n    }\n\n    /**\n     * Disables escaping.\n     */\n    disableEscaping(): this {\n        this.expressionMap.disableEscaping = false\n        return this\n    }\n\n    /**\n     * Escapes table name, column name or alias name using current database's escaping character.\n     */\n    escape(name: string): string {\n        if (!this.expressionMap.disableEscaping) return name\n        return this.connection.driver.escape(name)\n    }\n\n    /**\n     * Sets or overrides query builder's QueryRunner.\n     */\n    setQueryRunner(queryRunner: QueryRunner): this {\n        this.queryRunner = queryRunner\n        return this\n    }\n\n    /**\n     * Indicates if listeners and subscribers must be called before and after query execution.\n     * Enabled by default.\n     */\n    callListeners(enabled: boolean): this {\n        this.expressionMap.callListeners = enabled\n        return this\n    }\n\n    /**\n     * If set to true the query will be wrapped into a transaction.\n     */\n    useTransaction(enabled: boolean): this {\n        this.expressionMap.useTransaction = enabled\n        return this\n    }\n\n    /**\n     * Adds CTE to query\n     */\n    addCommonTableExpression(\n        queryBuilder: QueryBuilder<any> | string,\n        alias: string,\n        options?: QueryBuilderCteOptions,\n    ): this {\n        this.expressionMap.commonTableExpressions.push({\n            queryBuilder,\n            alias,\n            options: options || {},\n        })\n        return this\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets escaped table name with schema name if SqlServer driver used with custom\n     * schema name, otherwise returns escaped table name.\n     */\n    protected getTableName(tablePath: string): string {\n        return tablePath\n            .split(\".\")\n            .map((i) => {\n                // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n                if (i === \"\") return i\n                return this.escape(i)\n            })\n            .join(\".\")\n    }\n\n    /**\n     * Gets name of the table where insert should be performed.\n     */\n    protected getMainTableName(): string {\n        if (!this.expressionMap.mainAlias)\n            throw new TypeORMError(\n                `Entity where values should be inserted is not specified. Call \"qb.into(entity)\" method to specify it.`,\n            )\n\n        if (this.expressionMap.mainAlias.hasMetadata)\n            return this.expressionMap.mainAlias.metadata.tablePath\n\n        return this.expressionMap.mainAlias.tablePath!\n    }\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    protected createFromAlias(\n        entityTarget:\n            | EntityTarget<any>\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        aliasName?: string,\n    ): Alias {\n        // if table has a metadata then find it to properly escape its properties\n        // const metadata = this.connection.entityMetadatas.find(metadata => metadata.tableName === tableName);\n        if (this.connection.hasMetadata(entityTarget)) {\n            const metadata = this.connection.getMetadata(entityTarget)\n\n            return this.expressionMap.createAlias({\n                type: \"from\",\n                name: aliasName,\n                metadata: this.connection.getMetadata(entityTarget),\n                tablePath: metadata.tablePath,\n            })\n        } else {\n            if (typeof entityTarget === \"string\") {\n                const isSubquery =\n                    entityTarget.substr(0, 1) === \"(\" &&\n                    entityTarget.substr(-1) === \")\"\n\n                return this.expressionMap.createAlias({\n                    type: \"from\",\n                    name: aliasName,\n                    tablePath: !isSubquery\n                        ? (entityTarget as string)\n                        : undefined,\n                    subQuery: isSubquery ? entityTarget : undefined,\n                })\n            }\n\n            const subQueryBuilder: SelectQueryBuilder<any> = (\n                entityTarget as any\n            )((this as any as SelectQueryBuilder<any>).subQuery())\n            this.setParameters(subQueryBuilder.getParameters())\n            const subquery = subQueryBuilder.getQuery()\n\n            return this.expressionMap.createAlias({\n                type: \"from\",\n                name: aliasName,\n                subQuery: subquery,\n            })\n        }\n    }\n\n    /**\n     * @deprecated this way of replace property names is too slow.\n     *  Instead, we'll replace property names at the end - once query is build.\n     */\n    protected replacePropertyNames(statement: string) {\n        return statement\n    }\n\n    /**\n     * Replaces all entity's propertyName to name in the given SQL string.\n     */\n    protected replacePropertyNamesForTheWholeQuery(statement: string) {\n        const replacements: { [key: string]: { [key: string]: string } } = {}\n\n        for (const alias of this.expressionMap.aliases) {\n            if (!alias.hasMetadata) continue\n            const replaceAliasNamePrefix =\n                this.expressionMap.aliasNamePrefixingEnabled && alias.name\n                    ? `${alias.name}.`\n                    : \"\"\n\n            if (!replacements[replaceAliasNamePrefix]) {\n                replacements[replaceAliasNamePrefix] = {}\n            }\n\n            // Insert & overwrite the replacements from least to most relevant in our replacements object.\n            // To do this we iterate and overwrite in the order of relevance.\n            // Least to Most Relevant:\n            // * Relation Property Path to first join column key\n            // * Relation Property Path + Column Path\n            // * Column Database Name\n            // * Column Property Name\n            // * Column Property Path\n\n            for (const relation of alias.metadata.relations) {\n                if (relation.joinColumns.length > 0)\n                    replacements[replaceAliasNamePrefix][\n                        relation.propertyPath\n                    ] = relation.joinColumns[0].databaseName\n            }\n\n            for (const relation of alias.metadata.relations) {\n                const allColumns = [\n                    ...relation.joinColumns,\n                    ...relation.inverseJoinColumns,\n                ]\n                for (const joinColumn of allColumns) {\n                    const propertyKey = `${relation.propertyPath}.${\n                        joinColumn.referencedColumn!.propertyPath\n                    }`\n                    replacements[replaceAliasNamePrefix][propertyKey] =\n                        joinColumn.databaseName\n                }\n            }\n\n            for (const column of alias.metadata.columns) {\n                replacements[replaceAliasNamePrefix][column.databaseName] =\n                    column.databaseName\n            }\n\n            for (const column of alias.metadata.columns) {\n                replacements[replaceAliasNamePrefix][column.propertyName] =\n                    column.databaseName\n            }\n\n            for (const column of alias.metadata.columns) {\n                replacements[replaceAliasNamePrefix][column.propertyPath] =\n                    column.databaseName\n            }\n        }\n\n        const replacementKeys = Object.keys(replacements)\n        const replaceAliasNamePrefixes = replacementKeys\n            .map((key) => escapeRegExp(key))\n            .join(\"|\")\n\n        if (replacementKeys.length > 0) {\n            statement = statement.replace(\n                new RegExp(\n                    // Avoid a lookbehind here since it's not well supported\n                    `([ =(]|^.{0})` + // any of ' =(' or start of line\n                        // followed by our prefix, e.g. 'tablename.' or ''\n                        `${\n                            replaceAliasNamePrefixes\n                                ? \"(\" + replaceAliasNamePrefixes + \")\"\n                                : \"\"\n                        }([^ =(),]+)` + // a possible property name: sequence of anything but ' =(),'\n                        // terminated by ' =),' or end of line\n                        `(?=[ =),]|.{0}$)`,\n                    \"gm\",\n                ),\n                (...matches) => {\n                    let match: string, pre: string, p: string\n                    if (replaceAliasNamePrefixes) {\n                        match = matches[0]\n                        pre = matches[1]\n                        p = matches[3]\n\n                        if (replacements[matches[2]][p]) {\n                            return `${pre}${this.escape(\n                                matches[2].substring(0, matches[2].length - 1),\n                            )}.${this.escape(replacements[matches[2]][p])}`\n                        }\n                    } else {\n                        match = matches[0]\n                        pre = matches[1]\n                        p = matches[2]\n\n                        if (replacements[\"\"][p]) {\n                            return `${pre}${this.escape(replacements[\"\"][p])}`\n                        }\n                    }\n                    return match\n                },\n            )\n        }\n\n        return statement\n    }\n\n    protected createComment(): string {\n        if (!this.expressionMap.comment) {\n            return \"\"\n        }\n\n        // ANSI SQL 2003 support C style comments - comments that start with `/*` and end with `*/`\n        // In some dialects query nesting is available - but not all.  Because of this, we'll need\n        // to scrub \"ending\" characters from the SQL but otherwise we can leave everything else\n        // as-is and it should be valid.\n\n        return `/* ${this.expressionMap.comment.replace(/\\*\\//g, \"\")} */ `\n    }\n\n    /**\n     * Time travel queries for CockroachDB\n     */\n    protected createTimeTravelQuery(): string {\n        if (\n            this.expressionMap.queryType === \"select\" &&\n            this.expressionMap.timeTravel\n        ) {\n            return ` AS OF SYSTEM TIME ${this.expressionMap.timeTravel}`\n        }\n\n        return \"\"\n    }\n\n    /**\n     * Creates \"WHERE\" expression.\n     */\n    protected createWhereExpression() {\n        const conditionsArray = []\n\n        const whereExpression = this.createWhereClausesExpression(\n            this.expressionMap.wheres,\n        )\n\n        if (whereExpression.length > 0 && whereExpression !== \"1=1\") {\n            conditionsArray.push(this.replacePropertyNames(whereExpression))\n        }\n\n        if (this.expressionMap.mainAlias!.hasMetadata) {\n            const metadata = this.expressionMap.mainAlias!.metadata\n            // Adds the global condition of \"non-deleted\" for the entity with delete date columns in select query.\n            if (\n                this.expressionMap.queryType === \"select\" &&\n                !this.expressionMap.withDeleted &&\n                metadata.deleteDateColumn\n            ) {\n                const column = this.expressionMap.aliasNamePrefixingEnabled\n                    ? this.expressionMap.mainAlias!.name +\n                      \".\" +\n                      metadata.deleteDateColumn.propertyName\n                    : metadata.deleteDateColumn.propertyName\n\n                const condition = `${this.replacePropertyNames(column)} IS NULL`\n                conditionsArray.push(condition)\n            }\n\n            if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {\n                const column = this.expressionMap.aliasNamePrefixingEnabled\n                    ? this.expressionMap.mainAlias!.name +\n                      \".\" +\n                      metadata.discriminatorColumn.databaseName\n                    : metadata.discriminatorColumn.databaseName\n\n                const condition = `${this.replacePropertyNames(\n                    column,\n                )} IN (:...discriminatorColumnValues)`\n                conditionsArray.push(condition)\n            }\n        }\n\n        if (this.expressionMap.extraAppendedAndWhereCondition) {\n            const condition = this.replacePropertyNames(\n                this.expressionMap.extraAppendedAndWhereCondition,\n            )\n            conditionsArray.push(condition)\n        }\n\n        let condition = \"\"\n\n        // time travel\n        condition += this.createTimeTravelQuery()\n\n        if (!conditionsArray.length) {\n            condition += \"\"\n        } else if (conditionsArray.length === 1) {\n            condition += ` WHERE ${conditionsArray[0]}`\n        } else {\n            condition += ` WHERE ( ${conditionsArray.join(\" ) AND ( \")} )`\n        }\n\n        return condition\n    }\n\n    /**\n     * Creates \"RETURNING\" / \"OUTPUT\" expression.\n     */\n    protected createReturningExpression(returningType: ReturningType): string {\n        const columns = this.getReturningColumns()\n        const driver = this.connection.driver\n\n        // also add columns we must auto-return to perform entity updation\n        // if user gave his own returning\n        if (\n            typeof this.expressionMap.returning !== \"string\" &&\n            this.expressionMap.extraReturningColumns.length > 0 &&\n            driver.isReturningSqlSupported(returningType)\n        ) {\n            columns.push(\n                ...this.expressionMap.extraReturningColumns.filter((column) => {\n                    return columns.indexOf(column) === -1\n                }),\n            )\n        }\n\n        if (columns.length) {\n            let columnsExpression = columns\n                .map((column) => {\n                    const name = this.escape(column.databaseName)\n                    if (driver.options.type === \"mssql\") {\n                        if (\n                            this.expressionMap.queryType === \"insert\" ||\n                            this.expressionMap.queryType === \"update\" ||\n                            this.expressionMap.queryType === \"soft-delete\" ||\n                            this.expressionMap.queryType === \"restore\"\n                        ) {\n                            return \"INSERTED.\" + name\n                        } else {\n                            return (\n                                this.escape(this.getMainTableName()) +\n                                \".\" +\n                                name\n                            )\n                        }\n                    } else {\n                        return name\n                    }\n                })\n                .join(\", \")\n\n            if (driver.options.type === \"oracle\") {\n                columnsExpression +=\n                    \" INTO \" +\n                    columns\n                        .map((column) => {\n                            return this.createParameter({\n                                type: (\n                                    driver as OracleDriver\n                                ).columnTypeToNativeParameter(column.type),\n                                dir: (driver as OracleDriver).oracle.BIND_OUT,\n                            })\n                        })\n                        .join(\", \")\n            }\n\n            if (driver.options.type === \"mssql\") {\n                if (\n                    this.expressionMap.queryType === \"insert\" ||\n                    this.expressionMap.queryType === \"update\"\n                ) {\n                    columnsExpression += \" INTO @OutputTable\"\n                }\n            }\n\n            return columnsExpression\n        } else if (typeof this.expressionMap.returning === \"string\") {\n            return this.expressionMap.returning\n        }\n\n        return \"\"\n    }\n\n    /**\n     * If returning / output cause is set to array of column names,\n     * then this method will return all column metadatas of those column names.\n     */\n    protected getReturningColumns(): ColumnMetadata[] {\n        const columns: ColumnMetadata[] = []\n        if (Array.isArray(this.expressionMap.returning)) {\n            ;(this.expressionMap.returning as string[]).forEach(\n                (columnName) => {\n                    if (this.expressionMap.mainAlias!.hasMetadata) {\n                        columns.push(\n                            ...this.expressionMap.mainAlias!.metadata.findColumnsWithPropertyPath(\n                                columnName,\n                            ),\n                        )\n                    }\n                },\n            )\n        }\n        return columns\n    }\n\n    protected createWhereClausesExpression(clauses: WhereClause[]): string {\n        return clauses\n            .map((clause, index) => {\n                const expression = this.createWhereConditionExpression(\n                    clause.condition,\n                )\n\n                switch (clause.type) {\n                    case \"and\":\n                        return (\n                            (index > 0 ? \"AND \" : \"\") +\n                            `${\n                                this.connection.options.isolateWhereStatements\n                                    ? \"(\"\n                                    : \"\"\n                            }${expression}${\n                                this.connection.options.isolateWhereStatements\n                                    ? \")\"\n                                    : \"\"\n                            }`\n                        )\n                    case \"or\":\n                        return (\n                            (index > 0 ? \"OR \" : \"\") +\n                            `${\n                                this.connection.options.isolateWhereStatements\n                                    ? \"(\"\n                                    : \"\"\n                            }${expression}${\n                                this.connection.options.isolateWhereStatements\n                                    ? \")\"\n                                    : \"\"\n                            }`\n                        )\n                }\n\n                return expression\n            })\n            .join(\" \")\n            .trim()\n    }\n\n    /**\n     * Computes given where argument - transforms to a where string all forms it can take.\n     */\n    protected createWhereConditionExpression(\n        condition: WhereClauseCondition,\n        alwaysWrap: boolean = false,\n    ): string {\n        if (typeof condition === \"string\") return condition\n\n        if (Array.isArray(condition)) {\n            if (condition.length === 0) {\n                return \"1=1\"\n            }\n\n            // In the future we should probably remove this entire condition\n            // but for now to prevent any breaking changes it exists.\n            if (condition.length === 1 && !alwaysWrap) {\n                return this.createWhereClausesExpression(condition)\n            }\n\n            return \"(\" + this.createWhereClausesExpression(condition) + \")\"\n        }\n\n        const { driver } = this.connection\n\n        switch (condition.operator) {\n            case \"lessThan\":\n                return `${condition.parameters[0]} < ${condition.parameters[1]}`\n            case \"lessThanOrEqual\":\n                return `${condition.parameters[0]} <= ${condition.parameters[1]}`\n            case \"arrayContains\":\n                return `${condition.parameters[0]} @> ${condition.parameters[1]}`\n            case \"jsonContains\":\n                return `${condition.parameters[0]} ::jsonb @> ${condition.parameters[1]}`\n            case \"arrayContainedBy\":\n                return `${condition.parameters[0]} <@ ${condition.parameters[1]}`\n            case \"arrayOverlap\":\n                return `${condition.parameters[0]} && ${condition.parameters[1]}`\n            case \"moreThan\":\n                return `${condition.parameters[0]} > ${condition.parameters[1]}`\n            case \"moreThanOrEqual\":\n                return `${condition.parameters[0]} >= ${condition.parameters[1]}`\n            case \"notEqual\":\n                return `${condition.parameters[0]} != ${condition.parameters[1]}`\n            case \"equal\":\n                return `${condition.parameters[0]} = ${condition.parameters[1]}`\n            case \"ilike\":\n                if (\n                    driver.options.type === \"postgres\" ||\n                    driver.options.type === \"cockroachdb\"\n                ) {\n                    return `${condition.parameters[0]} ILIKE ${condition.parameters[1]}`\n                }\n\n                return `UPPER(${condition.parameters[0]}) LIKE UPPER(${condition.parameters[1]})`\n            case \"like\":\n                return `${condition.parameters[0]} LIKE ${condition.parameters[1]}`\n            case \"between\":\n                return `${condition.parameters[0]} BETWEEN ${condition.parameters[1]} AND ${condition.parameters[2]}`\n            case \"in\":\n                if (condition.parameters.length <= 1) {\n                    return \"0=1\"\n                }\n                return `${condition.parameters[0]} IN (${condition.parameters\n                    .slice(1)\n                    .join(\", \")})`\n            case \"any\":\n                if (driver.options.type === \"cockroachdb\") {\n                    return `${condition.parameters[0]}::STRING = ANY(${condition.parameters[1]}::STRING[])`\n                }\n\n                return `${condition.parameters[0]} = ANY(${condition.parameters[1]})`\n            case \"isNull\":\n                return `${condition.parameters[0]} IS NULL`\n\n            case \"not\":\n                return `NOT(${this.createWhereConditionExpression(\n                    condition.condition,\n                )})`\n            case \"brackets\":\n                return `${this.createWhereConditionExpression(\n                    condition.condition,\n                    true,\n                )}`\n            case \"and\":\n                return \"(\" + condition.parameters.join(\" AND \") + \")\"\n            case \"or\":\n                return \"(\" + condition.parameters.join(\" OR \") + \")\"\n        }\n\n        throw new TypeError(\n            `Unsupported FindOperator ${FindOperator.constructor.name}`,\n        )\n    }\n\n    protected createCteExpression(): string {\n        if (!this.hasCommonTableExpressions()) {\n            return \"\"\n        }\n        const databaseRequireRecusiveHint =\n            this.connection.driver.cteCapabilities.requiresRecursiveHint\n\n        const cteStrings = this.expressionMap.commonTableExpressions.map(\n            (cte) => {\n                const cteBodyExpression =\n                    typeof cte.queryBuilder === \"string\"\n                        ? cte.queryBuilder\n                        : cte.queryBuilder.getQuery()\n                if (typeof cte.queryBuilder !== \"string\") {\n                    if (cte.queryBuilder.hasCommonTableExpressions()) {\n                        throw new TypeORMError(\n                            `Nested CTEs aren't supported (CTE: ${cte.alias})`,\n                        )\n                    }\n                    if (\n                        !this.connection.driver.cteCapabilities.writable &&\n                        !InstanceChecker.isSelectQueryBuilder(cte.queryBuilder)\n                    ) {\n                        throw new TypeORMError(\n                            `Only select queries are supported in CTEs in ${this.connection.options.type} (CTE: ${cte.alias})`,\n                        )\n                    }\n                    this.setParameters(cte.queryBuilder.getParameters())\n                }\n                let cteHeader = this.escape(cte.alias)\n                if (cte.options.columnNames) {\n                    const escapedColumnNames = cte.options.columnNames.map(\n                        (column) => this.escape(column),\n                    )\n                    if (\n                        InstanceChecker.isSelectQueryBuilder(cte.queryBuilder)\n                    ) {\n                        if (\n                            cte.queryBuilder.expressionMap.selects.length &&\n                            cte.options.columnNames.length !==\n                                cte.queryBuilder.expressionMap.selects.length\n                        ) {\n                            throw new TypeORMError(\n                                `cte.options.columnNames length (${cte.options.columnNames.length}) doesn't match subquery select list length ${cte.queryBuilder.expressionMap.selects.length} (CTE: ${cte.alias})`,\n                            )\n                        }\n                    }\n                    cteHeader += `(${escapedColumnNames.join(\", \")})`\n                }\n                const recursiveClause =\n                    cte.options.recursive && databaseRequireRecusiveHint\n                        ? \"RECURSIVE\"\n                        : \"\"\n                let materializeClause = \"\"\n                if (\n                    this.connection.driver.cteCapabilities.materializedHint &&\n                    cte.options.materialized !== undefined\n                ) {\n                    materializeClause = cte.options.materialized\n                        ? \"MATERIALIZED\"\n                        : \"NOT MATERIALIZED\"\n                }\n\n                return [\n                    recursiveClause,\n                    cteHeader,\n                    \"AS\",\n                    materializeClause,\n                    `(${cteBodyExpression})`,\n                ]\n                    .filter(Boolean)\n                    .join(\" \")\n            },\n        )\n\n        return \"WITH \" + cteStrings.join(\", \") + \" \"\n    }\n\n    /**\n     * Creates \"WHERE\" condition for an in-ids condition.\n     */\n    protected getWhereInIdsCondition(\n        ids: any | any[],\n    ): ObjectLiteral | Brackets {\n        const metadata = this.expressionMap.mainAlias!.metadata\n        const normalized = (Array.isArray(ids) ? ids : [ids]).map((id) =>\n            metadata.ensureEntityIdMap(id),\n        )\n\n        // using in(...ids) for single primary key entities\n        if (!metadata.hasMultiplePrimaryKeys) {\n            const primaryColumn = metadata.primaryColumns[0]\n\n            // getEntityValue will try to transform `In`, it is a bug\n            // todo: remove this transformer check after #2390 is fixed\n            // This also fails for embedded & relation, so until that is fixed skip it.\n            if (\n                !primaryColumn.transformer &&\n                !primaryColumn.relationMetadata &&\n                !primaryColumn.embeddedMetadata\n            ) {\n                return {\n                    [primaryColumn.propertyName]: In(\n                        normalized.map((id) =>\n                            primaryColumn.getEntityValue(id, false),\n                        ),\n                    ),\n                }\n            }\n        }\n\n        return new Brackets((qb) => {\n            for (const data of normalized) {\n                qb.orWhere(new Brackets((qb) => qb.where(data)))\n            }\n        })\n    }\n\n    protected getExistsCondition(subQuery: any): [string, any[]] {\n        const query = subQuery\n            .clone()\n            .orderBy()\n            .groupBy()\n            .offset(undefined)\n            .limit(undefined)\n            .skip(undefined)\n            .take(undefined)\n            .select(\"1\")\n            .setOption(\"disable-global-order\")\n\n        return [`EXISTS (${query.getQuery()})`, query.getParameters()]\n    }\n\n    private findColumnsForPropertyPath(\n        propertyPath: string,\n    ): [Alias, string[], ColumnMetadata[]] {\n        // Make a helper to iterate the entity & relations?\n        // Use that to set the correct alias?  Or the other way around?\n\n        // Start with the main alias with our property paths\n        let alias = this.expressionMap.mainAlias\n        const root: string[] = []\n        const propertyPathParts = propertyPath.split(\".\")\n\n        while (propertyPathParts.length > 1) {\n            const part = propertyPathParts[0]\n\n            if (!alias?.hasMetadata) {\n                // If there's no metadata, we're wasting our time\n                // and can't actually look any of this up.\n                break\n            }\n\n            if (alias.metadata.hasEmbeddedWithPropertyPath(part)) {\n                // If this is an embedded then we should combine the two as part of our lookup.\n                // Instead of just breaking, we keep going with this in case there's an embedded/relation\n                // inside an embedded.\n                propertyPathParts.unshift(\n                    `${propertyPathParts.shift()}.${propertyPathParts.shift()}`,\n                )\n                continue\n            }\n\n            if (alias.metadata.hasRelationWithPropertyPath(part)) {\n                // If this is a relation then we should find the aliases\n                // that match the relation & then continue further down\n                // the property path\n                const joinAttr = this.expressionMap.joinAttributes.find(\n                    (joinAttr) => joinAttr.relationPropertyPath === part,\n                )\n\n                if (!joinAttr?.alias) {\n                    const fullRelationPath =\n                        root.length > 0 ? `${root.join(\".\")}.${part}` : part\n                    throw new Error(\n                        `Cannot find alias for relation at ${fullRelationPath}`,\n                    )\n                }\n\n                alias = joinAttr.alias\n                root.push(...part.split(\".\"))\n                propertyPathParts.shift()\n                continue\n            }\n\n            break\n        }\n\n        if (!alias) {\n            throw new Error(`Cannot find alias for property ${propertyPath}`)\n        }\n\n        // Remaining parts are combined back and used to find the actual property path\n        const aliasPropertyPath = propertyPathParts.join(\".\")\n\n        const columns =\n            alias.metadata.findColumnsWithPropertyPath(aliasPropertyPath)\n\n        if (!columns.length) {\n            throw new EntityPropertyNotFoundError(propertyPath, alias.metadata)\n        }\n\n        return [alias, root, columns]\n    }\n\n    /**\n     * Creates a property paths for a given ObjectLiteral.\n     */\n    protected createPropertyPath(\n        metadata: EntityMetadata,\n        entity: ObjectLiteral,\n        prefix: string = \"\",\n    ) {\n        const paths: string[] = []\n\n        for (const key of Object.keys(entity)) {\n            const path = prefix ? `${prefix}.${key}` : key\n\n            // There's times where we don't actually want to traverse deeper.\n            // If the value is a `FindOperator`, or null, or not an object, then we don't, for example.\n            if (\n                entity[key] === null ||\n                typeof entity[key] !== \"object\" ||\n                InstanceChecker.isFindOperator(entity[key])\n            ) {\n                paths.push(path)\n                continue\n            }\n\n            if (metadata.hasEmbeddedWithPropertyPath(path)) {\n                const subPaths = this.createPropertyPath(\n                    metadata,\n                    entity[key],\n                    path,\n                )\n                paths.push(...subPaths)\n                continue\n            }\n\n            if (metadata.hasRelationWithPropertyPath(path)) {\n                const relation = metadata.findRelationWithPropertyPath(path)!\n\n                // There's also cases where we don't want to return back all of the properties.\n                // These handles the situation where someone passes the model & we don't need to make\n                // a HUGE `where` to uniquely look up the entity.\n\n                // In the case of a *-to-one, there's only ever one possible entity on the other side\n                // so if the join columns are all defined we can return just the relation itself\n                // because it will fetch only the join columns and do the lookup.\n                if (\n                    relation.relationType === \"one-to-one\" ||\n                    relation.relationType === \"many-to-one\"\n                ) {\n                    const joinColumns = relation.joinColumns\n                        .map((j) => j.referencedColumn)\n                        .filter((j): j is ColumnMetadata => !!j)\n\n                    const hasAllJoinColumns =\n                        joinColumns.length > 0 &&\n                        joinColumns.every((column) =>\n                            column.getEntityValue(entity[key], false),\n                        )\n\n                    if (hasAllJoinColumns) {\n                        paths.push(path)\n                        continue\n                    }\n                }\n\n                if (\n                    relation.relationType === \"one-to-many\" ||\n                    relation.relationType === \"many-to-many\"\n                ) {\n                    throw new Error(\n                        `Cannot query across ${relation.relationType} for property ${path}`,\n                    )\n                }\n\n                // For any other case, if the `entity[key]` contains all of the primary keys we can do a\n                // lookup via these.  We don't need to look up via any other values 'cause these are\n                // the unique primary keys.\n                // This handles the situation where someone passes the model & we don't need to make\n                // a HUGE where.\n                const primaryColumns =\n                    relation.inverseEntityMetadata.primaryColumns\n                const hasAllPrimaryKeys =\n                    primaryColumns.length > 0 &&\n                    primaryColumns.every((column) =>\n                        column.getEntityValue(entity[key], false),\n                    )\n\n                if (hasAllPrimaryKeys) {\n                    const subPaths = primaryColumns.map(\n                        (column) => `${path}.${column.propertyPath}`,\n                    )\n                    paths.push(...subPaths)\n                    continue\n                }\n\n                // If nothing else, just return every property that's being passed to us.\n                const subPaths = this.createPropertyPath(\n                    relation.inverseEntityMetadata,\n                    entity[key],\n                ).map((p) => `${path}.${p}`)\n                paths.push(...subPaths)\n                continue\n            }\n\n            paths.push(path)\n        }\n\n        return paths\n    }\n\n    protected *getPredicates(where: ObjectLiteral) {\n        if (this.expressionMap.mainAlias!.hasMetadata) {\n            const propertyPaths = this.createPropertyPath(\n                this.expressionMap.mainAlias!.metadata,\n                where,\n            )\n\n            for (const propertyPath of propertyPaths) {\n                const [alias, aliasPropertyPath, columns] =\n                    this.findColumnsForPropertyPath(propertyPath)\n\n                for (const column of columns) {\n                    let containedWhere = where\n\n                    for (const part of aliasPropertyPath) {\n                        if (!containedWhere || !(part in containedWhere)) {\n                            containedWhere = {}\n                            break\n                        }\n\n                        containedWhere = containedWhere[part]\n                    }\n\n                    // Use the correct alias & the property path from the column\n                    const aliasPath = this.expressionMap\n                        .aliasNamePrefixingEnabled\n                        ? `${alias.name}.${column.propertyPath}`\n                        : column.propertyPath\n\n                    const parameterValue = column.getEntityValue(\n                        containedWhere,\n                        true,\n                    )\n\n                    yield [aliasPath, parameterValue]\n                }\n            }\n        } else {\n            for (const key of Object.keys(where)) {\n                const parameterValue = where[key]\n                const aliasPath = this.expressionMap.aliasNamePrefixingEnabled\n                    ? `${this.alias}.${key}`\n                    : key\n\n                yield [aliasPath, parameterValue]\n            }\n        }\n    }\n\n    protected getWherePredicateCondition(\n        aliasPath: string,\n        parameterValue: any,\n    ): WhereClauseCondition {\n        if (InstanceChecker.isFindOperator(parameterValue)) {\n            let parameters: any[] = []\n            if (parameterValue.useParameter) {\n                if (parameterValue.objectLiteralParameters) {\n                    this.setParameters(parameterValue.objectLiteralParameters)\n                } else if (parameterValue.multipleParameters) {\n                    for (const v of parameterValue.value) {\n                        parameters.push(this.createParameter(v))\n                    }\n                } else {\n                    parameters.push(this.createParameter(parameterValue.value))\n                }\n            }\n\n            if (parameterValue.type === \"raw\") {\n                if (parameterValue.getSql) {\n                    return parameterValue.getSql(aliasPath)\n                } else {\n                    return {\n                        operator: \"equal\",\n                        parameters: [aliasPath, parameterValue.value],\n                    }\n                }\n            } else if (parameterValue.type === \"not\") {\n                if (parameterValue.child) {\n                    return {\n                        operator: parameterValue.type,\n                        condition: this.getWherePredicateCondition(\n                            aliasPath,\n                            parameterValue.child,\n                        ),\n                    }\n                } else {\n                    return {\n                        operator: \"notEqual\",\n                        parameters: [aliasPath, ...parameters],\n                    }\n                }\n            } else if (parameterValue.type === \"and\") {\n                const values: FindOperator<any>[] = parameterValue.value\n\n                return {\n                    operator: parameterValue.type,\n                    parameters: values.map((operator) =>\n                        this.createWhereConditionExpression(\n                            this.getWherePredicateCondition(\n                                aliasPath,\n                                operator,\n                            ),\n                        ),\n                    ),\n                }\n            } else if (parameterValue.type === \"or\") {\n                const values: FindOperator<any>[] = parameterValue.value\n\n                return {\n                    operator: parameterValue.type,\n                    parameters: values.map((operator) =>\n                        this.createWhereConditionExpression(\n                            this.getWherePredicateCondition(\n                                aliasPath,\n                                operator,\n                            ),\n                        ),\n                    ),\n                }\n            } else {\n                return {\n                    operator: parameterValue.type,\n                    parameters: [aliasPath, ...parameters],\n                }\n            }\n            // } else if (parameterValue === null) {\n            //     return {\n            //         operator: \"isNull\",\n            //         parameters: [\n            //             aliasPath,\n            //         ]\n            //     };\n        } else {\n            return {\n                operator: \"equal\",\n                parameters: [aliasPath, this.createParameter(parameterValue)],\n            }\n        }\n    }\n\n    protected getWhereCondition(\n        where:\n            | string\n            | ((qb: this) => string)\n            | Brackets\n            | NotBrackets\n            | ObjectLiteral\n            | ObjectLiteral[],\n    ): WhereClauseCondition {\n        if (typeof where === \"string\") {\n            return where\n        }\n\n        if (InstanceChecker.isBrackets(where)) {\n            const whereQueryBuilder = this.createQueryBuilder()\n\n            whereQueryBuilder.parentQueryBuilder = this\n\n            whereQueryBuilder.expressionMap.mainAlias =\n                this.expressionMap.mainAlias\n            whereQueryBuilder.expressionMap.aliasNamePrefixingEnabled =\n                this.expressionMap.aliasNamePrefixingEnabled\n            whereQueryBuilder.expressionMap.parameters =\n                this.expressionMap.parameters\n            whereQueryBuilder.expressionMap.nativeParameters =\n                this.expressionMap.nativeParameters\n\n            whereQueryBuilder.expressionMap.wheres = []\n\n            where.whereFactory(whereQueryBuilder as any)\n\n            return {\n                operator: InstanceChecker.isNotBrackets(where)\n                    ? \"not\"\n                    : \"brackets\",\n                condition: whereQueryBuilder.expressionMap.wheres,\n            }\n        }\n\n        if (typeof where === \"function\") {\n            return where(this)\n        }\n\n        const wheres: ObjectLiteral[] = Array.isArray(where) ? where : [where]\n        const clauses: WhereClause[] = []\n\n        for (const where of wheres) {\n            const conditions: WhereClauseCondition = []\n\n            // Filter the conditions and set up the parameter values\n            for (const [aliasPath, parameterValue] of this.getPredicates(\n                where,\n            )) {\n                conditions.push({\n                    type: \"and\",\n                    condition: this.getWherePredicateCondition(\n                        aliasPath,\n                        parameterValue,\n                    ),\n                })\n            }\n\n            clauses.push({ type: \"or\", condition: conditions })\n        }\n\n        if (clauses.length === 1) {\n            return clauses[0].condition\n        }\n\n        return clauses\n    }\n\n    /**\n     * Creates a query builder used to execute sql queries inside this query builder.\n     */\n    protected obtainQueryRunner() {\n        return this.queryRunner || this.connection.createQueryRunner()\n    }\n\n    protected hasCommonTableExpressions(): boolean {\n        return this.expressionMap.commonTableExpressions.length > 0\n    }\n}\n"],"mappings":"AAIA,SAASA,kBAAkB,QAAQ,sBAAsB;AASzD,SAASC,QAAQ,QAAQ,YAAY;AAIrC,SAASC,YAAY,QAAQ,8BAA8B;AAC3D,SAASC,EAAE,QAAQ,6BAA6B;AAChD,SAASC,YAAY,QAAQ,UAAU;AAGvC,SAASC,2BAA2B,QAAQ,sCAAsC;AAGlF,SAASC,eAAe,QAAQ,yBAAyB;AACzD,SAASC,YAAY,QAAQ,sBAAsB;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA,OAAM,MAAgBC,YAAY;EAuD9B;;;EAGAC,YACIC,wBAAwD,EACxDC,WAAyB;IA3DpB,mBAAa,GAAGC,MAAM,CAACC,GAAG,CAAC,cAAc,CAAC;IA8BnD;;;IAGQ,KAAAC,cAAc,GAAG,CAAC;IA4BtB,IAAIR,eAAe,CAACS,YAAY,CAACL,wBAAwB,CAAC,EAAE;MACxD,IAAI,CAACM,UAAU,GAAGN,wBAAwB;MAC1C,IAAI,CAACC,WAAW,GAAGA,WAAW;MAC9B,IAAI,CAACM,aAAa,GAAG,IAAIjB,kBAAkB,CAAC,IAAI,CAACgB,UAAU,CAAC;IAChE,CAAC,MAAM;MACH,IAAI,CAACA,UAAU,GAAGN,wBAAwB,CAACM,UAAU;MACrD,IAAI,CAACL,WAAW,GAAGD,wBAAwB,CAACC,WAAW;MACvD,IAAI,CAACM,aAAa,GAAGP,wBAAwB,CAACO,aAAa,CAACC,KAAK,EAAE;IACvE;EACJ;EAEA,OAAOC,yBAAyBA,CAACC,IAAY,EAAEC,OAAY;IACvDb,YAAY,CAACc,oBAAoB,CAACF,IAAI,CAAC,GAAGC,OAAO;EACrD;EAWA;EACA;EACA;EAEA;;;EAGA,IAAIE,KAAKA,CAAA;IACL,IAAI,CAAC,IAAI,CAACN,aAAa,CAACO,SAAS,EAC7B,MAAM,IAAIpB,YAAY,CAAC,uBAAuB,CAAC,EAAC;IAEpD,OAAO,IAAI,CAACa,aAAa,CAACO,SAAS,CAACJ,IAAI;EAC5C;EA2BA;;;;EAIAK,MAAMA,CACFC,SAA6B,EAC7BC,kBAA2B;IAE3B,IAAI,CAACV,aAAa,CAACW,SAAS,GAAG,QAAQ;IACvC,IAAIC,KAAK,CAACC,OAAO,CAACJ,SAAS,CAAC,EAAE;MAC1B,IAAI,CAACT,aAAa,CAACc,OAAO,GAAGL,SAAS,CAACM,GAAG,CAAEN,SAAS,KAAM;QACvDA,SAAS,EAAEA;OACd,CAAC,CAAC;IACP,CAAC,MAAM,IAAIA,SAAS,EAAE;MAClB,IAAI,CAACT,aAAa,CAACc,OAAO,GAAG,CACzB;QAAEL,SAAS,EAAEA,SAAS;QAAEO,SAAS,EAAEN;MAAkB,CAAE,CAC1D;IACL;IAEA,IAAIrB,eAAe,CAAC4B,oBAAoB,CAAC,IAAI,CAAC,EAAE,OAAO,IAAW;IAElE,OAAO1B,YAAY,CAACc,oBAAoB,CAAC,oBAAoB,CAAC,CAAC,IAAI,CAAC;EACxE;EAEA;;;EAGAa,MAAMA,CAAA;IACF,IAAI,CAAClB,aAAa,CAACW,SAAS,GAAG,QAAQ;IAEvC,IAAItB,eAAe,CAAC8B,oBAAoB,CAAC,IAAI,CAAC,EAAE,OAAO,IAAW;IAElE,OAAO5B,YAAY,CAACc,oBAAoB,CAAC,oBAAoB,CAAC,CAAC,IAAI,CAAC;EACxE;EA8BA;;;EAGAe,MAAMA,CACFC,0BAA8D,EAC9DC,cAA8B;IAE9B,MAAMC,SAAS,GAAGD,cAAc,GAC1BA,cAAc,GACbD,0BAAwD;IAC/DA,0BAA0B,GAAGhC,eAAe,CAACmC,cAAc,CACvDH,0BAA0B,CAC7B,GACKA,0BAA0B,CAACI,OAAO,CAACtB,IAAI,GACvCkB,0BAA0B;IAEhC,IACI,OAAOA,0BAA0B,KAAK,UAAU,IAChD,OAAOA,0BAA0B,KAAK,QAAQ,EAChD;MACE,MAAMd,SAAS,GAAG,IAAI,CAACmB,eAAe,CAACL,0BAA0B,CAAC;MAClE,IAAI,CAACrB,aAAa,CAAC2B,YAAY,CAACpB,SAAS,CAAC;IAC9C;IAEA,IAAI,CAACP,aAAa,CAACW,SAAS,GAAG,QAAQ;IACvC,IAAI,CAACX,aAAa,CAAC4B,SAAS,GAAGL,SAAS;IAExC,IAAIlC,eAAe,CAACwC,oBAAoB,CAAC,IAAI,CAAC,EAAE,OAAO,IAAW;IAElE,OAAOtC,YAAY,CAACc,oBAAoB,CAAC,oBAAoB,CAAC,CAAC,IAAI,CAAC;EACxE;EAEA;;;EAGAyB,MAAMA,CAAA;IACF,IAAI,CAAC9B,aAAa,CAACW,SAAS,GAAG,QAAQ;IAEvC,IAAItB,eAAe,CAAC0C,oBAAoB,CAAC,IAAI,CAAC,EAAE,OAAO,IAAW;IAElE,OAAOxC,YAAY,CAACc,oBAAoB,CAAC,oBAAoB,CAAC,CAAC,IAAI,CAAC;EACxE;EAEA2B,UAAUA,CAAA;IACN,IAAI,CAAChC,aAAa,CAACW,SAAS,GAAG,aAAa;IAE5C,IAAItB,eAAe,CAAC4C,wBAAwB,CAAC,IAAI,CAAC,EAAE,OAAO,IAAW;IAEtE,OAAO1C,YAAY,CAACc,oBAAoB,CAAC,wBAAwB,CAAC,CAAC,IAAI,CAAC;EAC5E;EAEA6B,OAAOA,CAAA;IACH,IAAI,CAAClC,aAAa,CAACW,SAAS,GAAG,SAAS;IAExC,IAAItB,eAAe,CAAC4C,wBAAwB,CAAC,IAAI,CAAC,EAAE,OAAO,IAAW;IAEtE,OAAO1C,YAAY,CAACc,oBAAoB,CAAC,wBAAwB,CAAC,CAAC,IAAI,CAAC;EAC5E;EAeA;;;EAGA8B,QAAQA,CACJC,0BAA6C,EAC7CC,iBAA0B;IAE1B,MAAMC,YAAY,GACdC,SAAS,CAACC,MAAM,KAAK,CAAC,GAAGJ,0BAA0B,GAAGK,SAAS;IACnE,MAAMC,YAAY,GACdH,SAAS,CAACC,MAAM,KAAK,CAAC,GACfH,iBAA4B,GAC5BD,0BAAqC;IAEhD,IAAI,CAACpC,aAAa,CAACW,SAAS,GAAG,UAAU;IACzC,IAAI,CAACX,aAAa,CAAC2C,oBAAoB,GAAGD,YAAY;IAEtD,IAAIJ,YAAY,EAAE;MACd,MAAM/B,SAAS,GAAG,IAAI,CAACmB,eAAe,CAACY,YAAY,CAAC;MACpD,IAAI,CAACtC,aAAa,CAAC2B,YAAY,CAACpB,SAAS,CAAC;IAC9C;IAEA,IAAIlB,eAAe,CAACuD,sBAAsB,CAAC,IAAI,CAAC,EAAE,OAAO,IAAW;IAEpE,OAAOrD,YAAY,CAACc,oBAAoB,CAAC,sBAAsB,CAAC,CAAC,IAAI,CAAC;EAC1E;EAkBA;;;;;;EAMAwC,WAAWA,CACPC,MAAuB,EACvBX,QAA2B;IAE3B,MAAMY,cAAc,GAAG,IAAI,CAAChD,UAAU,CAACiD,WAAW,CAACF,MAAM,CAAC;IAC1D,MAAMG,SAAS,GAAGrC,KAAK,CAACC,OAAO,CAACsB,QAAQ,CAAC,GAAGA,QAAQ,GAAG,CAACA,QAAQ,CAAC;IACjE,OAAOc,SAAS,CAACC,KAAK,CAAEf,QAAQ,IAAI;MAChC,OAAO,CAAC,CAACY,cAAc,CAACI,4BAA4B,CAAChB,QAAQ,CAAC;IAClE,CAAC,CAAC;EACN;EAEA;;;EAGAiB,YAAYA,CAACC,GAAW;IACpB,OACI,IAAI,CAACC,kBAAkB,EAAEF,YAAY,CAACC,GAAG,CAAC,IAC1CA,GAAG,IAAI,IAAI,CAACrD,aAAa,CAACuD,UAAU;EAE5C;EAEA;;;;;EAKAC,YAAYA,CAACH,GAAW,EAAEI,KAAU;IAChC,IAAI,OAAOA,KAAK,KAAK,UAAU,EAAE;MAC7B,MAAM,IAAItE,YAAY,CAClB,uEAAuEkE,GAAG,cAAc,CAC3F;IACL;IAEA,IAAI,CAACA,GAAG,CAACK,KAAK,CAAC,oBAAoB,CAAC,EAAE;MAClC,MAAM,IAAIvE,YAAY,CAClB,yFAAyF,CAC5F;IACL;IAEA,IAAI,IAAI,CAACmE,kBAAkB,EAAE;MACzB,IAAI,CAACA,kBAAkB,CAACE,YAAY,CAACH,GAAG,EAAEI,KAAK,CAAC;IACpD;IAEA,IAAI,CAACzD,aAAa,CAACuD,UAAU,CAACF,GAAG,CAAC,GAAGI,KAAK;IAC1C,OAAO,IAAI;EACf;EAEA;;;EAGAE,aAAaA,CAACJ,UAAyB;IACnC,KAAK,MAAM,CAACF,GAAG,EAAEI,KAAK,CAAC,IAAIG,MAAM,CAACC,OAAO,CAACN,UAAU,CAAC,EAAE;MACnD,IAAI,CAACC,YAAY,CAACH,GAAG,EAAEI,KAAK,CAAC;IACjC;IAEA,OAAO,IAAI;EACf;EAEUK,eAAeA,CAACL,KAAU;IAChC,IAAIM,aAAa;IAEjB,GAAG;MACCA,aAAa,GAAG,aAAa,IAAI,CAAClE,cAAc,EAAE,EAAE;IACxD,CAAC,QAAQ,IAAI,CAACuD,YAAY,CAACW,aAAa,CAAC;IAEzC,IAAI,CAACP,YAAY,CAACO,aAAa,EAAEN,KAAK,CAAC;IAEvC,OAAO,IAAIM,aAAa,EAAE;EAC9B;EAEA;;;;;EAKAC,mBAAmBA,CAACT,UAAyB;IACzC;IACA,IAAI,IAAI,CAACD,kBAAkB,EAAE;MACzB,IAAI,CAACA,kBAAkB,CAACU,mBAAmB,CAACT,UAAU,CAAC;IAC3D;IAEAK,MAAM,CAACK,IAAI,CAACV,UAAU,CAAC,CAACW,OAAO,CAAEb,GAAG,IAAI;MACpC,IAAI,CAACrD,aAAa,CAACmE,gBAAgB,CAACd,GAAG,CAAC,GAAGE,UAAU,CAACF,GAAG,CAAC;IAC9D,CAAC,CAAC;IACF,OAAO,IAAI;EACf;EAEA;;;EAGAe,aAAaA,CAAA;IACT,MAAMb,UAAU,GAAkBK,MAAM,CAACS,MAAM,CAC3C,EAAE,EACF,IAAI,CAACrE,aAAa,CAACuD,UAAU,CAChC;IAED;IACA,IACI,IAAI,CAACvD,aAAa,CAACO,SAAS,IAC5B,IAAI,CAACP,aAAa,CAACO,SAAS,CAAC+D,WAAW,EAC1C;MACE,MAAMC,QAAQ,GAAG,IAAI,CAACvE,aAAa,CAACO,SAAU,CAACgE,QAAQ;MACvD,IAAIA,QAAQ,CAACC,mBAAmB,IAAID,QAAQ,CAACE,oBAAoB,EAAE;QAC/D,MAAMC,MAAM,GAAGH,QAAQ,CAACI,oBAAoB,CACvCC,MAAM,CACFC,aAAa,IAAKA,aAAa,CAACL,mBAAmB,CACvD,CACAzD,GAAG,CAAE8D,aAAa,IAAKA,aAAa,CAACC,kBAAkB,CAAC;QAC7DJ,MAAM,CAACK,IAAI,CAACR,QAAQ,CAACO,kBAAkB,CAAC;QACxCvB,UAAU,CAAC,2BAA2B,CAAC,GAAGmB,MAAM;MACpD;IACJ;IAEA,OAAOnB,UAAU;EACrB;EAEA;;;EAGAyB,QAAQA,CAAA;IACJ;IACA,MAAM,CAACC,KAAK,EAAE1B,UAAU,CAAC,GAAG,IAAI,CAAC2B,qBAAqB,EAAE;IACxD,IAAI,CAACnF,UAAU,CAACoF,MAAM,CAACC,QAAQ,CAACH,KAAK,EAAE1B,UAAU,CAAC;IAClD,OAAO,IAAI;EACf;EAEA;;;;EAIA8B,MAAMA,CAAA;IACF,OAAO,IAAI,CAACH,qBAAqB,EAAE,CAAC,CAAC,CAAC;EAC1C;EAEA;;;EAGAA,qBAAqBA,CAAA;IACjB;IACA,MAAMD,KAAK,GAAG,IAAI,CAACK,QAAQ,EAAE;IAC7B,MAAM/B,UAAU,GAAG,IAAI,CAACa,aAAa,EAAE;IACvC,OAAO,IAAI,CAACrE,UAAU,CAACwF,MAAM,CAACC,yBAAyB,CACnDP,KAAK,EACL1B,UAAU,EACV,IAAI,CAACvD,aAAa,CAACmE,gBAAgB,CACtC;EACL;EAEA;;;EAGA,MAAMsB,OAAOA,CAAA;IACT,MAAM,CAACC,GAAG,EAAEnC,UAAU,CAAC,GAAG,IAAI,CAAC2B,qBAAqB,EAAE;IACtD,MAAMxF,WAAW,GAAG,IAAI,CAACiG,iBAAiB,EAAE;IAC5C,IAAI;MACA,OAAO,MAAMjG,WAAW,CAACuF,KAAK,CAACS,GAAG,EAAEnC,UAAU,CAAC,EAAC;IACpD,CAAC,SAAS;MACN,IAAI7D,WAAW,KAAK,IAAI,CAACA,WAAW,EAAE;QAClC;QACA,MAAMA,WAAW,CAACkG,OAAO,EAAE;MAC/B;IACJ;EACJ;EAEA;;;;EAIAC,kBAAkBA,CAACnG,WAAyB;IACxC,OAAO,IAAK,IAAI,CAACF,WAAmB,CAAC,IAAI,CAACO,UAAU,EAAEL,WAAW,IAAI,IAAI,CAACA,WAAW,CAAC;EAC1F;EAEA;;;;;;EAMAO,KAAKA,CAAA;IACD,OAAO,IAAK,IAAI,CAACT,WAAmB,CAAC,IAAI,CAAC;EAC9C;EAEA;;;;;EAKAsG,OAAOA,CAACA,OAAe;IACnB,IAAI,CAAC9F,aAAa,CAAC8F,OAAO,GAAGA,OAAO;IACpC,OAAO,IAAI;EACf;EAEA;;;EAGAC,eAAeA,CAAA;IACX,IAAI,CAAC/F,aAAa,CAAC+F,eAAe,GAAG,KAAK;IAC1C,OAAO,IAAI;EACf;EAEA;;;EAGAC,MAAMA,CAAC7F,IAAY;IACf,IAAI,CAAC,IAAI,CAACH,aAAa,CAAC+F,eAAe,EAAE,OAAO5F,IAAI;IACpD,OAAO,IAAI,CAACJ,UAAU,CAACwF,MAAM,CAACS,MAAM,CAAC7F,IAAI,CAAC;EAC9C;EAEA;;;EAGA8F,cAAcA,CAACvG,WAAwB;IACnC,IAAI,CAACA,WAAW,GAAGA,WAAW;IAC9B,OAAO,IAAI;EACf;EAEA;;;;EAIAwG,aAAaA,CAACC,OAAgB;IAC1B,IAAI,CAACnG,aAAa,CAACkG,aAAa,GAAGC,OAAO;IAC1C,OAAO,IAAI;EACf;EAEA;;;EAGAC,cAAcA,CAACD,OAAgB;IAC3B,IAAI,CAACnG,aAAa,CAACoG,cAAc,GAAGD,OAAO;IAC3C,OAAO,IAAI;EACf;EAEA;;;EAGAE,wBAAwBA,CACpBC,YAAwC,EACxChG,KAAa,EACbmB,OAAgC;IAEhC,IAAI,CAACzB,aAAa,CAACuG,sBAAsB,CAACxB,IAAI,CAAC;MAC3CuB,YAAY;MACZhG,KAAK;MACLmB,OAAO,EAAEA,OAAO,IAAI;KACvB,CAAC;IACF,OAAO,IAAI;EACf;EAEA;EACA;EACA;EAEA;;;;EAIU+E,YAAYA,CAACC,SAAiB;IACpC,OAAOA,SAAS,CACXC,KAAK,CAAC,GAAG,CAAC,CACV3F,GAAG,CAAE4F,CAAC,IAAI;MACP;MACA,IAAIA,CAAC,KAAK,EAAE,EAAE,OAAOA,CAAC;MACtB,OAAO,IAAI,CAACX,MAAM,CAACW,CAAC,CAAC;IACzB,CAAC,CAAC,CACDC,IAAI,CAAC,GAAG,CAAC;EAClB;EAEA;;;EAGUC,gBAAgBA,CAAA;IACtB,IAAI,CAAC,IAAI,CAAC7G,aAAa,CAACO,SAAS,EAC7B,MAAM,IAAIpB,YAAY,CAClB,uGAAuG,CAC1G;IAEL,IAAI,IAAI,CAACa,aAAa,CAACO,SAAS,CAAC+D,WAAW,EACxC,OAAO,IAAI,CAACtE,aAAa,CAACO,SAAS,CAACgE,QAAQ,CAACkC,SAAS;IAE1D,OAAO,IAAI,CAACzG,aAAa,CAACO,SAAS,CAACkG,SAAU;EAClD;EAEA;;;;EAIU/E,eAAeA,CACrBY,YAEgE,EAChEtB,SAAkB;IAElB;IACA;IACA,IAAI,IAAI,CAACjB,UAAU,CAACuE,WAAW,CAAChC,YAAY,CAAC,EAAE;MAC3C,MAAMiC,QAAQ,GAAG,IAAI,CAACxE,UAAU,CAACiD,WAAW,CAACV,YAAY,CAAC;MAE1D,OAAO,IAAI,CAACtC,aAAa,CAAC8G,WAAW,CAAC;QAClCC,IAAI,EAAE,MAAM;QACZ5G,IAAI,EAAEa,SAAS;QACfuD,QAAQ,EAAE,IAAI,CAACxE,UAAU,CAACiD,WAAW,CAACV,YAAY,CAAC;QACnDmE,SAAS,EAAElC,QAAQ,CAACkC;OACvB,CAAC;IACN,CAAC,MAAM;MACH,IAAI,OAAOnE,YAAY,KAAK,QAAQ,EAAE;QAClC,MAAM0E,UAAU,GACZ1E,YAAY,CAAC2E,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,GAAG,IACjC3E,YAAY,CAAC2E,MAAM,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG;QAEnC,OAAO,IAAI,CAACjH,aAAa,CAAC8G,WAAW,CAAC;UAClCC,IAAI,EAAE,MAAM;UACZ5G,IAAI,EAAEa,SAAS;UACfyF,SAAS,EAAE,CAACO,UAAU,GACf1E,YAAuB,GACxBG,SAAS;UACfyE,QAAQ,EAAEF,UAAU,GAAG1E,YAAY,GAAGG;SACzC,CAAC;MACN;MAEA,MAAM0E,eAAe,GACjB7E,YACH,CAAE,IAAuC,CAAC4E,QAAQ,EAAE,CAAC;MACtD,IAAI,CAACvD,aAAa,CAACwD,eAAe,CAAC/C,aAAa,EAAE,CAAC;MACnD,MAAMgD,QAAQ,GAAGD,eAAe,CAAC7B,QAAQ,EAAE;MAE3C,OAAO,IAAI,CAACtF,aAAa,CAAC8G,WAAW,CAAC;QAClCC,IAAI,EAAE,MAAM;QACZ5G,IAAI,EAAEa,SAAS;QACfkG,QAAQ,EAAEE;OACb,CAAC;IACN;EACJ;EAEA;;;;EAIUC,oBAAoBA,CAACC,SAAiB;IAC5C,OAAOA,SAAS;EACpB;EAEA;;;EAGUC,oCAAoCA,CAACD,SAAiB;IAC5D,MAAME,YAAY,GAAiD,EAAE;IAErE,KAAK,MAAMlH,KAAK,IAAI,IAAI,CAACN,aAAa,CAACyH,OAAO,EAAE;MAC5C,IAAI,CAACnH,KAAK,CAACgE,WAAW,EAAE;MACxB,MAAMoD,sBAAsB,GACxB,IAAI,CAAC1H,aAAa,CAAC2H,yBAAyB,IAAIrH,KAAK,CAACH,IAAI,GACpD,GAAGG,KAAK,CAACH,IAAI,GAAG,GAChB,EAAE;MAEZ,IAAI,CAACqH,YAAY,CAACE,sBAAsB,CAAC,EAAE;QACvCF,YAAY,CAACE,sBAAsB,CAAC,GAAG,EAAE;MAC7C;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA,KAAK,MAAMvF,QAAQ,IAAI7B,KAAK,CAACiE,QAAQ,CAACtB,SAAS,EAAE;QAC7C,IAAId,QAAQ,CAACyF,WAAW,CAACpF,MAAM,GAAG,CAAC,EAC/BgF,YAAY,CAACE,sBAAsB,CAAC,CAChCvF,QAAQ,CAACO,YAAY,CACxB,GAAGP,QAAQ,CAACyF,WAAW,CAAC,CAAC,CAAC,CAACC,YAAY;MAChD;MAEA,KAAK,MAAM1F,QAAQ,IAAI7B,KAAK,CAACiE,QAAQ,CAACtB,SAAS,EAAE;QAC7C,MAAM6E,UAAU,GAAG,CACf,GAAG3F,QAAQ,CAACyF,WAAW,EACvB,GAAGzF,QAAQ,CAAC4F,kBAAkB,CACjC;QACD,KAAK,MAAMC,UAAU,IAAIF,UAAU,EAAE;UACjC,MAAMG,WAAW,GAAG,GAAG9F,QAAQ,CAACO,YAAY,IACxCsF,UAAU,CAACE,gBAAiB,CAACxF,YACjC,EAAE;UACF8E,YAAY,CAACE,sBAAsB,CAAC,CAACO,WAAW,CAAC,GAC7CD,UAAU,CAACH,YAAY;QAC/B;MACJ;MAEA,KAAK,MAAMM,MAAM,IAAI7H,KAAK,CAACiE,QAAQ,CAAC6D,OAAO,EAAE;QACzCZ,YAAY,CAACE,sBAAsB,CAAC,CAACS,MAAM,CAACN,YAAY,CAAC,GACrDM,MAAM,CAACN,YAAY;MAC3B;MAEA,KAAK,MAAMM,MAAM,IAAI7H,KAAK,CAACiE,QAAQ,CAAC6D,OAAO,EAAE;QACzCZ,YAAY,CAACE,sBAAsB,CAAC,CAACS,MAAM,CAACE,YAAY,CAAC,GACrDF,MAAM,CAACN,YAAY;MAC3B;MAEA,KAAK,MAAMM,MAAM,IAAI7H,KAAK,CAACiE,QAAQ,CAAC6D,OAAO,EAAE;QACzCZ,YAAY,CAACE,sBAAsB,CAAC,CAACS,MAAM,CAACzF,YAAY,CAAC,GACrDyF,MAAM,CAACN,YAAY;MAC3B;IACJ;IAEA,MAAMS,eAAe,GAAG1E,MAAM,CAACK,IAAI,CAACuD,YAAY,CAAC;IACjD,MAAMe,wBAAwB,GAAGD,eAAe,CAC3CvH,GAAG,CAAEsC,GAAG,IAAK/D,YAAY,CAAC+D,GAAG,CAAC,CAAC,CAC/BuD,IAAI,CAAC,GAAG,CAAC;IAEd,IAAI0B,eAAe,CAAC9F,MAAM,GAAG,CAAC,EAAE;MAC5B8E,SAAS,GAAGA,SAAS,CAACkB,OAAO,CACzB,IAAIC,MAAM;MACN;MACA,eAAe;MAAG;MACd;MACA,GACIF,wBAAwB,GAClB,GAAG,GAAGA,wBAAwB,GAAG,GAAG,GACpC,EACV,aAAa;MAAG;MAChB;MACA,kBAAkB,EACtB,IAAI,CACP,EACD,CAAC,GAAGG,OAAO,KAAI;QACX,IAAIhF,KAAa,EAAEiF,GAAW,EAAEC,CAAS;QACzC,IAAIL,wBAAwB,EAAE;UAC1B7E,KAAK,GAAGgF,OAAO,CAAC,CAAC,CAAC;UAClBC,GAAG,GAAGD,OAAO,CAAC,CAAC,CAAC;UAChBE,CAAC,GAAGF,OAAO,CAAC,CAAC,CAAC;UAEd,IAAIlB,YAAY,CAACkB,OAAO,CAAC,CAAC,CAAC,CAAC,CAACE,CAAC,CAAC,EAAE;YAC7B,OAAO,GAAGD,GAAG,GAAG,IAAI,CAAC3C,MAAM,CACvB0C,OAAO,CAAC,CAAC,CAAC,CAACG,SAAS,CAAC,CAAC,EAAEH,OAAO,CAAC,CAAC,CAAC,CAAClG,MAAM,GAAG,CAAC,CAAC,CACjD,IAAI,IAAI,CAACwD,MAAM,CAACwB,YAAY,CAACkB,OAAO,CAAC,CAAC,CAAC,CAAC,CAACE,CAAC,CAAC,CAAC,EAAE;UACnD;QACJ,CAAC,MAAM;UACHlF,KAAK,GAAGgF,OAAO,CAAC,CAAC,CAAC;UAClBC,GAAG,GAAGD,OAAO,CAAC,CAAC,CAAC;UAChBE,CAAC,GAAGF,OAAO,CAAC,CAAC,CAAC;UAEd,IAAIlB,YAAY,CAAC,EAAE,CAAC,CAACoB,CAAC,CAAC,EAAE;YACrB,OAAO,GAAGD,GAAG,GAAG,IAAI,CAAC3C,MAAM,CAACwB,YAAY,CAAC,EAAE,CAAC,CAACoB,CAAC,CAAC,CAAC,EAAE;UACtD;QACJ;QACA,OAAOlF,KAAK;MAChB,CAAC,CACJ;IACL;IAEA,OAAO4D,SAAS;EACpB;EAEUwB,aAAaA,CAAA;IACnB,IAAI,CAAC,IAAI,CAAC9I,aAAa,CAAC8F,OAAO,EAAE;MAC7B,OAAO,EAAE;IACb;IAEA;IACA;IACA;IACA;IAEA,OAAO,MAAM,IAAI,CAAC9F,aAAa,CAAC8F,OAAO,CAAC0C,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,MAAM;EACtE;EAEA;;;EAGUO,qBAAqBA,CAAA;IAC3B,IACI,IAAI,CAAC/I,aAAa,CAACW,SAAS,KAAK,QAAQ,IACzC,IAAI,CAACX,aAAa,CAACgJ,UAAU,EAC/B;MACE,OAAO,sBAAsB,IAAI,CAAChJ,aAAa,CAACgJ,UAAU,EAAE;IAChE;IAEA,OAAO,EAAE;EACb;EAEA;;;EAGUC,qBAAqBA,CAAA;IAC3B,MAAMC,eAAe,GAAG,EAAE;IAE1B,MAAMC,eAAe,GAAG,IAAI,CAACC,4BAA4B,CACrD,IAAI,CAACpJ,aAAa,CAACqJ,MAAM,CAC5B;IAED,IAAIF,eAAe,CAAC3G,MAAM,GAAG,CAAC,IAAI2G,eAAe,KAAK,KAAK,EAAE;MACzDD,eAAe,CAACnE,IAAI,CAAC,IAAI,CAACsC,oBAAoB,CAAC8B,eAAe,CAAC,CAAC;IACpE;IAEA,IAAI,IAAI,CAACnJ,aAAa,CAACO,SAAU,CAAC+D,WAAW,EAAE;MAC3C,MAAMC,QAAQ,GAAG,IAAI,CAACvE,aAAa,CAACO,SAAU,CAACgE,QAAQ;MACvD;MACA,IACI,IAAI,CAACvE,aAAa,CAACW,SAAS,KAAK,QAAQ,IACzC,CAAC,IAAI,CAACX,aAAa,CAACsJ,WAAW,IAC/B/E,QAAQ,CAACgF,gBAAgB,EAC3B;QACE,MAAMpB,MAAM,GAAG,IAAI,CAACnI,aAAa,CAAC2H,yBAAyB,GACrD,IAAI,CAAC3H,aAAa,CAACO,SAAU,CAACJ,IAAI,GAClC,GAAG,GACHoE,QAAQ,CAACgF,gBAAgB,CAAClB,YAAY,GACtC9D,QAAQ,CAACgF,gBAAgB,CAAClB,YAAY;QAE5C,MAAMmB,SAAS,GAAG,GAAG,IAAI,CAACnC,oBAAoB,CAACc,MAAM,CAAC,UAAU;QAChEe,eAAe,CAACnE,IAAI,CAACyE,SAAS,CAAC;MACnC;MAEA,IAAIjF,QAAQ,CAACC,mBAAmB,IAAID,QAAQ,CAACE,oBAAoB,EAAE;QAC/D,MAAM0D,MAAM,GAAG,IAAI,CAACnI,aAAa,CAAC2H,yBAAyB,GACrD,IAAI,CAAC3H,aAAa,CAACO,SAAU,CAACJ,IAAI,GAClC,GAAG,GACHoE,QAAQ,CAACC,mBAAmB,CAACqD,YAAY,GACzCtD,QAAQ,CAACC,mBAAmB,CAACqD,YAAY;QAE/C,MAAM2B,SAAS,GAAG,GAAG,IAAI,CAACnC,oBAAoB,CAC1Cc,MAAM,CACT,qCAAqC;QACtCe,eAAe,CAACnE,IAAI,CAACyE,SAAS,CAAC;MACnC;IACJ;IAEA,IAAI,IAAI,CAACxJ,aAAa,CAACyJ,8BAA8B,EAAE;MACnD,MAAMD,SAAS,GAAG,IAAI,CAACnC,oBAAoB,CACvC,IAAI,CAACrH,aAAa,CAACyJ,8BAA8B,CACpD;MACDP,eAAe,CAACnE,IAAI,CAACyE,SAAS,CAAC;IACnC;IAEA,IAAIA,SAAS,GAAG,EAAE;IAElB;IACAA,SAAS,IAAI,IAAI,CAACT,qBAAqB,EAAE;IAEzC,IAAI,CAACG,eAAe,CAAC1G,MAAM,EAAE;MACzBgH,SAAS,IAAI,EAAE;IACnB,CAAC,MAAM,IAAIN,eAAe,CAAC1G,MAAM,KAAK,CAAC,EAAE;MACrCgH,SAAS,IAAI,UAAUN,eAAe,CAAC,CAAC,CAAC,EAAE;IAC/C,CAAC,MAAM;MACHM,SAAS,IAAI,YAAYN,eAAe,CAACtC,IAAI,CAAC,WAAW,CAAC,IAAI;IAClE;IAEA,OAAO4C,SAAS;EACpB;EAEA;;;EAGUE,yBAAyBA,CAACC,aAA4B;IAC5D,MAAMvB,OAAO,GAAG,IAAI,CAACwB,mBAAmB,EAAE;IAC1C,MAAMrE,MAAM,GAAG,IAAI,CAACxF,UAAU,CAACwF,MAAM;IAErC;IACA;IACA,IACI,OAAO,IAAI,CAACvF,aAAa,CAAC6J,SAAS,KAAK,QAAQ,IAChD,IAAI,CAAC7J,aAAa,CAAC8J,qBAAqB,CAACtH,MAAM,GAAG,CAAC,IACnD+C,MAAM,CAACwE,uBAAuB,CAACJ,aAAa,CAAC,EAC/C;MACEvB,OAAO,CAACrD,IAAI,CACR,GAAG,IAAI,CAAC/E,aAAa,CAAC8J,qBAAqB,CAAClF,MAAM,CAAEuD,MAAM,IAAI;QAC1D,OAAOC,OAAO,CAAC4B,OAAO,CAAC7B,MAAM,CAAC,KAAK,CAAC,CAAC;MACzC,CAAC,CAAC,CACL;IACL;IAEA,IAAIC,OAAO,CAAC5F,MAAM,EAAE;MAChB,IAAIyH,iBAAiB,GAAG7B,OAAO,CAC1BrH,GAAG,CAAEoH,MAAM,IAAI;QACZ,MAAMhI,IAAI,GAAG,IAAI,CAAC6F,MAAM,CAACmC,MAAM,CAACN,YAAY,CAAC;QAC7C,IAAItC,MAAM,CAAC9D,OAAO,CAACsF,IAAI,KAAK,OAAO,EAAE;UACjC,IACI,IAAI,CAAC/G,aAAa,CAACW,SAAS,KAAK,QAAQ,IACzC,IAAI,CAACX,aAAa,CAACW,SAAS,KAAK,QAAQ,IACzC,IAAI,CAACX,aAAa,CAACW,SAAS,KAAK,aAAa,IAC9C,IAAI,CAACX,aAAa,CAACW,SAAS,KAAK,SAAS,EAC5C;YACE,OAAO,WAAW,GAAGR,IAAI;UAC7B,CAAC,MAAM;YACH,OACI,IAAI,CAAC6F,MAAM,CAAC,IAAI,CAACa,gBAAgB,EAAE,CAAC,GACpC,GAAG,GACH1G,IAAI;UAEZ;QACJ,CAAC,MAAM;UACH,OAAOA,IAAI;QACf;MACJ,CAAC,CAAC,CACDyG,IAAI,CAAC,IAAI,CAAC;MAEf,IAAIrB,MAAM,CAAC9D,OAAO,CAACsF,IAAI,KAAK,QAAQ,EAAE;QAClCkD,iBAAiB,IACb,QAAQ,GACR7B,OAAO,CACFrH,GAAG,CAAEoH,MAAM,IAAI;UACZ,OAAO,IAAI,CAACrE,eAAe,CAAC;YACxBiD,IAAI,EACAxB,MACH,CAAC2E,2BAA2B,CAAC/B,MAAM,CAACpB,IAAI,CAAC;YAC1CoD,GAAG,EAAG5E,MAAuB,CAAC6E,MAAM,CAACC;WACxC,CAAC;QACN,CAAC,CAAC,CACDzD,IAAI,CAAC,IAAI,CAAC;MACvB;MAEA,IAAIrB,MAAM,CAAC9D,OAAO,CAACsF,IAAI,KAAK,OAAO,EAAE;QACjC,IACI,IAAI,CAAC/G,aAAa,CAACW,SAAS,KAAK,QAAQ,IACzC,IAAI,CAACX,aAAa,CAACW,SAAS,KAAK,QAAQ,EAC3C;UACEsJ,iBAAiB,IAAI,oBAAoB;QAC7C;MACJ;MAEA,OAAOA,iBAAiB;IAC5B,CAAC,MAAM,IAAI,OAAO,IAAI,CAACjK,aAAa,CAAC6J,SAAS,KAAK,QAAQ,EAAE;MACzD,OAAO,IAAI,CAAC7J,aAAa,CAAC6J,SAAS;IACvC;IAEA,OAAO,EAAE;EACb;EAEA;;;;EAIUD,mBAAmBA,CAAA;IACzB,MAAMxB,OAAO,GAAqB,EAAE;IACpC,IAAIxH,KAAK,CAACC,OAAO,CAAC,IAAI,CAACb,aAAa,CAAC6J,SAAS,CAAC,EAAE;MAC7C;MAAE,IAAI,CAAC7J,aAAa,CAAC6J,SAAsB,CAAC3F,OAAO,CAC9CoG,UAAU,IAAI;QACX,IAAI,IAAI,CAACtK,aAAa,CAACO,SAAU,CAAC+D,WAAW,EAAE;UAC3C8D,OAAO,CAACrD,IAAI,CACR,GAAG,IAAI,CAAC/E,aAAa,CAACO,SAAU,CAACgE,QAAQ,CAACgG,2BAA2B,CACjED,UAAU,CACb,CACJ;QACL;MACJ,CAAC,CACJ;IACL;IACA,OAAOlC,OAAO;EAClB;EAEUgB,4BAA4BA,CAACoB,OAAsB;IACzD,OAAOA,OAAO,CACTzJ,GAAG,CAAC,CAAC0J,MAAM,EAAEC,KAAK,KAAI;MACnB,MAAMC,UAAU,GAAG,IAAI,CAACC,8BAA8B,CAClDH,MAAM,CAACjB,SAAS,CACnB;MAED,QAAQiB,MAAM,CAAC1D,IAAI;QACf,KAAK,KAAK;UACN,OACI,CAAC2D,KAAK,GAAG,CAAC,GAAG,MAAM,GAAG,EAAE,IACxB,GACI,IAAI,CAAC3K,UAAU,CAAC0B,OAAO,CAACoJ,sBAAsB,GACxC,GAAG,GACH,EACV,GAAGF,UAAU,GACT,IAAI,CAAC5K,UAAU,CAAC0B,OAAO,CAACoJ,sBAAsB,GACxC,GAAG,GACH,EACV,EAAE;QAEV,KAAK,IAAI;UACL,OACI,CAACH,KAAK,GAAG,CAAC,GAAG,KAAK,GAAG,EAAE,IACvB,GACI,IAAI,CAAC3K,UAAU,CAAC0B,OAAO,CAACoJ,sBAAsB,GACxC,GAAG,GACH,EACV,GAAGF,UAAU,GACT,IAAI,CAAC5K,UAAU,CAAC0B,OAAO,CAACoJ,sBAAsB,GACxC,GAAG,GACH,EACV,EAAE;MAEd;MAEA,OAAOF,UAAU;IACrB,CAAC,CAAC,CACD/D,IAAI,CAAC,GAAG,CAAC,CACTkE,IAAI,EAAE;EACf;EAEA;;;EAGUF,8BAA8BA,CACpCpB,SAA+B,EAC/BuB,UAAA,GAAsB,KAAK;IAE3B,IAAI,OAAOvB,SAAS,KAAK,QAAQ,EAAE,OAAOA,SAAS;IAEnD,IAAI5I,KAAK,CAACC,OAAO,CAAC2I,SAAS,CAAC,EAAE;MAC1B,IAAIA,SAAS,CAAChH,MAAM,KAAK,CAAC,EAAE;QACxB,OAAO,KAAK;MAChB;MAEA;MACA;MACA,IAAIgH,SAAS,CAAChH,MAAM,KAAK,CAAC,IAAI,CAACuI,UAAU,EAAE;QACvC,OAAO,IAAI,CAAC3B,4BAA4B,CAACI,SAAS,CAAC;MACvD;MAEA,OAAO,GAAG,GAAG,IAAI,CAACJ,4BAA4B,CAACI,SAAS,CAAC,GAAG,GAAG;IACnE;IAEA,MAAM;MAAEjE;IAAM,CAAE,GAAG,IAAI,CAACxF,UAAU;IAElC,QAAQyJ,SAAS,CAACwB,QAAQ;MACtB,KAAK,UAAU;QACX,OAAO,GAAGxB,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,MAAMiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,EAAE;MACpE,KAAK,iBAAiB;QAClB,OAAO,GAAGiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,OAAOiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,EAAE;MACrE,KAAK,eAAe;QAChB,OAAO,GAAGiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,OAAOiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,EAAE;MACrE,KAAK,cAAc;QACf,OAAO,GAAGiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,eAAeiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,EAAE;MAC7E,KAAK,kBAAkB;QACnB,OAAO,GAAGiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,OAAOiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,EAAE;MACrE,KAAK,cAAc;QACf,OAAO,GAAGiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,OAAOiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,EAAE;MACrE,KAAK,UAAU;QACX,OAAO,GAAGiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,MAAMiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,EAAE;MACpE,KAAK,iBAAiB;QAClB,OAAO,GAAGiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,OAAOiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,EAAE;MACrE,KAAK,UAAU;QACX,OAAO,GAAGiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,OAAOiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,EAAE;MACrE,KAAK,OAAO;QACR,OAAO,GAAGiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,MAAMiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,EAAE;MACpE,KAAK,OAAO;QACR,IACIgC,MAAM,CAAC9D,OAAO,CAACsF,IAAI,KAAK,UAAU,IAClCxB,MAAM,CAAC9D,OAAO,CAACsF,IAAI,KAAK,aAAa,EACvC;UACE,OAAO,GAAGyC,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,UAAUiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,EAAE;QACxE;QAEA,OAAO,SAASiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,gBAAgBiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,GAAG;MACrF,KAAK,MAAM;QACP,OAAO,GAAGiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,SAASiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,EAAE;MACvE,KAAK,SAAS;QACV,OAAO,GAAGiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,YAAYiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,QAAQiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,EAAE;MACzG,KAAK,IAAI;QACL,IAAIiG,SAAS,CAACjG,UAAU,CAACf,MAAM,IAAI,CAAC,EAAE;UAClC,OAAO,KAAK;QAChB;QACA,OAAO,GAAGgH,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,QAAQiG,SAAS,CAACjG,UAAU,CACxD0H,KAAK,CAAC,CAAC,CAAC,CACRrE,IAAI,CAAC,IAAI,CAAC,GAAG;MACtB,KAAK,KAAK;QACN,IAAIrB,MAAM,CAAC9D,OAAO,CAACsF,IAAI,KAAK,aAAa,EAAE;UACvC,OAAO,GAAGyC,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,kBAAkBiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,aAAa;QAC3F;QAEA,OAAO,GAAGiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,UAAUiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,GAAG;MACzE,KAAK,QAAQ;QACT,OAAO,GAAGiG,SAAS,CAACjG,UAAU,CAAC,CAAC,CAAC,UAAU;MAE/C,KAAK,KAAK;QACN,OAAO,OAAO,IAAI,CAACqH,8BAA8B,CAC7CpB,SAAS,CAACA,SAAS,CACtB,GAAG;MACR,KAAK,UAAU;QACX,OAAO,GAAG,IAAI,CAACoB,8BAA8B,CACzCpB,SAAS,CAACA,SAAS,EACnB,IAAI,CACP,EAAE;MACP,KAAK,KAAK;QACN,OAAO,GAAG,GAAGA,SAAS,CAACjG,UAAU,CAACqD,IAAI,CAAC,OAAO,CAAC,GAAG,GAAG;MACzD,KAAK,IAAI;QACL,OAAO,GAAG,GAAG4C,SAAS,CAACjG,UAAU,CAACqD,IAAI,CAAC,MAAM,CAAC,GAAG,GAAG;IAC5D;IAEA,MAAM,IAAIsE,SAAS,CACf,4BAA4BjM,YAAY,CAACO,WAAW,CAACW,IAAI,EAAE,CAC9D;EACL;EAEUgL,mBAAmBA,CAAA;IACzB,IAAI,CAAC,IAAI,CAACC,yBAAyB,EAAE,EAAE;MACnC,OAAO,EAAE;IACb;IACA,MAAMC,2BAA2B,GAC7B,IAAI,CAACtL,UAAU,CAACwF,MAAM,CAAC+F,eAAe,CAACC,qBAAqB;IAEhE,MAAMC,UAAU,GAAG,IAAI,CAACxL,aAAa,CAACuG,sBAAsB,CAACxF,GAAG,CAC3D0K,GAAG,IAAI;MACJ,MAAMC,iBAAiB,GACnB,OAAOD,GAAG,CAACnF,YAAY,KAAK,QAAQ,GAC9BmF,GAAG,CAACnF,YAAY,GAChBmF,GAAG,CAACnF,YAAY,CAAChB,QAAQ,EAAE;MACrC,IAAI,OAAOmG,GAAG,CAACnF,YAAY,KAAK,QAAQ,EAAE;QACtC,IAAImF,GAAG,CAACnF,YAAY,CAAC8E,yBAAyB,EAAE,EAAE;UAC9C,MAAM,IAAIjM,YAAY,CAClB,sCAAsCsM,GAAG,CAACnL,KAAK,GAAG,CACrD;QACL;QACA,IACI,CAAC,IAAI,CAACP,UAAU,CAACwF,MAAM,CAAC+F,eAAe,CAACK,QAAQ,IAChD,CAACtM,eAAe,CAAC4B,oBAAoB,CAACwK,GAAG,CAACnF,YAAY,CAAC,EACzD;UACE,MAAM,IAAInH,YAAY,CAClB,gDAAgD,IAAI,CAACY,UAAU,CAAC0B,OAAO,CAACsF,IAAI,UAAU0E,GAAG,CAACnL,KAAK,GAAG,CACrG;QACL;QACA,IAAI,CAACqD,aAAa,CAAC8H,GAAG,CAACnF,YAAY,CAAClC,aAAa,EAAE,CAAC;MACxD;MACA,IAAIwH,SAAS,GAAG,IAAI,CAAC5F,MAAM,CAACyF,GAAG,CAACnL,KAAK,CAAC;MACtC,IAAImL,GAAG,CAAChK,OAAO,CAACoK,WAAW,EAAE;QACzB,MAAMC,kBAAkB,GAAGL,GAAG,CAAChK,OAAO,CAACoK,WAAW,CAAC9K,GAAG,CACjDoH,MAAM,IAAK,IAAI,CAACnC,MAAM,CAACmC,MAAM,CAAC,CAClC;QACD,IACI9I,eAAe,CAAC4B,oBAAoB,CAACwK,GAAG,CAACnF,YAAY,CAAC,EACxD;UACE,IACImF,GAAG,CAACnF,YAAY,CAACtG,aAAa,CAACc,OAAO,CAAC0B,MAAM,IAC7CiJ,GAAG,CAAChK,OAAO,CAACoK,WAAW,CAACrJ,MAAM,KAC1BiJ,GAAG,CAACnF,YAAY,CAACtG,aAAa,CAACc,OAAO,CAAC0B,MAAM,EACnD;YACE,MAAM,IAAIrD,YAAY,CAClB,mCAAmCsM,GAAG,CAAChK,OAAO,CAACoK,WAAW,CAACrJ,MAAM,+CAA+CiJ,GAAG,CAACnF,YAAY,CAACtG,aAAa,CAACc,OAAO,CAAC0B,MAAM,UAAUiJ,GAAG,CAACnL,KAAK,GAAG,CACtL;UACL;QACJ;QACAsL,SAAS,IAAI,IAAIE,kBAAkB,CAAClF,IAAI,CAAC,IAAI,CAAC,GAAG;MACrD;MACA,MAAMmF,eAAe,GACjBN,GAAG,CAAChK,OAAO,CAACuK,SAAS,IAAIX,2BAA2B,GAC9C,WAAW,GACX,EAAE;MACZ,IAAIY,iBAAiB,GAAG,EAAE;MAC1B,IACI,IAAI,CAAClM,UAAU,CAACwF,MAAM,CAAC+F,eAAe,CAACY,gBAAgB,IACvDT,GAAG,CAAChK,OAAO,CAAC0K,YAAY,KAAK1J,SAAS,EACxC;QACEwJ,iBAAiB,GAAGR,GAAG,CAAChK,OAAO,CAAC0K,YAAY,GACtC,cAAc,GACd,kBAAkB;MAC5B;MAEA,OAAO,CACHJ,eAAe,EACfH,SAAS,EACT,IAAI,EACJK,iBAAiB,EACjB,IAAIP,iBAAiB,GAAG,CAC3B,CACI9G,MAAM,CAACwH,OAAO,CAAC,CACfxF,IAAI,CAAC,GAAG,CAAC;IAClB,CAAC,CACJ;IAED,OAAO,OAAO,GAAG4E,UAAU,CAAC5E,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG;EAChD;EAEA;;;EAGUyF,sBAAsBA,CAC5BC,GAAgB;IAEhB,MAAM/H,QAAQ,GAAG,IAAI,CAACvE,aAAa,CAACO,SAAU,CAACgE,QAAQ;IACvD,MAAMgI,UAAU,GAAG,CAAC3L,KAAK,CAACC,OAAO,CAACyL,GAAG,CAAC,GAAGA,GAAG,GAAG,CAACA,GAAG,CAAC,EAAEvL,GAAG,CAAEyL,EAAE,IACzDjI,QAAQ,CAACkI,iBAAiB,CAACD,EAAE,CAAC,CACjC;IAED;IACA,IAAI,CAACjI,QAAQ,CAACmI,sBAAsB,EAAE;MAClC,MAAMC,aAAa,GAAGpI,QAAQ,CAACqI,cAAc,CAAC,CAAC,CAAC;MAEhD;MACA;MACA;MACA,IACI,CAACD,aAAa,CAACE,WAAW,IAC1B,CAACF,aAAa,CAACG,gBAAgB,IAC/B,CAACH,aAAa,CAACI,gBAAgB,EACjC;QACE,OAAO;UACH,CAACJ,aAAa,CAACtE,YAAY,GAAGnJ,EAAE,CAC5BqN,UAAU,CAACxL,GAAG,CAAEyL,EAAE,IACdG,aAAa,CAACK,cAAc,CAACR,EAAE,EAAE,KAAK,CAAC,CAC1C;SAER;MACL;IACJ;IAEA,OAAO,IAAIxN,QAAQ,CAAEiO,EAAE,IAAI;MACvB,KAAK,MAAMC,IAAI,IAAIX,UAAU,EAAE;QAC3BU,EAAE,CAACE,OAAO,CAAC,IAAInO,QAAQ,CAAEiO,EAAE,IAAKA,EAAE,CAACG,KAAK,CAACF,IAAI,CAAC,CAAC,CAAC;MACpD;IACJ,CAAC,CAAC;EACN;EAEUG,kBAAkBA,CAACnG,QAAa;IACtC,MAAMjC,KAAK,GAAGiC,QAAQ,CACjBjH,KAAK,EAAE,CACPqN,OAAO,EAAE,CACTC,OAAO,EAAE,CACTC,MAAM,CAAC/K,SAAS,CAAC,CACjBgL,KAAK,CAAChL,SAAS,CAAC,CAChBiL,IAAI,CAACjL,SAAS,CAAC,CACfkL,IAAI,CAAClL,SAAS,CAAC,CACfjC,MAAM,CAAC,GAAG,CAAC,CACXoN,SAAS,CAAC,sBAAsB,CAAC;IAEtC,OAAO,CAAC,WAAW3I,KAAK,CAACK,QAAQ,EAAE,GAAG,EAAEL,KAAK,CAACb,aAAa,EAAE,CAAC;EAClE;EAEQyJ,0BAA0BA,CAC9BnL,YAAoB;IAEpB;IACA;IAEA;IACA,IAAIpC,KAAK,GAAG,IAAI,CAACN,aAAa,CAACO,SAAS;IACxC,MAAMuN,IAAI,GAAa,EAAE;IACzB,MAAMC,iBAAiB,GAAGrL,YAAY,CAACgE,KAAK,CAAC,GAAG,CAAC;IAEjD,OAAOqH,iBAAiB,CAACvL,MAAM,GAAG,CAAC,EAAE;MACjC,MAAMwL,IAAI,GAAGD,iBAAiB,CAAC,CAAC,CAAC;MAEjC,IAAI,CAACzN,KAAK,EAAEgE,WAAW,EAAE;QACrB;QACA;QACA;MACJ;MAEA,IAAIhE,KAAK,CAACiE,QAAQ,CAAC0J,2BAA2B,CAACD,IAAI,CAAC,EAAE;QAClD;QACA;QACA;QACAD,iBAAiB,CAACG,OAAO,CACrB,GAAGH,iBAAiB,CAACI,KAAK,EAAE,IAAIJ,iBAAiB,CAACI,KAAK,EAAE,EAAE,CAC9D;QACD;MACJ;MAEA,IAAI7N,KAAK,CAACiE,QAAQ,CAAC6J,2BAA2B,CAACJ,IAAI,CAAC,EAAE;QAClD;QACA;QACA;QACA,MAAMK,QAAQ,GAAG,IAAI,CAACrO,aAAa,CAACsO,cAAc,CAACC,IAAI,CAClDF,QAAQ,IAAKA,QAAQ,CAAC1L,oBAAoB,KAAKqL,IAAI,CACvD;QAED,IAAI,CAACK,QAAQ,EAAE/N,KAAK,EAAE;UAClB,MAAMkO,gBAAgB,GAClBV,IAAI,CAACtL,MAAM,GAAG,CAAC,GAAG,GAAGsL,IAAI,CAAClH,IAAI,CAAC,GAAG,CAAC,IAAIoH,IAAI,EAAE,GAAGA,IAAI;UACxD,MAAM,IAAIS,KAAK,CACX,qCAAqCD,gBAAgB,EAAE,CAC1D;QACL;QAEAlO,KAAK,GAAG+N,QAAQ,CAAC/N,KAAK;QACtBwN,IAAI,CAAC/I,IAAI,CAAC,GAAGiJ,IAAI,CAACtH,KAAK,CAAC,GAAG,CAAC,CAAC;QAC7BqH,iBAAiB,CAACI,KAAK,EAAE;QACzB;MACJ;MAEA;IACJ;IAEA,IAAI,CAAC7N,KAAK,EAAE;MACR,MAAM,IAAImO,KAAK,CAAC,kCAAkC/L,YAAY,EAAE,CAAC;IACrE;IAEA;IACA,MAAMgM,iBAAiB,GAAGX,iBAAiB,CAACnH,IAAI,CAAC,GAAG,CAAC;IAErD,MAAMwB,OAAO,GACT9H,KAAK,CAACiE,QAAQ,CAACgG,2BAA2B,CAACmE,iBAAiB,CAAC;IAEjE,IAAI,CAACtG,OAAO,CAAC5F,MAAM,EAAE;MACjB,MAAM,IAAIpD,2BAA2B,CAACsD,YAAY,EAAEpC,KAAK,CAACiE,QAAQ,CAAC;IACvE;IAEA,OAAO,CAACjE,KAAK,EAAEwN,IAAI,EAAE1F,OAAO,CAAC;EACjC;EAEA;;;EAGUuG,kBAAkBA,CACxBpK,QAAwB,EACxBqK,MAAqB,EACrBC,MAAA,GAAiB,EAAE;IAEnB,MAAMC,KAAK,GAAa,EAAE;IAE1B,KAAK,MAAMzL,GAAG,IAAIO,MAAM,CAACK,IAAI,CAAC2K,MAAM,CAAC,EAAE;MACnC,MAAMG,IAAI,GAAGF,MAAM,GAAG,GAAGA,MAAM,IAAIxL,GAAG,EAAE,GAAGA,GAAG;MAE9C;MACA;MACA,IACIuL,MAAM,CAACvL,GAAG,CAAC,KAAK,IAAI,IACpB,OAAOuL,MAAM,CAACvL,GAAG,CAAC,KAAK,QAAQ,IAC/BhE,eAAe,CAAC2P,cAAc,CAACJ,MAAM,CAACvL,GAAG,CAAC,CAAC,EAC7C;QACEyL,KAAK,CAAC/J,IAAI,CAACgK,IAAI,CAAC;QAChB;MACJ;MAEA,IAAIxK,QAAQ,CAAC0J,2BAA2B,CAACc,IAAI,CAAC,EAAE;QAC5C,MAAME,QAAQ,GAAG,IAAI,CAACN,kBAAkB,CACpCpK,QAAQ,EACRqK,MAAM,CAACvL,GAAG,CAAC,EACX0L,IAAI,CACP;QACDD,KAAK,CAAC/J,IAAI,CAAC,GAAGkK,QAAQ,CAAC;QACvB;MACJ;MAEA,IAAI1K,QAAQ,CAAC6J,2BAA2B,CAACW,IAAI,CAAC,EAAE;QAC5C,MAAM5M,QAAQ,GAAGoC,QAAQ,CAACpB,4BAA4B,CAAC4L,IAAI,CAAE;QAE7D;QACA;QACA;QAEA;QACA;QACA;QACA,IACI5M,QAAQ,CAAC+M,YAAY,KAAK,YAAY,IACtC/M,QAAQ,CAAC+M,YAAY,KAAK,aAAa,EACzC;UACE,MAAMtH,WAAW,GAAGzF,QAAQ,CAACyF,WAAW,CACnC7G,GAAG,CAAEoO,CAAC,IAAKA,CAAC,CAACjH,gBAAgB,CAAC,CAC9BtD,MAAM,CAAEuK,CAAC,IAA0B,CAAC,CAACA,CAAC,CAAC;UAE5C,MAAMC,iBAAiB,GACnBxH,WAAW,CAACpF,MAAM,GAAG,CAAC,IACtBoF,WAAW,CAAC1E,KAAK,CAAEiF,MAAM,IACrBA,MAAM,CAAC6E,cAAc,CAAC4B,MAAM,CAACvL,GAAG,CAAC,EAAE,KAAK,CAAC,CAC5C;UAEL,IAAI+L,iBAAiB,EAAE;YACnBN,KAAK,CAAC/J,IAAI,CAACgK,IAAI,CAAC;YAChB;UACJ;QACJ;QAEA,IACI5M,QAAQ,CAAC+M,YAAY,KAAK,aAAa,IACvC/M,QAAQ,CAAC+M,YAAY,KAAK,cAAc,EAC1C;UACE,MAAM,IAAIT,KAAK,CACX,uBAAuBtM,QAAQ,CAAC+M,YAAY,iBAAiBH,IAAI,EAAE,CACtE;QACL;QAEA;QACA;QACA;QACA;QACA;QACA,MAAMnC,cAAc,GAChBzK,QAAQ,CAACkN,qBAAqB,CAACzC,cAAc;QACjD,MAAM0C,iBAAiB,GACnB1C,cAAc,CAACpK,MAAM,GAAG,CAAC,IACzBoK,cAAc,CAAC1J,KAAK,CAAEiF,MAAM,IACxBA,MAAM,CAAC6E,cAAc,CAAC4B,MAAM,CAACvL,GAAG,CAAC,EAAE,KAAK,CAAC,CAC5C;QAEL,IAAIiM,iBAAiB,EAAE;UACnB,MAAML,QAAQ,GAAGrC,cAAc,CAAC7L,GAAG,CAC9BoH,MAAM,IAAK,GAAG4G,IAAI,IAAI5G,MAAM,CAACzF,YAAY,EAAE,CAC/C;UACDoM,KAAK,CAAC/J,IAAI,CAAC,GAAGkK,QAAQ,CAAC;UACvB;QACJ;QAEA;QACA,MAAMA,QAAQ,GAAG,IAAI,CAACN,kBAAkB,CACpCxM,QAAQ,CAACkN,qBAAqB,EAC9BT,MAAM,CAACvL,GAAG,CAAC,CACd,CAACtC,GAAG,CAAE6H,CAAC,IAAK,GAAGmG,IAAI,IAAInG,CAAC,EAAE,CAAC;QAC5BkG,KAAK,CAAC/J,IAAI,CAAC,GAAGkK,QAAQ,CAAC;QACvB;MACJ;MAEAH,KAAK,CAAC/J,IAAI,CAACgK,IAAI,CAAC;IACpB;IAEA,OAAOD,KAAK;EAChB;EAEU,CAACS,aAAaA,CAACnC,KAAoB;IACzC,IAAI,IAAI,CAACpN,aAAa,CAACO,SAAU,CAAC+D,WAAW,EAAE;MAC3C,MAAMkL,aAAa,GAAG,IAAI,CAACb,kBAAkB,CACzC,IAAI,CAAC3O,aAAa,CAACO,SAAU,CAACgE,QAAQ,EACtC6I,KAAK,CACR;MAED,KAAK,MAAM1K,YAAY,IAAI8M,aAAa,EAAE;QACtC,MAAM,CAAClP,KAAK,EAAEoO,iBAAiB,EAAEtG,OAAO,CAAC,GACrC,IAAI,CAACyF,0BAA0B,CAACnL,YAAY,CAAC;QAEjD,KAAK,MAAMyF,MAAM,IAAIC,OAAO,EAAE;UAC1B,IAAIqH,cAAc,GAAGrC,KAAK;UAE1B,KAAK,MAAMY,IAAI,IAAIU,iBAAiB,EAAE;YAClC,IAAI,CAACe,cAAc,IAAI,EAAEzB,IAAI,IAAIyB,cAAc,CAAC,EAAE;cAC9CA,cAAc,GAAG,EAAE;cACnB;YACJ;YAEAA,cAAc,GAAGA,cAAc,CAACzB,IAAI,CAAC;UACzC;UAEA;UACA,MAAM0B,SAAS,GAAG,IAAI,CAAC1P,aAAa,CAC/B2H,yBAAyB,GACxB,GAAGrH,KAAK,CAACH,IAAI,IAAIgI,MAAM,CAACzF,YAAY,EAAE,GACtCyF,MAAM,CAACzF,YAAY;UAEzB,MAAMiN,cAAc,GAAGxH,MAAM,CAAC6E,cAAc,CACxCyC,cAAc,EACd,IAAI,CACP;UAED,MAAM,CAACC,SAAS,EAAEC,cAAc,CAAC;QACrC;MACJ;IACJ,CAAC,MAAM;MACH,KAAK,MAAMtM,GAAG,IAAIO,MAAM,CAACK,IAAI,CAACmJ,KAAK,CAAC,EAAE;QAClC,MAAMuC,cAAc,GAAGvC,KAAK,CAAC/J,GAAG,CAAC;QACjC,MAAMqM,SAAS,GAAG,IAAI,CAAC1P,aAAa,CAAC2H,yBAAyB,GACxD,GAAG,IAAI,CAACrH,KAAK,IAAI+C,GAAG,EAAE,GACtBA,GAAG;QAET,MAAM,CAACqM,SAAS,EAAEC,cAAc,CAAC;MACrC;IACJ;EACJ;EAEUC,0BAA0BA,CAChCF,SAAiB,EACjBC,cAAmB;IAEnB,IAAItQ,eAAe,CAAC2P,cAAc,CAACW,cAAc,CAAC,EAAE;MAChD,IAAIpM,UAAU,GAAU,EAAE;MAC1B,IAAIoM,cAAc,CAACE,YAAY,EAAE;QAC7B,IAAIF,cAAc,CAACG,uBAAuB,EAAE;UACxC,IAAI,CAACnM,aAAa,CAACgM,cAAc,CAACG,uBAAuB,CAAC;QAC9D,CAAC,MAAM,IAAIH,cAAc,CAACI,kBAAkB,EAAE;UAC1C,KAAK,MAAMC,CAAC,IAAIL,cAAc,CAAClM,KAAK,EAAE;YAClCF,UAAU,CAACwB,IAAI,CAAC,IAAI,CAACjB,eAAe,CAACkM,CAAC,CAAC,CAAC;UAC5C;QACJ,CAAC,MAAM;UACHzM,UAAU,CAACwB,IAAI,CAAC,IAAI,CAACjB,eAAe,CAAC6L,cAAc,CAAClM,KAAK,CAAC,CAAC;QAC/D;MACJ;MAEA,IAAIkM,cAAc,CAAC5I,IAAI,KAAK,KAAK,EAAE;QAC/B,IAAI4I,cAAc,CAACtK,MAAM,EAAE;UACvB,OAAOsK,cAAc,CAACtK,MAAM,CAACqK,SAAS,CAAC;QAC3C,CAAC,MAAM;UACH,OAAO;YACH1E,QAAQ,EAAE,OAAO;YACjBzH,UAAU,EAAE,CAACmM,SAAS,EAAEC,cAAc,CAAClM,KAAK;WAC/C;QACL;MACJ,CAAC,MAAM,IAAIkM,cAAc,CAAC5I,IAAI,KAAK,KAAK,EAAE;QACtC,IAAI4I,cAAc,CAACM,KAAK,EAAE;UACtB,OAAO;YACHjF,QAAQ,EAAE2E,cAAc,CAAC5I,IAAI;YAC7ByC,SAAS,EAAE,IAAI,CAACoG,0BAA0B,CACtCF,SAAS,EACTC,cAAc,CAACM,KAAK;WAE3B;QACL,CAAC,MAAM;UACH,OAAO;YACHjF,QAAQ,EAAE,UAAU;YACpBzH,UAAU,EAAE,CAACmM,SAAS,EAAE,GAAGnM,UAAU;WACxC;QACL;MACJ,CAAC,MAAM,IAAIoM,cAAc,CAAC5I,IAAI,KAAK,KAAK,EAAE;QACtC,MAAMrC,MAAM,GAAwBiL,cAAc,CAAClM,KAAK;QAExD,OAAO;UACHuH,QAAQ,EAAE2E,cAAc,CAAC5I,IAAI;UAC7BxD,UAAU,EAAEmB,MAAM,CAAC3D,GAAG,CAAEiK,QAAQ,IAC5B,IAAI,CAACJ,8BAA8B,CAC/B,IAAI,CAACgF,0BAA0B,CAC3BF,SAAS,EACT1E,QAAQ,CACX,CACJ;SAER;MACL,CAAC,MAAM,IAAI2E,cAAc,CAAC5I,IAAI,KAAK,IAAI,EAAE;QACrC,MAAMrC,MAAM,GAAwBiL,cAAc,CAAClM,KAAK;QAExD,OAAO;UACHuH,QAAQ,EAAE2E,cAAc,CAAC5I,IAAI;UAC7BxD,UAAU,EAAEmB,MAAM,CAAC3D,GAAG,CAAEiK,QAAQ,IAC5B,IAAI,CAACJ,8BAA8B,CAC/B,IAAI,CAACgF,0BAA0B,CAC3BF,SAAS,EACT1E,QAAQ,CACX,CACJ;SAER;MACL,CAAC,MAAM;QACH,OAAO;UACHA,QAAQ,EAAE2E,cAAc,CAAC5I,IAAI;UAC7BxD,UAAU,EAAE,CAACmM,SAAS,EAAE,GAAGnM,UAAU;SACxC;MACL;MACA;MACA;MACA;MACA;MACA;MACA;MACA;IACJ,CAAC,MAAM;MACH,OAAO;QACHyH,QAAQ,EAAE,OAAO;QACjBzH,UAAU,EAAE,CAACmM,SAAS,EAAE,IAAI,CAAC5L,eAAe,CAAC6L,cAAc,CAAC;OAC/D;IACL;EACJ;EAEUO,iBAAiBA,CACvB9C,KAMqB;IAErB,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MAC3B,OAAOA,KAAK;IAChB;IAEA,IAAI/N,eAAe,CAAC8Q,UAAU,CAAC/C,KAAK,CAAC,EAAE;MACnC,MAAMgD,iBAAiB,GAAG,IAAI,CAACvK,kBAAkB,EAAE;MAEnDuK,iBAAiB,CAAC9M,kBAAkB,GAAG,IAAI;MAE3C8M,iBAAiB,CAACpQ,aAAa,CAACO,SAAS,GACrC,IAAI,CAACP,aAAa,CAACO,SAAS;MAChC6P,iBAAiB,CAACpQ,aAAa,CAAC2H,yBAAyB,GACrD,IAAI,CAAC3H,aAAa,CAAC2H,yBAAyB;MAChDyI,iBAAiB,CAACpQ,aAAa,CAACuD,UAAU,GACtC,IAAI,CAACvD,aAAa,CAACuD,UAAU;MACjC6M,iBAAiB,CAACpQ,aAAa,CAACmE,gBAAgB,GAC5C,IAAI,CAACnE,aAAa,CAACmE,gBAAgB;MAEvCiM,iBAAiB,CAACpQ,aAAa,CAACqJ,MAAM,GAAG,EAAE;MAE3C+D,KAAK,CAACiD,YAAY,CAACD,iBAAwB,CAAC;MAE5C,OAAO;QACHpF,QAAQ,EAAE3L,eAAe,CAACiR,aAAa,CAAClD,KAAK,CAAC,GACxC,KAAK,GACL,UAAU;QAChB5D,SAAS,EAAE4G,iBAAiB,CAACpQ,aAAa,CAACqJ;OAC9C;IACL;IAEA,IAAI,OAAO+D,KAAK,KAAK,UAAU,EAAE;MAC7B,OAAOA,KAAK,CAAC,IAAI,CAAC;IACtB;IAEA,MAAM/D,MAAM,GAAoBzI,KAAK,CAACC,OAAO,CAACuM,KAAK,CAAC,GAAGA,KAAK,GAAG,CAACA,KAAK,CAAC;IACtE,MAAM5C,OAAO,GAAkB,EAAE;IAEjC,KAAK,MAAM4C,KAAK,IAAI/D,MAAM,EAAE;MACxB,MAAMkH,UAAU,GAAyB,EAAE;MAE3C;MACA,KAAK,MAAM,CAACb,SAAS,EAAEC,cAAc,CAAC,IAAI,IAAI,CAACJ,aAAa,CACxDnC,KAAK,CACR,EAAE;QACCmD,UAAU,CAACxL,IAAI,CAAC;UACZgC,IAAI,EAAE,KAAK;UACXyC,SAAS,EAAE,IAAI,CAACoG,0BAA0B,CACtCF,SAAS,EACTC,cAAc;SAErB,CAAC;MACN;MAEAnF,OAAO,CAACzF,IAAI,CAAC;QAAEgC,IAAI,EAAE,IAAI;QAAEyC,SAAS,EAAE+G;MAAU,CAAE,CAAC;IACvD;IAEA,IAAI/F,OAAO,CAAChI,MAAM,KAAK,CAAC,EAAE;MACtB,OAAOgI,OAAO,CAAC,CAAC,CAAC,CAAChB,SAAS;IAC/B;IAEA,OAAOgB,OAAO;EAClB;EAEA;;;EAGU7E,iBAAiBA,CAAA;IACvB,OAAO,IAAI,CAACjG,WAAW,IAAI,IAAI,CAACK,UAAU,CAACyQ,iBAAiB,EAAE;EAClE;EAEUpF,yBAAyBA,CAAA;IAC/B,OAAO,IAAI,CAACpL,aAAa,CAACuG,sBAAsB,CAAC/D,MAAM,GAAG,CAAC;EAC/D;;AA3jDA;;;AAGejD,YAAA,CAAAc,oBAAoB,GAAwB,EAAxB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}