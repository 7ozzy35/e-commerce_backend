{"ast":null,"code":"/**\n * Loads database entities for all operate subjects which do not have database entity set.\n * All entities that we load database entities for are marked as updated or inserted.\n * To understand which of them really needs to be inserted or updated we need to load\n * their original representations from the database.\n */\nexport class SubjectDatabaseEntityLoader {\n  // ---------------------------------------------------------------------\n  // Constructor\n  // ---------------------------------------------------------------------\n  constructor(queryRunner, subjects) {\n    this.queryRunner = queryRunner;\n    this.subjects = subjects;\n  }\n  // ---------------------------------------------------------------------\n  // Public Methods\n  // ---------------------------------------------------------------------\n  /**\n   * Loads database entities for all subjects.\n   *\n   * loadAllRelations flag is used to load all relation ids of the object, no matter if they present in subject entity or not.\n   * This option is used for deletion.\n   */\n  async load(operationType) {\n    // we are grouping subjects by target to perform more optimized queries using WHERE IN operator\n    // go through the groups and perform loading of database entities of each subject in the group\n    const promises = this.groupByEntityTargets().map(async subjectGroup => {\n      // prepare entity ids of the subjects we need to load\n      const allIds = [];\n      const allSubjects = [];\n      subjectGroup.subjects.forEach(subject => {\n        // we don't load if subject already has a database entity loaded\n        if (subject.databaseEntity || !subject.identifier) return;\n        allIds.push(subject.identifier);\n        allSubjects.push(subject);\n      });\n      // if there no ids found (means all entities are new and have generated ids) - then nothing to load there\n      if (!allIds.length) return;\n      const loadRelationPropertyPaths = [];\n      // for the save, soft-remove and recover operation\n      // extract all property paths of the relations we need to load relation ids for\n      // this is for optimization purpose - this way we don't load relation ids for entities\n      // whose relations are undefined, and since they are undefined its really pointless to\n      // load something for them, since undefined properties are skipped by the orm\n      if (operationType === \"save\" || operationType === \"soft-remove\" || operationType === \"recover\") {\n        subjectGroup.subjects.forEach(subject => {\n          // gets all relation property paths that exist in the persisted entity.\n          subject.metadata.relations.forEach(relation => {\n            const value = relation.getEntityValue(subject.entityWithFulfilledIds);\n            if (value === undefined) return;\n            if (loadRelationPropertyPaths.indexOf(relation.propertyPath) === -1) loadRelationPropertyPaths.push(relation.propertyPath);\n          });\n        });\n      } else {\n        // remove\n        // for remove operation\n        // we only need to load junction relation ids since only they are removed by cascades\n        loadRelationPropertyPaths.push(...subjectGroup.subjects[0].metadata.manyToManyRelations.map(relation => relation.propertyPath));\n      }\n      const findOptions = {\n        loadEagerRelations: false,\n        loadRelationIds: {\n          relations: loadRelationPropertyPaths,\n          disableMixedMap: true\n        },\n        // the soft-deleted entities should be included in the loaded entities for recover operation\n        withDeleted: true\n      };\n      // load database entities for all given ids\n      let entities = [];\n      if (this.queryRunner.connection.driver.options.type === \"mongodb\") {\n        const mongoRepo = this.queryRunner.manager.getRepository(subjectGroup.target);\n        entities = await mongoRepo.findByIds(allIds, findOptions);\n      } else {\n        entities = await this.queryRunner.manager.getRepository(subjectGroup.target).createQueryBuilder().setFindOptions(findOptions).whereInIds(allIds).getMany();\n      }\n      // now when we have entities we need to find subject of each entity\n      // and insert that entity into database entity of the found subjects\n      entities.forEach(entity => {\n        const subjects = this.findByPersistEntityLike(subjectGroup.target, entity);\n        subjects.forEach(subject => {\n          subject.databaseEntity = entity;\n          if (!subject.identifier) subject.identifier = subject.metadata.hasAllPrimaryKeys(entity) ? subject.metadata.getEntityIdMap(entity) : undefined;\n        });\n      });\n      // this way we tell what subjects we tried to load database entities of\n      for (let subject of allSubjects) {\n        subject.databaseEntityLoaded = true;\n      }\n    });\n    await Promise.all(promises);\n  }\n  // ---------------------------------------------------------------------\n  // Protected Methods\n  // ---------------------------------------------------------------------\n  /**\n   * Finds subjects where entity like given subject's entity.\n   * Comparison made by entity id.\n   * Multiple subjects may be returned if duplicates are present in the subject array.\n   * This will likely result in the same row being updated multiple times during a transaction.\n   */\n  findByPersistEntityLike(entityTarget, entity) {\n    return this.subjects.filter(subject => {\n      if (!subject.entity) return false;\n      if (subject.entity === entity) return true;\n      return subject.metadata.target === entityTarget && subject.metadata.compareEntities(subject.entityWithFulfilledIds, entity);\n    });\n  }\n  /**\n   * Groups given Subject objects into groups separated by entity targets.\n   */\n  groupByEntityTargets() {\n    return this.subjects.reduce((groups, operatedEntity) => {\n      let group = groups.find(group => group.target === operatedEntity.metadata.target);\n      if (!group) {\n        group = {\n          target: operatedEntity.metadata.target,\n          subjects: []\n        };\n        groups.push(group);\n      }\n      group.subjects.push(operatedEntity);\n      return groups;\n    }, []);\n  }\n}","map":{"version":3,"names":["SubjectDatabaseEntityLoader","constructor","queryRunner","subjects","load","operationType","promises","groupByEntityTargets","map","subjectGroup","allIds","allSubjects","forEach","subject","databaseEntity","identifier","push","length","loadRelationPropertyPaths","metadata","relations","relation","value","getEntityValue","entityWithFulfilledIds","undefined","indexOf","propertyPath","manyToManyRelations","findOptions","loadEagerRelations","loadRelationIds","disableMixedMap","withDeleted","entities","connection","driver","options","type","mongoRepo","manager","getRepository","target","findByIds","createQueryBuilder","setFindOptions","whereInIds","getMany","entity","findByPersistEntityLike","hasAllPrimaryKeys","getEntityIdMap","databaseEntityLoaded","Promise","all","entityTarget","filter","compareEntities","reduce","groups","operatedEntity","group","find"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\persistence\\SubjectDatabaseEntityLoader.ts"],"sourcesContent":["import { Subject } from \"./Subject\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { FindManyOptions } from \"../find-options/FindManyOptions\"\nimport { MongoRepository } from \"../repository/MongoRepository\"\n\n/**\n * Loads database entities for all operate subjects which do not have database entity set.\n * All entities that we load database entities for are marked as updated or inserted.\n * To understand which of them really needs to be inserted or updated we need to load\n * their original representations from the database.\n */\nexport class SubjectDatabaseEntityLoader {\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(\n        protected queryRunner: QueryRunner,\n        protected subjects: Subject[],\n    ) {}\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Loads database entities for all subjects.\n     *\n     * loadAllRelations flag is used to load all relation ids of the object, no matter if they present in subject entity or not.\n     * This option is used for deletion.\n     */\n    async load(\n        operationType: \"save\" | \"remove\" | \"soft-remove\" | \"recover\",\n    ): Promise<void> {\n        // we are grouping subjects by target to perform more optimized queries using WHERE IN operator\n        // go through the groups and perform loading of database entities of each subject in the group\n        const promises = this.groupByEntityTargets().map(\n            async (subjectGroup) => {\n                // prepare entity ids of the subjects we need to load\n                const allIds: ObjectLiteral[] = []\n                const allSubjects: Subject[] = []\n                subjectGroup.subjects.forEach((subject) => {\n                    // we don't load if subject already has a database entity loaded\n                    if (subject.databaseEntity || !subject.identifier) return\n\n                    allIds.push(subject.identifier)\n                    allSubjects.push(subject)\n                })\n\n                // if there no ids found (means all entities are new and have generated ids) - then nothing to load there\n                if (!allIds.length) return\n\n                const loadRelationPropertyPaths: string[] = []\n\n                // for the save, soft-remove and recover operation\n                // extract all property paths of the relations we need to load relation ids for\n                // this is for optimization purpose - this way we don't load relation ids for entities\n                // whose relations are undefined, and since they are undefined its really pointless to\n                // load something for them, since undefined properties are skipped by the orm\n                if (\n                    operationType === \"save\" ||\n                    operationType === \"soft-remove\" ||\n                    operationType === \"recover\"\n                ) {\n                    subjectGroup.subjects.forEach((subject) => {\n                        // gets all relation property paths that exist in the persisted entity.\n                        subject.metadata.relations.forEach((relation) => {\n                            const value = relation.getEntityValue(\n                                subject.entityWithFulfilledIds!,\n                            )\n                            if (value === undefined) return\n\n                            if (\n                                loadRelationPropertyPaths.indexOf(\n                                    relation.propertyPath,\n                                ) === -1\n                            )\n                                loadRelationPropertyPaths.push(\n                                    relation.propertyPath,\n                                )\n                        })\n                    })\n                } else {\n                    // remove\n\n                    // for remove operation\n                    // we only need to load junction relation ids since only they are removed by cascades\n                    loadRelationPropertyPaths.push(\n                        ...subjectGroup.subjects[0].metadata.manyToManyRelations.map(\n                            (relation) => relation.propertyPath,\n                        ),\n                    )\n                }\n\n                const findOptions: FindManyOptions<any> = {\n                    loadEagerRelations: false,\n                    loadRelationIds: {\n                        relations: loadRelationPropertyPaths,\n                        disableMixedMap: true,\n                    },\n                    // the soft-deleted entities should be included in the loaded entities for recover operation\n                    withDeleted: true,\n                }\n\n                // load database entities for all given ids\n                let entities: any[] = []\n                if (\n                    this.queryRunner.connection.driver.options.type ===\n                    \"mongodb\"\n                ) {\n                    const mongoRepo =\n                        this.queryRunner.manager.getRepository<ObjectLiteral>(\n                            subjectGroup.target,\n                        ) as MongoRepository<ObjectLiteral>\n                    entities = await mongoRepo.findByIds(allIds, findOptions)\n                } else {\n                    entities = await this.queryRunner.manager\n                        .getRepository<ObjectLiteral>(subjectGroup.target)\n                        .createQueryBuilder()\n                        .setFindOptions(findOptions)\n                        .whereInIds(allIds)\n                        .getMany()\n                }\n\n                // now when we have entities we need to find subject of each entity\n                // and insert that entity into database entity of the found subjects\n                entities.forEach((entity) => {\n                    const subjects = this.findByPersistEntityLike(\n                        subjectGroup.target,\n                        entity,\n                    )\n                    subjects.forEach((subject) => {\n                        subject.databaseEntity = entity\n                        if (!subject.identifier)\n                            subject.identifier =\n                                subject.metadata.hasAllPrimaryKeys(entity)\n                                    ? subject.metadata.getEntityIdMap(entity)\n                                    : undefined\n                    })\n                })\n\n                // this way we tell what subjects we tried to load database entities of\n                for (let subject of allSubjects) {\n                    subject.databaseEntityLoaded = true\n                }\n            },\n        )\n\n        await Promise.all(promises)\n    }\n\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Finds subjects where entity like given subject's entity.\n     * Comparison made by entity id.\n     * Multiple subjects may be returned if duplicates are present in the subject array.\n     * This will likely result in the same row being updated multiple times during a transaction.\n     */\n    protected findByPersistEntityLike(\n        entityTarget: Function | string,\n        entity: ObjectLiteral,\n    ): Subject[] {\n        return this.subjects.filter((subject) => {\n            if (!subject.entity) return false\n\n            if (subject.entity === entity) return true\n\n            return (\n                subject.metadata.target === entityTarget &&\n                subject.metadata.compareEntities(\n                    subject.entityWithFulfilledIds!,\n                    entity,\n                )\n            )\n        })\n    }\n\n    /**\n     * Groups given Subject objects into groups separated by entity targets.\n     */\n    protected groupByEntityTargets(): {\n        target: Function | string\n        subjects: Subject[]\n    }[] {\n        return this.subjects.reduce((groups, operatedEntity) => {\n            let group = groups.find(\n                (group) => group.target === operatedEntity.metadata.target,\n            )\n            if (!group) {\n                group = { target: operatedEntity.metadata.target, subjects: [] }\n                groups.push(group)\n            }\n            group.subjects.push(operatedEntity)\n            return groups\n        }, [] as { target: Function | string; subjects: Subject[] }[])\n    }\n}\n"],"mappings":"AAMA;;;;;;AAMA,OAAM,MAAOA,2BAA2B;EACpC;EACA;EACA;EAEAC,YACcC,WAAwB,EACxBC,QAAmB;IADnB,KAAAD,WAAW,GAAXA,WAAW;IACX,KAAAC,QAAQ,GAARA,QAAQ;EACnB;EAEH;EACA;EACA;EAEA;;;;;;EAMA,MAAMC,IAAIA,CACNC,aAA4D;IAE5D;IACA;IACA,MAAMC,QAAQ,GAAG,IAAI,CAACC,oBAAoB,EAAE,CAACC,GAAG,CAC5C,MAAOC,YAAY,IAAI;MACnB;MACA,MAAMC,MAAM,GAAoB,EAAE;MAClC,MAAMC,WAAW,GAAc,EAAE;MACjCF,YAAY,CAACN,QAAQ,CAACS,OAAO,CAAEC,OAAO,IAAI;QACtC;QACA,IAAIA,OAAO,CAACC,cAAc,IAAI,CAACD,OAAO,CAACE,UAAU,EAAE;QAEnDL,MAAM,CAACM,IAAI,CAACH,OAAO,CAACE,UAAU,CAAC;QAC/BJ,WAAW,CAACK,IAAI,CAACH,OAAO,CAAC;MAC7B,CAAC,CAAC;MAEF;MACA,IAAI,CAACH,MAAM,CAACO,MAAM,EAAE;MAEpB,MAAMC,yBAAyB,GAAa,EAAE;MAE9C;MACA;MACA;MACA;MACA;MACA,IACIb,aAAa,KAAK,MAAM,IACxBA,aAAa,KAAK,aAAa,IAC/BA,aAAa,KAAK,SAAS,EAC7B;QACEI,YAAY,CAACN,QAAQ,CAACS,OAAO,CAAEC,OAAO,IAAI;UACtC;UACAA,OAAO,CAACM,QAAQ,CAACC,SAAS,CAACR,OAAO,CAAES,QAAQ,IAAI;YAC5C,MAAMC,KAAK,GAAGD,QAAQ,CAACE,cAAc,CACjCV,OAAO,CAACW,sBAAuB,CAClC;YACD,IAAIF,KAAK,KAAKG,SAAS,EAAE;YAEzB,IACIP,yBAAyB,CAACQ,OAAO,CAC7BL,QAAQ,CAACM,YAAY,CACxB,KAAK,CAAC,CAAC,EAERT,yBAAyB,CAACF,IAAI,CAC1BK,QAAQ,CAACM,YAAY,CACxB;UACT,CAAC,CAAC;QACN,CAAC,CAAC;MACN,CAAC,MAAM;QACH;QAEA;QACA;QACAT,yBAAyB,CAACF,IAAI,CAC1B,GAAGP,YAAY,CAACN,QAAQ,CAAC,CAAC,CAAC,CAACgB,QAAQ,CAACS,mBAAmB,CAACpB,GAAG,CACvDa,QAAQ,IAAKA,QAAQ,CAACM,YAAY,CACtC,CACJ;MACL;MAEA,MAAME,WAAW,GAAyB;QACtCC,kBAAkB,EAAE,KAAK;QACzBC,eAAe,EAAE;UACbX,SAAS,EAAEF,yBAAyB;UACpCc,eAAe,EAAE;SACpB;QACD;QACAC,WAAW,EAAE;OAChB;MAED;MACA,IAAIC,QAAQ,GAAU,EAAE;MACxB,IACI,IAAI,CAAChC,WAAW,CAACiC,UAAU,CAACC,MAAM,CAACC,OAAO,CAACC,IAAI,KAC/C,SAAS,EACX;QACE,MAAMC,SAAS,GACX,IAAI,CAACrC,WAAW,CAACsC,OAAO,CAACC,aAAa,CAClChC,YAAY,CAACiC,MAAM,CACY;QACvCR,QAAQ,GAAG,MAAMK,SAAS,CAACI,SAAS,CAACjC,MAAM,EAAEmB,WAAW,CAAC;MAC7D,CAAC,MAAM;QACHK,QAAQ,GAAG,MAAM,IAAI,CAAChC,WAAW,CAACsC,OAAO,CACpCC,aAAa,CAAgBhC,YAAY,CAACiC,MAAM,CAAC,CACjDE,kBAAkB,EAAE,CACpBC,cAAc,CAAChB,WAAW,CAAC,CAC3BiB,UAAU,CAACpC,MAAM,CAAC,CAClBqC,OAAO,EAAE;MAClB;MAEA;MACA;MACAb,QAAQ,CAACtB,OAAO,CAAEoC,MAAM,IAAI;QACxB,MAAM7C,QAAQ,GAAG,IAAI,CAAC8C,uBAAuB,CACzCxC,YAAY,CAACiC,MAAM,EACnBM,MAAM,CACT;QACD7C,QAAQ,CAACS,OAAO,CAAEC,OAAO,IAAI;UACzBA,OAAO,CAACC,cAAc,GAAGkC,MAAM;UAC/B,IAAI,CAACnC,OAAO,CAACE,UAAU,EACnBF,OAAO,CAACE,UAAU,GACdF,OAAO,CAACM,QAAQ,CAAC+B,iBAAiB,CAACF,MAAM,CAAC,GACpCnC,OAAO,CAACM,QAAQ,CAACgC,cAAc,CAACH,MAAM,CAAC,GACvCvB,SAAS;QAC3B,CAAC,CAAC;MACN,CAAC,CAAC;MAEF;MACA,KAAK,IAAIZ,OAAO,IAAIF,WAAW,EAAE;QAC7BE,OAAO,CAACuC,oBAAoB,GAAG,IAAI;MACvC;IACJ,CAAC,CACJ;IAED,MAAMC,OAAO,CAACC,GAAG,CAAChD,QAAQ,CAAC;EAC/B;EAEA;EACA;EACA;EAEA;;;;;;EAMU2C,uBAAuBA,CAC7BM,YAA+B,EAC/BP,MAAqB;IAErB,OAAO,IAAI,CAAC7C,QAAQ,CAACqD,MAAM,CAAE3C,OAAO,IAAI;MACpC,IAAI,CAACA,OAAO,CAACmC,MAAM,EAAE,OAAO,KAAK;MAEjC,IAAInC,OAAO,CAACmC,MAAM,KAAKA,MAAM,EAAE,OAAO,IAAI;MAE1C,OACInC,OAAO,CAACM,QAAQ,CAACuB,MAAM,KAAKa,YAAY,IACxC1C,OAAO,CAACM,QAAQ,CAACsC,eAAe,CAC5B5C,OAAO,CAACW,sBAAuB,EAC/BwB,MAAM,CACT;IAET,CAAC,CAAC;EACN;EAEA;;;EAGUzC,oBAAoBA,CAAA;IAI1B,OAAO,IAAI,CAACJ,QAAQ,CAACuD,MAAM,CAAC,CAACC,MAAM,EAAEC,cAAc,KAAI;MACnD,IAAIC,KAAK,GAAGF,MAAM,CAACG,IAAI,CAClBD,KAAK,IAAKA,KAAK,CAACnB,MAAM,KAAKkB,cAAc,CAACzC,QAAQ,CAACuB,MAAM,CAC7D;MACD,IAAI,CAACmB,KAAK,EAAE;QACRA,KAAK,GAAG;UAAEnB,MAAM,EAAEkB,cAAc,CAACzC,QAAQ,CAACuB,MAAM;UAAEvC,QAAQ,EAAE;QAAE,CAAE;QAChEwD,MAAM,CAAC3C,IAAI,CAAC6C,KAAK,CAAC;MACtB;MACAA,KAAK,CAAC1D,QAAQ,CAACa,IAAI,CAAC4C,cAAc,CAAC;MACnC,OAAOD,MAAM;IACjB,CAAC,EAAE,EAA0D,CAAC;EAClE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}