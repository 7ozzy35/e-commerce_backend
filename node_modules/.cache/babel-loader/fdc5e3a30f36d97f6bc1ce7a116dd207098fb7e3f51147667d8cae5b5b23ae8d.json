{"ast":null,"code":"import { getMetadataArgsStorage } from \"../../globals\";\n/**\n * A one-to-many relation allows creating the type of relation where Entity1 can have multiple instances of Entity2,\n * but Entity2 has only one Entity1. Entity2 is the owner of the relationship, and stores the id of Entity1 on its\n * side of the relation.\n */\nexport function OneToMany(typeFunctionOrTarget, inverseSide, options) {\n  return function (object, propertyName) {\n    if (!options) options = {};\n    // Now try to determine if it is a lazy relation.\n    let isLazy = options && options.lazy === true;\n    if (!isLazy && Reflect && Reflect.getMetadata) {\n      // automatic determination\n      const reflectedType = Reflect.getMetadata(\"design:type\", object, propertyName);\n      if (reflectedType && typeof reflectedType.name === \"string\" && reflectedType.name.toLowerCase() === \"promise\") isLazy = true;\n    }\n    getMetadataArgsStorage().relations.push({\n      target: object.constructor,\n      propertyName: propertyName,\n      // propertyType: reflectedType,\n      isLazy: isLazy,\n      relationType: \"one-to-many\",\n      type: typeFunctionOrTarget,\n      inverseSideProperty: inverseSide,\n      options: options\n    });\n  };\n}","map":{"version":3,"names":["getMetadataArgsStorage","OneToMany","typeFunctionOrTarget","inverseSide","options","object","propertyName","isLazy","lazy","Reflect","getMetadata","reflectedType","name","toLowerCase","relations","push","target","constructor","relationType","type","inverseSideProperty"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\decorator\\relations\\OneToMany.ts"],"sourcesContent":["import { getMetadataArgsStorage } from \"../../globals\"\nimport { RelationMetadataArgs } from \"../../metadata-args/RelationMetadataArgs\"\nimport { ObjectType } from \"../../common/ObjectType\"\nimport { RelationOptions } from \"../options/RelationOptions\"\n\n/**\n * A one-to-many relation allows creating the type of relation where Entity1 can have multiple instances of Entity2,\n * but Entity2 has only one Entity1. Entity2 is the owner of the relationship, and stores the id of Entity1 on its\n * side of the relation.\n */\nexport function OneToMany<T>(\n    typeFunctionOrTarget: string | ((type?: any) => ObjectType<T>),\n    inverseSide: string | ((object: T) => any),\n    options?: RelationOptions,\n): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        if (!options) options = {} as RelationOptions\n\n        // Now try to determine if it is a lazy relation.\n        let isLazy = options && options.lazy === true\n        if (!isLazy && Reflect && (Reflect as any).getMetadata) {\n            // automatic determination\n            const reflectedType = (Reflect as any).getMetadata(\n                \"design:type\",\n                object,\n                propertyName,\n            )\n            if (\n                reflectedType &&\n                typeof reflectedType.name === \"string\" &&\n                reflectedType.name.toLowerCase() === \"promise\"\n            )\n                isLazy = true\n        }\n\n        getMetadataArgsStorage().relations.push({\n            target: object.constructor,\n            propertyName: propertyName,\n            // propertyType: reflectedType,\n            isLazy: isLazy,\n            relationType: \"one-to-many\",\n            type: typeFunctionOrTarget,\n            inverseSideProperty: inverseSide,\n            options: options,\n        } as RelationMetadataArgs)\n    }\n}\n"],"mappings":"AAAA,SAASA,sBAAsB,QAAQ,eAAe;AAKtD;;;;;AAKA,OAAM,SAAUC,SAASA,CACrBC,oBAA8D,EAC9DC,WAA0C,EAC1CC,OAAyB;EAEzB,OAAO,UAAUC,MAAc,EAAEC,YAAoB;IACjD,IAAI,CAACF,OAAO,EAAEA,OAAO,GAAG,EAAqB;IAE7C;IACA,IAAIG,MAAM,GAAGH,OAAO,IAAIA,OAAO,CAACI,IAAI,KAAK,IAAI;IAC7C,IAAI,CAACD,MAAM,IAAIE,OAAO,IAAKA,OAAe,CAACC,WAAW,EAAE;MACpD;MACA,MAAMC,aAAa,GAAIF,OAAe,CAACC,WAAW,CAC9C,aAAa,EACbL,MAAM,EACNC,YAAY,CACf;MACD,IACIK,aAAa,IACb,OAAOA,aAAa,CAACC,IAAI,KAAK,QAAQ,IACtCD,aAAa,CAACC,IAAI,CAACC,WAAW,EAAE,KAAK,SAAS,EAE9CN,MAAM,GAAG,IAAI;IACrB;IAEAP,sBAAsB,EAAE,CAACc,SAAS,CAACC,IAAI,CAAC;MACpCC,MAAM,EAAEX,MAAM,CAACY,WAAW;MAC1BX,YAAY,EAAEA,YAAY;MAC1B;MACAC,MAAM,EAAEA,MAAM;MACdW,YAAY,EAAE,aAAa;MAC3BC,IAAI,EAAEjB,oBAAoB;MAC1BkB,mBAAmB,EAAEjB,WAAW;MAChCC,OAAO,EAAEA;KACY,CAAC;EAC9B,CAAC;AACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}