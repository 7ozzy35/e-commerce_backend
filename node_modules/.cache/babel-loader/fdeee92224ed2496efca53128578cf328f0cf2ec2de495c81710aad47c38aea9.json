{"ast":null,"code":"import { CannotCreateEntityIdMapError } from \"../error/CannotCreateEntityIdMapError\";\nimport { OrmUtils } from \"../util/OrmUtils\";\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { shorten } from \"../util/StringUtils\";\n/**\n * Contains all entity metadata.\n */\nexport class EntityMetadata {\n  // ---------------------------------------------------------------------\n  // Constructor\n  // ---------------------------------------------------------------------\n  constructor(options) {\n    this[\"@instanceof\"] = Symbol.for(\"EntityMetadata\");\n    /**\n     * Children entity metadatas. Used in inheritance patterns.\n     */\n    this.childEntityMetadatas = [];\n    /**\n     * All \"inheritance tree\" from a target entity.\n     * For example for target Post < ContentModel < Unit it will be an array of [Post, ContentModel, Unit].\n     * It also contains child entities for single table inheritance.\n     */\n    this.inheritanceTree = [];\n    /**\n     * Table type. Tables can be closure, junction, etc.\n     */\n    this.tableType = \"regular\";\n    /**\n     * Enables Sqlite \"WITHOUT ROWID\" modifier for the \"CREATE TABLE\" statement\n     */\n    this.withoutRowid = false;\n    /**\n     * Indicates if schema will be synchronized for this entity or not.\n     */\n    this.synchronize = true;\n    /**\n     * Checks if there any non-nullable column exist in this entity.\n     */\n    this.hasNonNullableRelations = false;\n    /**\n     * Indicates if this entity metadata of a junction table, or not.\n     * Junction table is a table created by many-to-many relationship.\n     *\n     * Its also possible to understand if entity is junction via tableType.\n     */\n    this.isJunction = false;\n    /**\n     * Indicates if the entity should be instantiated using the constructor\n     * or via allocating a new object via `Object.create()`.\n     */\n    this.isAlwaysUsingConstructor = true;\n    /**\n     * Checks if this table is a junction table of the closure table.\n     * This type is for tables that contain junction metadata of the closure tables.\n     */\n    this.isClosureJunction = false;\n    /**\n     * Checks if entity's table has multiple primary columns.\n     */\n    this.hasMultiplePrimaryKeys = false;\n    /**\n     * Indicates if this entity metadata has uuid generated columns.\n     */\n    this.hasUUIDGeneratedColumns = false;\n    /**\n     * Entity's column metadatas defined by user.\n     */\n    this.ownColumns = [];\n    /**\n     * Columns of the entity, including columns that are coming from the embeddeds of this entity.\n     */\n    this.columns = [];\n    /**\n     * Ancestor columns used only in closure junction tables.\n     */\n    this.ancestorColumns = [];\n    /**\n     * Descendant columns used only in closure junction tables.\n     */\n    this.descendantColumns = [];\n    /**\n     * All columns except for virtual columns.\n     */\n    this.nonVirtualColumns = [];\n    /**\n     * In the case if this entity metadata is junction table's entity metadata,\n     * this will contain all referenced columns of owner entity.\n     */\n    this.ownerColumns = [];\n    /**\n     * In the case if this entity metadata is junction table's entity metadata,\n     * this will contain all referenced columns of inverse entity.\n     */\n    this.inverseColumns = [];\n    /**\n     * Gets the column with generated flag.\n     */\n    this.generatedColumns = [];\n    /**\n     * Gets the primary columns.\n     */\n    this.primaryColumns = [];\n    /**\n     * Entity's relation metadatas.\n     */\n    this.ownRelations = [];\n    /**\n     * Relations of the entity, including relations that are coming from the embeddeds of this entity.\n     */\n    this.relations = [];\n    /**\n     * List of eager relations this metadata has.\n     */\n    this.eagerRelations = [];\n    /**\n     * List of eager relations this metadata has.\n     */\n    this.lazyRelations = [];\n    /**\n     * Gets only one-to-one relations of the entity.\n     */\n    this.oneToOneRelations = [];\n    /**\n     * Gets only owner one-to-one relations of the entity.\n     */\n    this.ownerOneToOneRelations = [];\n    /**\n     * Gets only one-to-many relations of the entity.\n     */\n    this.oneToManyRelations = [];\n    /**\n     * Gets only many-to-one relations of the entity.\n     */\n    this.manyToOneRelations = [];\n    /**\n     * Gets only many-to-many relations of the entity.\n     */\n    this.manyToManyRelations = [];\n    /**\n     * Gets only owner many-to-many relations of the entity.\n     */\n    this.ownerManyToManyRelations = [];\n    /**\n     * Gets only owner one-to-one and many-to-one relations.\n     */\n    this.relationsWithJoinColumns = [];\n    /**\n     * Entity's relation id metadatas.\n     */\n    this.relationIds = [];\n    /**\n     * Entity's relation id metadatas.\n     */\n    this.relationCounts = [];\n    /**\n     * Entity's foreign key metadatas.\n     */\n    this.foreignKeys = [];\n    /**\n     * Entity's embedded metadatas.\n     */\n    this.embeddeds = [];\n    /**\n     * All embeddeds - embeddeds from this entity metadata and from all child embeddeds, etc.\n     */\n    this.allEmbeddeds = [];\n    /**\n     * Entity's own indices.\n     */\n    this.ownIndices = [];\n    /**\n     * Entity's index metadatas.\n     */\n    this.indices = [];\n    /**\n     * Entity's unique metadatas.\n     */\n    this.uniques = [];\n    /**\n     * Entity's own uniques.\n     */\n    this.ownUniques = [];\n    /**\n     * Entity's check metadatas.\n     */\n    this.checks = [];\n    /**\n     * Entity's exclusion metadatas.\n     */\n    this.exclusions = [];\n    /**\n     * Entity's own listener metadatas.\n     */\n    this.ownListeners = [];\n    /**\n     * Entity listener metadatas.\n     */\n    this.listeners = [];\n    /**\n     * Listener metadatas with \"AFTER LOAD\" type.\n     */\n    this.afterLoadListeners = [];\n    /**\n     * Listener metadatas with \"BEFORE INSERT\" type.\n     */\n    this.beforeInsertListeners = [];\n    /**\n     * Listener metadatas with \"AFTER INSERT\" type.\n     */\n    this.afterInsertListeners = [];\n    /**\n     * Listener metadatas with \"BEFORE UPDATE\" type.\n     */\n    this.beforeUpdateListeners = [];\n    /**\n     * Listener metadatas with \"AFTER UPDATE\" type.\n     */\n    this.afterUpdateListeners = [];\n    /**\n     * Listener metadatas with \"BEFORE REMOVE\" type.\n     */\n    this.beforeRemoveListeners = [];\n    /**\n     * Listener metadatas with \"BEFORE SOFT REMOVE\" type.\n     */\n    this.beforeSoftRemoveListeners = [];\n    /**\n     * Listener metadatas with \"BEFORE RECOVER\" type.\n     */\n    this.beforeRecoverListeners = [];\n    /**\n     * Listener metadatas with \"AFTER REMOVE\" type.\n     */\n    this.afterRemoveListeners = [];\n    /**\n     * Listener metadatas with \"AFTER SOFT REMOVE\" type.\n     */\n    this.afterSoftRemoveListeners = [];\n    /**\n     * Listener metadatas with \"AFTER RECOVER\" type.\n     */\n    this.afterRecoverListeners = [];\n    this.connection = options.connection;\n    this.inheritanceTree = options.inheritanceTree || [];\n    this.inheritancePattern = options.inheritancePattern;\n    this.treeType = options.tableTree ? options.tableTree.type : undefined;\n    this.treeOptions = options.tableTree ? options.tableTree.options : undefined;\n    this.parentClosureEntityMetadata = options.parentClosureEntityMetadata;\n    this.tableMetadataArgs = options.args;\n    this.target = this.tableMetadataArgs.target;\n    this.tableType = this.tableMetadataArgs.type;\n    this.expression = this.tableMetadataArgs.expression;\n    this.withoutRowid = this.tableMetadataArgs.withoutRowid;\n    this.dependsOn = this.tableMetadataArgs.dependsOn;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates a new entity.\n   */\n  create(queryRunner, options) {\n    const pojo = options && options.pojo === true ? true : false;\n    // if target is set to a function (e.g. class) that can be created then create it\n    let ret;\n    if (typeof this.target === \"function\" && !pojo) {\n      if (!options?.fromDeserializer || this.isAlwaysUsingConstructor) {\n        ret = new this.target();\n      } else {\n        ret = Object.create(this.target.prototype);\n      }\n    } else {\n      // otherwise simply return a new empty object\n      ret = {};\n    }\n    // add \"typename\" property\n    if (this.connection.options.typename) {\n      ret[this.connection.options.typename] = this.targetName;\n    }\n    this.lazyRelations.forEach(relation => this.connection.relationLoader.enableLazyLoad(relation, ret, queryRunner));\n    return ret;\n  }\n  /**\n   * Checks if given entity has an id.\n   */\n  hasId(entity) {\n    if (!entity) return false;\n    return this.primaryColumns.every(primaryColumn => {\n      const value = primaryColumn.getEntityValue(entity);\n      return value !== null && value !== undefined && value !== \"\";\n    });\n  }\n  /**\n   * Checks if given entity / object contains ALL primary keys entity must have.\n   * Returns true if it contains all of them, false if at least one of them is not defined.\n   */\n  hasAllPrimaryKeys(entity) {\n    return this.primaryColumns.every(primaryColumn => {\n      const value = primaryColumn.getEntityValue(entity);\n      return value !== null && value !== undefined;\n    });\n  }\n  /**\n   * Ensures that given object is an entity id map.\n   * If given id is an object then it means its already id map.\n   * If given id isn't an object then it means its a value of the id column\n   * and it creates a new id map with this value and name of the primary column.\n   */\n  ensureEntityIdMap(id) {\n    if (ObjectUtils.isObject(id)) return id;\n    if (this.hasMultiplePrimaryKeys) throw new CannotCreateEntityIdMapError(this, id);\n    return this.primaryColumns[0].createValueMap(id);\n  }\n  /**\n   * Gets primary keys of the entity and returns them in a literal object.\n   * For example, for Post{ id: 1, title: \"hello\" } where id is primary it will return { id: 1 }\n   * For multiple primary keys it returns multiple keys in object.\n   * For primary keys inside embeds it returns complex object literal with keys in them.\n   */\n  getEntityIdMap(entity) {\n    if (!entity) return undefined;\n    return EntityMetadata.getValueMap(entity, this.primaryColumns, {\n      skipNulls: true\n    });\n  }\n  /**\n   * Creates a \"mixed id map\".\n   * If entity has multiple primary keys (ids) then it will return just regular id map, like what getEntityIdMap returns.\n   * But if entity has a single primary key then it will return just value of the id column of the entity, just value.\n   * This is called mixed id map.\n   */\n  getEntityIdMixedMap(entity) {\n    if (!entity) return entity;\n    const idMap = this.getEntityIdMap(entity);\n    if (this.hasMultiplePrimaryKeys) {\n      return idMap;\n    } else if (idMap) {\n      return this.primaryColumns[0].getEntityValue(idMap); // todo: what about parent primary column?\n    }\n    return idMap;\n  }\n  /**\n   * Compares two different entities by their ids.\n   * Returns true if they match, false otherwise.\n   */\n  compareEntities(firstEntity, secondEntity) {\n    const firstEntityIdMap = this.getEntityIdMap(firstEntity);\n    if (!firstEntityIdMap) return false;\n    const secondEntityIdMap = this.getEntityIdMap(secondEntity);\n    if (!secondEntityIdMap) return false;\n    return OrmUtils.compareIds(firstEntityIdMap, secondEntityIdMap);\n  }\n  /**\n   * Finds column with a given property name.\n   */\n  findColumnWithPropertyName(propertyName) {\n    return this.columns.find(column => column.propertyName === propertyName);\n  }\n  /**\n   * Finds column with a given database name.\n   */\n  findColumnWithDatabaseName(databaseName) {\n    return this.columns.find(column => column.databaseName === databaseName);\n  }\n  /**\n   * Checks if there is a column or relationship with a given property path.\n   */\n  hasColumnWithPropertyPath(propertyPath) {\n    const hasColumn = this.columns.some(column => column.propertyPath === propertyPath);\n    return hasColumn || this.hasRelationWithPropertyPath(propertyPath);\n  }\n  /**\n   * Finds column with a given property path.\n   */\n  findColumnWithPropertyPath(propertyPath) {\n    const column = this.columns.find(column => column.propertyPath === propertyPath);\n    if (column) return column;\n    // in the case if column with property path was not found, try to find a relation with such property path\n    // if we find relation and it has a single join column then its the column user was seeking\n    const relation = this.relations.find(relation => relation.propertyPath === propertyPath);\n    if (relation && relation.joinColumns.length === 1) return relation.joinColumns[0];\n    return undefined;\n  }\n  /**\n   * Finds column with a given property path.\n   * Does not search in relation unlike findColumnWithPropertyPath.\n   */\n  findColumnWithPropertyPathStrict(propertyPath) {\n    return this.columns.find(column => column.propertyPath === propertyPath);\n  }\n  /**\n   * Finds columns with a given property path.\n   * Property path can match a relation, and relations can contain multiple columns.\n   */\n  findColumnsWithPropertyPath(propertyPath) {\n    const column = this.columns.find(column => column.propertyPath === propertyPath);\n    if (column) return [column];\n    // in the case if column with property path was not found, try to find a relation with such property path\n    // if we find relation and it has a single join column then its the column user was seeking\n    const relation = this.findRelationWithPropertyPath(propertyPath);\n    if (relation && relation.joinColumns) return relation.joinColumns;\n    return [];\n  }\n  /**\n   * Checks if there is a relation with the given property path.\n   */\n  hasRelationWithPropertyPath(propertyPath) {\n    return this.relations.some(relation => relation.propertyPath === propertyPath);\n  }\n  /**\n   * Finds relation with the given property path.\n   */\n  findRelationWithPropertyPath(propertyPath) {\n    return this.relations.find(relation => relation.propertyPath === propertyPath);\n  }\n  /**\n   * Checks if there is an embedded with a given property path.\n   */\n  hasEmbeddedWithPropertyPath(propertyPath) {\n    return this.allEmbeddeds.some(embedded => embedded.propertyPath === propertyPath);\n  }\n  /**\n   * Finds embedded with a given property path.\n   */\n  findEmbeddedWithPropertyPath(propertyPath) {\n    return this.allEmbeddeds.find(embedded => embedded.propertyPath === propertyPath);\n  }\n  /**\n   * Returns an array of databaseNames mapped from provided propertyPaths\n   */\n  mapPropertyPathsToColumns(propertyPaths) {\n    return propertyPaths.map(propertyPath => {\n      const column = this.findColumnWithPropertyPath(propertyPath);\n      if (column == null) {\n        throw new EntityPropertyNotFoundError(propertyPath, this);\n      }\n      return column;\n    });\n  }\n  /**\n   * Iterates through entity and finds and extracts all values from relations in the entity.\n   * If relation value is an array its being flattened.\n   */\n  extractRelationValuesFromEntity(entity, relations) {\n    const relationsAndValues = [];\n    relations.forEach(relation => {\n      const value = relation.getEntityValue(entity);\n      if (Array.isArray(value)) {\n        value.forEach(subValue => relationsAndValues.push([relation, subValue, EntityMetadata.getInverseEntityMetadata(subValue, relation)]));\n      } else if (value) {\n        relationsAndValues.push([relation, value, EntityMetadata.getInverseEntityMetadata(value, relation)]);\n      }\n    });\n    return relationsAndValues;\n  }\n  /**\n   * In the case of SingleTableInheritance, find the correct metadata\n   * for a given value.\n   *\n   * @param value The value to find the metadata for.\n   * @returns The found metadata for the entity or the base metadata if no matching metadata\n   *          was found in the whole inheritance tree.\n   */\n  findInheritanceMetadata(value) {\n    // Check for single table inheritance and find the correct metadata in that case.\n    // Goal is to use the correct discriminator as we could have a repository\n    // for an (abstract) base class and thus the target would not match.\n    if (this.inheritancePattern === \"STI\" && this.childEntityMetadatas.length > 0) {\n      // There could be a column on the base class that can manually be set to override the type.\n      let manuallySetDiscriminatorValue;\n      if (this.discriminatorColumn) {\n        manuallySetDiscriminatorValue = value[this.discriminatorColumn.propertyName];\n      }\n      return this.childEntityMetadatas.find(meta => manuallySetDiscriminatorValue === meta.discriminatorValue || value.constructor === meta.target) || this;\n    }\n    return this;\n  }\n  // -------------------------------------------------------------------------\n  // Private Static Methods\n  // -------------------------------------------------------------------------\n  static getInverseEntityMetadata(value, relation) {\n    return relation.inverseEntityMetadata.findInheritanceMetadata(value);\n  }\n  // -------------------------------------------------------------------------\n  // Public Static Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates a property paths for a given entity.\n   *\n   * @deprecated\n   */\n  static createPropertyPath(metadata, entity, prefix = \"\") {\n    const paths = [];\n    Object.keys(entity).forEach(key => {\n      // check for function is needed in the cases when createPropertyPath used on values contain a function as a value\n      // example: .update().set({ name: () => `SUBSTR('', 1, 2)` })\n      const parentPath = prefix ? prefix + \".\" + key : key;\n      if (metadata.hasEmbeddedWithPropertyPath(parentPath)) {\n        const subPaths = this.createPropertyPath(metadata, entity[key], parentPath);\n        paths.push(...subPaths);\n      } else {\n        const path = prefix ? prefix + \".\" + key : key;\n        paths.push(path);\n      }\n    });\n    return paths;\n  }\n  /**\n   * Finds difference between two entity id maps.\n   * Returns items that exist in the first array and absent in the second array.\n   */\n  static difference(firstIdMaps, secondIdMaps) {\n    return firstIdMaps.filter(firstIdMap => {\n      return !secondIdMaps.find(secondIdMap => OrmUtils.compareIds(firstIdMap, secondIdMap));\n    });\n  }\n  /**\n   * Creates value map from the given values and columns.\n   * Examples of usages are primary columns map and join columns map.\n   */\n  static getValueMap(entity, columns, options) {\n    return columns.reduce((map, column) => {\n      const value = column.getEntityValueMap(entity, options);\n      // make sure that none of the values of the columns are not missing\n      if (map === undefined || value === null || value === undefined) return undefined;\n      return OrmUtils.mergeDeep(map, value);\n    }, {});\n  }\n  // ---------------------------------------------------------------------\n  // Public Builder Methods\n  // ---------------------------------------------------------------------\n  build() {\n    const namingStrategy = this.connection.namingStrategy;\n    const entityPrefix = this.connection.options.entityPrefix;\n    const entitySkipConstructor = this.connection.options.entitySkipConstructor;\n    this.engine = this.tableMetadataArgs.engine;\n    this.database = this.tableMetadataArgs.type === \"entity-child\" && this.parentEntityMetadata ? this.parentEntityMetadata.database : this.tableMetadataArgs.database;\n    if (this.tableMetadataArgs.schema) {\n      this.schema = this.tableMetadataArgs.schema;\n    } else if (this.tableMetadataArgs.type === \"entity-child\" && this.parentEntityMetadata) {\n      this.schema = this.parentEntityMetadata.schema;\n    } else if (this.connection.options?.hasOwnProperty(\"schema\")) {\n      this.schema = this.connection.options.schema;\n    }\n    this.givenTableName = this.tableMetadataArgs.type === \"entity-child\" && this.parentEntityMetadata ? this.parentEntityMetadata.givenTableName : this.tableMetadataArgs.name;\n    this.synchronize = this.tableMetadataArgs.synchronize === false ? false : true;\n    this.targetName = typeof this.tableMetadataArgs.target === \"function\" ? this.tableMetadataArgs.target.name : this.tableMetadataArgs.target;\n    if (this.tableMetadataArgs.type === \"closure-junction\") {\n      this.tableNameWithoutPrefix = namingStrategy.closureJunctionTableName(this.givenTableName);\n    } else if (this.tableMetadataArgs.type === \"entity-child\" && this.parentEntityMetadata) {\n      this.tableNameWithoutPrefix = namingStrategy.tableName(this.parentEntityMetadata.targetName, this.parentEntityMetadata.givenTableName);\n    } else {\n      this.tableNameWithoutPrefix = namingStrategy.tableName(this.targetName, this.givenTableName);\n      if (this.tableMetadataArgs.type === \"junction\" && this.connection.driver.maxAliasLength && this.connection.driver.maxAliasLength > 0 && this.tableNameWithoutPrefix.length > this.connection.driver.maxAliasLength) {\n        // note: we are not using DriverUtils.buildAlias here because we would like to avoid\n        // hashed table names. However, current algorithm also isn't perfect, but we cannot\n        // change it, since it's a big breaking change. Planned to 0.4.0\n        this.tableNameWithoutPrefix = shorten(this.tableNameWithoutPrefix, {\n          separator: \"_\",\n          segmentLength: 3\n        });\n      }\n    }\n    this.tableName = entityPrefix ? namingStrategy.prefixTableName(entityPrefix, this.tableNameWithoutPrefix) : this.tableNameWithoutPrefix;\n    this.target = this.target ? this.target : this.tableName;\n    this.name = this.targetName ? this.targetName : this.tableName;\n    this.expression = this.tableMetadataArgs.expression;\n    this.withoutRowid = this.tableMetadataArgs.withoutRowid === true ? true : false;\n    this.tablePath = this.connection.driver.buildTableName(this.tableName, this.schema, this.database);\n    this.orderBy = typeof this.tableMetadataArgs.orderBy === \"function\" ? this.tableMetadataArgs.orderBy(this.propertiesMap) : this.tableMetadataArgs.orderBy; // todo: is propertiesMap available here? Looks like its not\n    if (entitySkipConstructor !== undefined) {\n      this.isAlwaysUsingConstructor = !entitySkipConstructor;\n    }\n    this.isJunction = this.tableMetadataArgs.type === \"closure-junction\" || this.tableMetadataArgs.type === \"junction\";\n    this.isClosureJunction = this.tableMetadataArgs.type === \"closure-junction\";\n    this.comment = this.tableMetadataArgs.comment;\n  }\n  /**\n   * Registers a new column in the entity and recomputes all depend properties.\n   */\n  registerColumn(column) {\n    if (this.ownColumns.indexOf(column) !== -1) return;\n    this.ownColumns.push(column);\n    this.columns = this.embeddeds.reduce((columns, embedded) => columns.concat(embedded.columnsFromTree), this.ownColumns);\n    this.primaryColumns = this.columns.filter(column => column.isPrimary);\n    this.hasMultiplePrimaryKeys = this.primaryColumns.length > 1;\n    this.hasUUIDGeneratedColumns = this.columns.filter(column => column.isGenerated || column.generationStrategy === \"uuid\").length > 0;\n    this.propertiesMap = this.createPropertiesMap();\n    if (this.childEntityMetadatas) this.childEntityMetadatas.forEach(entityMetadata => entityMetadata.registerColumn(column));\n  }\n  /**\n   * Creates a special object - all columns and relations of the object (plus columns and relations from embeds)\n   * in a special format - { propertyName: propertyName }.\n   *\n   * example: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }.\n   * This method will create following object:\n   * { id: \"id\", counterEmbed: { count: \"counterEmbed.count\" }, category: \"category\" }\n   */\n  createPropertiesMap() {\n    const map = {};\n    this.columns.forEach(column => OrmUtils.mergeDeep(map, column.createValueMap(column.propertyPath)));\n    this.relations.forEach(relation => OrmUtils.mergeDeep(map, relation.createValueMap(relation.propertyPath)));\n    return map;\n  }\n  /**\n   * Checks if entity has any column which rely on returning data,\n   * e.g. columns with auto generated value, DEFAULT values considered as dependant of returning data.\n   * For example, if we need to have RETURNING after INSERT (or we need returned id for DBs not supporting RETURNING),\n   * it means we cannot execute bulk inserts in some cases.\n   */\n  getInsertionReturningColumns() {\n    return this.columns.filter(column => {\n      return column.default !== undefined || column.asExpression !== undefined || column.isGenerated || column.isCreateDate || column.isUpdateDate || column.isDeleteDate || column.isVersion;\n    });\n  }\n}","map":{"version":3,"names":["CannotCreateEntityIdMapError","OrmUtils","EntityPropertyNotFoundError","ObjectUtils","shorten","EntityMetadata","constructor","options","Symbol","for","childEntityMetadatas","inheritanceTree","tableType","withoutRowid","synchronize","hasNonNullableRelations","isJunction","isAlwaysUsingConstructor","isClosureJunction","hasMultiplePrimaryKeys","hasUUIDGeneratedColumns","ownColumns","columns","ancestorColumns","descendantColumns","nonVirtualColumns","ownerColumns","inverseColumns","generatedColumns","primaryColumns","ownRelations","relations","eagerRelations","lazyRelations","oneToOneRelations","ownerOneToOneRelations","oneToManyRelations","manyToOneRelations","manyToManyRelations","ownerManyToManyRelations","relationsWithJoinColumns","relationIds","relationCounts","foreignKeys","embeddeds","allEmbeddeds","ownIndices","indices","uniques","ownUniques","checks","exclusions","ownListeners","listeners","afterLoadListeners","beforeInsertListeners","afterInsertListeners","beforeUpdateListeners","afterUpdateListeners","beforeRemoveListeners","beforeSoftRemoveListeners","beforeRecoverListeners","afterRemoveListeners","afterSoftRemoveListeners","afterRecoverListeners","connection","inheritancePattern","treeType","tableTree","type","undefined","treeOptions","parentClosureEntityMetadata","tableMetadataArgs","args","target","expression","dependsOn","create","queryRunner","pojo","ret","fromDeserializer","Object","prototype","typename","targetName","forEach","relation","relationLoader","enableLazyLoad","hasId","entity","every","primaryColumn","value","getEntityValue","hasAllPrimaryKeys","ensureEntityIdMap","id","isObject","createValueMap","getEntityIdMap","getValueMap","skipNulls","getEntityIdMixedMap","idMap","compareEntities","firstEntity","secondEntity","firstEntityIdMap","secondEntityIdMap","compareIds","findColumnWithPropertyName","propertyName","find","column","findColumnWithDatabaseName","databaseName","hasColumnWithPropertyPath","propertyPath","hasColumn","some","hasRelationWithPropertyPath","findColumnWithPropertyPath","joinColumns","length","findColumnWithPropertyPathStrict","findColumnsWithPropertyPath","findRelationWithPropertyPath","hasEmbeddedWithPropertyPath","embedded","findEmbeddedWithPropertyPath","mapPropertyPathsToColumns","propertyPaths","map","extractRelationValuesFromEntity","relationsAndValues","Array","isArray","subValue","push","getInverseEntityMetadata","findInheritanceMetadata","manuallySetDiscriminatorValue","discriminatorColumn","meta","discriminatorValue","inverseEntityMetadata","createPropertyPath","metadata","prefix","paths","keys","key","parentPath","subPaths","path","difference","firstIdMaps","secondIdMaps","filter","firstIdMap","secondIdMap","reduce","getEntityValueMap","mergeDeep","build","namingStrategy","entityPrefix","entitySkipConstructor","engine","database","parentEntityMetadata","schema","hasOwnProperty","givenTableName","name","tableNameWithoutPrefix","closureJunctionTableName","tableName","driver","maxAliasLength","separator","segmentLength","prefixTableName","tablePath","buildTableName","orderBy","propertiesMap","comment","registerColumn","indexOf","concat","columnsFromTree","isPrimary","isGenerated","generationStrategy","createPropertiesMap","entityMetadata","getInsertionReturningColumns","default","asExpression","isCreateDate","isUpdateDate","isDeleteDate","isVersion"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\metadata\\EntityMetadata.ts"],"sourcesContent":["import { QueryRunner, SelectQueryBuilder } from \"..\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { CannotCreateEntityIdMapError } from \"../error/CannotCreateEntityIdMapError\"\nimport { OrderByCondition } from \"../find-options/OrderByCondition\"\nimport { TableMetadataArgs } from \"../metadata-args/TableMetadataArgs\"\nimport { TreeMetadataArgs } from \"../metadata-args/TreeMetadataArgs\"\nimport { OrmUtils } from \"../util/OrmUtils\"\nimport { CheckMetadata } from \"./CheckMetadata\"\nimport { ColumnMetadata } from \"./ColumnMetadata\"\nimport { EmbeddedMetadata } from \"./EmbeddedMetadata\"\nimport { EntityListenerMetadata } from \"./EntityListenerMetadata\"\nimport { ExclusionMetadata } from \"./ExclusionMetadata\"\nimport { ForeignKeyMetadata } from \"./ForeignKeyMetadata\"\nimport { IndexMetadata } from \"./IndexMetadata\"\nimport { RelationCountMetadata } from \"./RelationCountMetadata\"\nimport { RelationIdMetadata } from \"./RelationIdMetadata\"\nimport { RelationMetadata } from \"./RelationMetadata\"\nimport { TableType } from \"./types/TableTypes\"\nimport { TreeType } from \"./types/TreeTypes\"\nimport { UniqueMetadata } from \"./UniqueMetadata\"\nimport { ClosureTreeOptions } from \"./types/ClosureTreeOptions\"\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { shorten } from \"../util/StringUtils\"\n\n/**\n * Contains all entity metadata.\n */\nexport class EntityMetadata {\n    readonly \"@instanceof\" = Symbol.for(\"EntityMetadata\")\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection where this entity metadata is created.\n     */\n    connection: DataSource\n\n    /**\n     * Metadata arguments used to build this entity metadata.\n     */\n    tableMetadataArgs: TableMetadataArgs\n\n    /**\n     * If entity's table is a closure-typed table, then this entity will have a closure junction table metadata.\n     */\n    closureJunctionTable: EntityMetadata\n\n    /**\n     * If this is entity metadata for a junction closure table then its owner closure table metadata will be set here.\n     */\n    parentClosureEntityMetadata: EntityMetadata\n\n    /**\n     * Parent's entity metadata. Used in inheritance patterns.\n     */\n    parentEntityMetadata: EntityMetadata\n\n    /**\n     * Children entity metadatas. Used in inheritance patterns.\n     */\n    childEntityMetadatas: EntityMetadata[] = []\n\n    /**\n     * All \"inheritance tree\" from a target entity.\n     * For example for target Post < ContentModel < Unit it will be an array of [Post, ContentModel, Unit].\n     * It also contains child entities for single table inheritance.\n     */\n    inheritanceTree: Function[] = []\n\n    /**\n     * Table type. Tables can be closure, junction, etc.\n     */\n    tableType: TableType = \"regular\"\n\n    /**\n     * Target class to which this entity metadata is bind.\n     * Note, that when using table inheritance patterns target can be different rather then table's target.\n     * For virtual tables which lack of real entity (like junction tables) target is equal to their table name.\n     */\n    target: Function | string\n\n    /**\n     * Gets the name of the target.\n     */\n    targetName: string\n\n    /**\n     * Entity's name.\n     * Equal to entity target class's name if target is set to table.\n     * If target class is not then then it equals to table name.\n     */\n    name: string\n\n    /**\n     * View's expression.\n     * Used in views\n     */\n    expression?: string | ((connection: DataSource) => SelectQueryBuilder<any>)\n\n    /**\n     * View's dependencies.\n     * Used in views\n     */\n    dependsOn?: Set<Function | string>\n\n    /**\n     * Enables Sqlite \"WITHOUT ROWID\" modifier for the \"CREATE TABLE\" statement\n     */\n    withoutRowid?: boolean = false\n\n    /**\n     * Original user-given table name (taken from schema or @Entity(tableName) decorator).\n     * If user haven't specified a table name this property will be undefined.\n     */\n    givenTableName?: string\n\n    /**\n     * Entity table name in the database.\n     * This is final table name of the entity.\n     * This name already passed naming strategy, and generated based on\n     * multiple criteria, including user table name and global table prefix.\n     */\n    tableName: string\n\n    /**\n     * Entity table path. Contains database name, schema name and table name.\n     * E.g. myDB.mySchema.myTable\n     */\n    tablePath: string\n\n    /**\n     * Gets the table name without global table prefix.\n     * When querying table you need a table name with prefix, but in some scenarios,\n     * for example when you want to name a junction table that contains names of two other tables,\n     * you may want a table name without prefix.\n     */\n    tableNameWithoutPrefix: string\n\n    /**\n     * Indicates if schema will be synchronized for this entity or not.\n     */\n    synchronize: boolean = true\n\n    /**\n     * Table's database engine type (like \"InnoDB\", \"MyISAM\", etc).\n     */\n    engine?: string\n\n    /**\n     * Database name.\n     */\n    database?: string\n\n    /**\n     * Schema name. Used in Postgres and Sql Server.\n     */\n    schema?: string\n\n    /**\n     * Specifies a default order by used for queries from this table when no explicit order by is specified.\n     */\n    orderBy?: OrderByCondition\n\n    /**\n     * If this entity metadata's table using one of the inheritance patterns,\n     * then this will contain what pattern it uses.\n     */\n    inheritancePattern?: \"STI\" /*|\"CTI\"*/\n\n    /**\n     * Checks if there any non-nullable column exist in this entity.\n     */\n    hasNonNullableRelations: boolean = false\n\n    /**\n     * Indicates if this entity metadata of a junction table, or not.\n     * Junction table is a table created by many-to-many relationship.\n     *\n     * Its also possible to understand if entity is junction via tableType.\n     */\n    isJunction: boolean = false\n\n    /**\n     * Indicates if the entity should be instantiated using the constructor\n     * or via allocating a new object via `Object.create()`.\n     */\n    isAlwaysUsingConstructor: boolean = true\n\n    /**\n     * Indicates if this entity is a tree, what type of tree it is.\n     */\n    treeType?: TreeType\n\n    /**\n     * Indicates if this entity is a tree, what options of tree it has.\n     */\n    treeOptions?: ClosureTreeOptions\n\n    /**\n     * Checks if this table is a junction table of the closure table.\n     * This type is for tables that contain junction metadata of the closure tables.\n     */\n    isClosureJunction: boolean = false\n\n    /**\n     * Checks if entity's table has multiple primary columns.\n     */\n    hasMultiplePrimaryKeys: boolean = false\n\n    /**\n     * Indicates if this entity metadata has uuid generated columns.\n     */\n    hasUUIDGeneratedColumns: boolean = false\n\n    /**\n     * If this entity metadata is a child table of some table, it should have a discriminator value.\n     * Used to store a value in a discriminator column.\n     */\n    discriminatorValue?: string\n\n    /**\n     * Entity's column metadatas defined by user.\n     */\n    ownColumns: ColumnMetadata[] = []\n\n    /**\n     * Columns of the entity, including columns that are coming from the embeddeds of this entity.\n     */\n    columns: ColumnMetadata[] = []\n\n    /**\n     * Ancestor columns used only in closure junction tables.\n     */\n    ancestorColumns: ColumnMetadata[] = []\n\n    /**\n     * Descendant columns used only in closure junction tables.\n     */\n    descendantColumns: ColumnMetadata[] = []\n\n    /**\n     * All columns except for virtual columns.\n     */\n    nonVirtualColumns: ColumnMetadata[] = []\n\n    /**\n     * In the case if this entity metadata is junction table's entity metadata,\n     * this will contain all referenced columns of owner entity.\n     */\n    ownerColumns: ColumnMetadata[] = []\n\n    /**\n     * In the case if this entity metadata is junction table's entity metadata,\n     * this will contain all referenced columns of inverse entity.\n     */\n    inverseColumns: ColumnMetadata[] = []\n\n    /**\n     * Gets the column with generated flag.\n     */\n    generatedColumns: ColumnMetadata[] = []\n\n    /**\n     * Gets the object id column used with mongodb database.\n     */\n    objectIdColumn?: ColumnMetadata\n\n    /**\n     * Gets entity column which contains a create date value.\n     */\n    createDateColumn?: ColumnMetadata\n\n    /**\n     * Gets entity column which contains an update date value.\n     */\n    updateDateColumn?: ColumnMetadata\n\n    /**\n     * Gets entity column which contains a delete date value.\n     */\n    deleteDateColumn?: ColumnMetadata\n\n    /**\n     * Gets entity column which contains an entity version.\n     */\n    versionColumn?: ColumnMetadata\n\n    /**\n     * Gets the discriminator column used to store entity identificator in single-table inheritance tables.\n     */\n    discriminatorColumn?: ColumnMetadata\n\n    /**\n     * Special column that stores tree level in tree entities.\n     */\n    treeLevelColumn?: ColumnMetadata\n\n    /**\n     * Nested set's left value column.\n     * Used only in tree entities with nested set pattern applied.\n     */\n    nestedSetLeftColumn?: ColumnMetadata\n\n    /**\n     * Nested set's right value column.\n     * Used only in tree entities with nested set pattern applied.\n     */\n    nestedSetRightColumn?: ColumnMetadata\n\n    /**\n     * Materialized path column.\n     * Used only in tree entities with materialized path pattern applied.\n     */\n    materializedPathColumn?: ColumnMetadata\n\n    /**\n     * Gets the primary columns.\n     */\n    primaryColumns: ColumnMetadata[] = []\n\n    /**\n     * Entity's relation metadatas.\n     */\n    ownRelations: RelationMetadata[] = []\n\n    /**\n     * Relations of the entity, including relations that are coming from the embeddeds of this entity.\n     */\n    relations: RelationMetadata[] = []\n\n    /**\n     * List of eager relations this metadata has.\n     */\n    eagerRelations: RelationMetadata[] = []\n\n    /**\n     * List of eager relations this metadata has.\n     */\n    lazyRelations: RelationMetadata[] = []\n\n    /**\n     * Gets only one-to-one relations of the entity.\n     */\n    oneToOneRelations: RelationMetadata[] = []\n\n    /**\n     * Gets only owner one-to-one relations of the entity.\n     */\n    ownerOneToOneRelations: RelationMetadata[] = []\n\n    /**\n     * Gets only one-to-many relations of the entity.\n     */\n    oneToManyRelations: RelationMetadata[] = []\n\n    /**\n     * Gets only many-to-one relations of the entity.\n     */\n    manyToOneRelations: RelationMetadata[] = []\n\n    /**\n     * Gets only many-to-many relations of the entity.\n     */\n    manyToManyRelations: RelationMetadata[] = []\n\n    /**\n     * Gets only owner many-to-many relations of the entity.\n     */\n    ownerManyToManyRelations: RelationMetadata[] = []\n\n    /**\n     * Gets only owner one-to-one and many-to-one relations.\n     */\n    relationsWithJoinColumns: RelationMetadata[] = []\n\n    /**\n     * Tree parent relation. Used only in tree-tables.\n     */\n    treeParentRelation?: RelationMetadata\n\n    /**\n     * Tree children relation. Used only in tree-tables.\n     */\n    treeChildrenRelation?: RelationMetadata\n\n    /**\n     * Entity's relation id metadatas.\n     */\n    relationIds: RelationIdMetadata[] = []\n\n    /**\n     * Entity's relation id metadatas.\n     */\n    relationCounts: RelationCountMetadata[] = []\n\n    /**\n     * Entity's foreign key metadatas.\n     */\n    foreignKeys: ForeignKeyMetadata[] = []\n\n    /**\n     * Entity's embedded metadatas.\n     */\n    embeddeds: EmbeddedMetadata[] = []\n\n    /**\n     * All embeddeds - embeddeds from this entity metadata and from all child embeddeds, etc.\n     */\n    allEmbeddeds: EmbeddedMetadata[] = []\n\n    /**\n     * Entity's own indices.\n     */\n    ownIndices: IndexMetadata[] = []\n\n    /**\n     * Entity's index metadatas.\n     */\n    indices: IndexMetadata[] = []\n\n    /**\n     * Entity's unique metadatas.\n     */\n    uniques: UniqueMetadata[] = []\n\n    /**\n     * Entity's own uniques.\n     */\n    ownUniques: UniqueMetadata[] = []\n\n    /**\n     * Entity's check metadatas.\n     */\n    checks: CheckMetadata[] = []\n\n    /**\n     * Entity's exclusion metadatas.\n     */\n    exclusions: ExclusionMetadata[] = []\n\n    /**\n     * Entity's own listener metadatas.\n     */\n    ownListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Entity listener metadatas.\n     */\n    listeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"AFTER LOAD\" type.\n     */\n    afterLoadListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"BEFORE INSERT\" type.\n     */\n    beforeInsertListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"AFTER INSERT\" type.\n     */\n    afterInsertListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"BEFORE UPDATE\" type.\n     */\n    beforeUpdateListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"AFTER UPDATE\" type.\n     */\n    afterUpdateListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"BEFORE REMOVE\" type.\n     */\n    beforeRemoveListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"BEFORE SOFT REMOVE\" type.\n     */\n    beforeSoftRemoveListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"BEFORE RECOVER\" type.\n     */\n    beforeRecoverListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"AFTER REMOVE\" type.\n     */\n    afterRemoveListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"AFTER SOFT REMOVE\" type.\n     */\n    afterSoftRemoveListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"AFTER RECOVER\" type.\n     */\n    afterRecoverListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Map of columns and relations of the entity.\n     *\n     * example: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }.\n     * This method will create following object:\n     * { id: \"id\", counterEmbed: { count: \"counterEmbed.count\" }, category: \"category\" }\n     */\n    propertiesMap: ObjectLiteral\n\n    /**\n     * Table comment. Not supported by all database types.\n     */\n    comment?: string\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(options: {\n        connection: DataSource\n        inheritanceTree?: Function[]\n        inheritancePattern?: \"STI\" /*|\"CTI\"*/\n        tableTree?: TreeMetadataArgs\n        parentClosureEntityMetadata?: EntityMetadata\n        args: TableMetadataArgs\n    }) {\n        this.connection = options.connection\n        this.inheritanceTree = options.inheritanceTree || []\n        this.inheritancePattern = options.inheritancePattern\n        this.treeType = options.tableTree ? options.tableTree.type : undefined\n        this.treeOptions = options.tableTree\n            ? options.tableTree.options\n            : undefined\n        this.parentClosureEntityMetadata = options.parentClosureEntityMetadata!\n        this.tableMetadataArgs = options.args\n        this.target = this.tableMetadataArgs.target\n        this.tableType = this.tableMetadataArgs.type\n        this.expression = this.tableMetadataArgs.expression\n        this.withoutRowid = this.tableMetadataArgs.withoutRowid\n        this.dependsOn = this.tableMetadataArgs.dependsOn\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a new entity.\n     */\n    create(\n        queryRunner?: QueryRunner,\n        options?: { fromDeserializer?: boolean; pojo?: boolean },\n    ): any {\n        const pojo = options && options.pojo === true ? true : false\n        // if target is set to a function (e.g. class) that can be created then create it\n        let ret: any\n        if (typeof this.target === \"function\" && !pojo) {\n            if (!options?.fromDeserializer || this.isAlwaysUsingConstructor) {\n                ret = new (<any>this.target)()\n            } else {\n                ret = Object.create(this.target.prototype)\n            }\n        } else {\n            // otherwise simply return a new empty object\n            ret = {}\n        }\n\n        // add \"typename\" property\n        if (this.connection.options.typename) {\n            ret[this.connection.options.typename] = this.targetName\n        }\n\n        this.lazyRelations.forEach((relation) =>\n            this.connection.relationLoader.enableLazyLoad(\n                relation,\n                ret,\n                queryRunner,\n            ),\n        )\n        return ret\n    }\n\n    /**\n     * Checks if given entity has an id.\n     */\n    hasId(entity: ObjectLiteral): boolean {\n        if (!entity) return false\n\n        return this.primaryColumns.every((primaryColumn) => {\n            const value = primaryColumn.getEntityValue(entity)\n            return value !== null && value !== undefined && value !== \"\"\n        })\n    }\n\n    /**\n     * Checks if given entity / object contains ALL primary keys entity must have.\n     * Returns true if it contains all of them, false if at least one of them is not defined.\n     */\n    hasAllPrimaryKeys(entity: ObjectLiteral): boolean {\n        return this.primaryColumns.every((primaryColumn) => {\n            const value = primaryColumn.getEntityValue(entity)\n            return value !== null && value !== undefined\n        })\n    }\n\n    /**\n     * Ensures that given object is an entity id map.\n     * If given id is an object then it means its already id map.\n     * If given id isn't an object then it means its a value of the id column\n     * and it creates a new id map with this value and name of the primary column.\n     */\n    ensureEntityIdMap(id: any): ObjectLiteral {\n        if (ObjectUtils.isObject(id)) return id\n\n        if (this.hasMultiplePrimaryKeys)\n            throw new CannotCreateEntityIdMapError(this, id)\n\n        return this.primaryColumns[0].createValueMap(id)\n    }\n\n    /**\n     * Gets primary keys of the entity and returns them in a literal object.\n     * For example, for Post{ id: 1, title: \"hello\" } where id is primary it will return { id: 1 }\n     * For multiple primary keys it returns multiple keys in object.\n     * For primary keys inside embeds it returns complex object literal with keys in them.\n     */\n    getEntityIdMap(\n        entity: ObjectLiteral | undefined,\n    ): ObjectLiteral | undefined {\n        if (!entity) return undefined\n\n        return EntityMetadata.getValueMap(entity, this.primaryColumns, {\n            skipNulls: true,\n        })\n    }\n\n    /**\n     * Creates a \"mixed id map\".\n     * If entity has multiple primary keys (ids) then it will return just regular id map, like what getEntityIdMap returns.\n     * But if entity has a single primary key then it will return just value of the id column of the entity, just value.\n     * This is called mixed id map.\n     */\n    getEntityIdMixedMap(\n        entity: ObjectLiteral | undefined,\n    ): ObjectLiteral | undefined {\n        if (!entity) return entity\n\n        const idMap = this.getEntityIdMap(entity)\n        if (this.hasMultiplePrimaryKeys) {\n            return idMap\n        } else if (idMap) {\n            return this.primaryColumns[0].getEntityValue(idMap) // todo: what about parent primary column?\n        }\n\n        return idMap\n    }\n\n    /**\n     * Compares two different entities by their ids.\n     * Returns true if they match, false otherwise.\n     */\n    compareEntities(\n        firstEntity: ObjectLiteral,\n        secondEntity: ObjectLiteral,\n    ): boolean {\n        const firstEntityIdMap = this.getEntityIdMap(firstEntity)\n        if (!firstEntityIdMap) return false\n\n        const secondEntityIdMap = this.getEntityIdMap(secondEntity)\n        if (!secondEntityIdMap) return false\n\n        return OrmUtils.compareIds(firstEntityIdMap, secondEntityIdMap)\n    }\n\n    /**\n     * Finds column with a given property name.\n     */\n    findColumnWithPropertyName(\n        propertyName: string,\n    ): ColumnMetadata | undefined {\n        return this.columns.find(\n            (column) => column.propertyName === propertyName,\n        )\n    }\n\n    /**\n     * Finds column with a given database name.\n     */\n    findColumnWithDatabaseName(\n        databaseName: string,\n    ): ColumnMetadata | undefined {\n        return this.columns.find(\n            (column) => column.databaseName === databaseName,\n        )\n    }\n\n    /**\n     * Checks if there is a column or relationship with a given property path.\n     */\n    hasColumnWithPropertyPath(propertyPath: string): boolean {\n        const hasColumn = this.columns.some(\n            (column) => column.propertyPath === propertyPath,\n        )\n        return hasColumn || this.hasRelationWithPropertyPath(propertyPath)\n    }\n\n    /**\n     * Finds column with a given property path.\n     */\n    findColumnWithPropertyPath(\n        propertyPath: string,\n    ): ColumnMetadata | undefined {\n        const column = this.columns.find(\n            (column) => column.propertyPath === propertyPath,\n        )\n        if (column) return column\n\n        // in the case if column with property path was not found, try to find a relation with such property path\n        // if we find relation and it has a single join column then its the column user was seeking\n        const relation = this.relations.find(\n            (relation) => relation.propertyPath === propertyPath,\n        )\n        if (relation && relation.joinColumns.length === 1)\n            return relation.joinColumns[0]\n\n        return undefined\n    }\n\n    /**\n     * Finds column with a given property path.\n     * Does not search in relation unlike findColumnWithPropertyPath.\n     */\n    findColumnWithPropertyPathStrict(\n        propertyPath: string,\n    ): ColumnMetadata | undefined {\n        return this.columns.find(\n            (column) => column.propertyPath === propertyPath,\n        )\n    }\n\n    /**\n     * Finds columns with a given property path.\n     * Property path can match a relation, and relations can contain multiple columns.\n     */\n    findColumnsWithPropertyPath(propertyPath: string): ColumnMetadata[] {\n        const column = this.columns.find(\n            (column) => column.propertyPath === propertyPath,\n        )\n        if (column) return [column]\n\n        // in the case if column with property path was not found, try to find a relation with such property path\n        // if we find relation and it has a single join column then its the column user was seeking\n        const relation = this.findRelationWithPropertyPath(propertyPath)\n        if (relation && relation.joinColumns) return relation.joinColumns\n\n        return []\n    }\n\n    /**\n     * Checks if there is a relation with the given property path.\n     */\n    hasRelationWithPropertyPath(propertyPath: string): boolean {\n        return this.relations.some(\n            (relation) => relation.propertyPath === propertyPath,\n        )\n    }\n\n    /**\n     * Finds relation with the given property path.\n     */\n    findRelationWithPropertyPath(\n        propertyPath: string,\n    ): RelationMetadata | undefined {\n        return this.relations.find(\n            (relation) => relation.propertyPath === propertyPath,\n        )\n    }\n\n    /**\n     * Checks if there is an embedded with a given property path.\n     */\n    hasEmbeddedWithPropertyPath(propertyPath: string): boolean {\n        return this.allEmbeddeds.some(\n            (embedded) => embedded.propertyPath === propertyPath,\n        )\n    }\n\n    /**\n     * Finds embedded with a given property path.\n     */\n    findEmbeddedWithPropertyPath(\n        propertyPath: string,\n    ): EmbeddedMetadata | undefined {\n        return this.allEmbeddeds.find(\n            (embedded) => embedded.propertyPath === propertyPath,\n        )\n    }\n\n    /**\n     * Returns an array of databaseNames mapped from provided propertyPaths\n     */\n    mapPropertyPathsToColumns(propertyPaths: string[]) {\n        return propertyPaths.map((propertyPath) => {\n            const column = this.findColumnWithPropertyPath(propertyPath)\n            if (column == null) {\n                throw new EntityPropertyNotFoundError(propertyPath, this)\n            }\n            return column\n        })\n    }\n\n    /**\n     * Iterates through entity and finds and extracts all values from relations in the entity.\n     * If relation value is an array its being flattened.\n     */\n    extractRelationValuesFromEntity(\n        entity: ObjectLiteral,\n        relations: RelationMetadata[],\n    ): [RelationMetadata, any, EntityMetadata][] {\n        const relationsAndValues: [RelationMetadata, any, EntityMetadata][] = []\n        relations.forEach((relation) => {\n            const value = relation.getEntityValue(entity)\n            if (Array.isArray(value)) {\n                value.forEach((subValue) =>\n                    relationsAndValues.push([\n                        relation,\n                        subValue,\n                        EntityMetadata.getInverseEntityMetadata(\n                            subValue,\n                            relation,\n                        ),\n                    ]),\n                )\n            } else if (value) {\n                relationsAndValues.push([\n                    relation,\n                    value,\n                    EntityMetadata.getInverseEntityMetadata(value, relation),\n                ])\n            }\n        })\n        return relationsAndValues\n    }\n\n    /**\n     * In the case of SingleTableInheritance, find the correct metadata\n     * for a given value.\n     *\n     * @param value The value to find the metadata for.\n     * @returns The found metadata for the entity or the base metadata if no matching metadata\n     *          was found in the whole inheritance tree.\n     */\n    findInheritanceMetadata(value: any): EntityMetadata {\n        // Check for single table inheritance and find the correct metadata in that case.\n        // Goal is to use the correct discriminator as we could have a repository\n        // for an (abstract) base class and thus the target would not match.\n\n        if (\n            this.inheritancePattern === \"STI\" &&\n            this.childEntityMetadatas.length > 0\n        ) {\n            // There could be a column on the base class that can manually be set to override the type.\n            let manuallySetDiscriminatorValue: unknown\n            if (this.discriminatorColumn) {\n                manuallySetDiscriminatorValue =\n                    value[this.discriminatorColumn.propertyName]\n            }\n            return (\n                this.childEntityMetadatas.find(\n                    (meta) =>\n                        manuallySetDiscriminatorValue ===\n                            meta.discriminatorValue ||\n                        value.constructor === meta.target,\n                ) || this\n            )\n        }\n        return this\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Static Methods\n    // -------------------------------------------------------------------------\n\n    private static getInverseEntityMetadata(\n        value: any,\n        relation: RelationMetadata,\n    ): EntityMetadata {\n        return relation.inverseEntityMetadata.findInheritanceMetadata(value)\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Static Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a property paths for a given entity.\n     *\n     * @deprecated\n     */\n    static createPropertyPath(\n        metadata: EntityMetadata,\n        entity: ObjectLiteral,\n        prefix: string = \"\",\n    ) {\n        const paths: string[] = []\n        Object.keys(entity).forEach((key) => {\n            // check for function is needed in the cases when createPropertyPath used on values contain a function as a value\n            // example: .update().set({ name: () => `SUBSTR('', 1, 2)` })\n            const parentPath = prefix ? prefix + \".\" + key : key\n            if (metadata.hasEmbeddedWithPropertyPath(parentPath)) {\n                const subPaths = this.createPropertyPath(\n                    metadata,\n                    entity[key],\n                    parentPath,\n                )\n                paths.push(...subPaths)\n            } else {\n                const path = prefix ? prefix + \".\" + key : key\n                paths.push(path)\n            }\n        })\n        return paths\n    }\n\n    /**\n     * Finds difference between two entity id maps.\n     * Returns items that exist in the first array and absent in the second array.\n     */\n    static difference(\n        firstIdMaps: ObjectLiteral[],\n        secondIdMaps: ObjectLiteral[],\n    ): ObjectLiteral[] {\n        return firstIdMaps.filter((firstIdMap) => {\n            return !secondIdMaps.find((secondIdMap) =>\n                OrmUtils.compareIds(firstIdMap, secondIdMap),\n            )\n        })\n    }\n\n    /**\n     * Creates value map from the given values and columns.\n     * Examples of usages are primary columns map and join columns map.\n     */\n    static getValueMap(\n        entity: ObjectLiteral,\n        columns: ColumnMetadata[],\n        options?: { skipNulls?: boolean },\n    ): ObjectLiteral | undefined {\n        return columns.reduce((map, column) => {\n            const value = column.getEntityValueMap(entity, options)\n\n            // make sure that none of the values of the columns are not missing\n            if (map === undefined || value === null || value === undefined)\n                return undefined\n\n            return OrmUtils.mergeDeep(map, value)\n        }, {} as ObjectLiteral | undefined)\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Builder Methods\n    // ---------------------------------------------------------------------\n\n    build() {\n        const namingStrategy = this.connection.namingStrategy\n        const entityPrefix = this.connection.options.entityPrefix\n        const entitySkipConstructor =\n            this.connection.options.entitySkipConstructor\n\n        this.engine = this.tableMetadataArgs.engine\n        this.database =\n            this.tableMetadataArgs.type === \"entity-child\" &&\n            this.parentEntityMetadata\n                ? this.parentEntityMetadata.database\n                : this.tableMetadataArgs.database\n        if (this.tableMetadataArgs.schema) {\n            this.schema = this.tableMetadataArgs.schema\n        } else if (\n            this.tableMetadataArgs.type === \"entity-child\" &&\n            this.parentEntityMetadata\n        ) {\n            this.schema = this.parentEntityMetadata.schema\n        } else if (this.connection.options?.hasOwnProperty(\"schema\")) {\n            this.schema = (this.connection.options as any).schema\n        }\n        this.givenTableName =\n            this.tableMetadataArgs.type === \"entity-child\" &&\n            this.parentEntityMetadata\n                ? this.parentEntityMetadata.givenTableName\n                : this.tableMetadataArgs.name\n        this.synchronize =\n            this.tableMetadataArgs.synchronize === false ? false : true\n        this.targetName =\n            typeof this.tableMetadataArgs.target === \"function\"\n                ? (this.tableMetadataArgs.target as any).name\n                : this.tableMetadataArgs.target\n        if (this.tableMetadataArgs.type === \"closure-junction\") {\n            this.tableNameWithoutPrefix =\n                namingStrategy.closureJunctionTableName(this.givenTableName!)\n        } else if (\n            this.tableMetadataArgs.type === \"entity-child\" &&\n            this.parentEntityMetadata\n        ) {\n            this.tableNameWithoutPrefix = namingStrategy.tableName(\n                this.parentEntityMetadata.targetName,\n                this.parentEntityMetadata.givenTableName,\n            )\n        } else {\n            this.tableNameWithoutPrefix = namingStrategy.tableName(\n                this.targetName,\n                this.givenTableName,\n            )\n\n            if (\n                this.tableMetadataArgs.type === \"junction\" &&\n                this.connection.driver.maxAliasLength &&\n                this.connection.driver.maxAliasLength > 0 &&\n                this.tableNameWithoutPrefix.length >\n                    this.connection.driver.maxAliasLength\n            ) {\n                // note: we are not using DriverUtils.buildAlias here because we would like to avoid\n                // hashed table names. However, current algorithm also isn't perfect, but we cannot\n                // change it, since it's a big breaking change. Planned to 0.4.0\n                this.tableNameWithoutPrefix = shorten(\n                    this.tableNameWithoutPrefix,\n                    { separator: \"_\", segmentLength: 3 },\n                )\n            }\n        }\n        this.tableName = entityPrefix\n            ? namingStrategy.prefixTableName(\n                  entityPrefix,\n                  this.tableNameWithoutPrefix,\n              )\n            : this.tableNameWithoutPrefix\n        this.target = this.target ? this.target : this.tableName\n        this.name = this.targetName ? this.targetName : this.tableName\n        this.expression = this.tableMetadataArgs.expression\n        this.withoutRowid =\n            this.tableMetadataArgs.withoutRowid === true ? true : false\n        this.tablePath = this.connection.driver.buildTableName(\n            this.tableName,\n            this.schema,\n            this.database,\n        )\n        this.orderBy =\n            typeof this.tableMetadataArgs.orderBy === \"function\"\n                ? this.tableMetadataArgs.orderBy(this.propertiesMap)\n                : this.tableMetadataArgs.orderBy // todo: is propertiesMap available here? Looks like its not\n\n        if (entitySkipConstructor !== undefined) {\n            this.isAlwaysUsingConstructor = !entitySkipConstructor\n        }\n\n        this.isJunction =\n            this.tableMetadataArgs.type === \"closure-junction\" ||\n            this.tableMetadataArgs.type === \"junction\"\n        this.isClosureJunction =\n            this.tableMetadataArgs.type === \"closure-junction\"\n\n        this.comment = this.tableMetadataArgs.comment\n    }\n\n    /**\n     * Registers a new column in the entity and recomputes all depend properties.\n     */\n    registerColumn(column: ColumnMetadata) {\n        if (this.ownColumns.indexOf(column) !== -1) return\n\n        this.ownColumns.push(column)\n        this.columns = this.embeddeds.reduce(\n            (columns, embedded) => columns.concat(embedded.columnsFromTree),\n            this.ownColumns,\n        )\n        this.primaryColumns = this.columns.filter((column) => column.isPrimary)\n        this.hasMultiplePrimaryKeys = this.primaryColumns.length > 1\n        this.hasUUIDGeneratedColumns =\n            this.columns.filter(\n                (column) =>\n                    column.isGenerated || column.generationStrategy === \"uuid\",\n            ).length > 0\n        this.propertiesMap = this.createPropertiesMap()\n        if (this.childEntityMetadatas)\n            this.childEntityMetadatas.forEach((entityMetadata) =>\n                entityMetadata.registerColumn(column),\n            )\n    }\n\n    /**\n     * Creates a special object - all columns and relations of the object (plus columns and relations from embeds)\n     * in a special format - { propertyName: propertyName }.\n     *\n     * example: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }.\n     * This method will create following object:\n     * { id: \"id\", counterEmbed: { count: \"counterEmbed.count\" }, category: \"category\" }\n     */\n    createPropertiesMap(): { [name: string]: string | any } {\n        const map: { [name: string]: string | any } = {}\n        this.columns.forEach((column) =>\n            OrmUtils.mergeDeep(map, column.createValueMap(column.propertyPath)),\n        )\n        this.relations.forEach((relation) =>\n            OrmUtils.mergeDeep(\n                map,\n                relation.createValueMap(relation.propertyPath),\n            ),\n        )\n        return map\n    }\n\n    /**\n     * Checks if entity has any column which rely on returning data,\n     * e.g. columns with auto generated value, DEFAULT values considered as dependant of returning data.\n     * For example, if we need to have RETURNING after INSERT (or we need returned id for DBs not supporting RETURNING),\n     * it means we cannot execute bulk inserts in some cases.\n     */\n    getInsertionReturningColumns(): ColumnMetadata[] {\n        return this.columns.filter((column) => {\n            return (\n                column.default !== undefined ||\n                column.asExpression !== undefined ||\n                column.isGenerated ||\n                column.isCreateDate ||\n                column.isUpdateDate ||\n                column.isDeleteDate ||\n                column.isVersion\n            )\n        })\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}