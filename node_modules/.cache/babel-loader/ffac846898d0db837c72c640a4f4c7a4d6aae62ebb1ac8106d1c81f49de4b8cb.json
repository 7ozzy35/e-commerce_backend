{"ast":null,"code":"import { OrmUtils } from \"../../util/OrmUtils\";\nimport { NestedSetMultipleRootError } from \"../../error/NestedSetMultipleRootError\";\nclass NestedSetIds {}\n/**\n * Executes subject operations for nested set tree entities.\n */\nexport class NestedSetSubjectExecutor {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(queryRunner) {\n    this.queryRunner = queryRunner;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Executes operations when subject is being inserted.\n   */\n  async insert(subject) {\n    const escape = alias => this.queryRunner.connection.driver.escape(alias);\n    const tableName = this.getTableName(subject.metadata.tablePath);\n    const leftColumnName = escape(subject.metadata.nestedSetLeftColumn.databaseName);\n    const rightColumnName = escape(subject.metadata.nestedSetRightColumn.databaseName);\n    let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent\n    if (!parent && subject.parentSubject && subject.parentSubject.entity)\n      // if entity was attached via children\n      parent = subject.parentSubject.insertedValueSet ? subject.parentSubject.insertedValueSet : subject.parentSubject.entity;\n    const parentId = subject.metadata.getEntityIdMap(parent);\n    let parentNsRight = undefined;\n    if (parentId) {\n      parentNsRight = await this.queryRunner.manager.createQueryBuilder().select(subject.metadata.targetName + \".\" + subject.metadata.nestedSetRightColumn.propertyPath, \"right\").from(subject.metadata.target, subject.metadata.targetName).whereInIds(parentId).getRawOne().then(result => {\n        const value = result ? result[\"right\"] : undefined;\n        // CockroachDB returns numeric types as string\n        return typeof value === \"string\" ? parseInt(value) : value;\n      });\n    }\n    if (parentNsRight !== undefined) {\n      await this.queryRunner.query(`UPDATE ${tableName} SET ` + `${leftColumnName} = CASE WHEN ${leftColumnName} > ${parentNsRight} THEN ${leftColumnName} + 2 ELSE ${leftColumnName} END,` + `${rightColumnName} = ${rightColumnName} + 2 ` + `WHERE ${rightColumnName} >= ${parentNsRight}`);\n      OrmUtils.mergeDeep(subject.insertedValueSet, subject.metadata.nestedSetLeftColumn.createValueMap(parentNsRight), subject.metadata.nestedSetRightColumn.createValueMap(parentNsRight + 1));\n    } else {\n      const isUniqueRoot = await this.isUniqueRootEntity(subject, parent);\n      // Validate if a root entity already exits and throw an exception\n      if (!isUniqueRoot) throw new NestedSetMultipleRootError();\n      OrmUtils.mergeDeep(subject.insertedValueSet, subject.metadata.nestedSetLeftColumn.createValueMap(1), subject.metadata.nestedSetRightColumn.createValueMap(2));\n    }\n  }\n  /**\n   * Executes operations when subject is being updated.\n   */\n  async update(subject) {\n    let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent\n    if (!parent && subject.parentSubject && subject.parentSubject.entity)\n      // if entity was attached via children\n      parent = subject.parentSubject.entity;\n    let entity = subject.databaseEntity; // if entity was attached via parent\n    if (!entity && parent)\n      // if entity was attached via children\n      entity = subject.metadata.treeChildrenRelation.getEntityValue(parent).find(child => {\n        return Object.entries(subject.identifier).every(([key, value]) => child[key] === value);\n      });\n    // Exit if the parent or the entity where never set\n    if (entity === undefined || parent === undefined) {\n      return;\n    }\n    const oldParent = subject.metadata.treeParentRelation.getEntityValue(entity);\n    const oldParentId = subject.metadata.getEntityIdMap(oldParent);\n    const parentId = subject.metadata.getEntityIdMap(parent);\n    // Exit if the new and old parents are the same\n    if (OrmUtils.compareIds(oldParentId, parentId)) {\n      return;\n    }\n    if (parent) {\n      const escape = alias => this.queryRunner.connection.driver.escape(alias);\n      const tableName = this.getTableName(subject.metadata.tablePath);\n      const leftColumnName = escape(subject.metadata.nestedSetLeftColumn.databaseName);\n      const rightColumnName = escape(subject.metadata.nestedSetRightColumn.databaseName);\n      const entityId = subject.metadata.getEntityIdMap(entity);\n      let entityNs = undefined;\n      if (entityId) {\n        entityNs = (await this.getNestedSetIds(subject.metadata, entityId))[0];\n      }\n      let parentNs = undefined;\n      if (parentId) {\n        parentNs = (await this.getNestedSetIds(subject.metadata, parentId))[0];\n      }\n      if (entityNs !== undefined && parentNs !== undefined) {\n        const isMovingUp = parentNs.left > entityNs.left;\n        const treeSize = entityNs.right - entityNs.left + 1;\n        let entitySize;\n        if (isMovingUp) {\n          entitySize = parentNs.left - entityNs.right;\n        } else {\n          entitySize = parentNs.right - entityNs.left;\n        }\n        // Moved entity logic\n        const updateLeftSide = `WHEN ${leftColumnName} >= ${entityNs.left} AND ` + `${leftColumnName} < ${entityNs.right} ` + `THEN ${leftColumnName} + ${entitySize} `;\n        const updateRightSide = `WHEN ${rightColumnName} > ${entityNs.left} AND ` + `${rightColumnName} <= ${entityNs.right} ` + `THEN ${rightColumnName} + ${entitySize} `;\n        // Update the surrounding entities\n        if (isMovingUp) {\n          await this.queryRunner.query(`UPDATE ${tableName} ` + `SET ${leftColumnName} = CASE ` + `WHEN ${leftColumnName} > ${entityNs.right} AND ` + `${leftColumnName} <= ${parentNs.left} ` + `THEN ${leftColumnName} - ${treeSize} ` + updateLeftSide + `ELSE ${leftColumnName} ` + `END, ` + `${rightColumnName} = CASE ` + `WHEN ${rightColumnName} > ${entityNs.right} AND ` + `${rightColumnName} < ${parentNs.left} ` + `THEN ${rightColumnName} - ${treeSize} ` + updateRightSide + `ELSE ${rightColumnName} ` + `END`);\n        } else {\n          await this.queryRunner.query(`UPDATE ${tableName} ` + `SET ${leftColumnName} = CASE ` + `WHEN ${leftColumnName} < ${entityNs.left} AND ` + `${leftColumnName} > ${parentNs.right} ` + `THEN ${leftColumnName} + ${treeSize} ` + updateLeftSide + `ELSE ${leftColumnName} ` + `END, ` + `${rightColumnName} = CASE ` + `WHEN ${rightColumnName} < ${entityNs.left} AND ` + `${rightColumnName} >= ${parentNs.right} ` + `THEN ${rightColumnName} + ${treeSize} ` + updateRightSide + `ELSE ${rightColumnName} ` + `END`);\n        }\n      }\n    } else {\n      const isUniqueRoot = await this.isUniqueRootEntity(subject, parent);\n      // Validate if a root entity already exits and throw an exception\n      if (!isUniqueRoot) throw new NestedSetMultipleRootError();\n    }\n  }\n  /**\n   * Executes operations when subject is being removed.\n   */\n  async remove(subjects) {\n    if (!Array.isArray(subjects)) subjects = [subjects];\n    const metadata = subjects[0].metadata;\n    const escape = alias => this.queryRunner.connection.driver.escape(alias);\n    const tableName = this.getTableName(metadata.tablePath);\n    const leftColumnName = escape(metadata.nestedSetLeftColumn.databaseName);\n    const rightColumnName = escape(metadata.nestedSetRightColumn.databaseName);\n    let entitiesIds = [];\n    for (const subject of subjects) {\n      const entityId = metadata.getEntityIdMap(subject.entity);\n      if (entityId) {\n        entitiesIds.push(entityId);\n      }\n    }\n    let entitiesNs = await this.getNestedSetIds(metadata, entitiesIds);\n    for (const entity of entitiesNs) {\n      const treeSize = entity.right - entity.left + 1;\n      await this.queryRunner.query(`UPDATE ${tableName} ` + `SET ${leftColumnName} = CASE ` + `WHEN ${leftColumnName} > ${entity.left} THEN ${leftColumnName} - ${treeSize} ` + `ELSE ${leftColumnName} ` + `END, ` + `${rightColumnName} = CASE ` + `WHEN ${rightColumnName} > ${entity.right} THEN ${rightColumnName} - ${treeSize} ` + `ELSE ${rightColumnName} ` + `END`);\n    }\n  }\n  /**\n   * Get the nested set ids for a given entity\n   */\n  getNestedSetIds(metadata, ids) {\n    const select = {\n      left: `${metadata.targetName}.${metadata.nestedSetLeftColumn.propertyPath}`,\n      right: `${metadata.targetName}.${metadata.nestedSetRightColumn.propertyPath}`\n    };\n    const queryBuilder = this.queryRunner.manager.createQueryBuilder();\n    Object.entries(select).forEach(([key, value]) => {\n      queryBuilder.addSelect(value, key);\n    });\n    return queryBuilder.from(metadata.target, metadata.targetName).whereInIds(ids).orderBy(select.right, \"DESC\").getRawMany().then(results => {\n      const data = [];\n      for (const result of results) {\n        const entry = {};\n        for (const key of Object.keys(select)) {\n          const value = result ? result[key] : undefined;\n          // CockroachDB returns numeric types as string\n          entry[key] = typeof value === \"string\" ? parseInt(value) : value;\n        }\n        data.push(entry);\n      }\n      return data;\n    });\n  }\n  async isUniqueRootEntity(subject, parent) {\n    const escape = alias => this.queryRunner.connection.driver.escape(alias);\n    const tableName = this.getTableName(subject.metadata.tablePath);\n    const parameters = [];\n    const whereCondition = subject.metadata.treeParentRelation.joinColumns.map(column => {\n      const columnName = escape(column.databaseName);\n      const parameter = column.getEntityValue(parent);\n      if (parameter == null) {\n        return `${columnName} IS NULL`;\n      }\n      parameters.push(parameter);\n      const parameterName = this.queryRunner.connection.driver.createParameter(\"entity_\" + column.databaseName, parameters.length - 1);\n      return `${columnName} = ${parameterName}`;\n    }).join(\" AND \");\n    const countAlias = \"count\";\n    const result = await this.queryRunner.query(`SELECT COUNT(1) AS ${escape(countAlias)} FROM ${tableName} WHERE ${whereCondition}`, parameters, true);\n    return parseInt(result.records[0][countAlias]) === 0;\n  }\n  /**\n   * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom\n   * schema name, otherwise returns escaped table name.\n   */\n  getTableName(tablePath) {\n    return tablePath.split(\".\").map(i => {\n      // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n      return i === \"\" ? i : this.queryRunner.connection.driver.escape(i);\n    }).join(\".\");\n  }\n}","map":{"version":3,"names":["OrmUtils","NestedSetMultipleRootError","NestedSetIds","NestedSetSubjectExecutor","constructor","queryRunner","insert","subject","escape","alias","connection","driver","tableName","getTableName","metadata","tablePath","leftColumnName","nestedSetLeftColumn","databaseName","rightColumnName","nestedSetRightColumn","parent","treeParentRelation","getEntityValue","entity","parentSubject","insertedValueSet","parentId","getEntityIdMap","parentNsRight","undefined","manager","createQueryBuilder","select","targetName","propertyPath","from","target","whereInIds","getRawOne","then","result","value","parseInt","query","mergeDeep","createValueMap","isUniqueRoot","isUniqueRootEntity","update","databaseEntity","treeChildrenRelation","find","child","Object","entries","identifier","every","key","oldParent","oldParentId","compareIds","entityId","entityNs","getNestedSetIds","parentNs","isMovingUp","left","treeSize","right","entitySize","updateLeftSide","updateRightSide","remove","subjects","Array","isArray","entitiesIds","push","entitiesNs","ids","queryBuilder","forEach","addSelect","orderBy","getRawMany","results","data","entry","keys","parameters","whereCondition","joinColumns","map","column","columnName","parameter","parameterName","createParameter","length","join","countAlias","records","split","i"],"sources":["D:\\Ronwell Task 1\\node_modules\\typeorm\\browser\\src\\persistence\\tree\\NestedSetSubjectExecutor.ts"],"sourcesContent":["import { Subject } from \"../Subject\"\nimport { QueryRunner } from \"../../query-runner/QueryRunner\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { NestedSetMultipleRootError } from \"../../error/NestedSetMultipleRootError\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\"\n\nclass NestedSetIds {\n    left: number\n    right: number\n}\n\n/**\n * Executes subject operations for nested set tree entities.\n */\nexport class NestedSetSubjectExecutor {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected queryRunner: QueryRunner) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes operations when subject is being inserted.\n     */\n    async insert(subject: Subject): Promise<void> {\n        const escape = (alias: string) =>\n            this.queryRunner.connection.driver.escape(alias)\n        const tableName = this.getTableName(subject.metadata.tablePath)\n        const leftColumnName = escape(\n            subject.metadata.nestedSetLeftColumn!.databaseName,\n        )\n        const rightColumnName = escape(\n            subject.metadata.nestedSetRightColumn!.databaseName,\n        )\n\n        let parent = subject.metadata.treeParentRelation!.getEntityValue(\n            subject.entity!,\n        ) // if entity was attached via parent\n        if (!parent && subject.parentSubject && subject.parentSubject.entity)\n            // if entity was attached via children\n            parent = subject.parentSubject.insertedValueSet\n                ? subject.parentSubject.insertedValueSet\n                : subject.parentSubject.entity\n        const parentId = subject.metadata.getEntityIdMap(parent)\n\n        let parentNsRight: number | undefined = undefined\n        if (parentId) {\n            parentNsRight = await this.queryRunner.manager\n                .createQueryBuilder()\n                .select(\n                    subject.metadata.targetName +\n                        \".\" +\n                        subject.metadata.nestedSetRightColumn!.propertyPath,\n                    \"right\",\n                )\n                .from(subject.metadata.target, subject.metadata.targetName)\n                .whereInIds(parentId)\n                .getRawOne()\n                .then((result) => {\n                    const value: any = result ? result[\"right\"] : undefined\n                    // CockroachDB returns numeric types as string\n                    return typeof value === \"string\" ? parseInt(value) : value\n                })\n        }\n\n        if (parentNsRight !== undefined) {\n            await this.queryRunner.query(\n                `UPDATE ${tableName} SET ` +\n                    `${leftColumnName} = CASE WHEN ${leftColumnName} > ${parentNsRight} THEN ${leftColumnName} + 2 ELSE ${leftColumnName} END,` +\n                    `${rightColumnName} = ${rightColumnName} + 2 ` +\n                    `WHERE ${rightColumnName} >= ${parentNsRight}`,\n            )\n\n            OrmUtils.mergeDeep(\n                subject.insertedValueSet,\n                subject.metadata.nestedSetLeftColumn!.createValueMap(\n                    parentNsRight,\n                ),\n                subject.metadata.nestedSetRightColumn!.createValueMap(\n                    parentNsRight + 1,\n                ),\n            )\n        } else {\n            const isUniqueRoot = await this.isUniqueRootEntity(subject, parent)\n\n            // Validate if a root entity already exits and throw an exception\n            if (!isUniqueRoot) throw new NestedSetMultipleRootError()\n\n            OrmUtils.mergeDeep(\n                subject.insertedValueSet,\n                subject.metadata.nestedSetLeftColumn!.createValueMap(1),\n                subject.metadata.nestedSetRightColumn!.createValueMap(2),\n            )\n        }\n    }\n\n    /**\n     * Executes operations when subject is being updated.\n     */\n    async update(subject: Subject): Promise<void> {\n        let parent = subject.metadata.treeParentRelation!.getEntityValue(\n            subject.entity!,\n        ) // if entity was attached via parent\n        if (!parent && subject.parentSubject && subject.parentSubject.entity)\n            // if entity was attached via children\n            parent = subject.parentSubject.entity\n\n        let entity = subject.databaseEntity // if entity was attached via parent\n        if (!entity && parent)\n            // if entity was attached via children\n            entity = subject.metadata\n                .treeChildrenRelation!.getEntityValue(parent)\n                .find((child: any) => {\n                    return Object.entries(subject.identifier!).every(\n                        ([key, value]) => child[key] === value,\n                    )\n                })\n\n        // Exit if the parent or the entity where never set\n        if (entity === undefined || parent === undefined) {\n            return\n        }\n\n        const oldParent = subject.metadata.treeParentRelation!.getEntityValue(\n            entity!,\n        )\n        const oldParentId = subject.metadata.getEntityIdMap(oldParent)\n        const parentId = subject.metadata.getEntityIdMap(parent)\n\n        // Exit if the new and old parents are the same\n        if (OrmUtils.compareIds(oldParentId, parentId)) {\n            return\n        }\n\n        if (parent) {\n            const escape = (alias: string) =>\n                this.queryRunner.connection.driver.escape(alias)\n            const tableName = this.getTableName(subject.metadata.tablePath)\n            const leftColumnName = escape(\n                subject.metadata.nestedSetLeftColumn!.databaseName,\n            )\n            const rightColumnName = escape(\n                subject.metadata.nestedSetRightColumn!.databaseName,\n            )\n\n            const entityId = subject.metadata.getEntityIdMap(entity)\n\n            let entityNs: NestedSetIds | undefined = undefined\n            if (entityId) {\n                entityNs = (\n                    await this.getNestedSetIds(subject.metadata, entityId)\n                )[0]\n            }\n\n            let parentNs: NestedSetIds | undefined = undefined\n            if (parentId) {\n                parentNs = (\n                    await this.getNestedSetIds(subject.metadata, parentId)\n                )[0]\n            }\n\n            if (entityNs !== undefined && parentNs !== undefined) {\n                const isMovingUp = parentNs.left > entityNs.left\n                const treeSize = entityNs.right - entityNs.left + 1\n\n                let entitySize: number\n                if (isMovingUp) {\n                    entitySize = parentNs.left - entityNs.right\n                } else {\n                    entitySize = parentNs.right - entityNs.left\n                }\n\n                // Moved entity logic\n                const updateLeftSide =\n                    `WHEN ${leftColumnName} >= ${entityNs.left} AND ` +\n                    `${leftColumnName} < ${entityNs.right} ` +\n                    `THEN ${leftColumnName} + ${entitySize} `\n\n                const updateRightSide =\n                    `WHEN ${rightColumnName} > ${entityNs.left} AND ` +\n                    `${rightColumnName} <= ${entityNs.right} ` +\n                    `THEN ${rightColumnName} + ${entitySize} `\n\n                // Update the surrounding entities\n                if (isMovingUp) {\n                    await this.queryRunner.query(\n                        `UPDATE ${tableName} ` +\n                            `SET ${leftColumnName} = CASE ` +\n                            `WHEN ${leftColumnName} > ${entityNs.right} AND ` +\n                            `${leftColumnName} <= ${parentNs.left} ` +\n                            `THEN ${leftColumnName} - ${treeSize} ` +\n                            updateLeftSide +\n                            `ELSE ${leftColumnName} ` +\n                            `END, ` +\n                            `${rightColumnName} = CASE ` +\n                            `WHEN ${rightColumnName} > ${entityNs.right} AND ` +\n                            `${rightColumnName} < ${parentNs.left} ` +\n                            `THEN ${rightColumnName} - ${treeSize} ` +\n                            updateRightSide +\n                            `ELSE ${rightColumnName} ` +\n                            `END`,\n                    )\n                } else {\n                    await this.queryRunner.query(\n                        `UPDATE ${tableName} ` +\n                            `SET ${leftColumnName} = CASE ` +\n                            `WHEN ${leftColumnName} < ${entityNs.left} AND ` +\n                            `${leftColumnName} > ${parentNs.right} ` +\n                            `THEN ${leftColumnName} + ${treeSize} ` +\n                            updateLeftSide +\n                            `ELSE ${leftColumnName} ` +\n                            `END, ` +\n                            `${rightColumnName} = CASE ` +\n                            `WHEN ${rightColumnName} < ${entityNs.left} AND ` +\n                            `${rightColumnName} >= ${parentNs.right} ` +\n                            `THEN ${rightColumnName} + ${treeSize} ` +\n                            updateRightSide +\n                            `ELSE ${rightColumnName} ` +\n                            `END`,\n                    )\n                }\n            }\n        } else {\n            const isUniqueRoot = await this.isUniqueRootEntity(subject, parent)\n\n            // Validate if a root entity already exits and throw an exception\n            if (!isUniqueRoot) throw new NestedSetMultipleRootError()\n        }\n    }\n\n    /**\n     * Executes operations when subject is being removed.\n     */\n    async remove(subjects: Subject | Subject[]): Promise<void> {\n        if (!Array.isArray(subjects)) subjects = [subjects]\n\n        const metadata = subjects[0].metadata\n\n        const escape = (alias: string) =>\n            this.queryRunner.connection.driver.escape(alias)\n        const tableName = this.getTableName(metadata.tablePath)\n        const leftColumnName = escape(\n            metadata.nestedSetLeftColumn!.databaseName,\n        )\n        const rightColumnName = escape(\n            metadata.nestedSetRightColumn!.databaseName,\n        )\n\n        let entitiesIds: ObjectLiteral[] = []\n        for (const subject of subjects) {\n            const entityId = metadata.getEntityIdMap(subject.entity)\n\n            if (entityId) {\n                entitiesIds.push(entityId)\n            }\n        }\n\n        let entitiesNs = await this.getNestedSetIds(metadata, entitiesIds)\n\n        for (const entity of entitiesNs) {\n            const treeSize = entity.right - entity.left + 1\n\n            await this.queryRunner.query(\n                `UPDATE ${tableName} ` +\n                    `SET ${leftColumnName} = CASE ` +\n                    `WHEN ${leftColumnName} > ${entity.left} THEN ${leftColumnName} - ${treeSize} ` +\n                    `ELSE ${leftColumnName} ` +\n                    `END, ` +\n                    `${rightColumnName} = CASE ` +\n                    `WHEN ${rightColumnName} > ${entity.right} THEN ${rightColumnName} - ${treeSize} ` +\n                    `ELSE ${rightColumnName} ` +\n                    `END`,\n            )\n        }\n    }\n\n    /**\n     * Get the nested set ids for a given entity\n     */\n    protected getNestedSetIds(\n        metadata: EntityMetadata,\n        ids: ObjectLiteral | ObjectLiteral[],\n    ): Promise<NestedSetIds[]> {\n        const select = {\n            left: `${metadata.targetName}.${\n                metadata.nestedSetLeftColumn!.propertyPath\n            }`,\n            right: `${metadata.targetName}.${\n                metadata.nestedSetRightColumn!.propertyPath\n            }`,\n        }\n\n        const queryBuilder = this.queryRunner.manager.createQueryBuilder()\n\n        Object.entries(select).forEach(([key, value]) => {\n            queryBuilder.addSelect(value, key)\n        })\n\n        return queryBuilder\n            .from(metadata.target, metadata.targetName)\n            .whereInIds(ids)\n            .orderBy(select.right, \"DESC\")\n            .getRawMany()\n            .then((results) => {\n                const data: NestedSetIds[] = []\n\n                for (const result of results) {\n                    const entry: any = {}\n                    for (const key of Object.keys(select)) {\n                        const value = result ? result[key] : undefined\n\n                        // CockroachDB returns numeric types as string\n                        entry[key] =\n                            typeof value === \"string\" ? parseInt(value) : value\n                    }\n                    data.push(entry)\n                }\n\n                return data\n            })\n    }\n\n    private async isUniqueRootEntity(\n        subject: Subject,\n        parent: any,\n    ): Promise<boolean> {\n        const escape = (alias: string) =>\n            this.queryRunner.connection.driver.escape(alias)\n        const tableName = this.getTableName(subject.metadata.tablePath)\n        const parameters: any[] = []\n        const whereCondition = subject.metadata\n            .treeParentRelation!.joinColumns.map((column) => {\n                const columnName = escape(column.databaseName)\n                const parameter = column.getEntityValue(parent)\n\n                if (parameter == null) {\n                    return `${columnName} IS NULL`\n                }\n\n                parameters.push(parameter)\n                const parameterName =\n                    this.queryRunner.connection.driver.createParameter(\n                        \"entity_\" + column.databaseName,\n                        parameters.length - 1,\n                    )\n                return `${columnName} = ${parameterName}`\n            })\n            .join(\" AND \")\n\n        const countAlias = \"count\"\n        const result = await this.queryRunner.query(\n            `SELECT COUNT(1) AS ${escape(\n                countAlias,\n            )} FROM ${tableName} WHERE ${whereCondition}`,\n            parameters,\n            true,\n        )\n\n        return parseInt(result.records[0][countAlias]) === 0\n    }\n\n    /**\n     * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom\n     * schema name, otherwise returns escaped table name.\n     */\n    protected getTableName(tablePath: string): string {\n        return tablePath\n            .split(\".\")\n            .map((i) => {\n                // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n                return i === \"\"\n                    ? i\n                    : this.queryRunner.connection.driver.escape(i)\n            })\n            .join(\".\")\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}